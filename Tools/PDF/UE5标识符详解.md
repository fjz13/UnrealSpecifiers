# UE5æ ‡è¯†ç¬¦è¯¦è§£

- **ä½œè€…ï¼š** å¤§é’Š
- **æ–‡æ¡£ç‰ˆæœ¬ï¼š** 1.0
- **ä¿®è®¢æ—¥æœŸï¼š** 2024/08/27
- **é€‚ç”¨å¼•æ“ç‰ˆæœ¬ï¼š** UE5.4
- **GitHubåœ°å€ï¼š** https://github.com/fjz13/UnrealSpecifiers
- **çŸ¥ä¹åœ°å€ï¼š** https://www.zhihu.com/people/fjz13
- **é‚®ç®±ï¼š** fjz13@live.cn
- **ç‰ˆæƒå£°æ˜ï¼š** æœ¬æ–‡æ¡£å’Œç¤ºä¾‹å·¥ç¨‹ä½œä¸ºå¼€æºå…è´¹é˜…è¯»å­¦ä¹ ä½¿ç”¨ï¼Œç‰ˆæƒæ‰€æœ‰å½’äºä½œè€…ï¼ˆå¤§é’Šï¼‰ï¼Œå…¶ä»–äººä¸å¾—ç”¨äºå•†ä¸šç”¨é€”ã€‚

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å¤§é’Šã€‚æœ‰æ„Ÿäºè™šå¹»ç¤¾åŒºå†…ç»å¸¸æœ‰äººä¼šæé—®UEä¸­æ ‡è¯†ç¬¦ä»¥åŠå„ç§metaçš„ä½¿ç”¨ï¼Œä¹Ÿä¸æ»¡è¶³äºè™šå¹»å®˜æ–¹æ–‡æ¡£å¯¹æ¯ä¸ªæ ‡è¯†ç¬¦è§£é‡Šçš„åŒ®ä¹ï¼Œå› æ­¤ç‰¹æ•´ç†äº†æ­¤æ–‡æ¡£ã€‚åŒ…æ‹¬100å¤šä¸ªæ ‡è¯†ç¬¦å’Œ300å¤šä¸ªmetaçš„è¯¦è§£ã€‚æœ¬æ–‡æ¡£åº“æŒç»­ç»´æŠ¤ä¸­ã€‚

ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå»ºè®®åœ¨GitHubä¸Šæˆ–è€…cloneä¸‹æ¥ï¼ŒæŸ¥çœ‹å„ç§mdæ–‡ä»¶æ–‡æ¡£ï¼Œè¿™æ ·æœ‰æ›´å¥½çš„ç›®å½•åˆ’åˆ†ä»¥åŠé“¾æ¥è·³è½¬ã€‚ç½‘ç»œä¸ç•…çš„ä¹Ÿå¯ä»¥æŸ¥çœ‹pdfç‰ˆæœ¬ç”µå­ä¹¦ã€‚åœ¨æ–‡æ¡£çš„å¼€å¤´æœ‰å„ä¸ªæ ‡è¯†ç¬¦çš„æ•´ä½“è¡¨æ ¼ï¼Œæ–¹ä¾¿ä½ ç®€å•ä¸€è§ˆæ‰€æœ‰æ ‡è¯†ç¬¦çš„ä½œç”¨ã€‚ç„¶åå¯¹ç‰¹å®šçš„æ ‡è¯†ç¬¦ï¼Œè¯·å–„ç”¨æœç´¢åŠŸèƒ½æŸ¥æ‰¾ã€‚

æ–‡æ¡£å¿…ç„¶æœ‰å„ç§ç¼ºæ¼é”™è¯¯ä¸è¶³ä¹‹å¤„ï¼Œæ¬¢è¿æäº¤PRæˆ–ä¸æˆ‘åé¦ˆè”ç³»ï¼Œè®©è™šå¹»ç¤¾åŒºæ›´å¤šäººå—ç›Šã€‚

# Specifier

ä»¥ä¸‹æ˜¯å„ä¸ªæ ‡è¯†ç¬¦çš„è¡¨æ ¼é“¾æ¥ï¼š

- [UCLASS](Specifier/UCLASS.md)
- [UINTERFACE](Specifier/UINTERFACE.md)

- [USTRUCT](Specifier/USTRUCT.md)

- [UENUM](Specifier/UENUM.md)
- [UFUNCTION](Specifier/UFUNCTION.md)

- [UPARAM](Specifier/UPARAM.md)

- [UPROPERTY](Specifier/UPROPERTY.md)

# Meta

ä»¥ä¸‹æ˜¯metaè¡¨æ ¼é“¾æ¥ï¼š

- [Meta](Meta/Meta.md)

# Flags

ä»¥ä¸‹æ˜¯å„ä¸ªFlagsè¡¨æ ¼é“¾æ¥ï¼Œåˆ—å‡ºæ¥åªæ˜¯å› ä¸ºæ ‡è¯†ç¬¦çš„å†…éƒ¨ä½œç”¨æœºåˆ¶ä¼šæ·»åŠ å’Œç§»é™¤Flagsï¼Œæ”¾åœ¨è¿™é‡Œä¾›ä½ é˜…è¯»å‚è€ƒã€‚ä¸ç”¨å»ç»†ç ”ç©¶æ¯ä¸ªflagsçš„ç”¨å¤„ã€‚

- [EClassFlags](Flags/EClassFlags.md)

- [EStructFlags](Flags/EStructFlags.md)

- [EEnumFlags](Flags/EEnumFlags.md)

- [EFunctionFlags](Flags/EFunctionFlags.md)

- [EPropertyFlags](Flags/EPropertyFlags.md)


# UCLASS(æ ‡è¯†ç¬¦)

## UHT

| Name                                                       | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ---------------------------------------------------------- | -------- | ------------------------------------------------------------ | -------- |
| [NoExport](UCLASS/UHT/NoExport.md)                         | UHT      | æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚ | ğŸ’€        |
| [Intrinsic](UCLASS/UHT/Intrinsic.md)                       | UHT      | æŒ‡å®šUHTå®Œå…¨ä¸ä¸ºæ­¤ç±»ç”Ÿæˆä»£ç ï¼Œéœ€è¦è‡ªå·±æ‰‹å†™ã€‚                  | ğŸ’€        |
| [Interface](UCLASS/UHT/Interface.md)                       | UHT      | æ ‡è¯†è¿™ä¸ªClassæ˜¯ä¸ªInterfaceã€‚                                 | ğŸ’€        |
| [UCLASS()](UCLASS/UHT/UCLASS().md)                         | UHT      | ç•™ç©ºçš„é»˜è®¤è¡Œä¸ºæ˜¯ä¸èƒ½åœ¨è“å›¾ä¸­è¢«ç»§æ‰¿ï¼Œä¸èƒ½åœ¨è“å›¾ä¸­å®šä¹‰å˜é‡ï¼Œä½†æ‹¥æœ‰åå°„çš„åŠŸèƒ½ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [ä¸å†™UCLASS()](UCLASS/UHT/ä¸å†™UCLASS().md)                 | UHT      | åªæ˜¯ä½œä¸ºä¸€ä¸ªæ™®é€šçš„C++å¯¹è±¡ï¼Œæ²¡æœ‰åå°„åŠŸèƒ½ã€‚                    | â˜…        |
| [CustomThunkTemplates](UCLASS/UHT/CustomThunkTemplates.md) | UHT      | Specifies the struct that contains the CustomThunk implementations | ğŸ’€        |
| [CustomConstructor](UCLASS/UHT/CustomConstructor.md)       | UHT      | é˜»æ­¢æ„é€ å‡½æ•°å£°æ˜è‡ªåŠ¨ç”Ÿæˆã€‚                                   | ğŸ’€        |
| [CustomFieldNotify](UCLASS/UHT/CustomFieldNotify.md)       | UHT      | é˜»æ­¢UHTä¸ºè¯¥ç±»ç”ŸæˆFieldNotifyçš„ç›¸å…³ä»£ç ã€‚                     | ğŸ’€        |


## Blueprint

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ | -------- |
| [Blueprintable](UCLASS/Blueprint/Blueprintable/Blueprintable.md) | Blueprint | å¯ä»¥åœ¨è“å›¾é‡Œè¢«ç»§æ‰¿ï¼Œéšå«çš„ä½œç”¨ä¹Ÿå¯å½“å˜é‡ç±»å‹                 | â˜…â˜…â˜…â˜…â˜…    |
| [NotBlueprintable](UCLASS/Blueprint/NotBlueprintable.md)     | Blueprint | ä¸å¯åœ¨è“å›¾é‡Œç»§æ‰¿ï¼Œéšå«ä½œç”¨ä¹Ÿä¸å¯å½“ä½œå˜é‡                     | â˜…â˜…â˜…â˜…     |
| [BlueprintType](UCLASS/Blueprint/BlueprintType/BlueprintType.md) | Blueprint | å¯å½“åšå˜é‡ç±»å‹                                               | â˜…â˜…â˜…â˜…â˜…    |
| [NotBlueprintType](UCLASS/Blueprint/NotBlueprintType.md)     | Blueprint | ä¸å¯å½“åšå˜é‡ç±»å‹                                             | â˜…â˜…â˜…â˜…     |
| [Abstract](UCLASS/Blueprint/Abstract/Abstract.md)            | Blueprint | æŒ‡å®šæ­¤ç±»ä¸ºæŠ½è±¡åŸºç±»ã€‚å¯è¢«ç»§æ‰¿ï¼Œä½†ä¸å¯ç”Ÿæˆå¯¹è±¡ã€‚               | â˜…â˜…â˜…â˜…â˜…    |
| [Const](UPARAM/Blueprint/Const/Const.md)                     | Blueprint | è¡¨ç¤ºæœ¬ç±»çš„å†…éƒ¨å±æ€§ä¸å¯åœ¨è“å›¾ä¸­è¢«ä¿®æ”¹ï¼Œåªè¯»ä¸å¯å†™ã€‚           | â˜…â˜…â˜…      |
| [ShowFunctions](UCLASS/Blueprint/ShowFunctions.md)           | Blueprint | åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œé‡æ–°æ‰“å¼€æŸäº›å‡½æ•°ã€‚                     | â˜…â˜…       |
| [HideFunctions](UCLASS/Blueprint/HideFunctions/HideFunctions.md) | Blueprint | åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œéšè—æ‰æŸäº›å‡½æ•°ã€‚                       | â˜…â˜…       |
| [SparseClassDataType](UCLASS/Blueprint/SparseClassDataType/SparseClassDataType.md) | Blueprint | è®©Actorçš„ä¸€äº›é‡å¤ä¸å˜çš„æ•°æ®å­˜æ”¾åœ¨ä¸€ä¸ªå…±åŒçš„ç»“æ„é‡Œï¼Œä»¥è¾¾åˆ°å‡å°‘å†…å®¹ä½¿ç”¨é‡çš„ç›®çš„ | â˜…â˜…â˜…      |
| [NeedsDeferredDependencyLoading](UCLASS/Blueprint/NeedsDeferredDependencyLoading.md) | Blueprint |                                                              | ğŸ’€        |


## DllExport

| Name                                       | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                      | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------ | --------- | --------------------------------------------- | -------- |
| [MinimalAPI](UINTERFACE/UHT/MinimalAPI.md) | DllExport | ä¸dllå¯¼å‡ºè¯¥ç±»çš„å‡½æ•°ï¼Œåªå¯¼å‡ºç±»å‹ä¿¡æ¯å½“ä½œå˜é‡ã€‚ | â˜…â˜…â˜…      |


## Category

| Name                                                         | å¼•æ“æ¨¡å—         | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ | -------- |
| [ClassGroup](UCLASS/Category/ClassGroup/ClassGroup.md)       | Category | æŒ‡å®šç»„ä»¶åœ¨Actorçš„AddComponenté¢æ¿é‡Œçš„åˆ†ç»„ï¼Œä»¥åŠåœ¨è“å›¾å³é”®èœå•ä¸­çš„åˆ†ç»„ã€‚ | â˜…â˜…â˜…     |
| [ShowCategories](UCLASS/Category/ShowCategories/ShowCategories.md) | Category         | åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œæ˜¾ç¤ºæŸäº›Categoryçš„å±æ€§ã€‚        | â˜…â˜…â˜…     |
| [HideCategories](UCLASS/Category/HideCategories/HideCategories.md) | Category         | åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œéšè—æŸäº›Categoryçš„å±æ€§ã€‚        | â˜…â˜…â˜…â˜…    |
| [CollapseCategories](UCLASS/Category/CollapseCategories/CollapseCategories.md) | Category         | åœ¨ç±»çš„å±æ€§é¢æ¿é‡Œéšè—æ‰€æœ‰å¸¦Categoryçš„å±æ€§ï¼Œä½†æ˜¯åªå¯¹å¸¦æœ‰å¤šä¸ªåµŒå¥—Categoryçš„å±æ€§æ‰èµ·ä½œç”¨ã€‚ | â˜…â˜…      |
| [DontCollapseCategories](UCLASS/Category/DontCollapseCategories.md) | Category         | ä½¿ç»§æ‰¿è‡ªåŸºç±»çš„CollapseCatogoriesè¯´æ˜ç¬¦æ— æ•ˆã€‚                 | â˜…â˜…      |
| [AutoExpandCategories](UCLASS/Category/AutoExpandCategories/AutoExpandCategories.md) | Category         | æŒ‡å®šæ­¤ç±»çš„å¯¹è±¡åœ¨ç»†èŠ‚é¢æ¿ä¸­åº”è¯¥è‡ªåŠ¨å±•å¼€çš„Categoryã€‚           | â˜…       |
| [AutoCollapseCategories](UCLASS/Category/AutoCollapseCategories/AutoCollapseCategories.md) | Category         | AutoCollapseCategoriesè¯´æ˜ç¬¦ä½¿çˆ¶ç±»ä¸Šçš„ AutoExpandCategories è¯´æ˜ç¬¦çš„åˆ—å‡ºç±»åˆ«çš„æ•ˆæœæ— æ•ˆã€‚ | â˜…       |
| [DontAutoCollapseCategories](UCLASS/Category/DontAutoCollapseCategories.md) | Category         | ä½¿åˆ—å‡ºçš„ç±»åˆ«çš„ç»§æ‰¿è‡ªçˆ¶ç±»çš„AutoCollapseCategoriesè¯´æ˜ç¬¦æ— æ•ˆã€‚ | â˜…       |
| [PrioritizeCategories](UCLASS/Category/PrioritizeCategories/PrioritizeCategories.md) | Category         | æŠŠæŒ‡å®šçš„å±æ€§ç›®å½•ä¼˜å…ˆæ˜¾ç¤ºåœ¨ç»†èŠ‚é¢æ¿çš„å‰é¢ã€‚                   | â˜…â˜…â˜…     |
| [ComponentWrapperClass](UCLASS/Category/ComponentWrapperClass/ComponentWrapperClass.md) | Category         | æŒ‡å®šè¯¥ç±»ä¸ºä¸€ä¸ªç®€å•çš„å°è£…ç±»ï¼Œå¿½ç•¥æ‰å­ç±»çš„Categoryç›¸å…³è®¾ç½®ã€‚   | â˜…â˜…      |
| [AdvancedClassDisplay](UCLASS/Category/AdvancedClassDisplay/AdvancedClassDisplay.md) | Category         | æŠŠè¯¥ç±»ä¸‹çš„æ‰€æœ‰å±æ€§éƒ½é»˜è®¤æ˜¾ç¤ºåœ¨é«˜çº§ç›®å½•ä¸‹                     | â˜…â˜…â˜…â˜…    |


## TypePicker

| Name                                                         | å¼•æ“æ¨¡å—   | åŠŸèƒ½æè¿°             | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ---------- | -------------------- | -------- |
| [HideDropDown](UCLASS/TypePicker/HideDropDown/HideDropDown.md) | TypePicker | åœ¨ç±»é€‰æ‹©å™¨ä¸­éšè—æ­¤ç±» | â˜…â˜…       |

## Development

| Name                                                         | å¼•æ“æ¨¡å—    | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | -------- |
| [Deprecated](UCLASS/Development/Deprecated/Deprecated.md)    | Development | æ ‡æ˜è¯¥ç±»å·²ç»å¼ƒç”¨ã€‚                                           | â˜…â˜…â˜…      |
| [Experimental](UCLASS/Development/Experimental/Experimental.md) | Development | æ ‡æ˜è¯¥ç±»æ˜¯è¯•éªŒæ€§ç‰ˆæœ¬ï¼Œå½“å‰æ²¡æœ‰æ–‡æ¡£æè¿°ï¼Œä¹‹åæœ‰å¯èƒ½åºŸå¼ƒæ‰ã€‚   | â˜…â˜…â˜…      |
| [EarlyAccessPreview](UCLASS/Development/EarlyAccessPreview/EarlyAccessPreview.md) | Development | æ ‡æ˜è¯¥ç±»æ˜¯æ—©æœŸé¢„è§ˆç‰ˆï¼Œæ¯”è¯•éªŒç‰ˆè¦æ›´å®Œå–„ä¸€äº›ï¼Œä½†è¿˜æ˜¯æ²¡åˆ°äº§å“çº§ã€‚ | â˜…â˜…â˜…      |

## Instance

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [Within](UCLASS/Instance/Within.md)                          | Instance | æŒ‡å®šå¯¹è±¡åˆ›å»ºçš„æ—¶å€™å¿…é¡»ä¾èµ–äºOuterClassNameçš„å¯¹è±¡ä½œä¸ºOuterã€‚  | â˜…â˜…â˜…      |
| [DefaultToInstanced](UCLASS/Instance/DefaultToInstanced/DefaultToInstanced.md) | Instance | æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å®ä¾‹å±æ€§éƒ½é»˜è®¤æ˜¯UPROPERTY(instanced)ï¼Œå³éƒ½é»˜è®¤åˆ›å»ºæ–°çš„å®ä¾‹ï¼Œè€Œä¸æ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨ã€‚ | â˜…â˜…â˜…â˜…     |
| [EditInlineNew](UCLASS/Instance/EditInlineNew/EditInlineNew.md) | Instance | æŒ‡å®šè¯¥ç±»çš„å¯¹è±¡å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œç›´æ¥å†…è”åˆ›å»ºï¼Œè¦å’Œå±æ€§çš„Instancedé…åˆã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [NotEditInlineNew](UCLASS/Instance/NotEditInlineNew.md)      | Instance | ä¸èƒ½é€šè¿‡EditInlineæŒ‰é’®åˆ›å»º                                   | â˜…        |


## Scene

| Name                                                         | å¼•æ“æ¨¡å—         | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ | -------- |
| [NotPlaceable](UCLASS/Scene/NotPlaceable/NotPlaceable.md)    | Scene         | æ ‡æ˜è¯¥Actorä¸å¯è¢«æ”¾ç½®åœ¨å…³å¡é‡Œ                                | â˜…â˜…â˜…     |
| [Placeable](UCLASS/Scene/Placeable/Placeable.md)             | Scene            | æ ‡æ˜è¯¥Actorå¯ä»¥æ”¾ç½®åœ¨å…³å¡é‡Œã€‚                                | â˜…â˜…â˜…     |
| [ConversionRoot](UCLASS/Scene/ConversionRoot/ConversionRoot.md) | Scene            | åœ¨åœºæ™¯ç¼–è¾‘å™¨é‡Œå…è®¸Actoråœ¨è‡ªèº«ä»¥åŠå­ç±»ä¹‹é—´åšè½¬æ¢              | â˜…       |

## Config

| Name                                                         | å¼•æ“æ¨¡å—         | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ | -------- |
| [Config](UCLASS/Config/Config.md)                            | Config           | æŒ‡å®šé…ç½®æ–‡ä»¶çš„åå­—ï¼ŒæŠŠè¯¥å¯¹è±¡çš„å€¼ä¿å­˜åˆ°inié…ç½®æ–‡ä»¶ä¸­ã€‚        | â˜…â˜…â˜…â˜…â˜…   |
| [PerObjectConfig](UCLASS/Config/PerObjectConfig.md)          | Config           | åœ¨å·²ç»æœ‰configé…ç½®æ–‡ä»¶åå­—çš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šåº”è¯¥æŒ‰æ¯ä¸ªå¯¹è±¡å®ä¾‹æ¥å­˜å‚¨å€¼ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç±»ä¸€ä¸ªå­˜å‚¨å€¼ã€‚ | â˜…â˜…â˜…â˜…â˜…   |
| [ConfigDoNotCheckDefaults](UCLASS/Config/ConfigDoNotCheckDefaults.md) | Config           | æŒ‡å®šåœ¨ä¿å­˜é…ç½®å€¼çš„æ—¶å€™å¿½ç•¥ä¸Šä¸€çº§çš„é…ç½®å€¼çš„ä¸€è‡´æ€§æ£€æŸ¥ã€‚       | â˜…       |
| [DefaultConfig](UCLASS/Config/DefaultConfig/DefaultConfig.md) | Config           | æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯Project/Config/DefaultXXX.iniã€‚    | â˜…â˜…â˜…     |
| [GlobalUserConfig](UCLASS/Config/GlobalUserConfig/GlobalUserConfig.md) | Config           | æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯å…¨å±€ç”¨æˆ·è®¾ç½® Engine/Config/UserXXX.iniã€‚ | â˜…â˜…â˜…     |
| [ProjectUserConfig](UCLASS/Config/ProjectUserConfig/ProjectUserConfig.md) | Config           | æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯é¡¹ç›®ç”¨æˆ·è®¾ç½® Project/Config/UserXXX.iniã€‚ | â˜…â˜…â˜…     |
| [EditorConfig](UCLASS/Config/EditorConfig/EditorConfig.md)   | Config   | ç”¨æ¥åœ¨ç¼–è¾‘å™¨çŠ¶æ€ä¸‹ä¿å­˜ä¿¡æ¯ã€‚                                 | â˜…       |


## Serialization

| Name                                                         | å¼•æ“æ¨¡å—      | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------- |
| [Transient](UCLASS/Serialization/Transient/Transient.md)     | Serialization | æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡éƒ½ç•¥è¿‡åºåˆ—åŒ–ã€‚                             | â˜…â˜…â˜…      |
| [NonTransient](UCLASS/Serialization/NonTransient.md)         | Serialization | ä½¿ç»§æ‰¿è‡ªåŸºç±»çš„Transientè¯´æ˜ç¬¦æ— æ•ˆã€‚                          | â˜…â˜…â˜…      |
| [Optional](UCLASS/Serialization/Optional/Optional.md)        | Serialization | æ ‡è®°è¯¥ç±»çš„å¯¹è±¡æ˜¯å¯é€‰çš„ï¼Œåœ¨Cookingçš„æ—¶å€™å¯ä»¥é€‰æ‹©æ˜¯å¦è¦å¿½ç•¥ä¿å­˜å®ƒä»¬ã€‚ | â˜…        |
| [MatchedSerializers](UCLASS/Serialization/MatchedSerializers/MatchedSerializers.md) | Serialization | æŒ‡å®šç±»æ”¯æŒæ–‡æœ¬ç»“æ„åºåˆ—åŒ–                                     | ğŸ’€        |


# UINTERFACE(æ ‡è¯†ç¬¦)

## DllExport

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------- | -------- |
| [MinimalAPI](UINTERFACE/UHT/MinimalAPI.md)                   | DllExport | æŒ‡å®šè¯¥UInterfaceå¯¹è±¡ä¸å¯¼å‡ºåˆ°åˆ«çš„æ¨¡å—                    | â˜…        |


## Blueprint

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------- | -------- |
| [Blueprintable](UINTERFACE/Blueprint/Blueprintable/Blueprintable.md) | Blueprint | å¯ä»¥åœ¨è“å›¾ä¸­å®ç°                                        | â˜…â˜…â˜…â˜…â˜…    |
| [NotBlueprintable](UINTERFACE/Blueprint/NotBlueprintable/NotBlueprintable.md) | Blueprint | æŒ‡å®šä¸å¯ä»¥åœ¨è“å›¾ä¸­å®ç°                                  | â˜…â˜…â˜…      |
| [ConversionRoot](UINTERFACE/UHT/ConversionRoot.md)           | Blueprint | Sets IsConversionRoot metadata flag for this interface. | ğŸ’€        |


# USTRUCT(æ ‡è¯†ç¬¦)

 ## UHT

| Name                                                         | å¼•æ“æ¨¡å—      | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------- |
| [NoExport](USTRUCT/UHT/NoExport/NoExport.md)                 | UHT           | æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚ | â˜…        |
| [Atomic](USTRUCT/UHT/Atomic/Atomic.md)                       | UHT           | æŒ‡å®šè¯¥ç»“æ„åœ¨åºåˆ—åŒ–çš„æ—¶å€™æ€»æ˜¯ä¸€æ•´ä¸ªè¾“å‡ºå…¨éƒ¨å±æ€§ï¼Œè€Œä¸æ˜¯åªè¾“å‡ºæ”¹å˜çš„å±æ€§ã€‚ | â˜…        |
| [IsAlwaysAccessible](USTRUCT/UHT/IsAlwaysAccessible.md)      | UHT           | æŒ‡å®šUHTåœ¨ç”Ÿæˆæ–‡ä»¶çš„æ—¶å€™æ€»æ˜¯å¯ä»¥è®¿é—®åˆ°æ”¹ç»“æ„çš„å£°æ˜ï¼Œå¦åˆ™è¦åœ¨gen.cppé‡Œç”Ÿæˆé•œåƒç»“æ„å®šä¹‰ | ğŸ’€        |
| [HasDefaults](USTRUCT/UHT/HasDefaults.md)                    | UHT           | æŒ‡å®šè¯¥ç»“æ„çš„å­—æ®µæ‹¥æœ‰é»˜è®¤å€¼ã€‚è¿™æ ·å¦‚æœæœ¬ç»“æ„ä½œä¸ºå‡½æ•°å‚æ•°æˆ–è¿”å›å€¼æ—¶å€™ï¼Œå‡½æ•°åˆ™å¯ä»¥ä¸ºå…¶æä¾›é»˜è®¤å€¼ã€‚ | ğŸ’€        |
| [HasNoOpConstructor](USTRUCT/UHT/HasNoOpConstructor.md)      | UHT           | æŒ‡å®šè¯¥ç»“æ„æ‹¥æœ‰ForceInitçš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·åœ¨ä½œä¸ºBP functionè¿”å›å€¼çš„æ—¶å€™ï¼Œå¯ä»¥è°ƒç”¨æ¥åˆå§‹åŒ– | ğŸ’€        |
| [IsCoreType](USTRUCT/UHT/IsCoreType.md)                      | UHT           | æŒ‡å®šè¯¥ç»“æ„æ˜¯æ ¸å¿ƒç±»ï¼ŒUHTåœ¨ç”¨å®ƒçš„æ—¶å€™ä¸éœ€è¦å‰å‘å£°æ˜ã€‚          | ğŸ’€        |


 ## Blueprint

| Name                                                         | å¼•æ“æ¨¡å—      | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------- |
| [BlueprintType](USTRUCT/Blueprint/BlueprintType/BlueprintType.md) | Blueprint     | å…è®¸è¿™ä¸ªç»“æ„åœ¨è“å›¾ä¸­å£°æ˜å˜é‡                                 | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintInternalUseOnly](USTRUCT/Blueprint/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md) | Blueprint     | ä¸å¯å®šä¹‰æ–°BPå˜é‡ï¼Œä½†å¯ä½œä¸ºåˆ«çš„ç±»çš„æˆå‘˜å˜é‡æš´éœ²å’Œå˜é‡ä¼ é€’     | â˜…â˜…       |
| [BlueprintInternalUseOnlyHierarchical](USTRUCT/Blueprint/BlueprintInternalUseOnlyHierarchical.md) | Blueprint     | åœ¨BlueprintInternalUseOnlyçš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†å­ç±»ä¹Ÿä¸èƒ½å®šä¹‰æ–°BPå˜é‡çš„é™åˆ¶ã€‚ | â˜…        |


 ## Serialization

| Name                                                         | å¼•æ“æ¨¡å—      | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------- |
| [immutable](USTRUCT/Serialization/immutable.md)              | Serialization | Immutable is only legal in Object.h and is being phased out, do not use on new structs! | ğŸ’€        |


# UENUM(æ ‡è¯†ç¬¦)

 ## Trait

| Name                                    | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                   | å¸¸ç”¨ç¨‹åº¦ |
| --------------------------------------- | --------- | ------------------------------------------ | -------- |
| [Flags](UENUM/Flags/Flags.md)           | Trait     | æŠŠè¯¥æšä¸¾çš„å€¼ä½œä¸ºä¸€ä¸ªæ ‡å¿—æ¥æ‹¼æ¥å­—ç¬¦ä¸²è¾“å‡ºã€‚ | â˜…â˜…â˜…â˜…â˜…    |


 ## Blueprint

| Name                                    | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                   | å¸¸ç”¨ç¨‹åº¦ |
| --------------------------------------- | --------- | ------------------------------------------ | -------- |
| [BlueprintType](UENUM/BlueprintType.md) | Blueprint | å¯ä»¥ä½œä¸ºè“å›¾å˜é‡                           | â˜…â˜…â˜…â˜…â˜…    |


# UFUNCTION(æ ‡è¯†ç¬¦)

## Editor

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                             | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ---------------------------------------------------- | -------- |
| [Category](UFUNCTION/Category/Category.md)                   | Editor   | åœ¨è“å›¾çš„å³é”®èœå•ä¸­ä¸ºè¯¥å‡½æ•°æŒ‡å®šç±»åˆ«åˆ†ç»„ï¼Œå¯ä»¥åµŒå¥—å¤šçº§ | â˜…â˜…â˜…â˜…â˜…    |
| [CallInEditor](UFUNCTION/Blueprint/CallInEditor/CallInEditor.md) | Editor   | å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸Šä½œä¸ºä¸€ä¸ªæŒ‰é’®æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚       | â˜…â˜…â˜…â˜…â˜…    |


## Blueprint

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                              | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ----------------------------------------------------- | -------- |
| [BlueprintCallable](UFUNCTION/Blueprint/BlueprintCallable/BlueprintCallable.md) | Blueprint | æš´éœ²åˆ°è“å›¾ä¸­å¯è¢«è°ƒç”¨                                  | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintPure](UFUNCTION/Blueprint/BlueprintPure/BlueprintPure.md) | Blueprint | æŒ‡å®šä½œä¸ºä¸€ä¸ªçº¯å‡½æ•°ï¼Œä¸€èˆ¬ç”¨äºGetå‡½æ•°ç”¨æ¥è¿”å›å€¼ã€‚       | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintImplementableEvent](UFUNCTION/Blueprint/BlueprintImplementableEvent/BlueprintImplementableEvent.md) | Blueprint | æŒ‡å®šä¸€ä¸ªå‡½æ•°è°ƒç”¨ç‚¹ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­é‡è½½å®ç°ã€‚            | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintNativeEvent](UFUNCTION/Blueprint/BlueprintNativeEvent/BlueprintNativeEvent.md) | Blueprint | å¯ä»¥åœ¨è“å›¾æ€»è¦†ç›–å®ç°ï¼Œä½†æ˜¯ä¹Ÿåœ¨C++ä¸­æä¾›ä¸€ä¸ªé»˜è®¤å®ç°ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintGetter](UFUNCTION/Blueprint/BlueprintGetter.md)    | Blueprint | æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Getå‡½æ•°ã€‚                   | â˜…â˜…       |
| [BlueprintSetter](UFUNCTION/Blueprint/BlueprintSetter.md)    | Blueprint | æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Setå‡½æ•°ã€‚                   | â˜…â˜…       |


## Behavior

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [Exec](UFUNCTION/Exec/Exec.md)                               | Behavior | åœ¨ç‰¹å®šç±»é‡Œæ³¨å†Œä¸€ä¸ªå‡½æ•°ä¸ºä½œä¸ºæ§åˆ¶å°å‘½ä»¤ï¼Œå…è®¸æ¥å—å‚æ•°ã€‚       | â˜…â˜…â˜…      |
| [SealedEvent](UFUNCTION/Blueprint/SealedEvent/SealedEvent.md) | Behavior | æ— æ³•åœ¨å­ç±»ä¸­è¦†ç›–æ­¤å‡½æ•°ã€‚SealedEventå…³é”®è¯åªèƒ½ç”¨äºäº‹ä»¶ã€‚å¯¹äºéäº‹ä»¶å‡½æ•°ï¼Œè¯·å°†å®ƒä»¬å£°æ˜ä¸ºstaticæˆ–finalï¼Œä»¥å¯†å°å®ƒä»¬ã€‚ | ğŸ’€        |


## Network

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [BlueprintAuthorityOnly](UFUNCTION/Network/BlueprintAuthorityOnly/BlueprintAuthorityOnly.md) | Network  | è¿™ä¸ªå‡½æ•°åªèƒ½åœ¨æ‹¥æœ‰ç½‘ç»œæƒé™çš„ç«¯ä¸Šè¿è¡Œã€‚                       | â˜…â˜…â˜…      |
| [BlueprintCosmetic](UFUNCTION/Network/BlueprintCosmetic/BlueprintCosmetic.md) | Network  | æ­¤å‡½æ•°ä¸ºä¿®é¥°æ€§çš„ï¼Œæ— æ³•åœ¨DSä¸Šè¿è¡Œã€‚                           | â˜…â˜…â˜…      |
| [Client](UFUNCTION/Network/Client/Client.md)                 | Network  | åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨å®¢æˆ·ç«¯ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [Server](UFUNCTION/Network/Server/Server.md)                 | Network  | åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨æœåŠ¡å™¨ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ | â˜…â˜…â˜…â˜…â˜…    |
| [NetMulticast](UFUNCTION/Network/NetMulticast/NetMulticast.md) | Network  | å®šä¹‰ä¸€ä¸ªå¤šæ’­RPCå‡½æ•°åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¸Šéƒ½æ‰§è¡Œã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [Reliable](UFUNCTION/Network/Reliable.md)                    | Network  | æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œå¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶ä¼šé‡å‘ä»¥ä¿è¯åˆ°è¾¾ã€‚ä¸€èˆ¬ç”¨åœ¨é€»è¾‘å…³é”®çš„å‡½æ•°ä¸Šã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [Unreliable](UFUNCTION/Network/Unreliable.md)                | Network  | æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œä¸å¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶å°±ä¼šè¢«ä¸¢å¼ƒã€‚ä¸€èˆ¬ç”¨åœ¨ä¼ æ’­æ•ˆæœè¡¨ç°çš„å‡½æ•°ä¸Šï¼Œå°±ç®—æ¼æ‰ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [WithValidation](UFUNCTION/Network/WithValidation.md)        | Network  | æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°åœ¨æ‰§è¡Œå‰éœ€è¦éªŒè¯ï¼Œåªæœ‰éªŒè¯é€šè¿‡æ‰å¯ä»¥æ‰§è¡Œã€‚    | â˜…â˜…â˜…â˜…â˜…    |
| [ServiceRequest](UFUNCTION/Network/ServiceRequest.md)        | Network  | æ­¤å‡½æ•°ä¸ºRPCï¼ˆè¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼‰æœåŠ¡è¯·æ±‚ã€‚rpcæœåŠ¡è¯·æ±‚             | ğŸ’€        |
| [ServiceResponse](UFUNCTION/Network/ServiceResponse.md)      | Network  | æ­¤å‡½æ•°ä¸ºRPCæœåŠ¡å“åº”ã€‚rpcæœåŠ¡å›å¤                             | ğŸ’€        |


## UHT

| Name                                                         | å¼•æ“æ¨¡å—       | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ | -------- |
| [BlueprintInternalUseOnly](UFUNCTION/UHT/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md) | Blueprint, UHT | æŒ‡ç¤ºä¸åº”å‘æœ€ç»ˆç”¨æˆ·å…¬å¼€æ­¤å‡½æ•°ã€‚è“å›¾å†…éƒ¨è°ƒç”¨ï¼Œä¸æš´éœ²ç»™ç”¨æˆ·ã€‚   | â˜…â˜…â˜…      |
| [CustomThunk](UFUNCTION/UHT/CustomThunk/CustomThunk.md)      | UHT            | æŒ‡å®šUHTä¸ä¸ºè¯¥å‡½æ•°ç”Ÿæˆè“å›¾è°ƒç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œè€Œéœ€è¦ç”¨æˆ·è‡ªå®šä¹‰ç¼–å†™ã€‚ | â˜…â˜…â˜…      |
| [Variadic](UFUNCTION/UHT/Variadic/Variadic.md)               | Blueprint, UHT | æ ‡è¯†ä¸€ä¸ªå‡½æ•°å¯ä»¥æ¥å—ä»»æ„ç±»å‹çš„å¤šä¸ªå‚æ•°ï¼ˆåŒ…æ‹¬input/output)ï¼  | â˜…â˜…â˜…      |
| [FieldNotify](UFUNCTION/UHT/FieldNotify/FieldNotify.md)      | UHT            | ä¸ºè¯¥å‡½æ•°åˆ›å»ºä¸€ä¸ªFieldNotifyçš„ç»‘å®šç‚¹ã€‚                        | â˜…â˜…â˜…      |


# UPARAM(æ ‡è¯†ç¬¦)

 ## Blueprint

| Name                                                       | åŠŸèƒ½æè¿°                             | å¼•æ“æ¨¡å—                      | å¸¸ç”¨ç¨‹åº¦ |
| ---------------------------------------------------------- | ------------------------------------ | ----------------------------- | -------- |
| [DisplayName](UPARAM/Blueprint/DisplayName/DisplayName.md) | æ›´æ”¹å‡½æ•°å‚æ•°åœ¨è“å›¾èŠ‚ç‚¹ä¸Šçš„æ˜¾ç¤ºåå­—   | Blueprint, Parameter          | â˜…â˜…â˜…â˜…â˜…    |
| [ref](UPARAM/Blueprint/ref/ref.md)                         | ä½¿å¾—å‡½æ•°çš„å‚æ•°å˜æˆå¼•ç”¨ç±»å‹           | Blueprint, Parameter          | â˜…â˜…â˜…â˜…â˜…    |
| [Const](UPARAM/Blueprint/Const/Const.md)                   | æŒ‡å®šè¯¥å‡½æ•°å‚æ•°ä¸å¯æ›´æ”¹               | Blueprint, Parameter          | â˜…        |
| [Required](UPARAM/Blueprint/Required/Required.md)          | æŒ‡å®šå‡½æ•°çš„å‚æ•°èŠ‚ç‚¹å¿…é¡»è¿æ¥æä¾›ä¸€ä¸ªå€¼ | Blueprint, Parameter          | â˜…â˜…       |


 ## Network

| Name                                                       | åŠŸèƒ½æè¿°                             | å¼•æ“æ¨¡å—                      | å¸¸ç”¨ç¨‹åº¦ |
| ---------------------------------------------------------- | ------------------------------------ | ----------------------------- | -------- |
| [NotReplicated](UPARAM/Network/NotReplicated.md)           |                                      | Blueprint, Network, Parameter | ğŸ’€        |


# UPROPERTY(æ ‡è¯†ç¬¦)

 ## Serialization

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Export](UPROPERTY/Serialization/Export/Export.md)                                                       | Serialization        | åœ¨å¯¹Assetå¯¼å‡ºçš„æ—¶å€™ï¼Œå†³å®šè¯¥ç±»çš„å¯¹è±¡åº”è¯¥å¯¼å‡ºå†…éƒ¨çš„å±æ€§å€¼ï¼Œè€Œæ˜¯å¯¹è±¡çš„è·¯å¾„ã€‚                                                                              | â˜…     |
| [SaveGame](UPROPERTY/Serialization/SaveGame/SaveGame.md)                                                 | Serialization        | åœ¨SaveGameå­˜æ¡£çš„æ—¶å€™ï¼Œåªåºåˆ—åŒ–æœ‰SaveGameæ ‡è®°çš„å±æ€§ï¼Œè€Œä¸åºåˆ—åŒ–åˆ«çš„å±æ€§ã€‚                                                                         | â˜…â˜…â˜…â˜…â˜… |
| [SkipSerialization](UPROPERTY/Serialization/SkipSerialization/SkipSerialization.md)                      | Serialization        | äºŒè¿›åˆ¶åºåˆ—åŒ–æ—¶è·³è¿‡è¯¥å±æ€§ï¼Œä½†åœ¨ExportTextçš„æ—¶å€™ä¾ç„¶å¯ä»¥å¯¼å‡ºã€‚                                                                                  | â˜…â˜…â˜…   |
| [TextExportTransient](UPROPERTY/Serialization/TextExportTransient.md)                                    | Serialization        | åœ¨ExportTextå¯¼å‡ºä¸º.COPYæ ¼å¼çš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚                                                                                      | â˜…     |
| [Transient](UPROPERTY/Serialization/Transient/Transient.md)                                              | Serialization        | ä¸åºåˆ—åŒ–è¯¥å±æ€§ï¼Œè¯¥å±æ€§åˆå§‹åŒ–æ—¶å€™ä¼šè¢«0å¡«å……ã€‚                                                                                               | â˜…â˜…â˜…â˜…â˜… |
| [DuplicateTransient](UPROPERTY/Serialization/DuplicateTransient/DuplicateTransient.md)                   | Serialization        | åœ¨å¯¹è±¡å¤åˆ¶æˆ–COPYæ ¼å¼å¯¼å‡ºçš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚                                                                                             | â˜…â˜…    |
| [NonPIEDuplicateTransient](UPROPERTY/Serialization/NonPIEDuplicateTransient/NonPIEDuplicateTransient.md) | Serialization        | åœ¨å¯¹è±¡å¤åˆ¶çš„æ—¶å€™ï¼Œä¸”åœ¨ä¸æ˜¯PIEçš„åœºåˆï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚                                                                                           | â˜…     |


 ## Sequencer

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Interp](UPROPERTY/DetaisPanel/Interp/Interp.md)                                                         | Sequencer            | æŒ‡å®šè¯¥å±æ€§å€¼å¯æš´éœ²åˆ°æ—¶é—´è½´é‡Œç¼–è¾‘ï¼Œåœ¨å¹³å¸¸çš„Timelineæˆ–UMGçš„åŠ¨ç”»é‡Œä½¿ç”¨ã€‚                                                                             | â˜…â˜…â˜…   |


 ## Network

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Replicated](UPROPERTY/Network/Replicated.md)                                                            | Network              | æŒ‡å®šè¯¥å±æ€§åº”éšç½‘ç»œè¿›è¡Œå¤åˆ¶ã€‚                                                                                                       | â˜…â˜…â˜…â˜…â˜… |
| [ReplicatedUsing](UPROPERTY/Network/ReplicatedUsing/ReplicatedUsing.md)                                  | Network              | æŒ‡å®šä¸€ä¸ªé€šçŸ¥å›è°ƒå‡½æ•°ï¼Œåœ¨å±æ€§é€šè¿‡ç½‘ç»œæ›´æ–°åæ‰§è¡Œã€‚                                                                                             | â˜…â˜…â˜…â˜…â˜… |
| [NotReplicated](UPROPERTY/Network/NotReplicated.md)                                                      | Network              | è·³è¿‡å¤åˆ¶ã€‚è¿™åªä¼šåº”ç”¨åˆ°æœåŠ¡è¯·æ±‚å‡½æ•°ä¸­çš„ç»“æ„ä½“æˆå‘˜å’Œå‚æ•°ã€‚                                                                                         | â˜…â˜…â˜…   |
| [RepRetry](UPROPERTY/Network/RepRetry.md)                                                                | Network              | åªé€‚ç”¨äºç»“æ„ä½“å±æ€§ã€‚å¦‚æœæ­¤å±æ€§æœªèƒ½å®Œå…¨å‘é€ï¼ˆä¸¾ä¾‹è€Œè¨€ï¼šObjectå¼•ç”¨å°šæ— æ³•é€šè¿‡ç½‘ç»œè¿›è¡Œåºåˆ—åŒ–ï¼‰ï¼Œåˆ™é‡æ–°å°è¯•å¯¹å…¶çš„å¤åˆ¶ã€‚å¯¹ç®€å•å¼•ç”¨è€Œè¨€ï¼Œè¿™æ˜¯é»˜è®¤é€‰æ‹©ï¼›ä½†å¯¹ç»“æ„ä½“è€Œè¨€ï¼Œè¿™ä¼šäº§ç”Ÿå¸¦å®½å¼€é”€ï¼Œå¹¶éä¼˜é€‰é¡¹ã€‚å› æ­¤åœ¨æŒ‡å®šæ­¤æ ‡ç­¾ä¹‹å‰å…¶å‡ä¸ºç¦ç”¨çŠ¶æ€ã€‚ | ğŸ’€    |


 ## UHT

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [FieldNotify](UPROPERTY/UHT/FieldNotify/FieldNotify.md)                                                  | MVVM, UHT            | åœ¨æ‰“å¼€MVVMæ’ä»¶åï¼Œä½¿å¾—è¯¥å±æ€§å˜æˆæ”¯æŒFieldNotifyçš„å±æ€§ã€‚                                                                                  | â˜…â˜…â˜…â˜…  |


 ## Instance

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Instanced](UPROPERTY/Instance/Instanced/Instanced.md)                                                   | Instance             | æŒ‡å®šå¯¹è¯¥å¯¹è±¡å±æ€§çš„ç¼–è¾‘èµ‹å€¼åº”è¯¥æ–°åˆ›å»ºä¸€ä¸ªå®ä¾‹å¹¶ä½œä¸ºå­å¯¹è±¡ï¼Œè€Œä¸æ˜¯å¯»æ‰¾ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ã€‚                                                                            | â˜…â˜…â˜…   |


 ## Editor

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [NonTransactional](UPROPERTY/DetaisPanel/NonTransactional/NonTransactional.md)                           | Editor               | å¯¹è¯¥å±æ€§çš„æ”¹å˜æ“ä½œï¼Œä¸ä¼šè¢«åŒ…å«è¿›ç¼–è¾‘å™¨çš„Undo/Redoå‘½ä»¤ä¸­ã€‚                                                                                    | â˜…â˜…    |


 ## DetailsPanel

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Category](UPROPERTY/DetaisPanel/Category/Category.md)                                                   | DetailsPanel, Editor | æŒ‡å®šå±æ€§çš„ç±»åˆ«ï¼Œä½¿ç”¨ &#124; è¿ç®—ç¬¦å®šä¹‰åµŒå¥—ç±»ç›®ã€‚                                                                                         | â˜…â˜…â˜…â˜…â˜… |
| [SimpleDisplay](UPROPERTY/DetaisPanel/SimpleDisplay/SimpleDisplay.md)                                    | DetailsPanel, Editor | åœ¨ç»†èŠ‚é¢æ¿ä¸­ç›´æ¥å¯è§ï¼Œä¸æŠ˜å åˆ°é«˜çº§ä¸­ã€‚                                                                                                  | â˜…â˜…â˜…   |
| [AdvancedDisplay](UPROPERTY/DetaisPanel/AdvancedDisplay/AdvancedDisplay.md)                              | DetailsPanel, Editor | è¢«æŠ˜å åˆ°é«˜çº§æ ä¸‹ï¼Œè¦æ‰‹åŠ¨æ‰“å¼€ã€‚ä¸€èˆ¬ç”¨åœ¨ä¸å¤ªå¸¸ç”¨çš„å±æ€§ä¸Šé¢ã€‚                                                                                        | â˜…â˜…â˜…â˜…â˜… |
| [EditAnywhere](UPROPERTY/DetaisPanel/EditAnywhere/EditAnywhere.md)                                       | DetailsPanel, Editor | åœ¨é»˜è®¤å€¼å’Œå®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šå‡å¯ç¼–è¾‘                                                                                                    | â˜…â˜…â˜…â˜…â˜… |
| [EditDefaultsOnly](UPROPERTY/DetaisPanel/EditDefaultsOnly.md)                                            | DetailsPanel, Editor | åªèƒ½åœ¨é»˜è®¤å€¼é¢æ¿é‡Œç¼–è¾‘                                                                                                          | â˜…â˜…â˜…â˜…â˜… |
| [EditInstanceOnly](UPROPERTY/DetaisPanel/EditInstanceOnly.md)                                            | DetailsPanel, Editor | åªèƒ½åœ¨å®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šç¼–è¾‘è¯¥å±æ€§                                                                                                     | â˜…â˜…â˜…â˜…â˜… |
| [VisibleAnywhere](UPROPERTY/DetaisPanel/VisibleAnywhere.md)                                              | DetailsPanel, Editor | åœ¨é»˜è®¤å€¼å’Œå®ä¾‹ç»†èŠ‚é¢æ¿å‡å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘                                                                                                 | â˜…â˜…â˜…â˜…â˜… |
| [VisibleDefaultsOnly](UPROPERTY/DetaisPanel/VisibleDefaultsOnly.md)                                      | DetailsPanel, Editor | åœ¨é»˜è®¤å€¼ç»†èŠ‚é¢æ¿å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘                                                                                                     | â˜…â˜…â˜…â˜…â˜… |
| [VisibleInstanceOnly](UPROPERTY/DetaisPanel/VisibleInstanceOnly.md)                                      | DetailsPanel, Editor | åœ¨å®ä¾‹ç»†èŠ‚é¢æ¿å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘                                                                                                      | â˜…â˜…â˜…â˜…â˜… |
| [EditFixedSize](UPROPERTY/DetaisPanel/EditFixedSize/EditFixedSize.md)                                    | DetailsPanel, Editor | åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸å…è®¸æ”¹å˜è¯¥å®¹å™¨çš„å…ƒç´ ä¸ªæ•°ã€‚                                                                                                 | â˜…â˜…â˜…   |
| [NoClear](UPROPERTY/DetaisPanel/NoClear/NoClear.md)                                                      | DetailsPanel, Editor | æŒ‡å®šè¯¥å±æ€§çš„ç¼–è¾‘é€‰é¡¹ä¸­ä¸å‡ºç°ClearæŒ‰é’®ï¼Œä¸å…è®¸ç½®nullã€‚                                                                                      | â˜…â˜…â˜…   |


 ## Config

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Config](UPROPERTY/Config/Config.md)                                                                     | Config               | æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªé…ç½®å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥è¢«åºåˆ—åŒ–è¯»å†™åˆ°iniæ–‡ä»¶ï¼ˆè·¯å¾„ç”±uclassçš„configæ ‡ç­¾æŒ‡å®šï¼‰ä¸­ã€‚                                                               | â˜…â˜…â˜…   |
| [GlobalConfig](UPROPERTY/Config/GlobalConfig/GlobalConfig.md)                                            | Config               | å’ŒConfigä¸€æ ·æŒ‡å®šè¯¥å±æ€§å¯ä½œä¸ºé…ç½®è¯»å–å’Œå†™å…¥iniä¸­ï¼Œä½†åªä¼šè¯»å–å†™å…¥åˆ°é…ç½®æ–‡ä»¶é‡ŒåŸºç±»çš„å€¼ï¼Œè€Œä¸ä¼šä½¿ç”¨é…ç½®æ–‡ä»¶é‡Œå­ç±»é‡Œçš„å€¼ã€‚                                                      | â˜…â˜…â˜…   |


 ## Blueprint

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [BlueprintAuthorityOnly](UPROPERTY/Blueprint/BlueprintAuthorityOnly/BlueprintAuthorityOnly.md)           | Blueprint, Network   | åªèƒ½ç»‘å®šä¸ºBlueprintAuthorityOnlyçš„äº‹ä»¶ï¼Œè®©è¯¥å¤šæ’­å§”æ‰˜åªæ¥å—åœ¨æœåŠ¡ç«¯è¿è¡Œçš„äº‹ä»¶                                                                    | â˜…â˜…â˜…   |
| [BlueprintReadWrite](UPROPERTY/Blueprint/BlueprintReadWrite/BlueprintReadWrite.md)                       | Blueprint            | å¯ä»è“å›¾è¯»å–æˆ–å†™å…¥æ­¤å±æ€§ã€‚                                                                                                        | â˜…â˜…â˜…â˜…â˜… |
| [BlueprintReadOnly](UPROPERTY/Blueprint/BlueprintReadOnly/BlueprintReadOnly.md)                          | Blueprint            | æ­¤å±æ€§å¯ç”±è“å›¾è¯»å–ï¼Œä½†ä¸èƒ½è¢«ä¿®æ”¹ã€‚                                                                                                    | â˜…â˜…â˜…â˜…â˜… |
| [BlueprintGetter](UPROPERTY/Blueprint/BlueprintGetter/BlueprintGetter.md)                                | Blueprint            | ä¸ºå±æ€§å®šä¹‰ä¸€ä¸ªè‡ªå®šä¹‰çš„Getå‡½æ•°æ¥è¯»å–ã€‚                                                                                                 | â˜…â˜…â˜…   |
| [Getter](UPROPERTY/Blueprint/Getter.md)                                                                  | Blueprint            | ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Getå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚                                                                                          | â˜…â˜…â˜…   |
| [Setter](UPROPERTY/Blueprint/Setter/Setter.md)                                                           | Blueprint            | ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Setå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚                                                                                          | â˜…â˜…â˜…   |
| [BlueprintSetter](UPROPERTY/Blueprint/BlueprintSetter.md)                                                | Blueprint            | é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„setå‡½æ•°æ¥è¯»å–ã€‚                                                                                                    | â˜…â˜…â˜…   |
| [BlueprintCallable](UPROPERTY/Blueprint/BlueprintCallable/BlueprintCallable.md)                          | Blueprint            | åœ¨è“å›¾ä¸­å¯ä»¥è°ƒç”¨è¿™ä¸ªå¤šæ’­å§”æ‰˜                                                                                                       | â˜…â˜…â˜…   |
| [BlueprintAssignable](UPROPERTY/Blueprint/BlueprintAssignable/BlueprintAssignable.md)                    | Blueprint            | åœ¨è“å›¾ä¸­å¯ä»¥ä¸ºè¿™ä¸ªå¤šæ’­å§”æ‰˜ç»‘å®šäº‹ä»¶                                                                                                    | â˜…â˜…â˜…   |


 ## Behavior

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [Localized](UPROPERTY/Asset/Localized.md)                                                                | Behavior             | æ­¤å±æ€§çš„å€¼å°†æ‹¥æœ‰ä¸€ä¸ªå®šä¹‰çš„æœ¬åœ°åŒ–å€¼ã€‚å¤šç”¨äºå­—ç¬¦ä¸²ã€‚æš—ç¤ºä¸º ReadOnlyã€‚è¯¥å€¼æœ‰ä¸€ä¸ªæœ¬åœ°åŒ–å€¼ã€‚æœ€å¸¸æ ‡è®°åœ¨stringä¸Š                                                         | ğŸ’€    |
| [Native](UPROPERTY/UHT/Native.md)                                                                        | Behavior             | å±æ€§ä¸ºæœ¬åœ°ï¼šC++ä»£ç è´Ÿè´£å¯¹å…¶è¿›è¡Œåºåˆ—åŒ–å¹¶å…¬å¼€åˆ°åƒåœ¾å›æ”¶ ã€‚                                                                                       | ğŸ’€    |


 ## Asset

| Name                                                                                                     | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                 | å¸¸ç”¨ç¨‹åº¦  |
|----------------------------------------------------------------------------------------------------------|----------------------|----------------------------------------------------------------------------------------------------------------------|-------|
| [AssetRegistrySearchable](UPROPERTY/Asset/AssetRegistrySearchable/AssetRegistrySearchable.md)            | Asset                | æ ‡è®°è¯¥å±æ€§å¯ä»¥ä½œä¸ºAssetRegistryçš„Tagå’ŒValueå€¼æ¥è¿›è¡Œèµ„äº§çš„è¿‡æ»¤æœç´¢                                                                          | â˜…â˜…â˜…   |


# Meta = (å…ƒæ•°æ®)

## Any

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [FullyExpand](Object/FullyExpand.md)                         |          |                                                              | ğŸ’€        |
| [HideThen](Blueprint/HideThen/HideThen.md)                   |          | éšè—å¼‚æ­¥è“å›¾èŠ‚ç‚¹çš„Thenå¼•è„š                                   | ğŸ’€        |
| [MapKeyParam](Blueprint/Param/MapParam/MapKeyParam.md)       |          | æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºMapçš„Keyï¼Œå…¶æ ¹æ®MapParamæŒ‡å®šçš„å®é™…Mapå‚æ•°çš„Keyç±»å‹è€Œç›¸åº”æ”¹å˜ã€‚ | â˜…â˜…â˜…      |
| [EditConditionHides](DetailsPanel/EditConditionHides/EditConditionHides.md) |          | åœ¨å·²ç»æœ‰EditConditionçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šè¯¥å±æ€§åœ¨EditConditionä¸æ»¡è¶³çš„æƒ…å†µä¸‹éšè—èµ·æ¥ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [InlineEditConditionToggle](DetailsPanel/InlineEditConditionToggle/InlineEditConditionToggle.md) |          | ä½¿è¿™ä¸ªboolå±æ€§åœ¨è¢«ç”¨ä½œEditConditionçš„æ—¶å€™å†…è”åˆ°å¯¹æ–¹çš„å±æ€§è¡Œé‡Œæˆä¸ºä¸€ä¸ªå•é€‰æ¡†ï¼Œè€Œä¸æ˜¯è‡ªå·±æˆä¸ºä¸€ä¸ªç¼–è¾‘è¡Œã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [NeedsLatentFixup](Blueprint/Latent/NeedsLatentFixup.md)     |          | ç”¨åœ¨FLatentActionInfo::Linkageå±æ€§ä¸Šï¼Œå‘Šè¯‰è“å›¾VMç”Ÿæˆè·³è½¬ä¿¡æ¯ | â˜…        |
| [HideSpawnParms](Blueprint/Param/HideSpawnParms/HideSpawnParms.md) |          | åœ¨UGamelayTaskå­ç±»ç”Ÿæˆçš„è“å›¾å¼‚æ­¥èŠ‚ç‚¹ä¸Šéšè—UGamelayTaskå­ç±»ç»§æ‰¿é“¾ä¸­æŸäº›å±æ€§ã€‚ | ğŸ’€        |
| [ShowOnlyInnerProperties](Object/ShowOnlyInnerProperties/ShowOnlyInnerProperties.md) |          | æŠŠç»“æ„å±æ€§çš„å†…éƒ¨å±æ€§ç›´æ¥ä¸Šæä¸€ä¸ªå±‚çº§ç›´æ¥å±•ç¤º                 | â˜…â˜…â˜…      |
| [LatentInfo](Blueprint/Latent/LatentInfo.md)                 |          | å’ŒLatenté…åˆï¼ŒæŒ‡æ˜å“ªä¸ªå‡½æ•°å‚æ•°æ˜¯LatentInfoå‚æ•°ã€‚             | â˜…â˜…â˜…      |
| [NativeBreakFunc](Blueprint/NativeBreakFunc.md)              |          | æŒ‡å®šä¸€ä¸ªå‡½æ•°é‡‡ç”¨BreakStructçš„å›¾æ ‡ã€‚                          | â˜…        |
| [ShowCategories](DetailsPanel/ShowCategories.md)             |          | æ˜¾ç¤ºç±»åˆ«                                                     | ğŸ’€        |
| [HasNativeMake](Struct/HasNativeMake.md)                     |          | ä¸ºè¯¥ç»“æ„æŒ‡å®šä¸€ä¸ªC++å†…çš„UFunctionå‡½æ•°ä½œä¸ºMreakèŠ‚ç‚¹çš„å®ç°      | â˜…â˜…â˜…â˜…â˜…    |
| [EntryClass](Widget/EntryClass.md)                           |          | é™å®šEntryWidgetClasså±æ€§ä¸Šå¯é€‰ç±»å¿…é¡»ç»§æ‰¿è‡ªçš„åŸºç±»ï¼Œç”¨åœ¨DynamicEntryBoxå’ŒListViewè¿™ä¸¤ä¸ªWidgetä¸Šã€‚ | â˜…â˜…â˜…      |
| [NoEditInline](DetailsPanel/NoEditInline.md)                 |          | Object properties pointing to an UObject instance whos class is marked editinline will not show their properties inline in property windows. Useful for getting actor components to appear in the component tree but not inline in the root actor details panel. | ğŸ’€        |
| [NotBlueprintThreadSafe](Blueprint/NotBlueprintThreadSafe.md) |          | ç”¨åœ¨å‡½æ•°ä¸Šï¼Œæ ‡è®°è¿™ä¸ªå‡½æ•°æ˜¯ä¸çº¿ç¨‹å®‰å…¨çš„                       | â˜…        |
| [ShowWorldContextPin](Blueprint/ShowWorldContextPin/ShowWorldContextPin.md) |          | æ”¾åœ¨UCLASSä¸Šï¼ŒæŒ‡å®šæœ¬ç±»é‡Œçš„å‡½æ•°è°ƒç”¨éƒ½å¿…é¡»æ˜¾ç¤ºWorldContextå¼•è„šï¼Œæ— è®ºå…¶æœ¬æ¥æ˜¯å¦é»˜è®¤éšè— | ğŸ’€        |
| [ChildCannotTick](Actor/ChildCannotTick.md)                  |          | ç”¨äºActoræˆ–ActorComponentå­ç±»ï¼Œæ ‡è®°å…è®¸å…¶è“å›¾å­ç±»ä¸å¯ä»¥æ¥å—å“åº”Tickäº‹ä»¶ï¼Œå“ªæ€•çˆ¶ç±»å¯ä»¥Tick | â˜…â˜…â˜…      |
| [DynamicOutputParam](Blueprint/Param/DynamicOutputParam.md)  |          | é…åˆDeterminesOutputTypeï¼ŒæŒ‡å®šå¤šä¸ªæ”¯æŒåŠ¨æ€ç±»å‹çš„è¾“å‡ºå‚æ•°ã€‚   | ğŸ’€        |
| [HasDedicatedAsyncNode](Blueprint/HasDedicatedAsyncNode/HasDedicatedAsyncNode.md) |          |                                                              | ğŸ’€        |
| [LatentCallbackTarget](Blueprint/Latent/LatentCallbackTarget.md) |          | ç”¨åœ¨FLatentActionInfo::CallbackTargetå±æ€§ä¸Šï¼Œå‘Šè¯‰è“å›¾VMåœ¨å“ªä¸ªå¯¹è±¡ä¸Šè°ƒç”¨å‡½æ•°ã€‚ | â˜…        |
| [MapValueParam](Blueprint/Param/MapParam/MapValueParam.md)   |          | æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºMapçš„Valueï¼Œå…¶æ ¹æ®MapParamæŒ‡å®šçš„å®é™…Mapå‚æ•°çš„Valueç±»å‹è€Œç›¸åº”æ”¹å˜ã€‚ | â˜…â˜…â˜…      |
| [UseEnumValuesAsMaskValuesInEditor](Enum/UseEnumValuesAsMaskValuesInEditor/UseEnumValuesAsMaskValuesInEditor.md) |          | æŒ‡å®šæšä¸¾å€¼å·²ç»æ˜¯ä½ç§»åçš„å€¼ï¼Œè€Œä¸æ˜¯ä½æ ‡è®°çš„ç´¢å¼•ä¸‹æ ‡ã€‚         | â˜…â˜…       |
| [ExpandBoolAsExecs](Blueprint/Exec/ExpandBoolAsExecs.md)     |          | æ˜¯ExpandEnumAsExecsçš„åˆ«åï¼Œå®Œå…¨ç­‰ä»·å…¶åŠŸèƒ½ã€‚                  | â˜…â˜…â˜…â˜…â˜…    |
| [AllowPrivateAccess](Blueprint/AllowPrivateAccess/AllowPrivateAccess.md) |          | å…è®¸ä¸€ä¸ªåœ¨C++ä¸­privateçš„å±æ€§ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­è®¿é—®ã€‚             | â˜…â˜…â˜…â˜…â˜…    |
| [AllowEditInlineCustomization](DetailsPanel/AllowEditInlineCustomization/AllowEditInlineCustomization.md) |          | å…è®¸EditInlineçš„å¯¹è±¡å±æ€§å¯ä»¥è‡ªå®šä¹‰å±æ€§ç»†èŠ‚é¢æ¿æ¥ç¼–è¾‘è¯¥å¯¹è±¡å†…çš„æ•°æ®ã€‚ | â˜…        |
| [BlueprintPrivate](Blueprint/BlueprintPrivate/BlueprintPrivate.md) |          | æŒ‡å®šè¯¥å‡½æ•°æˆ–å±æ€§åªèƒ½åœ¨æœ¬ç±»ä¸­è¢«è°ƒç”¨æˆ–è¯»å†™ï¼Œç±»ä¼¼C++ä¸­çš„privateçš„ä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚ | â˜…â˜…       |
| [CollapsableChildProperties](Object/CollapsableChildProperties.md) |          | åœ¨TextureGraphæ¨¡å—ä¸­æ–°å¢åŠ çš„metaã€‚ç”¨äºæŠ˜å ä¸€ä¸ªç»“æ„çš„å†…éƒ¨å±æ€§ã€‚ | ğŸ’€        |
| [BitmaskEnum](Enum/BitmaskEnum/BitmaskEnum.md)               |          | ä½¿ç”¨ä½æ ‡è®°åé‡‡ç”¨çš„æšä¸¾åå­—                                   | â˜…â˜…â˜…â˜…â˜…    |
| [ShortTooltip](Development/ShortTooltip.md)                  |          | æä¾›ä¸€ä¸ªæ›´ç®€æ´ç‰ˆæœ¬çš„æç¤ºæ–‡æœ¬ï¼Œä¾‹å¦‚åœ¨ç±»å‹é€‰æ‹©å™¨çš„æ—¶å€™æ˜¾ç¤º     | ğŸ’€        |
| [ArrayTypeDependentParams](Blueprint/Param/ArrayTypeDependentParams/ArrayTypeDependentParams.md) |          | å½“ArryParamæŒ‡å®šçš„å‡½æ•°æ‹¥æœ‰ä¸¤ä¸ªæˆ–ä»¥ä¸ŠArrayå‚æ•°çš„æ—¶å€™ï¼ŒæŒ‡å®šå“ªäº›æ•°ç»„å‚æ•°çš„ç±»å‹ä¹Ÿåº”è¯¥ç›¸åº”çš„è¢«æ›´æ–°æ”¹å˜ã€‚ | ğŸ’€        |
| [ForceInlineRow](DetailsPanel/ForceInlineRow/ForceInlineRow.md) |          | å¼ºåˆ¶TMapå±æ€§é‡Œçš„ç»“æ„keyå’Œå…¶ä»–Valueåˆå¹¶åˆ°åŒä¸€è¡Œæ¥æ˜¾ç¤º         | â˜…        |
| [CallableWithoutWorldContext](Blueprint/CallableWithoutWorldContext/CallableWithoutWorldContext.md) |          | è®©å‡½æ•°ä¹Ÿå¯ä»¥è„±ç¦»WorldContextObjectè€Œä½¿ç”¨                     | ğŸ’€        |


## Actor

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [ChildCanTick](Actor/ChildCanTick/ChildCanTick.md)                                                                             | Actor                | æ ‡è®°å…è®¸å…¶è“å›¾å­ç±»å¯ä»¥æ¥å—å“åº”Tickäº‹ä»¶                                                                                                                                                                                                                                            | â˜…â˜…â˜…   |


## AnimationGraph

| Name                                                         | å¼•æ“æ¨¡å—       | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ | -------- |
| [AnimNotifyBoneName](AnimationGraph/AnimNotifyBoneName/AnimNotifyBoneName.md) | AnimationGraph | ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„FNameå±æ€§ä½œä¸ºBoneNameçš„ä½œç”¨ã€‚ | â˜…â˜…       |
| [AnimBlueprintFunction](AnimationGraph/AnimBlueprintFunction.md) | AnimationGraph | æ ‡æ˜æ˜¯åŠ¨ç”»è“å›¾é‡Œçš„å†…éƒ¨çº¯å­˜æ ¹å‡½æ•°ï¼Œåªåœ¨åŠ¨ç”»è“å›¾ç¼–è¯‘æ—¶è®¾ç½®     | ğŸ’€        |
| [CustomizeProperty](AnimationGraph/CustomizeProperty/CustomizeProperty.md) | AnimationGraph | ä½¿ç”¨åœ¨FAnimNodeçš„æˆå‘˜å±æ€§ä¸Šï¼Œå‘Šè¯‰ç¼–è¾‘å™¨ä¸è¦ä¸ºå®ƒç”Ÿæˆé»˜è®¤Detailsé¢æ¿æ§ä»¶ï¼Œåç»­ä¼šåœ¨DetailsCustomizationé‡Œè‡ªå®šä¹‰åˆ›å»ºç›¸åº”çš„ç¼–è¾‘æ§ä»¶ã€‚ | â˜…        |
| [AnimNotifyExpand](AnimationGraph/AnimNotifyExpand.md)       | AnimationGraph | ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„å±æ€§ç›´æ¥å±•å¼€åˆ°ç»†èŠ‚é¢æ¿é‡Œã€‚ | ğŸ’€        |
| [OnEvaluate](AnimationGraph/OnEvaluate.md)                   | AnimationGraph |                                                              | ğŸ’€        |
| [FoldProperty](AnimationGraph/FoldProperty/FoldProperty.md)  | AnimationGraph | åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æˆä¸ºFoldPropertyã€‚         | â˜…        |
| [BlueprintCompilerGeneratedDefaults](AnimationGraph/BlueprintCompilerGeneratedDefaults.md) | AnimationGraph | æŒ‡å®šè¯¥å±æ€§çš„å€¼æ˜¯ç¼–è¯‘å™¨ç”Ÿæˆçš„ï¼Œå› æ­¤åœ¨ç¼–è¯‘åæ— éœ€å¤åˆ¶ï¼Œå¯ä»¥åŠ é€Ÿä¸€äº›ç¼–è¯‘æ€§èƒ½ã€‚ | ğŸ’€        |
| [CustomWidget](AnimationGraph/CustomWidget.md)               | AnimationGraph |                                                              | ğŸ’€        |
| [AllowedParamType](AnimationGraph/AllowedParamType.md)       | AnimationGraph |                                                              | ğŸ’€        |
| [PinShownByDefault](AnimationGraph/PinShownByDefault/PinShownByDefault.md) | AnimationGraph | åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§ä¸€å¼€å§‹å°±æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„šï¼Œä½†ä¹Ÿå¯ä»¥æ”¹å˜ã€‚ | â˜…â˜…â˜…      |
| [GetterContext](AnimationGraph/GetterContext/GetterContext.md) | AnimationGraph | ç»§ç»­é™å®šAnimGetterå‡½æ•°åœ¨å“ªä¸ªåœ°æ–¹æ‰å¯ä»¥ä½¿ç”¨ï¼Œå¦‚æœä¸å¡«ï¼Œåˆ™é»˜è®¤éƒ½å¯ä»¥ç”¨ã€‚ | â˜…â˜…       |
| [AnimGetter](AnimationGraph/AnimGetter/AnimGetter.md)        | AnimationGraph | æŒ‡å®šUAnimInstanceåŠå­ç±»çš„è¯¥å‡½æ•°æˆä¸ºä¸€ä¸ªAnimGetterå‡½æ•°ã€‚      | â˜…â˜…â˜…      |


## Asset

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [DisallowedAssetDataTags](Asset/DisallowedAssetDataTags.md)  | Asset    | åœ¨UObject*å±æ€§ä¸ŠæŒ‡å®šTagsæ¥è¿›è¡Œè¿‡æ»¤ï¼Œå¿…é¡»æ²¡æœ‰æ‹¥æœ‰è¯¥Tagsæ‰å¯ä»¥è¢«é€‰æ‹©ã€‚ | â˜…â˜…       |
| [RequiredAssetDataTags](Asset/RequiredAssetDataTags/RequiredAssetDataTags.md) | Asset    | åœ¨UObject*å±æ€§ä¸ŠæŒ‡å®šTagsæ¥è¿›è¡Œè¿‡æ»¤ï¼Œå¿…é¡»æ‹¥æœ‰è¯¥Tagsæ‰å¯ä»¥è¢«é€‰æ‹©ã€‚ | â˜…â˜…       |
| [ForceShowEngineContent](Asset/ForceShowEngineContent/ForceShowEngineContent.md) | Asset    | æŒ‡å®šUObject*å±æ€§çš„èµ„æºå¯é€‰åˆ—è¡¨é‡Œå¼ºåˆ¶å¯é€‰å¼•æ“çš„å†…å»ºèµ„æº       | â˜…â˜…       |
| [ForceShowPluginContent](Asset/ForceShowEngineContent/ForceShowPluginContent.md) | Asset    | æŒ‡å®šUObject*å±æ€§çš„èµ„æºå¯é€‰åˆ—è¡¨é‡Œå¼ºåˆ¶å¯é€‰å…¶ä»–æ’ä»¶é‡Œçš„å†…å»ºèµ„æº | ğŸ’€        |
| [GetAssetFilter](Asset/GetAssetFilter/GetAssetFilter.md)     | Asset    | æŒ‡å®šä¸€ä¸ªUFUNCTIONæ¥å¯¹UObject*å±æ€§çš„å¯é€‰èµ„æºè¿›è¡Œæ’é™¤è¿‡æ»¤ã€‚    | â˜…â˜…â˜…      |


## Blueprint

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ | -------- |
| [IgnoreTypePromotion](Blueprint/IgnoreTypePromotion/IgnoreTypePromotion.md) | Blueprint | æ ‡è®°è¯¥å‡½æ•°ä¸æ”¶å½•è¿›ç±»å‹æå‡å‡½æ•°åº“                             | â˜…â˜…       |
| [Variadic](Blueprint/Variadic.md)                            | Blueprint | æŒ‡å®šè¯¥å‡½æ•°æ¥å—å¤šä¸ªå‚æ•°                                       | â˜…â˜…â˜…      |
| [ForceAsFunction](Blueprint/ForceAsFunction/ForceAsFunction.md) | Blueprint | æŠŠC++é‡Œç”¨BlueprintImplementableEventæˆ–NativeEventå®šä¹‰çš„äº‹ä»¶å¼ºåˆ¶æ”¹ä¸ºå‡½æ•°åœ¨å­ç±»ä¸­è¦†å†™ã€‚ | â˜…â˜…â˜…      |
| [CannotImplementInterfaceInBlueprint](Blueprint/CannotImplementInterfaceInBlueprint.md) | Blueprint | æŒ‡å®šè¯¥æ¥å£ä¸èƒ½åœ¨è“å›¾ä¸­å®ç°                                   | â˜…â˜…â˜…      |
| [CallInEditor](Blueprint/CallInEditor.md)                    | Blueprint | å¯ä»¥åœ¨Actorçš„ç»†èŠ‚é¢æ¿ä¸Šä½œä¸ºä¸€ä¸ªæŒ‰é’®æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚            | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintProtected](Blueprint/BlueprintProtected/BlueprintProtected.md) | Blueprint | æŒ‡å®šè¯¥å‡½æ•°æˆ–å±æ€§åªèƒ½åœ¨æœ¬ç±»ä»¥åŠå­ç±»ä¸­è¢«è°ƒç”¨æˆ–è¯»å†™ï¼Œç±»ä¼¼C++ä¸­çš„protectedä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚ | â˜…â˜…â˜…      |
| [CommutativeAssociativeBinaryOperator](Blueprint/CommutativeAssociativeBinaryOperator/CommutativeAssociativeBinaryOperator.md) | Blueprint | æ ‡è®°ä¸€ä¸ªäºŒå…ƒè¿ç®—å‡½æ•°çš„è¿ç®—æ”¯æŒäº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œåœ¨è“å›¾èŠ‚ç‚¹ä¸Šå¢åŠ ä¸€ä¸ªâ€œ+â€å¼•è„šï¼Œå…è®¸åŠ¨æ€çš„ç›´æ¥æ·»åŠ å¤šä¸ªè¾“å…¥å€¼ã€‚ | â˜…â˜…â˜…â˜…     |
| [CompactNodeTitle](Blueprint/CompactNodeTitle/CompactNodeTitle.md) | Blueprint | ä½¿å¾—å‡½æ•°çš„å±•ç¤ºå½¢å¼å˜æˆç²¾ç®€å‹ç¼©æ¨¡å¼ï¼ŒåŒæ—¶æŒ‡å®šä¸€ä¸ªæ–°çš„ç²¾ç®€çš„åå­— | â˜…â˜…â˜…      |
| [CustomStructureParam](Blueprint/Param/CustomStructureParam/CustomStructureParam.md) | Blueprint | è¢«CustomStructureParamæ ‡è®°çš„å‡½æ•°å‚æ•°ä¼šå˜æˆWildcardçš„é€šé…ç¬¦å‚æ•°ï¼Œå…¶å¼•è„šçš„ç±»å‹ä¼šç­‰äºè¿æ¥çš„å˜é‡ç±»å‹ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [DefaultToSelf](Blueprint/DefaultToSelf/DefaultToSelf.md)    | Blueprint | ç”¨åœ¨å‡½æ•°ä¸Šï¼ŒæŒ‡å®šä¸€ä¸ªå‚æ•°çš„é»˜è®¤å€¼ä¸ºSelfå€¼                     | â˜…â˜…â˜…â˜…â˜…    |
| [ExpandEnumAsExecs](Blueprint/Exec/ExpandEnumAsExecs/ExpandEnumAsExecs.md) | Blueprint | æŒ‡å®šå¤šä¸ªenumæˆ–boolç±»å‹çš„å‡½æ•°å‚æ•°ï¼Œè‡ªåŠ¨æ ¹æ®æ¡ç›®ç”Ÿæˆç›¸åº”çš„å¤šä¸ªè¾“å…¥æˆ–è¾“å‡ºæ‰§è¡Œå¼•è„šï¼Œå¹¶æ ¹æ®å®å‚å€¼ä¸åŒæ¥ç›¸åº”æ”¹å˜æ§åˆ¶æµã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [ArrayParm](Blueprint/Param/ArrayParm/ArrayParm.md)          | Blueprint | æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨Array<*>çš„å‡½æ•°ï¼Œæ•°ç»„å…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚ | â˜…â˜…â˜…      |
| [AdvancedDisplay](Blueprint/AdvancedDisplay/AdvancedDisplay.md) | Blueprint | æŠŠå‡½æ•°çš„ä¸€äº›å‚æ•°æŠ˜å èµ·æ¥ä¸æ˜¾ç¤ºï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å¼€ä¸‹æ‹‰ç®­å¤´æ¥å±•å¼€ç¼–è¾‘ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [SetParam](Blueprint/SetParam/SetParam.md)                   | Blueprint | æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨Set<TItem>çš„å‡½æ•°ï¼Œå…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚ | â˜…â˜…â˜…      |
| [MapParam](Blueprint/Param/MapParam/MapParam.md)             | Blueprint | æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨TMap<TKey,TValue>çš„å‡½æ•°ï¼Œå…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚ | â˜…â˜…â˜…      |
| [InternalUseParam](Pin/InternalUseParam/InternalUseParam.md) | Blueprint | ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼ŒæŒ‡å®šè¦éšè—çš„å‚æ•°åç§°ï¼Œä¹Ÿå¯ä»¥éšè—è¿”å›å€¼ã€‚å¯ä»¥éšè—å¤šä¸ª | â˜…â˜…â˜…â˜…â˜…    |
| [Keywords](Blueprint/Keywords/Keywords.md)                   | Blueprint | æŒ‡å®šä¸€ç³»åˆ—å…³é”®å­—ç”¨äºåœ¨è“å›¾å†…å³é”®æ‰¾åˆ°è¯¥å‡½æ•°                   | â˜…â˜…â˜…â˜…â˜…    |
| [Latent](Blueprint/Latent/Latent.md)                         | Blueprint | æ ‡æ˜ä¸€ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªå»¶è¿Ÿå¼‚æ­¥æ“ä½œ                               | â˜…â˜…â˜…â˜…â˜…    |
| [NativeMakeFunc](Blueprint/NativeMakeFunc/NativeMakeFunc.md) | Blueprint | æŒ‡å®šä¸€ä¸ªå‡½æ•°é‡‡ç”¨MakeStructçš„å›¾æ ‡                             | â˜…        |
| [UnsafeDuringActorConstruction](Blueprint/UnsafeDuringActorConstruction/UnsafeDuringActorConstruction.md) | Blueprint | æ ‡æ˜è¯¥å‡½æ•°ä¸èƒ½åœ¨Actorçš„æ„é€ å‡½æ•°é‡Œè°ƒç”¨                        | â˜…â˜…       |
| [BlueprintAutocast](Blueprint/BlueprintAutocast/BlueprintAutocast.md) | Blueprint | å‘Šè¯‰è“å›¾ç³»ç»Ÿè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ”¯æŒä»Aç±»å‹åˆ°Bç±»å‹çš„è‡ªåŠ¨è½¬æ¢ã€‚     | â˜…        |
| [DeterminesOutputType](Blueprint/Param/DeterminesOutputType/DeterminesOutputType.md) | Blueprint | æŒ‡å®šä¸€ä¸ªå‚æ•°çš„ç±»å‹ä½œä¸ºå‡½æ•°åŠ¨æ€è°ƒæ•´è¾“å‡ºå‚æ•°ç±»å‹çš„å‚è€ƒç±»å‹     | â˜…â˜…â˜…      |
| [ReturnDisplayName](Blueprint/ReturnDisplayName/ReturnDisplayName.md) | Blueprint | æ”¹å˜å‡½æ•°è¿”å›å€¼çš„åå­—ï¼Œé»˜è®¤æ˜¯ReturnValue                      | â˜…â˜…â˜…â˜…â˜…    |
| [WorldContext](Blueprint/WorldContext/WorldContext.md)       | Blueprint | æŒ‡å®šå‡½æ•°çš„ä¸€ä¸ªå‚æ•°è‡ªåŠ¨æ¥æ”¶WorldContextå¯¹è±¡ï¼Œä»¥ä¾¿ç¡®å®šå½“å‰è¿è¡Œæ‰€å¤„äºçš„World | â˜…â˜…â˜…â˜…â˜…    |
| [AutoCreateRefTerm](Blueprint/Param/AutoCreateRefTerm/AutoCreateRefTerm.md) | Blueprint | æŒ‡å®šå‡½æ•°çš„å¤šä¸ªè¾“å…¥å¼•ç”¨å‚æ•°åœ¨æ²¡æœ‰è¿æ¥çš„æ—¶å€™è‡ªåŠ¨ä¸ºå…¶åˆ›å»ºé»˜è®¤å€¼ | â˜…â˜…â˜…â˜…â˜…    |
| [ProhibitedInterfaces](Blueprint/ProhibitedInterfaces/ProhibitedInterfaces.md) | Blueprint | åˆ—å‡ºä¸è“å›¾ç±»ä¸å…¼å®¹çš„æ¥å£ï¼Œé˜»æ­¢å®ç°                           | â˜…â˜…       |
| [HiddenNode](Blueprint/HiddenNode/HiddenNode.md)             | Blueprint | æŠŠæŒ‡å®šçš„UBTNodeéšè—ä¸åœ¨å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚                      | â˜…        |
| [HideFunctions](Blueprint/HideFunctions.md)                  | Blueprint | åœ¨å±æ€§æŸ¥çœ‹å™¨ä¸­ä¸æ˜¾ç¤ºæŒ‡å®šç±»åˆ«ä¸­çš„æ‰€æœ‰å‡½æ•°ã€‚                   | â˜…â˜…â˜…      |
| [ExposedAsyncProxy](Blueprint/ExposedAsyncProxy/ExposedAsyncProxy.md) | Blueprint | åœ¨ Async Task èŠ‚ç‚¹ä¸­å…¬å¼€æ­¤ç±»çš„ä¸€ä¸ªä»£ç†å¯¹è±¡ã€‚                 | â˜…â˜…â˜…      |
| [NotInputConfigurable](Blueprint/NotInputConfigurable/NotInputConfigurable.md) | Blueprint | è®©ä¸€äº›UInputModifierå’ŒUInputTriggerä¸èƒ½åœ¨ProjectSettingsé‡Œé…ç½®ã€‚ | â˜…        |
| [BlueprintThreadSafe](Blueprint/BlueprintThreadSafe/BlueprintThreadSafe.md) | Blueprint | ç”¨åœ¨ç±»ä¸Šæˆ–å‡½æ•°ä¸Šï¼Œæ ‡è®°ç±»é‡Œçš„å‡½æ•°éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ è¿™æ ·å°±å¯ä»¥åœ¨åŠ¨ç”»è“å›¾ç­‰éæ¸¸æˆçº¿ç¨‹è¢«è°ƒç”¨äº†ã€‚ | â˜…â˜…â˜…      |
| [RestrictedToClasses](Blueprint/RestrictedToClasses/RestrictedToClasses.md) | Blueprint | é™åˆ¶è“å›¾å‡½æ•°åº“ä¸‹çš„å‡½æ•°åªèƒ½åœ¨RestrictedToClassesæŒ‡å®šçš„ç±»è“å›¾ä¸­å³é”®åˆ›å»ºå‡ºæ¥ | â˜…â˜…â˜…      |
| [DontUseGenericSpawnObject](Blueprint/DontUseGenericSpawnObject/DontUseGenericSpawnObject.md) | Blueprint | é˜»æ­¢ä½¿ç”¨è“å›¾ä¸­çš„Generic Create ObjectèŠ‚ç‚¹æ¥ç”Ÿæˆæœ¬ç±»çš„å¯¹è±¡ã€‚  | â˜…â˜…       |
| [ObjectSetType](Blueprint/ObjectSetType/ObjectSetType.md)    | Blueprint | æŒ‡å®šç»Ÿè®¡é¡µé¢çš„å¯¹è±¡é›†åˆç±»å‹ã€‚                                 | â˜…        |
| [SparseClassDataTypes](Blueprint/SparseClassDataTypes.md)    | Blueprint |                                                              | â˜…â˜…â˜…      |
| [KismetHideOverrides](Blueprint/KismetHideOverrides/KismetHideOverrides.md) | Blueprint | ä¸å…è®¸è¢«è¦†ç›–çš„è“å›¾äº‹ä»¶çš„åˆ—è¡¨ã€‚                               | ğŸ’€        |
| [BlueprintType](Blueprint/BlueprintType.md)                  | Blueprint | è¡¨æ˜å¯ä»¥ä½œä¸ºä¸€ä¸ªè“å›¾å˜é‡                                     | â˜…â˜…â˜…â˜…â˜…    |
| [IsConversionRoot](Blueprint/IsConversionRoot.md)            | Blueprint | å…è®¸Actoråœ¨è‡ªèº«ä»¥åŠå­ç±»ä¹‹é—´åšè½¬æ¢                            | â˜…â˜…â˜…      |
| [BlueprintInternalUseOnlyHierarchical](Blueprint/BlueprintInternalUseOnlyHierarchical.md) | Blueprint | æ ‡æ˜è¯¥ç»“æ„åŠå…¶å­ç±»éƒ½ä¸æš´éœ²ç»™ç”¨æˆ·å®šä¹‰å’Œä½¿ç”¨ï¼Œå‡åªèƒ½åœ¨è“å›¾ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨ | â˜…        |
| [BlueprintSetter](Blueprint/BlueprintSetter.md)              | Blueprint | é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„setå‡½æ•°æ¥è¯»å–ã€‚ ä¼šé»˜è®¤è®¾ç½®BlueprintReadWrite. | â˜…â˜…â˜…      |
| [DisplayName](Blueprint/DisplayName.md)                      | Blueprint | æ­¤èŠ‚ç‚¹åœ¨è“å›¾ä¸­çš„å‘½åå°†è¢«æ­¤å¤„æä¾›çš„å€¼æ‰€å–ä»£ï¼Œè€Œéä»£ç ç”Ÿæˆçš„å‘½åã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [ExposeOnSpawn](Blueprint/ExposeOnSpawn/ExposeOnSpawn.md)    | Blueprint | ä½¿è¯¥å±æ€§åœ¨ContructObjectæˆ–SpawnActorç­‰åˆ›å»ºå¯¹è±¡çš„æ—¶å€™æš´éœ²å‡ºæ¥ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [NativeConst](Blueprint/NativeConst.md)                      | Blueprint | æŒ‡å®šæœ‰C++é‡Œçš„constæ ‡å¿—                                       | â˜…        |
| [CPP_Default_XXX](Blueprint/CPP_Default_XXX.md)              | Blueprint | XXX=å‚æ•°åå­—                                                 | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintGetter](Blueprint/BlueprintGetter.md)              | Blueprint | é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„getå‡½æ•°æ¥è¯»å–ã€‚ å¦‚æœæ²¡æœ‰è®¾ç½®BlueprintSetteræˆ–BlueprintReadWrite, åˆ™ä¼šé»˜è®¤è®¾ç½®BlueprintReadOnly. | â˜…â˜…â˜…      |
| [IsBlueprintBase](Blueprint/IsBlueprintBase.md)              | Blueprint | è¯´æ˜æ­¤ç±»æ˜¯å¦ä¸ºåˆ›å»ºè“å›¾çš„ä¸€ä¸ªå¯æ¥å—åŸºç±»ï¼Œä¸ UCLASS è¯´æ˜ç¬¦ã€Blueprintable æˆ– 'NotBlueprintable` ç›¸ä¼¼ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [BlueprintInternalUseOnly](Blueprint/BlueprintInternalUseOnly.md) | Blueprint | æ ‡æ˜è¯¥å…ƒç´ æ˜¯ä½œä¸ºè“å›¾ç³»ç»Ÿçš„å†…éƒ¨è°ƒç”¨æˆ–ä½¿ç”¨ï¼Œä¸æš´éœ²å‡ºæ¥åœ¨ç”¨æˆ·å±‚é¢ç›´æ¥å®šä¹‰æˆ–ä½¿ç”¨ã€‚ | â˜…â˜…â˜…      |


## Component

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ | -------- |
| [UseComponentPicker](Component/UseComponentPicker/UseComponentPicker.md) | Component | ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œä½¿å¾—é€‰å–å™¨çš„åˆ—è¡¨é‡Œå±•ç¤ºå‡ºActorå±ä¸‹çš„Componentä»¥ä¾¿é€‰æ‹©ã€‚ | â˜…â˜…       |
| [AllowAnyActor](Component/AllowAnyActor.md)                  | Component | ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œåœ¨UseComponentPickerçš„æƒ…å†µä¸‹ä½¿å¾—ç»„ä»¶é€‰å–å™¨æ‰©å¤§åˆ°åœºæ™¯é‡Œå…¶ä»–Actorä¸‹çš„å…¶ä»–ç»„ä»¶ã€‚ | â˜…â˜…       |
| [BlueprintSpawnableComponent](Component/BlueprintSpawnableComponent/BlueprintSpawnableComponent.md) | Component | å…è®¸è¯¥ç»„ä»¶å‡ºç°åœ¨Actorè“å›¾é‡ŒAddç»„ä»¶çš„é¢æ¿é‡Œã€‚                 | â˜…â˜…â˜…â˜…     |


## Config

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [ConsoleVariable](Config/ConsoleVariable/ConsoleVariable.md)                                                                   | Config               | æŠŠä¸€ä¸ªConifgå±æ€§çš„å€¼åŒæ­¥åˆ°ä¸€ä¸ªåŒåçš„æ§åˆ¶å°å˜é‡ã€‚                                                                                                                                                                                                                                      | â˜…â˜…â˜…â˜…â˜… |
| [EditorConfig](Config/EditorConfig.md)                                                                                         | Config               | ä¿å­˜ç¼–è¾‘å™¨çš„é…ç½®                                                                                                                                                                                                                                                         | â˜…â˜…â˜…   |
| [ConfigHierarchyEditable](Config/ConfigHierarchyEditable/ConfigHierarchyEditable.md)                                           | Config               | ä½¿å¾—ä¸€ä¸ªå±æ€§å¯ä»¥åœ¨Configçš„å„ä¸ªå±‚çº§é…ç½®ã€‚                                                                                                                                                                                                                                          | â˜…â˜…â˜…   |
| [ConfigRestartRequired](Config/ConfigRestartRequired/ConfigRestartRequired.md)                                                 | Config               | ä½¿å±æ€§åœ¨è®¾ç½®é‡Œæ”¹å˜åå¼¹å‡ºé‡å¯ç¼–è¾‘å™¨çš„å¯¹è¯æ¡†ã€‚                                                                                                                                                                                                                                           | â˜…â˜…â˜…   |


## Container

| Name                                                         | å¼•æ“æ¨¡å—  | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ | -------- |
| [ReadOnlyKeys](Container/ReadOnlyKeys/ReadOnlyKeys.md)       | Container | ä½¿TMapå±æ€§çš„Keyä¸èƒ½ç¼–è¾‘ã€‚                                    | â˜…â˜…       |
| [ArraySizeEnum](Container/ArraySizeEnum/ArraySizeEnum.md)    | Container | ä¸ºå›ºå®šæ•°ç»„æä¾›ä¸€ä¸ªæšä¸¾ï¼Œä½¿å¾—æ•°ç»„å…ƒç´ æŒ‰ç…§æšä¸¾å€¼æ¥ä½œä¸ºç´¢å¼•å’Œæ˜¾ç¤ºã€‚ | â˜…â˜…â˜…      |
| [TitleProperty](Container/TitleProperty/TitleProperty.md)    | Container | æŒ‡å®šç»“æ„æ•°ç»„é‡Œçš„ç»“æ„æˆå‘˜å±æ€§å†…å®¹æ¥ä½œä¸ºç»“æ„æ•°ç»„å…ƒç´ çš„æ˜¾ç¤ºæ ‡é¢˜ã€‚ | â˜…â˜…       |
| [EditFixedOrder](Container/EditFixedOrder/EditFixedOrder.md) | Container | ä½¿æ•°ç»„çš„å…ƒç´ æ— æ³•é€šè¿‡æ‹–æ‹½æ¥é‡æ–°æ’åºã€‚                         | â˜…â˜…       |
| [NoElementDuplicate](Container/NoElementDuplicate/NoElementDuplicate.md) | Container | å»é™¤TArrayå±æ€§é‡Œæ•°æ®é¡¹çš„Duplicateèœå•é¡¹æŒ‰é’®ã€‚                | â˜…        |


## Debug

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [DebugTreeLeaf](Debug/DebugTreeLeaf/DebugTreeLeaf.md)                                                                          | Debug                | é˜»æ­¢BlueprintDebuggerå±•å¼€è¯¥ç±»çš„å±æ€§ä»¥åŠ é€Ÿç¼–è¾‘å™¨é‡Œè°ƒè¯•å™¨çš„æ€§èƒ½                                                                                                                                                                                                                          | â˜…     |


## DetailsPanel

| Name                                                         | å¼•æ“æ¨¡å—     | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | -------- |
| [HideInDetailPanel](DetailsPanel/HideInDetailPanel/HideInDetailPanel.md) | DetailsPanel | åœ¨Actorçš„äº‹ä»¶é¢æ¿é‡Œéšè—è¯¥åŠ¨æ€å¤šæ’­å§”æ‰˜å±æ€§ã€‚                  | â˜…â˜…       |
| [DisplayAfter](DetailsPanel/DisplayAfter/DisplayAfter.md)    | DetailsPanel | ä½¿æœ¬å±æ€§åœ¨æŒ‡å®šçš„å±æ€§ä¹‹åæ˜¾ç¤ºã€‚                               | â˜…â˜…â˜…      |
| [EditCondition](DetailsPanel/EditCondition/EditCondition.md) | DetailsPanel | ç»™ä¸€ä¸ªå±æ€§æŒ‡å®šå¦å¤–ä¸€ä¸ªå±æ€§æˆ–è€…è¡¨è¾¾å¼æ¥ä½œä¸ºæ˜¯å¦å¯ç¼–è¾‘çš„æ¡ä»¶ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [DisplayPriority](DetailsPanel/DisplayPriority/DisplayPriority.md) | DetailsPanel | æŒ‡å®šæœ¬å±æ€§åœ¨ç»†èŠ‚é¢æ¿çš„æ˜¾ç¤ºé¡ºåºä¼˜å…ˆçº§ï¼Œè¶Šå°çš„ä¼˜å…ˆçº§è¶Šé«˜ã€‚     | â˜…â˜…â˜…      |
| [AdvancedClassDisplay](DetailsPanel/AdvancedClassDisplay.md) | DetailsPanel | æŒ‡å®šè¯¥ç±»å‹çš„å˜é‡åœ¨é«˜çº§æ˜¾ç¤ºé‡Œæ˜¾ç¤º                             | â˜…â˜…â˜…      |
| [bShowOnlyWhenTrue](DetailsPanel/bShowOnlyWhenTrue/bShowOnlyWhenTrue.md) | DetailsPanel | æ ¹æ®ç¼–è¾‘å™¨configé…ç½®æ–‡ä»¶é‡Œå­—æ®µå€¼æ¥å†³å®šå½“å‰å±æ€§æ˜¯å¦æ˜¾ç¤ºã€‚     | â˜…        |
| [PrioritizeCategories](DetailsPanel/PrioritizeCategories.md) | DetailsPanel | æŠŠæŒ‡å®šçš„å±æ€§ç›®å½•ä¼˜å…ˆæ˜¾ç¤ºåœ¨å‰é¢                               | â˜…â˜…â˜…      |
| [AutoExpandCategories](DetailsPanel/AutoExpandCategories.md) | DetailsPanel | æŒ‡å®šç±»å†…éƒ¨çš„å±æ€§ç›®å½•è‡ªåŠ¨å±•å¼€èµ·æ¥                             | â˜…â˜…â˜…      |
| [AutoCollapseCategories](DetailsPanel/AutoCollapseCategories.md) | DetailsPanel | æŒ‡å®šç±»å†…éƒ¨çš„å±æ€§ç›®å½•è‡ªåŠ¨æŠ˜å èµ·æ¥                             | â˜…â˜…â˜…      |
| [HideEditConditionToggle](DetailsPanel/HideEditConditionToggle/HideEditConditionToggle.md) | DetailsPanel | ç”¨åœ¨ä½¿ç”¨EditConditionçš„å±æ€§ä¸Šï¼Œè¡¨ç¤ºè¯¥å±æ€§ä¸æƒ³è¦å…¶EditConditionç”¨åˆ°çš„å±æ€§è¢«éšè—èµ·æ¥ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [ClassGroupNames](DetailsPanel/ClassGroupNames.md)           | DetailsPanel | æŒ‡å®šClassGroupçš„åå­—                                         | â˜…â˜…â˜…      |
| [MaxPropertyDepth](DetailsPanel/MaxPropertyDepth/MaxPropertyDepth.md) | DetailsPanel | æŒ‡å®šå¯¹è±¡æˆ–ç»“æ„åœ¨ç»†èŠ‚é¢æ¿é‡Œå±•å¼€çš„å±‚æ•°ã€‚                       | â˜…        |
| [DeprecatedNode](DetailsPanel/DeprecatedNode/DeprecatedNode.md) | DetailsPanel | ç”¨äºBehaviorTreeNodeæˆ–EnvQueryNodeï¼Œè¯´æ˜è¯¥ç±»å·²åºŸå¼ƒï¼Œåœ¨ç¼–è¾‘å™¨ä¸­çº¢è‰²é”™è¯¯å±•ç¤ºå¹¶æœ‰é”™è¯¯ToolTipæç¤º | â˜…â˜…       |
| [UsesHierarchy](DetailsPanel/UsesHierarchy.md)               | DetailsPanel | è¯´æ˜ç±»ä½¿ç”¨å±‚çº§æ•°æ®ã€‚ç”¨äºå®ä¾‹åŒ–â€œç»†èŠ‚â€é¢æ¿ä¸­çš„å±‚çº§ç¼–è¾‘åŠŸèƒ½ã€‚   | ğŸ’€        |
| [IgnoreCategoryKeywordsInSubclasses](DetailsPanel/IgnoreCategoryKeywordsInSubclasses.md) | DetailsPanel | ç”¨äºè®©ä¸€ä¸ªç±»çš„é¦–ä¸ªå­ç±»å¿½ç•¥æ‰€æœ‰ç»§æ‰¿çš„ ShowCategories å’Œ HideCategories è¯´æ˜ç¬¦ã€‚ | â˜…        |
| [NoResetToDefault](DetailsPanel/NoResetToDefault/NoResetToDefault.md) | DetailsPanel | ç¦ç”¨å’Œéšè—å±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸Šçš„â€œé‡ç½®â€åŠŸèƒ½ã€‚                     | â˜…â˜…â˜…      |
| [ReapplyCondition](DetailsPanel/ReapplyCondition.md)         | DetailsPanel | // Properties that have a ReapplyCondition should be disabled behind the specified property when in reapply mode | â˜…        |
| [HideBehind](DetailsPanel/HideBehind.md)                     | DetailsPanel | åªåœ¨æŒ‡å®šçš„å±æ€§ä¸ºtrueæˆ–ä¸ä¸ºç©ºçš„æ—¶å€™æœ¬å±æ€§æ‰æ˜¾ç¤º               | â˜…        |
| [Category](DetailsPanel/Category.md)                         | DetailsPanel | æŒ‡å®šå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­çš„åˆ†ç±»                                   | â˜…â˜…â˜…â˜…â˜…    |
| [HideCategories](DetailsPanel/HideCategories.md)             | DetailsPanel | éšè—çš„ç±»åˆ«                                                   | â˜…â˜…â˜…      |
| [EditInline](DetailsPanel/EditInline/EditInline.md)          | DetailsPanel | ä¸ºå¯¹è±¡å±æ€§åˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä½œä¸ºå­å¯¹è±¡ã€‚                       | â˜…â˜…â˜…      |


## Development

| Name                                                         | å¼•æ“æ¨¡å—    | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | -------- |
| [DeprecatedProperty](Development/DeprecatedProperty/DeprecatedProperty.md) | Development | æ ‡è®°å¼ƒç”¨ï¼Œå¼•ç”¨åˆ°è¯¥å±æ€§çš„è“å›¾ä¼šè§¦å‘ä¸€ä¸ªè­¦å‘Š                   | â˜…        |
| [Deprecated](Development/Deprecated/Deprecated.md)           | Development | æŒ‡å®šè¯¥å…ƒç´ è¦åºŸå¼ƒçš„å¼•æ“ç‰ˆæœ¬å·ã€‚                               | â˜…        |
| [DevelopmentOnly](Development/DevelopmentOnly/DevelopmentOnly.md) | Development | ä½¿å¾—ä¸€ä¸ªå‡½æ•°å˜ä¸ºDevelopmentOnlyï¼Œæ„å‘³ç€åªä¼šåœ¨Developmentæ¨¡å¼ä¸­è¿è¡Œã€‚é€‚ç”¨äºè°ƒè¯•è¾“å‡ºä¹‹ç±»çš„åŠŸèƒ½ï¼Œä½†åœ¨æœ€ç»ˆå‘å¸ƒç‰ˆä¸­ä¼šè·³è¿‡ã€‚ | â˜…        |
| [DeprecationMessage](Development/DeprecationMessage.md)      | Development | å®šä¹‰å¼ƒç”¨çš„æ¶ˆæ¯                                               | â˜…        |
| [DeprecatedFunction](Development/DeprecatedFunction.md)      | Development | æ ‡æ˜ä¸€ä¸ªå‡½æ•°å·²ç»è¢«å¼ƒç”¨                                       | â˜…        |
| [Comment](Development/Comment/Comment.md)                    | Development | ç”¨æ¥è®°å½•æ³¨é‡Šçš„å†…å®¹                                           | â˜…â˜…â˜…      |
| [FriendlyName](Development/FriendlyName.md)                  | Development | å’ŒDisplayNameä¸€æ ·ï¼Ÿ                                          | ğŸ’€        |
| [DevelopmentStatus](Development/DevelopmentStatus.md)        | Development | æ ‡æ˜å¼€å‘çŠ¶æ€                                                 | â˜…        |
| [ToolTip](Development/ToolTip/ToolTip.md)                    | Development | åœ¨Metaé‡Œæä¾›ä¸€ä¸ªæç¤ºæ–‡æœ¬ï¼Œè¦†ç›–ä»£ç æ³¨é‡Šé‡Œçš„æ–‡æœ¬               | â˜…â˜…â˜…      |


## Enum

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [Enum](Enum/Enum.md)                                         | Enum     | ç»™ä¸€ä¸ªStringæŒ‡å®šä»¥æšä¸¾é‡Œå€¼çš„åç§°ä½œä¸ºé€‰é¡¹                     | â˜…â˜…â˜…      |
| [GetRestrictedEnumValues](Enum/GetRestrictedEnumValues.md)   | Enum     | æŒ‡å®šä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šæšä¸¾å±æ€§å€¼çš„å“ªäº›æšä¸¾é€‰é¡¹æ˜¯ç¦ç”¨çš„           | â˜…â˜…â˜…      |
| [EnumValueDisplayNameOverrides](Enum/EnumValueDisplayNameOverrides/EnumValueDisplayNameOverrides.md) | Enum     | æ”¹å˜æšä¸¾å±æ€§å€¼ä¸Šçš„æ˜¾ç¤ºåå­—                                   | â˜…â˜…       |
| [EnumDisplayNameFn](Enum/EnumDisplayNameFn/EnumDisplayNameFn.md) | Enum     | åœ¨Runtimeä¸‹ä¸ºæšä¸¾å­—æ®µæä¾›è‡ªå®šä¹‰åç§°çš„å‡½æ•°å›è°ƒ                | â˜…â˜…       |
| [Bitflags](Enum/Bitflags/Bitflags.md)                        | Enum     | è®¾å®šä¸€ä¸ªæšä¸¾æ”¯æŒé‡‡ç”¨ä½æ ‡è®°èµ‹å€¼ï¼Œä»è€Œåœ¨è“å›¾ä¸­å¯ä»¥è¯†åˆ«å‡ºæ¥æ˜¯BitMask | â˜…â˜…â˜…â˜…â˜…    |
| [Spacer](Enum/UMETA/Spacer.md)                               | Enum     | éšè—UENUMçš„æŸä¸ªå€¼                                            | â˜…â˜…â˜…â˜…â˜…    |
| [InvalidEnumValues](Enum/InvalidEnumValues.md)               | Enum     | æŒ‡å®šæšä¸¾å±æ€§å€¼ä¸Šä¸å¯é€‰çš„æšä¸¾å€¼é€‰é¡¹ï¼Œç”¨ä»¥æ’é™¤ä¸€äº›é€‰é¡¹         | â˜…â˜…â˜…      |
| [ValidEnumValues](Enum/ValidEnumValues/ValidEnumValues.md)   | Enum     | æŒ‡å®šæšä¸¾å±æ€§å€¼ä¸Šå¯é€‰çš„æšä¸¾å€¼é€‰é¡¹                             | â˜…â˜…â˜…      |
| [DisplayName](Enum/UMETA/DisplayName/DisplayName)            | Enum     | æ”¹å˜æšä¸¾å€¼çš„æ˜¾ç¤ºåç§°                                         | â˜…â˜…â˜…â˜…â˜…    |
| [Hidden](Enum/UMETA/Hidden/Hidden)                           | Enum     | éšè—UENUMçš„æŸä¸ªå€¼                                            | â˜…â˜…â˜…â˜…â˜…    |
| [DisplayValue](Enum/UMETA/DisplayValue.md)                   | Enum     | Enum /Script/Engine.AnimPhysCollisionType                    | ğŸ’€        |
| [Grouping](Enum/UMETA/Grouping.md)                           | Enum     | Enum /Script/Engine.EAlphaBlendOption                        | ğŸ’€        |
| [TraceQuery](Enum/UMETA/TraceQuery.md)                       | Enum     | Enum /Script/Engine.ECollisionChannel                        | ğŸ’€        |
| [Bitmask](Enum/BitmaskEnum/BitmaskEnum.md)                   | Enum     | è®¾å®šä¸€ä¸ªå±æ€§é‡‡ç”¨Bitmaskèµ‹å€¼                                  | â˜…â˜…â˜…â˜…â˜…    |


## FieldNotify

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [FieldNotifyInterfaceParam](UHT/FieldNotifyInterfaceParam/FieldNotifyInterfaceParam.md)                                        | FieldNotify          | æŒ‡å®šå‡½æ•°çš„æŸä¸ªå‚æ•°æä¾›FieldNotifyçš„ViewModelä¿¡æ¯ã€‚                                                                                                                                                                                                                              | â˜…â˜…â˜…   |


## GAS

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [HideInDetailsView](GAS/HideInDetailsView/HideInDetailsView.md)                                                                | GAS                  | æŠŠè¯¥UAttributeSetå­ç±»é‡Œçš„å±æ€§éšè—åœ¨FGameplayAttributeçš„é€‰é¡¹åˆ—è¡¨é‡Œã€‚                                                                                                                                                                                                                | â˜…â˜…â˜…   |
| [SystemGameplayAttribute](GAS/SystemGameplayAttribute/SystemGameplayAttribute.md)                                              | GAS                  | æŠŠUAbilitySystemComponentå­ç±»é‡Œé¢çš„å±æ€§æš´éœ²åˆ°FGameplayAttribute é€‰é¡¹æ¡†é‡Œã€‚                                                                                                                                                                                                       | â˜…â˜…â˜…   |
| [HideFromModifiers](GAS/HideFromModifiers/HideFromModifiers.md)                                                                | GAS                  | æŒ‡å®šAttributeSetä¸‹çš„æŸå±æ€§ä¸å‡ºç°åœ¨GameplayEffectä¸‹çš„Modifiersçš„Attributeé€‰æ‹©é‡Œã€‚                                                                                                                                                                                                   | â˜…â˜…â˜…   |


## Material

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [MaterialParameterCollectionFunction](Material/MaterialParameterCollectionFunction/MaterialParameterCollectionFunction.md) | Material | æŒ‡å®šè¯¥å‡½æ•°æ˜¯ç”¨äºæ“ä½œUMaterialParameterCollectionï¼Œä»è€Œæ”¯æŒParameterNameçš„æå–å’ŒéªŒè¯ | â˜…â˜…â˜…      |
| [MaterialNewHLSLGenerator](Material/MaterialNewHLSLGenerator/MaterialNewHLSLGenerator.md) | Material | æ ‡è¯†è¯¥UMaterialExpressionä¸ºé‡‡ç”¨æ–°HLSLç”Ÿæˆå™¨çš„èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚ | â˜…        |
| [ShowAsInputPin](Material/ShowAsInputPin/ShowAsInputPin.md)  | Material | ä½¿å¾—UMaterialExpressioné‡Œçš„ä¸€äº›åŸºç¡€ç±»å‹å±æ€§å˜æˆæè´¨èŠ‚ç‚¹ä¸Šçš„å¼•è„šã€‚ | â˜…â˜…â˜…      |
| [RequiredInput](Material/RequiredInput.md)                   | Material | åœ¨UMaterialExpressionä¸­æŒ‡å®šFExpressionInputå±æ€§æ˜¯å¦è¦æ±‚è¾“å…¥ï¼Œå¼•è„šæ˜¾ç¤ºç™½è‰²æˆ–ç°è‰²ã€‚ | ğŸ’€        |
| [MaterialControlFlow](Material/MaterialControlFlow/MaterialControlFlow.md) | Material | æ ‡è¯†è¯¥UMaterialExpressionä¸ºä¸€ä¸ªæ§åˆ¶æµèŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚ | â˜…        |
| [OverridingInputProperty](Material/OverridingInputProperty/OverridingInputProperty.md) | Material | åœ¨UMaterialExpressionä¸­æŒ‡å®šæœ¬floatè¦è¦†ç›–çš„å…¶ä»–FExpressionInput å±æ€§ã€‚ | â˜…â˜…â˜…      |
| [Private](Material/Private/Private.md)                       | Material | æ ‡è¯†è¯¥UMaterialExpressionä¸ºç§æœ‰èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚ | â˜…        |


## Niagara

| Name                                                      | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                      | å¸¸ç”¨ç¨‹åº¦ |
| --------------------------------------------------------- | -------- | --------------------------------------------- | -------- |
| [NiagaraClearEachFrame](Niagara/NiagaraClearEachFrame.md) | Niagara  | ScriptStruct /Script/Niagara.NiagaraSpawnInfo | ğŸ’€        |
| [NiagaraInternalType](Niagara/NiagaraInternalType.md)     | Niagara  | æŒ‡å®šè¯¥ç»“æ„çš„ç±»å‹ä¸ºNiagaraçš„å†…éƒ¨ç±»å‹ã€‚         | ğŸ’€        |


## Numeric

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [CtrlMultiplier](Numeric/CtrlMultiplier/CtrlMultiplier.md)   | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†åœ¨CtrlæŒ‰ä¸‹æ—¶é¼ æ ‡è½®æ»šåŠ¨å’Œé¼ æ ‡æ‹–åŠ¨æ”¹å˜å€¼çš„å€ç‡ã€‚ | â˜…â˜…       |
| [ShiftMultiplier](Numeric/ShiftMultiplier.md)                | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†åœ¨ShiftæŒ‰ä¸‹æ—¶é¼ æ ‡è½®æ»šåŠ¨å’Œé¼ æ ‡æ‹–åŠ¨æ”¹å˜å€¼çš„å€ç‡ã€‚ | â˜…â˜…       |
| [SliderExponent](Numeric/SliderExponent/SliderExponent.md)   | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„å˜åŒ–æŒ‡æ•°åˆ†å¸ƒ                     | â˜…â˜…â˜…â˜…â˜…    |
| [Multiple](Numeric/Multiple/Multiple.md)                     | Numeric  | æŒ‡å®šæ•°å­—çš„å€¼å¿…é¡»æ˜¯Mutlipleæä¾›çš„å€¼çš„æ•´æ•°å€ã€‚                 | â˜…â˜…â˜…      |
| [ForceUnits](Numeric/ForceUnits.md)                          | Numeric  | å›ºå®šè®¾å®šå±æ€§å€¼çš„å•ä½ä¿æŒä¸å˜ï¼Œä¸æ ¹æ®æ•°å€¼åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºå•ä½ã€‚   | â˜…â˜…â˜…      |
| [Units](Numeric/Units/Units.md)                              | Numeric  | è®¾å®šå±æ€§å€¼çš„å•ä½ï¼Œæ”¯æŒå®æ—¶æ ¹æ®æ•°å€¼ä¸åŒåŠ¨æ€æ”¹å˜æ˜¾ç¤ºçš„å•ä½ã€‚   | â˜…â˜…â˜…      |
| [LinearDeltaSensitivity](Numeric/LinearDeltaSensitivity.md)  | Numeric  | åœ¨è®¾å®šDeltaåï¼Œè¿›ä¸€æ­¥è®¾å®šæ•°å­—è¾“å…¥æ¡†å˜æˆçº¿æ€§æ”¹å˜ä»¥åŠæ”¹å˜çš„æ•æ„Ÿåº¦ï¼ˆå€¼è¶Šå¤§è¶Šä¸æ•æ„Ÿï¼‰ | â˜…â˜…â˜…      |
| [Delta](Numeric/Delta/Delta.md)                              | Numeric  | è®¾å®šæ•°å­—è¾“å…¥æ¡†å€¼æ”¹å˜çš„å¹…åº¦ä¸ºDeltaçš„å€æ•°                      | â˜…â˜…â˜…      |
| [UIMax](Numeric/UIMax.md)                                    | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„æœ€å¤§èŒƒå›´å€¼                       | â˜…â˜…â˜…â˜…â˜…    |
| [UIMin](Numeric/UIMin/UIMin.md)                              | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„æœ€å°èŒƒå›´å€¼                       | â˜…â˜…â˜…â˜…â˜…    |
| [SupportDynamicSliderMaxValue](Numeric/SupportDynamicSliderMaxValue.md) | Numeric  | æ”¯æŒæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡çš„æœ€å¤§èŒƒå›´å€¼åœ¨AltæŒ‰ä¸‹æ—¶è¢«åŠ¨æ€æ”¹å˜      | â˜…        |
| [ClampMax](Numeric/ClampMax.md)                              | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†å®é™…æ¥å—çš„æœ€å¤§å€¼                               | â˜…â˜…â˜…â˜…â˜…    |
| [ClampMin](Numeric/ClampMin.md)                              | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†å®é™…æ¥å—çš„æœ€å°å€¼                               | â˜…â˜…â˜…â˜…â˜…    |
| [ArrayClamp](Numeric/ArrayClamp/ArrayClamp.md)               | Numeric  | é™å®šæ•´æ•°å±æ€§çš„å€¼å¿…é¡»åœ¨æŒ‡å®šæ•°ç»„çš„åˆæ³•ä¸‹æ ‡èŒƒå›´å†…ï¼Œ[0,ArrayClamp.Size()-1] | â˜…â˜…â˜…      |
| [HideAlphaChannel](Numeric/HideAlphaChannel/HideAlphaChannel.md) | Numeric  | ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™éšè—Alphaé€šé“ã€‚        | â˜…â˜…â˜…      |
| [AllowPreserveRatio](Numeric/AllowPreserveRatio/AllowPreserveRatio.md) | Numeric  | åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸ºFVectorå±æ€§æ·»åŠ ä¸€ä¸ªæ¯”ç‡é”ã€‚                    | â˜…â˜…â˜…      |
| [NoSpinbox](Numeric/NoSpinbox/NoSpinbox.md)                  | Numeric  | ä½¿æ•°å€¼å±æ€§ç¦æ­¢é»˜è®¤çš„æ‹–æ”¾å’Œæ»šè½®çš„UIç¼–è¾‘åŠŸèƒ½ï¼Œæ•°å€¼å±æ€§åŒ…æ‹¬intç³»åˆ—ä»¥åŠfloatç³»åˆ—ã€‚ | â˜…â˜…       |
| [SupportDynamicSliderMinValue](Numeric/SupportDynamicSliderMinValue/SupportDynamicSliderMinValue.md) | Numeric  | æ”¯æŒæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡çš„æœ€å°èŒƒå›´å€¼åœ¨AltæŒ‰ä¸‹æ—¶è¢«åŠ¨æ€æ”¹å˜      | â˜…        |
| [sRGB](Numeric/sRGB.md)                                      | Numeric  | ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™é‡‡ç”¨sRGBæ–¹å¼ã€‚         | ğŸ’€        |
| [WheelStep](Numeric/WheelStep/WheelStep.md)                  | Numeric  | æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šé¼ æ ‡è½®ä¸Šä¸‹æ»šåŠ¨äº§ç”Ÿçš„å˜åŒ–å€¼                   | â˜…â˜…â˜…      |
| [InlineColorPicker](Numeric/InlineColorPicker/InlineColorPicker.md) | Numeric  | ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™ç›´æ¥å†…è”ä¸€ä¸ªé¢œè‰²é€‰æ‹©å™¨ã€‚ | â˜…â˜…       |
| [ShowNormalize](Numeric/ShowNormalize/ShowNormalize.md)      | Numeric  | ä½¿å¾—FVectorå˜é‡åœ¨ç»†èŠ‚é¢æ¿å‡ºç°ä¸€ä¸ªæ­£è§„åŒ–çš„æŒ‰é’®ã€‚              | â˜…â˜…â˜…      |
| [ColorGradingMode](Numeric/ColorGradingMode/ColorGradingMode.md) | Numeric  | ä½¿å¾—ä¸€ä¸ªFVector4å±æ€§æˆä¸ºé¢œè‰²æ˜¾ç¤º                             | â˜…â˜…       |


## Object

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [ThumbnailSize](Object/ThumbnailSize.md)                     | Object   | æ”¹å˜ç¼©ç•¥å›¾çš„å¤§å°ã€‚                                           | ğŸ’€        |
| [LoadBehavior](Object/LoadBehavior/LoadBehavior.md)          | Object   | ç”¨åœ¨UCLASSä¸Šæ ‡è®°è¿™ä¸ªç±»çš„åŠ è½½è¡Œä¸ºï¼Œä½¿å¾—ç›¸åº”çš„TObjectPtrå±æ€§æ”¯æŒå»¶è¿ŸåŠ è½½ã€‚å¯é€‰çš„åŠ è½½è¡Œä¸ºé»˜è®¤ä¸ºEagerï¼Œå¯æ”¹ä¸ºLazyOnDemandã€‚ | â˜…        |
| [DisplayThumbnail](Object/DisplayThumbnail/DisplayThumbnail.md) | Object   | æŒ‡å®šæ˜¯å¦åœ¨è¯¥å±æ€§å·¦ä¾§æ˜¾ç¤ºä¸€ä¸ªç¼©ç•¥å›¾ã€‚                         | â˜…â˜…â˜…      |
| [ShowInnerProperties](Object/ShowInnerProperties/ShowInnerProperties.md) | Object   | åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºå¯¹è±¡å¼•ç”¨çš„å†…éƒ¨å±æ€§                       | â˜…â˜…â˜…â˜…â˜…    |
| [Untracked](Object/Untracked/Untracked.md)                   | Object   | ä½¿å¾—TSoftObjectPtrå’ŒFSoftObjectPathçš„è½¯å¯¹è±¡å¼•ç”¨ç±»å‹çš„å±æ€§ï¼Œä¸è·Ÿè¸ªè®°å½•èµ„äº§çš„ ã€‚ | â˜…        |
| [HideAssetPicker](Object/HideAssetPicker/HideAssetPicker.md) | Object   | éšè—Objectç±»å‹å¼•è„šä¸Šçš„AssetPickerçš„é€‰æ‹©åˆ—è¡¨                  | â˜…â˜…       |
| [AssetBundles](Object/AssetBundles/AssetBundles.md)          | Object   | æ ‡æ˜è¯¥å±æ€§å…¶å¼•ç”¨çš„èµ„äº§å±äºå“ªä¸€äº›AssetBundlesã€‚               | â˜…â˜…â˜…      |
| [MustBeLevelActor](Object/MustBeLevelActor.md)               | Object   |                                                              |          |
| [ExposeFunctionCategories](Object/ExposeFunctionCategories/ExposeFunctionCategories.md) | Object   | æŒ‡å®šè¯¥Objectå±æ€§æ‰€å±äºçš„ç±»é‡Œçš„æŸäº›ç›®å½•ä¸‹çš„å‡½æ•°å¯ä»¥ç›´æ¥åœ¨æœ¬ç±»ä¸Šæš´éœ²å‡ºæ¥ã€‚ | â˜…â˜…â˜…      |
| [IncludeAssetBundles](Object/IncludeAssetBundles/IncludeAssetBundles.md) | Object   | ç”¨äºUPrimaryDataAssetçš„å­å¯¹è±¡å±æ€§ï¼ŒæŒ‡å®šåº”è¯¥ç»§ç»­é€’å½’åˆ°è¯¥å­å¯¹è±¡é‡Œå»æ¢æµ‹AssetBundleæ•°æ®ã€‚ | â˜…â˜…       |


## Path

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [RelativeToGameContentDir](Path/RelativeToGameContentDir.md) | Path     | ä½¿å¾—ç³»ç»Ÿç›®å½•é€‰æ‹©å¯¹è¯æ¡†çš„ç»“æœä¸ºç›¸å¯¹Contentçš„ç›¸å¯¹è·¯å¾„ã€‚        | ğŸ’€        |
| [ContentDir](Path/ContentDir/ContentDir.md)                  | Path     | ä½¿ç”¨UEçš„é£æ ¼æ¥é€‰æ‹©Contentä»¥åŠå­ç›®å½•ã€‚                        | â˜…â˜…â˜…      |
| [LongPackageName](Path/LongPackageName.md)                   | Path     | ä½¿ç”¨UEçš„é£æ ¼æ¥é€‰æ‹©Contentä»¥åŠå­ç›®å½•ï¼Œæˆ–è€…æŠŠæ–‡ä»¶è·¯å¾„è½¬æ¢ä¸ºé•¿åŒ…åã€‚ | â˜…â˜…â˜…      |
| [FilePathFilter](Path/FilePathFilter.md)                     | Path     | è®¾å®šæ–‡ä»¶é€‰æ‹©å™¨çš„æ‰©å±•åï¼Œè§„åˆ™ç¬¦åˆç³»ç»Ÿå¯¹è¯æ¡†çš„æ ¼å¼è§„èŒƒï¼Œå¯ä»¥å¡«å†™å¤šä¸ªæ‰©å±•åã€‚ | â˜…â˜…â˜…      |
| [RelativePath](Path/RelativePath.md)                         | Path     | ä½¿å¾—ç³»ç»Ÿç›®å½•é€‰æ‹©å¯¹è¯æ¡†çš„ç»“æœä¸ºå½“å‰è¿è¡Œexeçš„ç›¸å¯¹è·¯å¾„ã€‚        | ğŸ’€        |
| [RelativeToGameDir](Path/RelativeToGameDir/RelativeToGameDir.md) | Path     | å¦‚æœç³»ç»Ÿç›®å½•é€‰æ‹©æ¡†çš„ç»“æœä¸ºProjectçš„å­ç›®å½•ï¼Œåˆ™è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ï¼Œå¦åˆ™è¿”å›ç»å¯¹è·¯å¾„ã€‚ | â˜…â˜…â˜…      |


## Pin

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [HidePin](Pin/HidePin/HidePin.md)                                                                                              | Pin                  | ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼ŒæŒ‡å®šè¦éšè—çš„å‚æ•°åç§°ï¼Œä¹Ÿå¯ä»¥éšè—è¿”å›å€¼ã€‚å¯ä»¥éšè—å¤šä¸ªå‚æ•°                                                                                                                                                                                                                             | â˜…â˜…    |
| [InternalUseParam](Pin/InternalUseParam/InternalUseParam.md)                                                                   | Pin                  | ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼ŒæŒ‡å®šè¦éšè—çš„å‚æ•°åç§°ï¼Œä¹Ÿå¯ä»¥éšè—è¿”å›å€¼ã€‚å¯ä»¥éšè—å¤šä¸ªå‚æ•°                                                                                                                                                                                                                             | â˜…â˜…    |
| [HideSelfPin](Pin/HideSelfPin/HideSelfPin.md)                                                                                  | Pin                  | ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼Œéšè—é»˜è®¤çš„SelfPinï¼Œä¹Ÿå°±æ˜¯Targetï¼Œå¯¼è‡´è¯¥å‡½æ•°åªèƒ½åœ¨OwnerClasså†…è°ƒç”¨ã€‚                                                                                                                                                                                                            | â˜…â˜…    |
| [DataTablePin](Pin/DataTablePin/DataTablePin.md)                                                                               | Pin                  | æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºDataTableæˆ–CurveTableç±»å‹ï¼Œä»¥ä¾¿ä¸ºFNameçš„å…¶ä»–å‚æ•°æä¾›RowNameListçš„é€‰æ‹©ã€‚                                                                                                                                                                                                   | â˜…â˜…    |
| [DisableSplitPin](Pin/DisableSplitPin/DisableSplitPin.md)                                                                      | Pin                  | ç¦ç”¨Structçš„splitåŠŸèƒ½                                                                                                                                                                                                                                                 | â˜…â˜…    |
| [HiddenByDefault](Pin/HiddenByDefault/HiddenByDefault.md)                                                                      | Pin                  | Structçš„Make Structå’ŒBreak StructèŠ‚ç‚¹ä¸­çš„å¼•è„šé»˜è®¤ä¸ºéšè—çŠ¶æ€                                                                                                                                                                                                                     | â˜…     |
| [AlwaysAsPin](AnimationGraph/AlwaysAsPin/AlwaysAsPin.md)                                                                       | Pin                  | åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æ€»æ˜¯æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„š                                                                                                                                                                                                                                      | â˜…â˜…â˜…   |
| [NeverAsPin](AnimationGraph/NeverAsPin/NeverAsPin.md)                                                                          | Pin                  | åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æ€»æ˜¯ä¸æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„š                                                                                                                                                                                                                                     | â˜…â˜…â˜…   |
| [PinHiddenByDefault](Pin/PinHiddenByDefault/PinHiddenByDefault.md)                                                             | Pin                  | ä½¿å¾—è¿™ä¸ªç»“æ„é‡Œçš„å±æ€§åœ¨è“å›¾é‡Œä½œä¸ºå¼•è„šæ—¶é»˜è®¤æ˜¯éšè—çš„ã€‚                                                                                                                                                                                                                                       | â˜…â˜…    |


## RigVMStruct

| Name                                                         | å¼•æ“æ¨¡å—    | åŠŸèƒ½æè¿°                                                 | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ----------- | -------------------------------------------------------- | -------- |
| [Hidden](RigVM/Hidden.md)                                    | RigVMStruct | æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§éšè—                               | â˜…â˜…â˜…      |
| [Input](RigVM/Input/Input.md)                                | RigVMStruct | æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å…¥å¼•è„šã€‚                     | â˜…â˜…â˜…â˜…â˜…    |
| [TemplateName](RigVM/TemplateName/TemplateName.md)           | RigVMStruct | æŒ‡å®šè¯¥FRigUnitæˆä¸ºä¸€ä¸ªæ³›å‹æ¨¡æ¿èŠ‚ç‚¹ã€‚                     | â˜…â˜…â˜…      |
| [CustomWidget](RigVM/CustomWidget/CustomWidget.md)           | RigVMStruct | æŒ‡å®šè¯¥FRigUnité‡Œçš„å±æ€§è¦ç”¨è‡ªå®šä¹‰çš„æ§ä»¶æ¥ç¼–è¾‘ã€‚           | â˜…â˜…       |
| [ExpandByDefault](RigVM/ExpandByDefault/ExpandByDefault.md)  | RigVMStruct | æŠŠFRigUnité‡Œçš„å±æ€§å¼•è„šé»˜è®¤å±•å¼€ã€‚                         | â˜…â˜…â˜…      |
| [Aggregate](RigVM/Aggregate/Aggregate.md)                    | RigVMStruct | æŒ‡å®šFRigUnité‡Œçš„å±æ€§å¼•è„šä¸ºå¯æ‰©å±•è¿ç»­äºŒå…ƒè¿ç®—ç¬¦çš„è¿ç®—æ•°ã€‚ | â˜…â˜…â˜…      |
| [Visible](RigVM/Visible/Visible.md)                          | RigVMStruct | æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä¸ºå¸¸é‡å¼•è„šï¼Œæ— æ³•è¿æ¥å˜é‡ã€‚         | â˜…â˜…â˜…      |
| [Output](RigVM/Output.md)                                    | RigVMStruct | æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å‡ºå¼•è„šã€‚                     | â˜…â˜…â˜…â˜…â˜…    |
| [DetailsOnly](RigVM/DetailsOnly/DetailsOnly.md)              | RigVMStruct | æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§åªåœ¨ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºã€‚               | â˜…â˜…â˜…      |
| [Varying](RigVM/Varying.md)                                  | RigVMStruct | ScriptStruct /Script/RigVM.RigVMFunction_GetDeltaTime    | ğŸ’€        |
| [MenuDescSuffix](RigVM/MenuDescSuffix/MenuDescSuffix.md)     | RigVMStruct | æ ‡è¯†FRigUnitåœ¨è“å›¾å³é”®èœå•é¡¹çš„åå­—åç¼€ã€‚                 | â˜…â˜…â˜…      |
| [NodeColor](RigVM/NodeColor/NodeColor.md)                    | RigVMStruct | æŒ‡å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„RGBé¢œè‰²å€¼ã€‚                        | â˜…â˜…       |
| [Icon](RigVM/Icon/Icon.md)                                   | RigVMStruct | è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„å›¾æ ‡ã€‚                             | â˜…â˜…       |
| [Deprecated](RigVM/Deprecated)                               | RigVMStruct | æ ‡è¯†è¯¥FRigUnitä¸ºå¼ƒç”¨çŠ¶æ€ï¼Œä¸åœ¨è“å›¾å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚       | â˜…â˜…       |
| [Abstract](RigVM/Abstract/Abstract.md)                       | RigVMStruct | æ ‡è¯†è¯¥FRigUnitä¸ºæŠ½è±¡ç±»ï¼Œä¸ç”¨å®ç°Executeã€‚                | â˜…â˜…       |
| [Constant](RigVM/Constant.md)                                | RigVMStruct | æ ‡è¯†ä¸€ä¸ªå±æ€§æˆä¸ºä¸€ä¸ªå¸¸é‡çš„å¼•è„šã€‚                         | â˜…â˜…â˜…      |
| [RigVMTypeAllowed](RigVM/RigVMTypeAllowed/RigVMTypeAllowed.md) | RigVMStruct | æŒ‡å®šä¸€ä¸ªUENUMå¯ä»¥åœ¨FRigUnitçš„UEnum*å±æ€§ä¸­è¢«é€‰æ‹©ã€‚        | â˜…â˜…       |
| [Keywords](RigVM/Keywords/Keywords.md)                       | RigVMStruct | è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹åœ¨å³é”®èœå•ä¸­çš„å…³é”®å­—ï¼Œæ–¹ä¾¿è¾“å…¥æŸ¥æ‰¾ã€‚ | â˜…â˜…â˜…      |


## Scene

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [MakeEditWidget](Scene/MakeEditWidget/MakeEditWidget.md)                                                                       | Scene                | ä½¿FVectorå’ŒFTranformåœ¨åœºæ™¯ç¼–è¾‘å™¨é‡Œå‡ºç°ä¸€ä¸ªå¯ç§»åŠ¨çš„æ§ä»¶ã€‚                                                                                                                                                                                                                             | â˜…â˜…â˜…   |
| [ValidateWidgetUsing](Scene/ValidateWidgetUsing/ValidateWidgetUsing.md)                                                        | Scene                | æä¾›ä¸€ä¸ªå‡½æ•°æ¥éªŒè¯å½“å‰å±æ€§å€¼æ˜¯å¦åˆæ³•ã€‚                                                                                                                                                                                                                                              | â˜…â˜…â˜…   |
| [AllowedLocators](Scene/AllowedLocators.md)                                                                                    | Scene                | ç”¨æ¥ç»™Sequencerå®šä½å¯ç»‘å®šçš„å¯¹è±¡                                                                                                                                                                                                                                             | â˜…     |


## Script

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [ScriptNoExport](Script/ScriptNoExport.md)                                                                                     | Script               | ä¸å¯¼å‡ºè¯¥å‡½æ•°æˆ–å±æ€§åˆ°è„šæœ¬ã€‚                                                                                                                                                                                                                                                    | â˜…â˜…â˜…   |
| [ScriptConstant](Script/ScriptConstant.md)                                                                                     | Script               | æŠŠä¸€ä¸ªé™æ€å‡½æ•°çš„è¿”å›å€¼åŒ…è£…æˆä¸ºä¸€ä¸ªå¸¸é‡å€¼ã€‚                                                                                                                                                                                                                                            | â˜…â˜…â˜…   |
| [ScriptMethodMutable](Script/ScriptMethodMutable.md)                                                                           | Script               | æŠŠScriptMethodçš„ç¬¬ä¸€ä¸ªconstç»“æ„å‚æ•°åœ¨è°ƒç”¨ä¸Šæ”¹æˆå¼•ç”¨å‚æ•°ï¼Œå‡½æ•°å†…ä¿®æ”¹çš„å€¼ä¼šä¿å­˜ä¸‹æ¥ã€‚                                                                                                                                                                                                               | â˜…â˜…    |
| [ScriptName](Script/ScriptName.md)                                                                                             | Script               | åœ¨å¯¼å‡ºåˆ°è„šæœ¬é‡Œæ—¶ä½¿ç”¨çš„åå­—                                                                                                                                                                                                                                                    | â˜…â˜…â˜…   |
| [ScriptConstantHost](Script/ScriptConstantHost.md)                                                                             | Script               | åœ¨ScriptConstantçš„åŸºç¡€ä¸Šï¼ŒæŒ‡å®šå¸¸é‡ç”Ÿæˆçš„æ‰€åœ¨ç±»å‹ã€‚                                                                                                                                                                                                                                 | â˜…     |
| [ScriptMethodSelfReturn](Script/ScriptMethodSelfReturn.md)                                                                     | Script               | åœ¨ScriptMethodçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šæŠŠè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼è¦å»è¦†ç›–è¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚                                                                                                                                                                                                                      | â˜…â˜…    |
| [ScriptMethod](Script/ScriptMethod.md)                                                                                         | Script               | æŠŠé™æ€å‡½æ•°å¯¼å‡ºå˜æˆç¬¬ä¸€ä¸ªå‚æ•°çš„æˆå‘˜å‡½æ•°ã€‚                                                                                                                                                                                                                                             | â˜…â˜…â˜…   |
| [ScriptDefaultBreak](Script/ScriptDefaultBreak.md)                                                                             | Script               |                                                                                                                                                                                                                                                                  | â˜…     |
| [ScriptOperator](Script/ScriptOperator.md)                                                                                     | Script               | æŠŠç¬¬ä¸€ä¸ªå‚æ•°ä¸ºç»“æ„çš„é™æ€å‡½æ•°åŒ…è£…æˆç»“æ„çš„è¿ç®—ç¬¦ã€‚                                                                                                                                                                                                                                         | â˜…â˜…â˜…   |
| [ScriptDefaultMake](Script/ScriptDefaultMake.md)                                                                               | Script               | ç¦ç”¨ç»“æ„ä¸Šçš„HasNativeMakeï¼Œåœ¨è„šæœ¬é‡Œæ„é€ çš„æ—¶å€™ä¸è°ƒç”¨C++é‡Œçš„NativeMakeå‡½æ•°ï¼Œè€Œé‡‡ç”¨è„šæœ¬å†…å»ºçš„é»˜è®¤åˆå§‹åŒ–æ–¹å¼ã€‚                                                                                                                                                                                               | â˜…     |


## Sequencer

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [TakeRecorderDisplayName](Sequencer/TakeRecorderDisplayName/TakeRecorderDisplayName.md)                                        | Sequencer            | æŒ‡å®šUTakeRecorderSourceçš„æ˜¾ç¤ºåå­—ã€‚                                                                                                                                                                                                                                      | â˜…â˜…    |
| [SequencerBindingResolverLibrary](Sequencer/SequencerBindingResolverLibrary/SequencerBindingResolverLibrary.md)                | Sequencer            | æŠŠå…·æœ‰SequencerBindingResolverLibraryæ ‡è®°çš„UBlueprintFunctionLibraryä½œä¸ºåŠ¨æ€ç»‘å®šçš„ç±»ã€‚                                                                                                                                                                                          | â˜…â˜…    |
| [CommandLineID](Sequencer/CommandLineID/CommandLineID.md)                                                                      | Sequencer            | æ ‡è®°UMovieSceneCaptureProtocolBaseçš„å­ç±»çš„åè®®ç±»å‹ã€‚                                                                                                                                                                                                                        | â˜…â˜…    |


## Serialization

| Name                                                         | å¼•æ“æ¨¡å—      | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ | -------- |
| [SkipUCSModifiedProperties](Serialization/SkipUCSModifiedProperties.md) | Serialization | è·³è¿‡åºåˆ—åŒ–Componenté‡ŒæŸä¸ªå±æ€§                                | ğŸ’€        |
| [MatchedSerializers](Serialization/MatchedSerializers.md)    | Serialization | åªåœ¨NoExportTypes.hä¸­ä½¿ç”¨ï¼Œæ ‡æ˜é‡‡ç”¨ç»“æ„åºåˆ—åŒ–å™¨ã€‚æ˜¯å¦æ”¯æŒæ–‡æœ¬å¯¼å…¥å¯¼å‡º | ğŸ’€        |


## SparseDataType

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [NoGetter](SparseDataType/NoGetter/NoGetter.md)                                                                                | SparseDataType       | é˜»æ­¢UHTä¸ºè¯¥å±æ€§ç”Ÿæˆä¸€ä¸ªC++çš„getå‡½æ•°ï¼Œåªå¯¹ç¨€ç–ç±»çš„ç»“æ„æ•°æ®é‡Œçš„å±æ€§ç”Ÿæ•ˆã€‚                                                                                                                                                                                                                         | â˜…     |


## String/Text

| Name                                                         | å¼•æ“æ¨¡å—    | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ | -------- |
| [PasswordField](String/PasswordField/PasswordField.md)       | String/Text | ä½¿å¾—æ–‡æœ¬å±æ€§æ˜¾ç¤ºä¸ºå¯†ç æ¡†                                     | â˜…â˜…â˜…â˜…â˜…    |
| [PropertyValidator](String/PropertyValidator/PropertyValidator.md) | String/Text | ç”¨åå­—æŒ‡å®šä¸€ä¸ªUFUNCTIONå‡½æ•°æ¥è¿›è¡Œæ–‡æœ¬çš„éªŒè¯                  | â˜…â˜…â˜…      |
| [MultiLine](String/MultiLine/MultiLine.md)                   | String/Text | ä½¿å¾—æ–‡æœ¬å±æ€§ç¼–è¾‘æ¡†æ”¯æŒæ¢è¡Œã€‚                                 | â˜…â˜…â˜…â˜…â˜…    |
| [AllowedCharacters](String/AllowedCharacters/AllowedCharacters.md) | String/Text | åªå…è®¸æ–‡æœ¬æ¡†é‡Œå¯ä»¥è¾“å…¥è¿™äº›å­—ç¬¦ã€‚                             | â˜…â˜…â˜…      |
| [GetValueOptions](String/GetValueOptions.md)                 | String/Text | ä¸ºTMapé‡Œçš„FName/FStringä½œValueæä¾›ç»†èŠ‚é¢æ¿é‡Œé€‰é¡¹æ¡†çš„é€‰é¡¹å€¼   | ğŸ’€        |
| [GetOptions](String/GetOptions/GetOptions.md)                | String/Text | æŒ‡å®šä¸€ä¸ªå¤–éƒ¨ç±»çš„å‡½æ•°æä¾›é€‰é¡¹ç»™FNameæˆ–FStringå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­ä¸‹æ‹‰é€‰é¡¹æ¡†æä¾›å€¼åˆ—è¡¨ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [GetKeyOptions](String/GetKeyOptions.md)                     | String/Text | ä¸ºTMapé‡Œçš„FName/FStringä½œä¸ºKeyæä¾›ç»†èŠ‚é¢æ¿é‡Œé€‰é¡¹æ¡†çš„é€‰é¡¹å€¼   | ğŸ’€        |
| [MaxLength](String/MaxLength/MaxLength.md)                   | String/Text | åœ¨æ–‡æœ¬ç¼–è¾‘æ¡†é‡Œé™åˆ¶æ–‡æœ¬çš„æœ€å¤§é•¿åº¦                             | â˜…â˜…â˜…â˜…â˜…    |


## Struct

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [MakeStructureDefaultValue](Struct/MakeStructureDefaultValue/MakeStructureDefaultValue.md) | Struct   | å­˜å‚¨BPä¸­è‡ªå®šä¹‰ç»“æ„é‡Œçš„å±æ€§çš„é»˜è®¤å€¼ã€‚                         | â˜…        |
| [IgnoreForMemberInitializationTest](Struct/IgnoreForMemberInitializationTest.md) | Struct   | ä½¿å¾—è¯¥å±æ€§å¿½ç•¥ç»“æ„çš„æœªåˆå§‹éªŒè¯ã€‚                             | â˜…â˜…       |
| [HasNativeBreak](Struct/HasNativeBreak/HasNativeBreak.md)    | Struct   | ä¸ºè¯¥ç»“æ„æŒ‡å®šä¸€ä¸ªC++å†…çš„UFunctionå‡½æ•°ä½œä¸ºBreakèŠ‚ç‚¹çš„å®ç°      | â˜…â˜…â˜…â˜…â˜…    |
| [DataflowFlesh](Struct/DataflowFlesh.md)                     | Struct   | ScriptStruct /Script/DataflowNodes.FloatOverrideDataflowNode | ğŸ’€        |


## TypePicker

| Name                                                                                                                           | å¼•æ“æ¨¡å—                 | åŠŸèƒ½æè¿°                                                                                                                                                                                                                                                             | å¸¸ç”¨ç¨‹åº¦  |
|--------------------------------------------------------------------------------------------------------------------------------|----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------|
| [AllowedTypes](TypePicker/AllowedTypes/AllowedTypes.md)                                                                        | TypePicker           | ä¸ºFPrimaryAssetIdå¯ä»¥æŒ‡å®šå…è®¸çš„èµ„äº§ç±»å‹ã€‚                                                                                                                                                                                                                                     | â˜…â˜…â˜…   |
| [BaseClass](TypePicker/BaseClass/BaseClass.md)                                                                                 | TypePicker           | åªåœ¨StateTreeæ¨¡å—ä¸­ä½¿ç”¨ï¼Œé™åˆ¶FStateTreeEditorNodeé€‰æ‹©çš„åŸºç±»ç±»å‹ã€‚                                                                                                                                                                                                                  | â˜…     |
| [GetDisallowedClasses](TypePicker/GetDisallowedClasses/GetDisallowedClasses.md)                                                | TypePicker           | ç”¨åœ¨ç±»é€‰æ‹©å™¨ä¸Šï¼Œé€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šé€‰æ‹©çš„ç±»å‹åˆ—è¡¨ä¸­æ’é™¤æ‰æŸä¸€äº›ç±»å‹åŸºç±»ã€‚                                                                                                                                                                                                                             | â˜…â˜…    |
| [GetAllowedClasses](TypePicker/GetAllowedClasses/GetAllowedClasses.md)                                                         | TypePicker           | ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼Œé€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šé€‰æ‹©çš„å¯¹è±¡å¿…é¡»å±äºæŸä¸€äº›ç±»å‹åŸºç±»ã€‚                                                                                                                                                                                                                            | â˜…â˜…    |
| [AllowedClasses](TypePicker/AllowedClasses/AllowedClasses.md)                                                                  | TypePicker           | ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡å¿…é¡»å±äºæŸä¸€äº›ç±»å‹åŸºç±»ã€‚                                                                                                                                                                                                                                   | â˜…â˜…â˜…   |
| [DisallowedClasses](TypePicker/DisallowedClasses/DisallowedClasses.md)                                                         | TypePicker           | ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡æ’é™¤æ‰æŸä¸€äº›ç±»å‹åŸºç±»ã€‚                                                                                                                                                                                                                                    | â˜…â˜…â˜…   |
| [BaseStruct](TypePicker/BaseStruct/BaseStruct.md)                                                                              | TypePicker           | æŒ‡å®šFInstancedStructå±æ€§é€‰é¡¹åˆ—è¡¨é€‰æ‹©çš„ç»“æ„éƒ½å¿…é¡»ç»§æ‰¿äºBaseStructæŒ‡å‘çš„ç»“æ„ã€‚                                                                                                                                                                                                              | â˜…â˜…â˜…   |
| [MetaStruct](TypePicker/MetaStruct/MetaStruct.md)                                                                              | TypePicker           | è®¾å®šåˆ°UScriptStruct*å±æ€§ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„ç±»å‹çš„çˆ¶ç»“æ„ã€‚                                                                                                                                                                                                                                | â˜…â˜…â˜…   |
| [ExactClass](TypePicker/ExactClass/ExactClass.md)                                                                              | TypePicker           | åœ¨åŒæ—¶è®¾ç½®AllowedClasseså’ŒGetAllowedClassesçš„æ—¶å€™ï¼ŒExactClassæŒ‡å®šåªå–è¿™ä¸¤ä¸ªé›†åˆä¸­ç±»å‹å®Œå…¨ä¸€è‡´çš„ç±»å‹äº¤é›†ï¼Œå¦åˆ™å–ä¸€è‡´çš„äº¤é›†å†åŠ ä¸Šå…¶å­ç±»ã€‚                                                                                                                                                                         | â˜…     |
| [ShowDisplayNames](TypePicker/ShowDisplayNames/ShowDisplayNames.md)                                                            | TypePicker           | åœ¨Classå’ŒStructå±æ€§ä¸Šï¼ŒæŒ‡å®šç±»é€‰æ‹©å™¨æ˜¾ç¤ºå¦å¤–çš„æ˜¾ç¤ºåç§°è€Œä¸æ˜¯ç±»åŸå§‹çš„åå­—ã€‚                                                                                                                                                                                                                       | â˜…     |
| [DisallowedStructs](TypePicker/DisallowedStructs.md)                                                                           | TypePicker           | åªåœ¨SmartObjectæ¨¡å—ä¸­åº”ç”¨ï¼Œç”¨ä»¥åœ¨ç±»é€‰æ‹©å™¨ä¸­æ’é™¤æ‰æŸä¸ªç±»ä»¥åŠå­ç±»ã€‚                                                                                                                                                                                                                           | â˜…     |
| [ExcludeBaseStruct](TypePicker/ExcludeBaseStruct.md)                                                                           | TypePicker           | åœ¨ä½¿ç”¨BaseStructçš„FInstancedStructå±æ€§ä¸Šå¿½ç•¥BaseStructæŒ‡å‘çš„ç»“æ„åŸºç±»ã€‚                                                                                                                                                                                                            | â˜…â˜…â˜…   |
| [RowType](TypePicker/RowType/RowType.md)                                                                                       | TypePicker           | æŒ‡å®šFDataTableRowHandle å±æ€§çš„å¯é€‰è¡Œç±»å‹çš„åŸºç±»ã€‚                                                                                                                                                                                                                               | â˜…â˜…â˜…   |
| [MustImplement](TypePicker/MustImplement/MustImplement.md)                                                                     | TypePicker           | æŒ‡å®šTSubClassOfæˆ–FSoftClassPathå±æ€§é€‰æ‹©çš„ç±»å¿…é¡»å®ç°è¯¥æ¥å£                                                                                                                                                                                                                        | â˜…â˜…â˜…   |
| [ShowTreeView](TypePicker/ShowTreeView/ShowTreeView.md)                                                                        | TypePicker           | ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œä½¿å¾—åœ¨ç±»é€‰å–å™¨ä¸­æ˜¾ç¤ºä¸ºæ ‘å½¢è€Œä¸æ˜¯åˆ—è¡¨ã€‚                                                                                                                                                                                                                         | â˜…â˜…    |
| [BlueprintBaseOnly](TypePicker/BlueprintBaseOnly/BlueprintBaseOnly.md)                                                         | TypePicker           | ç”¨äºç±»å±æ€§ï¼ŒæŒ‡å®šæ˜¯å¦åªæ¥å—å¯åˆ›å»ºè“å›¾å­ç±»çš„åŸºç±»                                                                                                                                                                                                                                          | â˜…â˜…    |
| [MetaClass](TypePicker/MetaClass/MetaClass.md)                                                                                 | TypePicker           | ç”¨åœ¨è½¯å¼•ç”¨å±æ€§ä¸Šï¼Œé™å®šè¦é€‰æ‹©çš„å¯¹è±¡çš„åŸºç±»                                                                                                                                                                                                                                             | â˜…â˜…    |
| [StructTypeConst](TypePicker/StructTypeConst.md)                                                                               | TypePicker           | æŒ‡å®šFInstancedStructå±æ€§çš„ç±»å‹ä¸èƒ½åœ¨ç¼–è¾‘å™¨è¢«é€‰æ‹©ã€‚                                                                                                                                                                                                                                | â˜…     |
| [AllowAbstract](TypePicker/AllowAbstract/AllowAbstract.md)                                                                     | TypePicker           | ç”¨äºç±»å±æ€§ï¼ŒæŒ‡å®šæ˜¯å¦æ¥å—æŠ½è±¡ç±»ã€‚                                                                                                                                                                                                                                                 | â˜…â˜…    |
| [HideViewOptions](TypePicker/HideViewOptions/HideViewOptions.md)                                                               | TypePicker           | ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œéšè—åœ¨ç±»é€‰å–å™¨ä¸­ä¿®æ”¹æ˜¾ç¤ºé€‰é¡¹çš„åŠŸèƒ½ã€‚                                                                                                                                                                                                                          | â˜…     |
| [OnlyPlaceable](TypePicker/OnlyPlaceable/OnlyPlaceable.md)                                                                     | TypePicker           | ç”¨åœ¨ç±»å±æ€§ä¸Šï¼ŒæŒ‡å®šæ˜¯å¦åªæ¥å—å¯è¢«æ”¾ç½®åˆ°åœºæ™¯é‡Œçš„Actor                                                                                                                                                                                                                                     | â˜…â˜…    |


## UHT

| Name                                                    | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------- | -------- | ------------------------------------------------------------ | -------- |
| [DocumentationPolicy](UHT/DocumentationPolicy.md)       | UHT      | æŒ‡å®šæ–‡æ¡£éªŒè¯çš„è§„åˆ™ï¼Œå½“å‰åªèƒ½è®¾ä¸ºStrict                       | â˜…        |
| [GetByRef](Blueprint/GetByRef.md)                       | UHT      | æŒ‡å®šUHTä¸ºè¯¥å±æ€§ç”Ÿæˆè¿”å›å¼•ç”¨çš„C++ä»£ç                          | ğŸ’€        |
| [CustomThunk](UHT/CustomThunk.md)                       | UHT      | æŒ‡å®šUHTä¸ä¸ºè¯¥å‡½æ•°ç”Ÿæˆè“å›¾è°ƒç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œè€Œéœ€è¦ç”¨æˆ·è‡ªå®šä¹‰ç¼–å†™ã€‚ | â˜…â˜…â˜…â˜…â˜…    |
| [NativeConstTemplateArg](UHT/NativeConstTemplateArg.md) | UHT      | æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªconstçš„æ¨¡æ¿å‚æ•°ã€‚                            | ğŸ’€        |
| [CppFromBpEvent](UHT/CppFromBpEvent.md)                 | UHT      |                                                              | ğŸ’€        |
| [IncludePath](UHT/IncludePath.md)                       | UHT      | è®°å½•UClassçš„å¼•ç”¨è·¯å¾„                                         | ğŸ’€        |
| [ModuleRelativePath](UHT/ModuleRelativePath.md)         | UHT      | è®°å½•ç±»å‹å®šä¹‰çš„çš„å¤´æ–‡ä»¶è·¯å¾„ï¼Œä¸ºå…¶å¤„äºæ¨¡å—çš„å†…éƒ¨ç›¸å¯¹è·¯å¾„ã€‚     | ğŸ’€        |


## Widget

| Name                                                         | å¼•æ“æ¨¡å— | åŠŸèƒ½æè¿°                                                     | å¸¸ç”¨ç¨‹åº¦ |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | -------- |
| [DisableNativeTick](Widget/DisableNativeTick/DisableNativeTick.md) | Widget   | ç¦ç”¨è¯¥UserWidgetçš„NativeTickã€‚                               | â˜…â˜…â˜…      |
| [ViewmodelBlueprintWidgetExtension](Widget/ViewmodelBlueprintWidgetExtension.md) | Widget   | ç”¨æ¥éªŒè¯InListItemsçš„Objectç±»å‹æ˜¯å¦ç¬¦åˆEntryWidgetClassçš„MVVMç»‘å®šçš„ViewModelPropertyã€‚ | ğŸ’€        |
| [DesignerRebuild](Widget/DesignerRebuild/DesignerRebuild.md) | Widget   | æŒ‡å®šWidgeté‡Œçš„æŸä¸ªå±æ€§å€¼æ”¹å˜ååº”è¯¥é‡æ–°åˆ·æ–°UMGçš„é¢„è§ˆç•Œé¢ã€‚    | â˜…        |
| [DefaultGraphNode](Widget/DefaultGraphNode.md)               | Widget   | æ ‡è®°å¼•æ“é»˜è®¤åˆ›å»ºçš„è“å›¾èŠ‚ç‚¹ã€‚                                 | ğŸ’€        |
| [BindWidget](Widget/BindWidget/BindWidget.md)                | Widget   | æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ã€‚     | â˜…â˜…â˜…â˜…â˜…    |
| [BindWidgetOptional](Widget/BindWidgetOptional/BindWidgetOptional.md) | Widget   | æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§å¯ä»¥ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚ | â˜…â˜…â˜…      |
| [OptionalWidget](Widget/OptionalWidget.md)                   | Widget   | æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§å¯ä»¥ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚ | â˜…â˜…â˜…      |
| [BindWidgetAnimOptional](Widget/BindWidgetAnimOptional/BindWidgetAnimOptional.md) | Widget   | æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥UWidgetAnimationå±æ€§å¯ä»¥è¦ç»‘å®šåˆ°UMGä¸‹çš„æŸä¸ªåŠ¨ç”»ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚ | â˜…â˜…â˜…      |
| [IsBindableEvent](Widget/IsBindableEvent/IsBindableEvent.md) | Widget   | æŠŠä¸€ä¸ªåŠ¨æ€å•æ’­å§”æ‰˜æš´éœ²åˆ°UMGè“å›¾é‡Œä»¥ç»‘å®šç›¸åº”äº‹ä»¶ã€‚            | â˜…â˜…â˜…      |
| [EntryInterface](Widget/EntryInterface/EntryInterface.md)    | Widget   | é™å®šEntryWidgetClasså±æ€§ä¸Šå¯é€‰ç±»å¿…é¡»å®ç°çš„æ¥å£ï¼Œç”¨åœ¨DynamicEntryBoxå’ŒListViewè¿™ä¸¤ä¸ªWidgetä¸Šã€‚ | â˜…â˜…â˜…      |
| [BindWidgetAnim](Widget/BindWidgetAnim/BindWidgetAnim.md)    | Widget   | æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥UWidgetAnimationå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGä¸‹çš„æŸä¸ªåŠ¨ç”» | â˜…â˜…â˜…â˜…â˜…    |


# ClassFlags :

|Name                                |Feature             |Trait                                                                                                                                                                                                                                                           |Value|Description                                                                                                                                                                                              |UCLASS                                                                                                                                 |Related to UPROPERTY|
|------------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|--------------------|
|CLASS_Abstract                      |Blueprint           |                                                                                                                                                                                                                                                                |0x00000001|æŒ‡å®šè¿™ä¸ªç±»æ˜¯æŠ½è±¡åŸºç±»ï¼Œä¸å¯å®ä¾‹åŒ–                                                                                                                                                                                         |Abstract (Specifier/UCLASS/Abstract.md)                                                                                                |                    |
|CLASS_Const                         |Blueprint           |Inherit                                                                                                                                                                                                                                                         |0x00010000|è¯¥ç±»çš„æ‰€æœ‰å±æ€§å’Œå‡½æ•°éƒ½æ˜¯constçš„ï¼Œä¹Ÿåº”è¯¥è¢«æš´éœ²ä¸ºconst                                                                                                                                                                          |Const (Specifier/UCLASS/Const.md)                                                                                                      |                    |
|CLASS_CompiledFromBlueprint         |Blueprint           |                                                                                                                                                                                                                                                                |0x00040000u|æŒ‡å®šè¯¥ç±»ä»è“å›¾çš„ç¼–è¯‘ä¸­åˆ›å»º                                                                                                                                                                                            |                                                                                                                                       |                    |
|CLASS_NewerVersionExists            |Blueprint           |                                                                                                                                                                                                                                                                |0x80000000u|                                                                                                                                                                                                         |                                                                                                                                       |                    |
|CLASS_NoExport                      |UHT                 |                                                                                                                                                                                                                                                                |0x00000100u|ä¸æš´éœ²åˆ°C++å¤´æ–‡ä»¶ï¼Œä¸ç”Ÿæˆæ³¨å†Œä»£ç                                                                                                                                                                                        |NoExport (Specifier/UCLASS/NoExport.md)                                                                                                |                    |
|CLASS_CustomConstructor             |UHT                 |                                                                                                                                                                                                                                                                |0x00008000u|ä¸åˆ›å»ºä¸€ä¸ªé»˜è®¤æ„é€ å‡½æ•°ï¼Œåªåœ¨C++ç¯å¢ƒä¸‹ä½¿ç”¨                                                                                                                                                                                   |CustomConstructor (Specifier/UCLASS/CustomConstructor.md)                                                                              |                    |
|CLASS_Deprecated                    |Editor              |Inherit                                                                                                                                                                                                                                                         |0x02000000u|æ˜¾ç¤ºåºŸå¼ƒè­¦å‘Š                                                                                                                                                                                                   |Deprecated (Specifier/UCLASS/Deprecated.md)                                                                                            |                    |
|CLASS_HideDropDown                  |Editor              |                                                                                                                                                                                                                                                                |0x04000000u|ç±»ä¸åœ¨å³é”®é€‰æ‹©æ¡†ä¸­æ˜¾ç¤º                                                                                                                                                                                              |HideDropDown (Specifier/UCLASS/HideDropDown.md)                                                                                        |                    |
|CLASS_EditInlineNew                 |Editor              |                                                                                                                                                                                                                                                                |0x00001000u|å¯¹è±¡å¯ä»¥é€šè¿‡EditinlineNewæŒ‰é’®æ„é€                                                                                                                                                                                   |EditInlineNew (Specifier/UCLASS/EditInlineNew.md), NotEditInlineNew (Specifier/UCLASS/NotEditInlineNew.md)                             |                    |
|CLASS_Hidden                        |Editor              |                                                                                                                                                                                                                                                                |0x01000000u|ä¸åœ¨ç¼–è¾‘å™¨çš„ç±»æµè§ˆå™¨å’Œedit inline newä¸­æ˜¾ç¤º                                                                                                                                                                            |                                                                                                                                       |                    |
|CLASS_CollapseCategories            |Editor              |                                                                                                                                                                                                                                                                |0x00002000u|å±æ€§åœ¨å±•ç¤ºæ—¶ä¸åˆ†ç›®å½•                                                                                                                                                                                               |CollapseCategories (Specifier/UCLASS/CollapseCategories.md), DontCollapseCategories (Specifier/UCLASS/DontCollapseCategories.md)       |                    |
|CLASS_NotPlaceable                  |Behavior            |Inherit                                                                                                                                                                                                                                                         |0x00000200u|ä¸èƒ½è¢«æ”¾ç½®åœ¨åœºæ™¯ä¸­                                                                                                                                                                                                |Deprecated (Specifier/UCLASS/Deprecated.md), NotPlaceable (Specifier/UCLASS/NotPlaceable.md), Placeable (Specifier/UCLASS/Placeable.md)|                    |
|CLASS_ReplicationDataIsSetUp        |Behavior            |                                                                                                                                                                                                                                                                |0x00000800u|æ˜¯å¦åœ¨è¯¥ç±»ä»ç„¶éœ€è¦è°ƒç”¨SetUpRuntimeReplicationData                                                                                                                                                                   |                                                                                                                                       |                    |
|CLASS_MinimalAPI                    |DllExport           |                                                                                                                                                                                                                                                                |0x00080000u|æŒ‡å®šè¯¥ç±»çš„æœ€å°å¯¼å‡ºï¼Œåªå¯¼å‡ºè·å¾—ç±»æŒ‡é’ˆçš„å‡½æ•°                                                                                                                                                                                    |MinimalAPI (Specifier/UCLASS/MinimalAPI.md)                                                                                            |                    |
|CLASS_RequiredAPI                   |DllExport           |DefaultC++, Internal                                                                                                                                                                                                                                            |0x00100000u|æŒ‡å®šè¯¥ç±»å¿…é¡»å…·æœ‰DLLå¯¼å‡ºï¼Œå¯¼å‡ºæ‰€æœ‰å‡½æ•°å’Œå±æ€§                                                                                                                                                                                  |UCLASS() (Specifier/UCLASS/UCLASS().md)                                                                                                |                    |
|                                    |DllExport           |                                                                                                                                                                                                                                                                |     |                                                                                                                                                                                                         |                                                                                                                                       |                    |
|CLASS_DefaultToInstanced            |LoadConstruct       |Inherit                                                                                                                                                                                                                                                         |0x00200000u|æŒ‡å®šå¼•ç”¨åˆ°è¯¥ç±»çš„æ‰€æœ‰å¼•ç”¨éƒ½é»˜è®¤åˆ›å»ºä¸ªå®ä¾‹å¯¹è±¡                                                                                                                                                                                   |DefaultToInstanced (Specifier/UCLASS/DefaultToInstanced.md)                                                                            |                    |
|CLASS_HasInstancedReference         |LoadConstruct       |Inherit                                                                                                                                                                                                                                                         |0x00800000u|ç±»æ‹¥æœ‰ç»„ä»¶å±æ€§                                                                                                                                                                                                  |                                                                                                                                       |                    |
|CLASS_Parsed                        |LoadConstruct       |                                                                                                                                                                                                                                                                |0x00000010u|æˆåŠŸè§£æå®Œæˆ                                                                                                                                                                                                   |                                                                                                                                       |                    |
|CLASS_TokenStreamAssembled          |LoadConstruct       |DefaultC++                                                                                                                                                                                                                                                      |0x00400000u|æŒ‡å®šçˆ¶ç±»çš„TokenStreamå·²ç»è¢«æˆåŠŸåˆå¹¶åˆ°è‡ªèº«ç±»ä¸Š                                                                                                                                                                             |UCLASS() (Specifier/UCLASS/UCLASS().md)                                                                                                |                    |
|CLASS_LayoutChanging                |LoadConstruct       |                                                                                                                                                                                                                                                                |     |æŒ‡å®šè¯¥ç±»çš„å†…å­˜å¸ƒå±€å·²ç»è¢«æ”¹å˜ï¼Œå› æ­¤ç›®å‰è¿˜ä¸èƒ½åˆ›å»ºCDO                                                                                                                                                                              |                                                                                                                                       |                    |
|CLASS_Constructed                   |LoadConstruct       |DefaultC++                                                                                                                                                                                                                                                      |0x20000000u|ç±»å·²ç»è¢«æ„é€ å®Œæˆ                                                                                                                                                                                                 |UCLASS() (Specifier/UCLASS/UCLASS().md)                                                                                                |                    |
|CLASS_NeedsDeferredDependencyLoading|LoadConstruct       |Inherit                                                                                                                                                                                                                                                         |     |æŒ‡å®šè¯¥ç±»éœ€è¦å»¶è¿Ÿä¾èµ–åŠ è½½                                                                                                                                                                                             |NeedsDeferredDependencyLoading (Specifier/UCLASS/NeedsDeferredDependencyLoading.md)                                                    |                    |
|CLASS_Transient                     |LoadConstruct       |Inherit                                                                                                                                                                                                                                                         |0x00000008u|é€æ˜çš„ï¼Œåœ¨åºåˆ—åŒ–çš„æ—¶å€™è¢«è·³è¿‡                                                                                                                                                                                           |Transient (Specifier/UCLASS/Transient.md), NonTransient (Specifier/UCLASS/NonTransient.md)                                             |                    |
|CLASS_MatchedSerializers            |LoadConstruct       |DefaultC++, Internal                                                                                                                                                                                                                                            |0x00000020u|                                                                                                                                                                                                         |UCLASS() (Specifier/UCLASS/UCLASS().md), MatchedSerializers (Specifier/UCLASS/MatchedSerializers.md)                                   |                    |
|CLASS_Native                        |Traits              |DefaultC++                                                                                                                                                                                                                                                      |0x00000080u|æŒ‡å®šä¸ºåŸç”Ÿç±»ï¼ŒC++é‡Œåˆ›å»ºçš„ç±»                                                                                                                                                                                          |UCLASS() (Specifier/UCLASS/UCLASS().md)                                                                                                |                    |
|CLASS_Intrinsic                     |Traits              |DefaultC++                                                                                                                                                                                                                                                      |0x10000000u|ç±»åœ¨C++ä¸­å®šä¹‰ï¼Œä¸”æ²¡æœ‰UHTç”Ÿæˆçš„ä»£ç                                                                                                                                                                                      |Intrinsic (Specifier/UCLASS/Intrinsic.md), UCLASS() (Specifier/UCLASS/UCLASS().md)                                                     |                    |
|CLASS_Interface                     |Traits              |                                                                                                                                                                                                                                                                |0x00004000u|è¯¥ç±»æ˜¯ä¸€ä¸ªæ¥å£                                                                                                                                                                                                  |Interface (Specifier/UCLASS/Interface.md)                                                                                              |                    |
|CLASS_Optional                      |Traits              |Inherit                                                                                                                                                                                                                                                         |0x00000010u|This object type may not be available in certain context. (i.e. game runtime or in certain configuration). Optional class data is saved separately to other object types. (i.e. might use sidecar files) |Optional (Specifier/UCLASS/Optional.md)                                                                                                |                    |
|CLASS_Config                        |Config              |Inherit                                                                                                                                                                                                                                                         |0x00000004u|åœ¨æ„é€ çš„æ—¶å€™è½½å…¥å¯¹è±¡çš„configé…ç½®                                                                                                                                                                                      |                                                                                                                                       |                    |
|CLASS_DefaultConfig                 |Config              |Inherit                                                                                                                                                                                                                                                         |0x00000002u|ä¿å­˜å¯¹è±¡é…ç½®åˆ°DefaultXXX.iniï¼Œè€Œä¸æ˜¯Localï¼Œå¿…é¡»å’ŒCLASS_Configè¿ç”¨                                                                                                                                                         |DefaultConfig (Specifier/UCLASS/DefaultConfig.md)                                                                                      |                    |
|CLASS_ProjectUserConfig             |Config              |Inherit                                                                                                                                                                                                                                                         |0x00000040u|æŒ‡å®šsettingsçš„configæ–‡ä»¶ä¿å­˜åœ¨Project/User*.ini å’ŒCLASS_GlobalUserConfigç±»ä¼¼                                                                                                                                        |ProjectUserConfig (Specifier/UCLASS/ProjectUserConfig.md)                                                                              |                    |
|CLASS_PerObjectConfig               |Config              |Inherit                                                                                                                                                                                                                                                         |0x00000400u|å¯¹æ¯ä¸ªå¯¹è±¡è¿›è¡Œé…ç½®ï¼Œè€Œä¸æ˜¯åœ¨ç±»çº§åˆ«                                                                                                                                                                                        |PerObjectConfig (Specifier/UCLASS/PerObjectConfig.md)                                                                                  |                    |
|CLASS_GlobalUserConfig              |Config              |Inherit                                                                                                                                                                                                                                                         |0x08000000u|ç±»Setttingsè¢«ä¿å­˜åˆ°<AppData>/..../Blah.ini                                                                                                                                                                    |GlobalUserConfig (Specifier/UCLASS/GlobalUserConfig.md)                                                                                |                    |
|CLASS_ConfigDoNotCheckDefaults      |Config              |Inherit                                                                                                                                                                                                                                                         |0x40000000u|æŒ‡å®šå¯¹è±¡é…ç½®å°†ä¸ä¼šæ£€æŸ¥base/defaults ini                                                                                                                                                                             |ConfigDoNotCheckDefaults (Specifier/UCLASS/ConfigDoNotCheckDefaults.md)                                                                |                    |
|HasCustomFieldNotify                |                    |                                                                                                                                                                                                                                                                |     |                                                                                                                                                                                                         |CustomFieldNotify (Specifier/UCLASS/CustomFieldNotify.md)                                                                              |                    |


# StructFlags :
|Name                                |Value               |Description                                                                                                                                                                                                                                                     |USTRUCT                                                                                                                   |
|------------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
|STRUCT_NoFlags                      |0x00000000          |                                                                                                                                                                                                                                                                |                                                                                                                          |
|STRUCT_Native                       |0x00000001          |                                                                                                                                                                                                                                                                |                                                                                                                          |
|STRUCT_IdenticalNative              |0x00000002          |If set, this struct will be compared using native code                                                                                                                                                                                                          |                                                                                                                          |
|STRUCT_HasInstancedReference        |0x00000004          |                                                                                                                                                                                                                                                                |                                                                                                                          |
|STRUCT_NoExport                     |0x00000008          |                                                                                                                                                                                                                                                                |                                                                                                                          |
|STRUCT_Atomic                       |0x00000010          |Indicates that this struct should always be serialized as a single unit                                                                                                                                                                                         |Atomic (Specifier/USTRUCT/Atomic.md)                                                                                      |
|STRUCT_Immutable                    |0x00000020          |Indicates that this struct uses binary serialization; it is unsafe to add/remove members from this struct without incrementing the package version                                                                                                              |immutable (Specifier/USTRUCT/immutable.md)                                                                                |
|STRUCT_AddStructReferencedObjects   |0x00000040          |If set, native code needs to be run to find referenced objects                                                                                                                                                                                                  |                                                                                                                          |
|STRUCT_RequiredAPI                  |0x00000200          |Indicates that this struct should be exportable/importable at the DLL layer. Base structs must also be exportable for this to work.                                                                                                                             |                                                                                                                          |
|STRUCT_NetSerializeNative           |0x00000400          |If set, this struct will be serialized using the CPP net serializer                                                                                                                                                                                             |                                                                                                                          |
|STRUCT_SerializeNative              |0x00000800          |If set, this struct will be serialized using the CPP serializer                                                                                                                                                                                                 |                                                                                                                          |
|STRUCT_CopyNative                   |0x00001000          |If set, this struct will be copied using the CPP operator=                                                                                                                                                                                                      |                                                                                                                          |
|STRUCT_IsPlainOldData               |0x00002000          |If set, this struct will be copied using memcpy                                                                                                                                                                                                                 |                                                                                                                          |
|STRUCT_NoDestructor                 |0x00004000          |If set, this struct has no destructor and non will be called. STRUCT_IsPlainOldData implies STRUCT_NoDestructor                                                                                                                                                 |                                                                                                                          |
|STRUCT_ZeroConstructor              |0x00008000          |If set, this struct will not be constructed because it is assumed that memory is zero before construction.                                                                                                                                                      |                                                                                                                          |
|STRUCT_ExportTextItemNative         |0x00010000          |If set, native code will be used to export text                                                                                                                                                                                                                 |                                                                                                                          |
|STRUCT_ImportTextItemNative         |0x00020000          |If set, native code will be used to export text                                                                                                                                                                                                                 |                                                                                                                          |
|STRUCT_PostSerializeNative          |0x00040000          |If set, this struct will have PostSerialize called on it after CPP serializer or tagged property serialization is complete                                                                                                                                      |                                                                                                                          |
|STRUCT_SerializeFromMismatchedTag   |0x00080000          |If set, this struct will have SerializeFromMismatchedTag called on it if a mismatched tag is encountered.                                                                                                                                                       |                                                                                                                          |
|STRUCT_NetDeltaSerializeNative      |0x00100000          |If set, this struct will be serialized using the CPP net delta serializer                                                                                                                                                                                       |                                                                                                                          |
|STRUCT_PostScriptConstruct          |0x00200000          |If set, this struct will be have PostScriptConstruct called on it after a temporary object is constructed in a running blueprint                                                                                                                                |                                                                                                                          |
|STRUCT_NetSharedSerialization       |0x00400000          |If set, this struct can share net serialization state across connections                                                                                                                                                                                        |                                                                                                                          |
|STRUCT_Trashed                      |0x00800000          |If set, this struct has been cleaned and sanitized (trashed) and should not be used                                                                                                                                                                             |                                                                                                                          |
|STRUCT_NewerVersionExists           |0x01000000          |If set, this structure has been replaced via reinstancing                                                                                                                                                                                                       |                                                                                                                          |
|STRUCT_CanEditChange                |0x02000000          |If set, this struct will have CanEditChange on it in the editor to determine if a child property can be edited                                                                                                                                                  |                                                                                                                          |


# EnumFlags :

|Name                                |Feature             |Value                                                                                                                                                                                                                                                           |Description|UENUM                                                                                                                                                                                                    |UENUM 1                                                                                                                                |
|------------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
|Flags                               |Trait               |0x00000001                                                                                                                                                                                                                                                      |Whether the UEnum represents a set of flags|                                                                                                                                                                                                         |Flags (Specifier/UENUM/Flags.md)                                                                                                       |
|NewerVersionExists                  |Trait               |0x00000002                                                                                                                                                                                                                                                      |If set, this UEnum has been replaced by a newer version|                                                                                                                                                                                                         |                                                                                                                                       |


# FunctionFlags :
|Name                                |Feature             |Value                                                                                                                                                                                                                                                           |Description|UFUNCTION/UDELEGATE                                                                                                                                                                                      |UFUNCTION/UDELEGATE 1                                                                                                                  |USTRUCT                                       |
|------------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
|FUNC_Final                          |Trait               |0x00000001                                                                                                                                                                                                                                                      |Function is final (prebindable, non-overridable function).|SealedEvent (Specifier/UFUNCTION/SealedEvent.md)                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_RequiredAPI                    |Dll                 |0x00000002                                                                                                                                                                                                                                                      |Indicates this function is DLL exported/imported.|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_BlueprintAuthorityOnly         |Network             |0x00000004                                                                                                                                                                                                                                                      |Function will only run if the object has network authority|BlueprintAuthorityOnly (Specifier/UFUNCTION/BlueprintAuthorityOnly.md)                                                                                                                                   |                                                                                                                                       |                                              |
|FUNC_BlueprintCosmetic              |Network             |0x00000008                                                                                                                                                                                                                                                      |Function is cosmetic in nature and should not be invoked on dedicated servers|BlueprintCosmetic (Specifier/UFUNCTION/BlueprintCosmetic.md)                                                                                                                                             |                                                                                                                                       |                                              |
|FUNC_Net                            |Network             |0x00000040                                                                                                                                                                                                                                                      |Function is network-replicated.|Client (Specifier/UFUNCTION/Client.md), NetMulticast (Specifier/UFUNCTION/NetMulticast.md), Server (Specifier/UFUNCTION/Server.md), ServiceRequest (Specifier/UFUNCTION/ServiceRequest.md), ServiceResponse (Specifier/UFUNCTION/ServiceResponse.md)|                                                                                                                                       |                                              |
|FUNC_NetReliable                    |Network             |0x00000080                                                                                                                                                                                                                                                      |Function should be sent reliably on the network.|Reliable (Specifier/UFUNCTION/Reliable.md), ServiceRequest (Specifier/UFUNCTION/ServiceRequest.md), ServiceResponse (Specifier/UFUNCTION/ServiceResponse.md)                                             |                                                                                                                                       |                                              |
|FUNC_NetRequest                     |Network             |0x00000100                                                                                                                                                                                                                                                      |Function is sent to a net service|ServiceRequest (Specifier/UFUNCTION/ServiceRequest.md)                                                                                                                                                   |                                                                                                                                       |                                              |
|FUNC_Exec                           |Trait               |0x00000200                                                                                                                                                                                                                                                      |Executable from command line.|Exec (Specifier/UFUNCTION/Exec.md)                                                                                                                                                                       |                                                                                                                                       |                                              |
|FUNC_Native                         |Trait               |0x00000400                                                                                                                                                                                                                                                      |Native function.|BlueprintImplementableEvent (Specifier/UFUNCTION/BlueprintImplementableEvent.md)                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Event                          |Trait               |0x00000800                                                                                                                                                                                                                                                      |Event function.|BlueprintImplementableEvent (Specifier/UFUNCTION/BlueprintImplementableEvent.md), BlueprintNativeEvent (Specifier/UFUNCTION/BlueprintNativeEvent.md), ServiceRequest (Specifier/UFUNCTION/ServiceRequest.md), ServiceResponse (Specifier/UFUNCTION/ServiceResponse.md)|                                                                                                                                       |                                              |
|FUNC_NetResponse                    |Network             |0x00001000                                                                                                                                                                                                                                                      |Function response from a net service|ServiceResponse (Specifier/UFUNCTION/ServiceResponse.md)                                                                                                                                                 |                                                                                                                                       |                                              |
|FUNC_Static                         |                    |0x00002000                                                                                                                                                                                                                                                      |Static function.|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_NetMulticast                   |Network             |0x00004000                                                                                                                                                                                                                                                      |Function is networked multicast Server -> All Clients|NetMulticast (Specifier/UFUNCTION/NetMulticast.md)                                                                                                                                                       |                                                                                                                                       |                                              |
|FUNC_UbergraphFunction              |Blueprint           |0x00008000                                                                                                                                                                                                                                                      |Function is used as the merge 'ubergraph' for a blueprint, only assigned when using the persistent 'ubergraph' frame|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_MulticastDelegate              |Trait               |0x00010000                                                                                                                                                                                                                                                      |Function is a multi-cast delegate signature (also requires FUNC_Delegate to be set!)|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Public                         |Trait               |0x00020000                                                                                                                                                                                                                                                      |Function is accessible in all classes (if overridden, parameters must remain unchanged).|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Private                        |Trait               |0x00040000                                                                                                                                                                                                                                                      |Function is accessible only in the class it is defined in (cannot be overridden, but function name may be reused in subclasses. IOW: if overridden, parameters don't need to match, and Super.Func() cannot be accessed since it's private.)|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Protected                      |Trait               |0x00080000                                                                                                                                                                                                                                                      |Function is accessible only in the class it is defined in and subclasses (if overridden, parameters much remain unchanged).|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Delegate                       |Trait               |0x00100000                                                                                                                                                                                                                                                      |Function is delegate signature (either single-cast or multi-cast, depending on whether FUNC_MulticastDelegate is set.)|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_NetServer                      |Network             |0x00200000                                                                                                                                                                                                                                                      |Function is executed on servers (set by replication code if passes check)|Server (Specifier/UFUNCTION/Server.md)                                                                                                                                                                   |                                                                                                                                       |                                              |
|FUNC_HasOutParms                    |Trait               |0x00400000                                                                                                                                                                                                                                                      |function has out (pass by reference) parameters|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_HasDefaults                    |Trait               |0x00800000                                                                                                                                                                                                                                                      |function has structs that contain defaults|                                                                                                                                                                                                         |                                                                                                                                       |HasDefaults (Specifier/USTRUCT/HasDefaults.md)|
|FUNC_NetClient                      |Network             |0x01000000                                                                                                                                                                                                                                                      |function is executed on clients|Client (Specifier/UFUNCTION/Client.md)                                                                                                                                                                   |                                                                                                                                       |                                              |
|FUNC_DLLImport                      |Dll                 |0x02000000                                                                                                                                                                                                                                                      |function is imported from a DLL|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_BlueprintCallable              |Blueprint           |0x04000000                                                                                                                                                                                                                                                      |function can be called from blueprint code|BlueprintGetter (Specifier/UFUNCTION/BlueprintGetter.md), BlueprintPure (Specifier/UFUNCTION/BlueprintPure.md), BlueprintSetter (Specifier/UFUNCTION/BlueprintSetter.md), BlueprintCallable (Specifier/UFUNCTION/BlueprintCallable.md)|                                                                                                                                       |                                              |
|FUNC_BlueprintEvent                 |Blueprint           |0x08000000                                                                                                                                                                                                                                                      |function can be overridden/implemented from a blueprint|BlueprintImplementableEvent (Specifier/UFUNCTION/BlueprintImplementableEvent.md), BlueprintNativeEvent (Specifier/UFUNCTION/BlueprintNativeEvent.md)                                                     |                                                                                                                                       |                                              |
|FUNC_BlueprintPure                  |Blueprint           |0x10000000                                                                                                                                                                                                                                                      |function can be called from blueprint code, and is also pure (produces no side effects). If you set this, you should set FUNC_BlueprintCallable as well.|BlueprintGetter (Specifier/UFUNCTION/BlueprintGetter.md), BlueprintPure (Specifier/UFUNCTION/BlueprintPure.md)                                                                                           |                                                                                                                                       |                                              |
|FUNC_EditorOnly                     |Trait               |0x20000000                                                                                                                                                                                                                                                      |function can only be called from an editor scrippt.|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_Const                          |Trait               |0x40000000                                                                                                                                                                                                                                                      |function can be called from blueprint code, and only reads state (never writes state)|                                                                                                                                                                                                         |                                                                                                                                       |                                              |
|FUNC_NetValidate                    |Network             |0x80000000                                                                                                                                                                                                                                                      |function must supply a _Validate implementation|WithValidation (Specifier/UFUNCTION/WithValidation.md)                                                                                                                                                   |                                                                                                                                       |                                              |


# PropertyFlags :
|Name                                |Feature             |Value                                                                                                                                                                                                                                                           |Description                                                                                                               |UPARAM                                           |UPROPERTY                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|CPF_Edit                            |Editor              |0x0000000000000001                                                                                                                                                                                                                                              |Property is user-settable in the editor.                                                                                  |                                                 |EditAnywhere (Specifier/UPROPERTY/EditAnywhere.md), EditDefaultsOnly (Specifier/UPROPERTY/EditDefaultsOnly.md), EditInstanceOnly (Specifier/UPROPERTY/EditInstanceOnly.md), VisibleAnywhere (Specifier/UPROPERTY/VisibleAnywhere.md), VisibleDefaultsOnly (Specifier/UPROPERTY/VisibleDefaultsOnly.md), VisibleInstanceOnly (Specifier/UPROPERTY/VisibleInstanceOnly.md), Interp (Specifier/UPROPERTY/Interp.md)|
|CPF_ConstParm                       |Trait               |0x0000000000000002                                                                                                                                                                                                                                              |This is a constant function parameter                                                                                     |Const (Specifier/UPARAM/Const.md)                |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_BlueprintVisible                |Blueprint           |0x0000000000000004                                                                                                                                                                                                                                              |This property can be read by blueprint code                                                                               |                                                 |BlueprintReadWrite (Specifier/UPROPERTY/BlueprintReadWrite.md), BlueprintReadOnly (Specifier/UPROPERTY/BlueprintReadOnly.md), BlueprintSetter (Specifier/UPROPERTY/BlueprintSetter.md), BlueprintGetter (Specifier/UPROPERTY/BlueprintGetter.md), Interp (Specifier/UPROPERTY/Interp.md)                                                                                                                        |
|CPF_ExportObject                    |Serialization       |0x0000000000000008                                                                                                                                                                                                                                              |Object can be exported with actor.                                                                                        |                                                 |Instanced (Specifier/UPROPERTY/Instanced.md), Export (Specifier/UPROPERTY/Export.md)                                                                                                                                                                                                                                                                                                                            |
|CPF_BlueprintReadOnly               |Blueprint           |0x0000000000000010                                                                                                                                                                                                                                              |This property cannot be modified by blueprint code                                                                        |                                                 |BlueprintReadOnly (Specifier/UPROPERTY/BlueprintReadOnly.md), BlueprintGetter (Specifier/UPROPERTY/BlueprintGetter.md)                                                                                                                                                                                                                                                                                          |
|CPF_Net                             |Network             |0x0000000000000020                                                                                                                                                                                                                                              |Property is relevant to network replication.                                                                              |                                                 |Replicated (Specifier/UPROPERTY/Replicated.md), ReplicatedUsing (Specifier/UPROPERTY/ReplicatedUsing.md)                                                                                                                                                                                                                                                                                                        |
|CPF_EditFixedSize                   |Editor              |0x0000000000000040                                                                                                                                                                                                                                              |Indicates that elements of an array can be modified, but its size cannot be changed.                                      |                                                 |EditFixedSize (Specifier/UPROPERTY/EditFixedSize.md)                                                                                                                                                                                                                                                                                                                                                            |
|CPF_Parm                            |Function            |0x0000000000000080                                                                                                                                                                                                                                              |Function/When call parameter.                                                                                             |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_OutParm                         |Function            |0x0000000000000100                                                                                                                                                                                                                                              |Value is copied out after function call.                                                                                  |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_ZeroConstructor                 |Trait               |0x0000000000000200                                                                                                                                                                                                                                              |memset is fine for construction                                                                                           |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_ReturnParm                      |Function            |0x0000000000000400                                                                                                                                                                                                                                              |Return value.                                                                                                             |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_DisableEditOnTemplate           |Editor              |0x0000000000000800                                                                                                                                                                                                                                              |Disable editing of this property on an archetype/sub-blueprint                                                            |                                                 |EditInstanceOnly (Specifier/UPROPERTY/EditInstanceOnly.md), VisibleInstanceOnly (Specifier/UPROPERTY/VisibleInstanceOnly.md)                                                                                                                                                                                                                                                                                    |
|CPF_NonNullable                     |Trait               |0x0000000000001000                                                                                                                                                                                                                                              |Object property can never be null                                                                                         |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_Transient                       |Serialization       |0x0000000000002000                                                                                                                                                                                                                                              |Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.                                           |                                                 |Transient (Specifier/UPROPERTY/Transient.md)                                                                                                                                                                                                                                                                                                                                                                    |
|CPF_Config                          |Config              |0x0000000000004000                                                                                                                                                                                                                                              |Property should be loaded/saved as permanent profile.                                                                     |                                                 |Config (Specifier/UPROPERTY/Config.md)                                                                                                                                                                                                                                                                                                                                                                          |
|CPF_RequiredParm                    |Editor              |0x0000000000008000                                                                                                                                                                                                                                              |Parameter must be linked explicitly in blueprint. Leaving the parameter out results in a compile error.                   |Required (Specifier/UPARAM/Required.md)          |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_DisableEditOnInstance           |Editor              |0x0000000000010000                                                                                                                                                                                                                                              |Disable editing on an instance of this class                                                                              |                                                 |EditDefaultsOnly (Specifier/UPROPERTY/EditDefaultsOnly.md), VisibleDefaultsOnly (Specifier/UPROPERTY/VisibleDefaultsOnly.md)                                                                                                                                                                                                                                                                                    |
|CPF_EditConst                       |Editor              |0x0000000000020000                                                                                                                                                                                                                                              |Property is uneditable in the editor.                                                                                     |                                                 |VisibleAnywhere (Specifier/UPROPERTY/VisibleAnywhere.md)                                                                                                                                                                                                                                                                                                                                                        |
|CPF_GlobalConfig                    |Config              |0x0000000000040000                                                                                                                                                                                                                                              |Load config from base class, not subclass.                                                                                |                                                 |GlobalConfig (Specifier/UPROPERTY/GlobalConfig.md)                                                                                                                                                                                                                                                                                                                                                              |
|CPF_InstancedReference              |Trait               |0x0000000000080000                                                                                                                                                                                                                                              |Property is a component references.                                                                                       |                                                 |Instanced (Specifier/UPROPERTY/Instanced.md)                                                                                                                                                                                                                                                                                                                                                                    |
|CPF_DuplicateTransient              |Serialization       |0x0000000000200000                                                                                                                                                                                                                                              |Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)|                                                 |DuplicateTransient (Specifier/UPROPERTY/DuplicateTransient.md)                                                                                                                                                                                                                                                                                                                                                  |
|CPF_SaveGame                        |Serialization       |0x0000000001000000                                                                                                                                                                                                                                              |Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame           |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_NoClear                         |Editor              |0x0000000002000000                                                                                                                                                                                                                                              |Hide clear button.                                                                                                        |                                                 |NoClear (Specifier/UPROPERTY/NoClear.md)                                                                                                                                                                                                                                                                                                                                                                        |
|CPF_ReferenceParm                   |Function            |0x0000000008000000                                                                                                                                                                                                                                              |Value is passed by reference; CPF_OutParam and CPF_Param should also be set.                                              |ref (Specifier/UPARAM/ref.md)                    |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_BlueprintAssignable             |Blueprint           |0x0000000010000000                                                                                                                                                                                                                                              |MC Delegates only.  Property should be exposed for assigning in blueprint code                                            |                                                 |BlueprintAssignable (Specifier/UPROPERTY/BlueprintAssignable.md)                                                                                                                                                                                                                                                                                                                                                |
|CPF_Deprecated                      |Trait               |0x0000000020000000                                                                                                                                                                                                                                              |Property is deprecated.  Read it from an archive, but don't save it.                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_IsPlainOldData                  |Trait               |0x0000000040000000                                                                                                                                                                                                                                              |If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue                         |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_RepSkip                         |Network             |0x0000000080000000                                                                                                                                                                                                                                              |Not replicated. For non replicated properties in replicated structs                                                       |NotReplicated (Specifier/UPARAM/NotReplicated.md)|NotReplicated (Specifier/UPROPERTY/NotReplicated.md)                                                                                                                                                                                                                                                                                                                                                            |
|CPF_RepNotify                       |Network             |0x0000000100000000                                                                                                                                                                                                                                              |Notify actors when a property is replicated                                                                               |                                                 |ReplicatedUsing (Specifier/UPROPERTY/ReplicatedUsing.md)                                                                                                                                                                                                                                                                                                                                                        |
|CPF_Interp                          |Editor              |0x0000000200000000                                                                                                                                                                                                                                              |interpolatable property for use with cinematics                                                                           |                                                 |Interp (Specifier/UPROPERTY/Interp.md)                                                                                                                                                                                                                                                                                                                                                                          |
|CPF_NonTransactional                |Editor              |0x0000000400000000                                                                                                                                                                                                                                              |Property isn't transacted                                                                                                 |                                                 |NonTransactional (Specifier/UPROPERTY/NonTransactional.md)                                                                                                                                                                                                                                                                                                                                                      |
|CPF_EditorOnly                      |Editor              |0x0000000800000000                                                                                                                                                                                                                                              |Property should only be loaded in the editor                                                                              |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_NoDestructor                    |Trait               |0x0000001000000000                                                                                                                                                                                                                                              |No destructor                                                                                                             |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_AutoWeak                        |Trait               |0x0000004000000000                                                                                                                                                                                                                                              |Only used for weak pointers, means the export type is autoweak                                                            |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_ContainsInstancedReference      |Trait               |0x0000008000000000                                                                                                                                                                                                                                              |Property contains component references.                                                                                   |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_AssetRegistrySearchable         |Editor              |0x0000010000000000                                                                                                                                                                                                                                              |asset instances will add properties with this flag to the asset registry automatically                                    |                                                 |AssetRegistrySearchable (Specifier/UPROPERTY/AssetRegistrySearchable.md)                                                                                                                                                                                                                                                                                                                                        |
|CPF_SimpleDisplay                   |Editor              |0x0000020000000000                                                                                                                                                                                                                                              |The property is visible by default in the editor details view                                                             |                                                 |SimpleDisplay (Specifier/UPROPERTY/SimpleDisplay.md)                                                                                                                                                                                                                                                                                                                                                            |
|CPF_AdvancedDisplay                 |Editor              |0x0000040000000000                                                                                                                                                                                                                                              |The property is advanced and not visible by default in the editor details view                                            |                                                 |AdvancedDisplay (Specifier/UPROPERTY/AdvancedDisplay.md)                                                                                                                                                                                                                                                                                                                                                        |
|CPF_Protected                       |Editor              |0x0000080000000000                                                                                                                                                                                                                                              |property is protected from the perspective of script                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_BlueprintCallable               |Blueprint           |0x0000100000000000                                                                                                                                                                                                                                              |MC Delegates only.  Property should be exposed for calling in blueprint code                                              |                                                 |BlueprintCallable (Specifier/UPROPERTY/BlueprintCallable.md)                                                                                                                                                                                                                                                                                                                                                    |
|CPF_BlueprintAuthorityOnly          |Network             |0x0000200000000000                                                                                                                                                                                                                                              |MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.                    |                                                 |BlueprintAuthorityOnly (Specifier/UPROPERTY/BlueprintAuthorityOnly.md)                                                                                                                                                                                                                                                                                                                                          |
|CPF_TextExportTransient             |Serialization       |0x0000400000000000                                                                                                                                                                                                                                              |Property shouldn't be exported to text format (e.g. copy/paste)                                                           |                                                 |TextExportTransient (Specifier/UPROPERTY/TextExportTransient.md)                                                                                                                                                                                                                                                                                                                                                |
|CPF_NonPIEDuplicateTransient        |Serialization       |0x0000800000000000                                                                                                                                                                                                                                              |Property should only be copied in PIE                                                                                     |                                                 |NonPIEDuplicateTransient (Specifier/UPROPERTY/NonPIEDuplicateTransient.md)                                                                                                                                                                                                                                                                                                                                      |
|CPF_ExposeOnSpawn                   |Trait               |0x0001000000000000                                                                                                                                                                                                                                              |Property is exposed on spawn                                                                                              |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_PersistentInstance              |Serialization       |0x0002000000000000                                                                                                                                                                                                                                              |A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)             |                                                 |Instanced (Specifier/UPROPERTY/Instanced.md)                                                                                                                                                                                                                                                                                                                                                                    |
|CPF_UObjectWrapper                  |Trait               |0x0004000000000000                                                                                                                                                                                                                                              |Property was parsed as a wrapper class like TSubclassOf<T>, FScriptInterface etc., rather than a USomething*              |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_HasGetValueTypeHash             |Trait               |0x0008000000000000                                                                                                                                                                                                                                              |This property can generate a meaningful hash value.                                                                       |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_NativeAccessSpecifierPublic     |Trait               |0x0010000000000000                                                                                                                                                                                                                                              |Public native access specifier                                                                                            |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_NativeAccessSpecifierProtected  |Trait               |0x0020000000000000                                                                                                                                                                                                                                              |Protected native access specifier                                                                                         |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_NativeAccessSpecifierPrivate    |Trait               |0x0040000000000000                                                                                                                                                                                                                                              |Private native access specifier                                                                                           |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                |
|CPF_SkipSerialization               |Serialization       |0x0080000000000000                                                                                                                                                                                                                                              |Property shouldn't be serialized, can still be exported to text                                                           |                                                 |SkipSerialization (Specifier/UPROPERTY/SkipSerialization.md)                                                                                                                                                                                                                                                                                                                                                    |


ï»¿# ChildCannotTick

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºActoræˆ–ActorComponentå­ç±»ï¼Œæ ‡è®°å…è®¸å…¶è“å›¾å­ç±»ä¸å¯ä»¥æ¥å—å“åº”Tickäº‹ä»¶ï¼Œå“ªæ€•çˆ¶ç±»å¯ä»¥Tick
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Actorç±»
- **å…³è”é¡¹ï¼š** [ChildCanTick](ChildCanTick/ChildCanTick.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# ChildCanTick

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°å…è®¸å…¶è“å›¾å­ç±»å¯ä»¥æ¥å—å“åº”Tickäº‹ä»¶
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Actor
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Actoræˆ–ActorComponentå­ç±»
- **å…³è”é¡¹ï¼š** [ChildCannotTick](../ChildCannotTick.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¦åœ¨è“å›¾ä¸­é‡è½½Tickäº‹ä»¶å‡½æ•°å¹¶åªä¼šåœ¨ç¼–è¯‘çš„æ—¶å€™è§¦å‘åˆ¤æ–­ã€‚

```cpp
//(BlueprintType = true, ChildCannotTick = , IncludePath = Class/Blueprint/MyActor_ChildTick.h, IsBlueprintBase = true, ModuleRelativePath = Class/Blueprint/MyActor_ChildTick.h)
UCLASS(Blueprintable,meta=(ChildCanTick))
class INSIDER_API AMyActor_ChildCanTick : public AActor
{
	GENERATED_BODY()
public:
	AMyActor_ChildCanTick()
	{
		PrimaryActorTick.bCanEverTick = false;
	}
};

//(BlueprintType = true, ChildCanTick = , IncludePath = Class/Blueprint/MyActor_ChildTick.h, IsBlueprintBase = true, ModuleRelativePath = Class/Blueprint/MyActor_ChildTick.h)
UCLASS(Blueprintable,meta=(ChildCanTick))
class INSIDER_API UMyActorComponent_ChildCanTick : public UActorComponent
{
	GENERATED_BODY()
public:
};

//(BlueprintType = true, ChildCannotTick = , IncludePath = Class/Blueprint/MyActor_ChildTick.h, IsBlueprintBase = true, ModuleRelativePath = Class/Blueprint/MyActor_ChildTick.h)
UCLASS(Blueprintable,meta=(ChildCannotTick))
class INSIDER_API AMyActor_ChildCannotTick : public AActor
{
	GENERATED_BODY()
public:
};

//(BlueprintType = true, ChildCannotTick = , IncludePath = Class/Blueprint/MyActor_ChildTick.h, IsBlueprintBase = true, ModuleRelativePath = Class/Blueprint/MyActor_ChildTick.h)
UCLASS(Blueprintable,meta=(ChildCannotTick))
class INSIDER_API UMyActorComponent_ChildCannotTick : public UActorComponent
{
	GENERATED_BODY()
public:
};
```

è“å›¾Actoræˆ–ActorComponenté‡Œæµ‹è¯•ï¼š

ä¹Ÿæ³¨æ„åˆ°è¿™ä¸ªåˆ¤æ–­è·Ÿè“å›¾ä¸­æ˜¯å¦å¼€å¯Tickå¹¶æ²¡æœ‰å…³ç³»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Actor\ChildCanTick\Untitled.png)

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Actor\ChildCanTick\Untitled%201.png)

è€ŒAMyActor_ChildCanTickç±»é‡Œè™½ç„¶å·²ç»æ‰‹åŠ¨å…³é—­äº†PrimaryActorTick.bCanEverTickï¼Œä½†æ˜¯åœ¨å­ç±»é‡Œä¾ç„¶å¯ä»¥æ­£å¸¸çš„Tickï¼ˆåœ¨ç¼–è¯‘çš„æ—¶å€™å†…éƒ¨å¯ä»¥æ­£å¸¸çš„å†é‡æ–°å¼€å¯bCanEverTickï¼‰ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Actor\ChildCanTick\Untitled%202.png)

## æºç é‡Œåˆ¤æ–­çš„é€»è¾‘ï¼š

å¼€å¯bCanEverTick=trueçš„æ¡ä»¶æœ‰3ï¼Œä¸€æ˜¯EngineSettings->bCanBlueprintsTickByDefaultï¼ŒäºŒæ˜¯çˆ¶ç±»æ˜¯AActoræˆ–UActorComponentæœ¬èº«ï¼Œä¸‰æ˜¯C++åŸºç±»ä¸Šæœ‰ChildCanTickçš„æ ‡è®°ã€‚

```cpp
void FKismetCompilerContext::SetCanEverTick() const
{
// RECEIVE TICK
if (!TickFunction->bCanEverTick)
{
	// Make sure that both AActor and UActorComponent have the same name for their tick method
	static FName ReceiveTickName(GET_FUNCTION_NAME_CHECKED(AActor, ReceiveTick));
	static FName ComponentReceiveTickName(GET_FUNCTION_NAME_CHECKED(UActorComponent, ReceiveTick));

	if (const UFunction* ReceiveTickEvent = FKismetCompilerUtilities::FindOverriddenImplementableEvent(ReceiveTickName, NewClass))
	{
		// We have a tick node, but are we allowed to?

		const UEngine* EngineSettings = GetDefault<UEngine>();
		const bool bAllowTickingByDefault = EngineSettings->bCanBlueprintsTickByDefault;

		const UClass* FirstNativeClass = FBlueprintEditorUtils::FindFirstNativeClass(NewClass);
		const bool bHasCanTickMetadata = (FirstNativeClass != nullptr) && FirstNativeClass->HasMetaData(FBlueprintMetadata::MD_ChildCanTick);
		const bool bHasCannotTickMetadata = (FirstNativeClass != nullptr) && FirstNativeClass->HasMetaData(FBlueprintMetadata::MD_ChildCannotTick);
		const bool bHasUniversalParent = (FirstNativeClass != nullptr) && ((AActor::StaticClass() == FirstNativeClass) || (UActorComponent::StaticClass() == FirstNativeClass));

		if (bHasCanTickMetadata && bHasCannotTickMetadata)
		{
			// User error: The C++ class has conflicting metadata
			const FString ConlictingMetadataWarning = FText::Format(
				LOCTEXT("HasBothCanAndCannotMetadataFmt", "Native class %s has both '{0}' and '{1}' metadata specified, they are mutually exclusive and '{1}' will win."),
				FText::FromString(FirstNativeClass->GetPathName()),
				FText::FromName(FBlueprintMetadata::MD_ChildCanTick),
				FText::FromName(FBlueprintMetadata::MD_ChildCannotTick)
			).ToString();
			MessageLog.Warning(*ConlictingMetadataWarning);
		}

		if (bHasCannotTickMetadata)
		{
			// This could only happen if someone adds bad metadata to AActor or UActorComponent directly
			check(!bHasUniversalParent);

			// Parent class has forbidden us to tick
			const FString NativeClassSaidNo = FText::Format(
				LOCTEXT("NativeClassProhibitsTickingFmt", "@@ is not allowed as the C++ parent class {0} has disallowed Blueprint subclasses from ticking.  Please consider using a Timer instead of Tick."),
				FText::FromString(FirstNativeClass->GetPathName())
			).ToString();
			MessageLog.Warning(*NativeClassSaidNo, FindLocalEntryPoint(ReceiveTickEvent));
		}
		else
		{
			if (bAllowTickingByDefault || bHasUniversalParent || bHasCanTickMetadata)
			{
				// We're allowed to tick for one reason or another
				TickFunction->bCanEverTick = true;
			}
			else
			{
				// Nothing allowing us to tick
				const FString ReceiveTickEventWarning = FText::Format(
					LOCTEXT("ReceiveTick_CanNeverTickFmt", "@@ is not allowed for Blueprints based on the C++ parent class {0}, so it will never Tick!"),
					FText::FromString(FirstNativeClass ? *FirstNativeClass->GetPathName() : TEXT("<null>"))
				).ToString();
				MessageLog.Warning(*ReceiveTickEventWarning, FindLocalEntryPoint(ReceiveTickEvent));

				const FString ReceiveTickEventRemedies = FText::Format(
					LOCTEXT("ReceiveTick_CanNeverTickRemediesFmt", "You can solve this in several ways:\n  1) Consider using a Timer instead of Tick.\n  2) Add meta=({0}) to the parent C++ class\n  3) Reparent the Blueprint to AActor or UActorComponent, which can always tick."),
					FText::FromName(FBlueprintMetadata::MD_ChildCanTick)
				).ToString();
				MessageLog.Warning(*ReceiveTickEventRemedies);
			}
		}
	}
}
}
```


ï»¿# AllowedParamType

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

```cpp
// Sets a parameter's value in the supplied scope.
// @param    Scope    Scopes corresponding to an existing scope in a schedule, or "None". Passing "None" will apply the parameter to the whole schedule.
// @param    Ordering Where to apply the parameter in relation to the supplied scope. Ignored for scope "None".
// @param    Name     The name of the parameter to apply
// @param    Value    The value to set the parameter to
UFUNCTION(BlueprintCallable, Category = "AnimNext", CustomThunk, meta = (CustomStructureParam = Value, UnsafeDuringActorConstruction))
void SetParameterInScope(UPARAM(meta = (CustomWidget = "ParamName", AllowedParamType = "FAnimNextScope")) FName Scope, EAnimNextParameterScopeOrdering Ordering, UPARAM(meta = (CustomWidget = "ParamName")) FName Name, int32 Value);
```

æŸ¥äº†ä¸€ä¸‹ï¼Œåªåœ¨AnimNextä¸­ç”¨åˆ°ã€‚


ï»¿# AlwaysAsPin

- **åŠŸèƒ½æè¿°ï¼š** åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æ€»æ˜¯æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„š
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNode_Base
- **å…³è”é¡¹ï¼š** [PinShownByDefault](../PinShownByDefault/PinShownByDefault.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å’ŒPinShownByDefaultçš„åŒºåˆ«æ˜¯å‰è€…ä¼šå¯¼è‡´åªèƒ½ä¸€ç›´æ˜¾ç¤ºä¸ºå¼•è„šã€‚è€ŒPinShownByDefaulté»˜è®¤æ˜¾ç¤ºä¸ºå¼•è„šï¼Œå½“ä¹Ÿä¹‹åä¹Ÿå¯ä»¥æ”¹å˜ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct INSIDEREDITOR_API FAnimNode_MyTestPinShown : public FAnimNode_Base
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest)
	int32 MyInt_NotShown = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (PinShownByDefault))
	int32 MyInt_PinShownByDefault = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (AlwaysAsPin))
	int32 MyInt_AlwaysAsPin = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (NeverAsPin))
	int32 MyInt_NeverAsPin = 123;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\AlwaysAsPin\PinShown.gif](PinShown.gif)

## åŸç†ï¼š

æ ¹æ®æºç çš„é‡Œçš„é€»è¾‘å¯è§ï¼ŒbAlwaysShow ä¼šå¯¼è‡´bShowPinï¼Œå’ŒPinShownByDefaultçš„åŒºåˆ«æ˜¯å‰è€…ä¼šå¯¼è‡´åªèƒ½ä¸€ç›´æ˜¾ç¤ºä¸ºå¼•è„šã€‚è€ŒPinShownByDefaulté»˜è®¤æ˜¾ç¤ºä¸ºå¼•è„šï¼Œå½“ä¹Ÿä¹‹åä¹Ÿå¯ä»¥æ”¹å˜ã€‚

```cpp
void FAnimBlueprintNodeOptionalPinManager::GetRecordDefaults(FProperty* TestProperty, FOptionalPinFromProperty& Record) const
{
	const UAnimationGraphSchema* Schema = GetDefault<UAnimationGraphSchema>();

	// Determine if this is a pose or array of poses
	FArrayProperty* ArrayProp = CastField<FArrayProperty>(TestProperty);
	FStructProperty* StructProp = CastField<FStructProperty>(ArrayProp ? ArrayProp->Inner : TestProperty);
	const bool bIsPoseInput = (StructProp  && StructProp->Struct->IsChildOf(FPoseLinkBase::StaticStruct()));

	//@TODO: Error if they specified two or more of these flags
	const bool bAlwaysShow = TestProperty->HasMetaData(Schema->NAME_AlwaysAsPin) || bIsPoseInput;
	const bool bOptional_ShowByDefault = TestProperty->HasMetaData(Schema->NAME_PinShownByDefault);
	const bool bOptional_HideByDefault = TestProperty->HasMetaData(Schema->NAME_PinHiddenByDefault);
	const bool bNeverShow = TestProperty->HasMetaData(Schema->NAME_NeverAsPin);
	const bool bPropertyIsCustomized = TestProperty->HasMetaData(Schema->NAME_CustomizeProperty);
	const bool bCanTreatPropertyAsOptional = CanTreatPropertyAsOptional(TestProperty);

	Record.bCanToggleVisibility = bCanTreatPropertyAsOptional && (bOptional_ShowByDefault || bOptional_HideByDefault);
	Record.bShowPin = bAlwaysShow || bOptional_ShowByDefault;
	Record.bPropertyIsCustomized = bPropertyIsCustomized;
}
```


ï»¿# AnimBlueprintFunction

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜æ˜¯åŠ¨ç”»è“å›¾é‡Œçš„å†…éƒ¨çº¯å­˜æ ¹å‡½æ•°ï¼Œåªåœ¨åŠ¨ç”»è“å›¾ç¼–è¯‘æ—¶è®¾ç½®
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Anim BP

åªæ˜¯åœ¨å†…éƒ¨ä½¿ç”¨ï¼Œåœ¨åŠ¨ç”»è“å›¾ç¼–è¯‘çš„æ—¶å€™è®¾ç½®ã€‚ä½†æ˜¯æ²¡æœ‰åœ¨ä»£ç é‡Œæ˜¾å¼çš„ç¼–å†™ã€‚


ï»¿# AnimGetter

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUAnimInstanceåŠå­ç±»çš„è¯¥å‡½æ•°æˆä¸ºä¸€ä¸ªAnimGetterå‡½æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAnimInstanceåŠå­ç±»çš„å‡½æ•°
- **å…³è”é¡¹ï¼š** [GetterContext](../GetterContext/GetterContext.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šUAnimInstanceåŠå­ç±»çš„è¯¥å‡½æ•°æˆä¸ºä¸€ä¸ªAnimGetterå‡½æ•°ã€‚

- åœ¨ä¸€äº›æƒ…å†µä¸‹ä¼šç»§æ‰¿UAnimInstanceåˆ›å»ºè‡ªå·±çš„åŠ¨ç”»è“å›¾å­ç±»ï¼Œç„¶åé‡Œé¢å¯ä»¥è‡ªå·±åšä¸€äº›ä¼˜åŒ–ï¼Œæˆ–è€…æ·»åŠ ä¸€äº›è‡ªå·±çš„åŠŸèƒ½å‡½æ•°ã€‚
- æ‰€è°“çš„AnimGetterï¼Œå…¶å®å°±æ˜¯ä¼šè¢«UK2Node_AnimGetterè¯†åˆ«å¹¶åŒ…è£…æˆè¯¥è“å›¾èŠ‚ç‚¹çš„å‡½æ•°ã€‚è¯†åˆ«çš„èŒƒå›´æ˜¯åœ¨UAnimInstanceåŠå­ç±»ï¼ˆå°±æ˜¯åŠ¨ç”»è“å›¾ï¼‰çš„C++å‡½æ•°ã€‚
- AnimGetterè¿˜æœ‰ä¸¤ä¸ªé¢å¤–åŠŸèƒ½ï¼šä¸€æ˜¯ä¼šè‡ªåŠ¨æ ¹æ®å½“å‰ä¸Šä¸‹æ–‡å¡«å……å‡½æ•°é‡Œçš„AssetPlayerIndexï¼ŒMachineIndexï¼ŒStateIndexï¼ŒTransitionIndexå’Œå‚æ•°ã€‚äºŒæ˜¯ä¼šæ ¹æ®GetterContextæŠŠè¯¥å‡½æ•°é™å®šåªèƒ½åœ¨æŸäº›è“å›¾é‡Œè°ƒç”¨ã€‚æ™®é€šçš„è“å›¾å‡½æ•°ä¸å…·æœ‰è¿™äº›ä¾¿åˆ©çš„åŠŸèƒ½å’Œæ£€æŸ¥ï¼Œç”¨èµ·æ¥å°±ä¸å¤Ÿæ™ºèƒ½ã€‚
- è¦æˆä¸ºAnimGetterè¿˜å¿…é¡»å…·æœ‰ï¼š
    - AnimGetterï¼Œè‡ªç„¶ä¸å¿…è¯´
    - BlueprintThreadSafeï¼Œæ‰èƒ½åœ¨åŠ¨ç”»è“å›¾é‡Œè°ƒç”¨ï¼Œå¤šçº¿ç¨‹å®‰å…¨
    - BlueprintPureï¼Œæˆä¸ºä¸€ä¸ªå­˜è·å–å€¼çš„å‡½æ•°
    - BlueprintInternalUseOnly = "trueâ€ï¼Œé¿å…å†ç”Ÿæˆä¸€ä¸ªé»˜è®¤çš„è“å›¾èŠ‚ç‚¹ï¼Œåªç”¨UK2Node_AnimGetteråŒ…è£…è€Œæˆçš„é‚£ä¸ªã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyAnimInstance :public UAnimInstance
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintInternalUseOnly = "true", AnimGetter, BlueprintThreadSafe))
	float MyGetAnimationLength_AnimGetter(int32 AssetPlayerIndex);

	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintThreadSafe))
	float MyGetAnimationLength(int32 AssetPlayerIndex);
public:
	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintInternalUseOnly = "true", AnimGetter, BlueprintThreadSafe))
	float MyGetStateWeight_AnimGetter(int32 MachineIndex, int32 StateIndex);

	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintThreadSafe))
	float MyGetStateWeight(int32 MachineIndex, int32 StateIndex);
public:
	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintInternalUseOnly = "true", AnimGetter, BlueprintThreadSafe))
	float MyGetTransitionTimeElapsed_AnimGetter(int32 MachineIndex, int32 TransitionIndex);

	UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintThreadSafe))
	float MyGetTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex);
};

```

## æµ‹è¯•æ•ˆæœï¼š

åˆ†åˆ«å®šä¹‰ä½¿ç”¨äº†AssetPlayerIndexï¼ŒMachineIndexï¼ŒStateIndexï¼ŒTransitionIndexçš„AnimGetterå‡½æ•°ä»¥åŠæ™®é€šè“å›¾å‡½æ•°ä½œä¸ºå¯¹æ¯”ã€‚åˆ†åˆ«æŸ¥çœ‹åœ¨åŠ¨ç”»è“å›¾é‡Œå‡ ä¸ªä½œç”¨åŸŸé‡Œçš„ç”¨æ³•ã€‚

- å¯è§åœ¨ä¸ç®¡ä»€ä¹ˆä½œç”¨åŸŸï¼Œæ™®é€šè“å›¾å‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ï¼ˆæ¯•ç«Ÿæ²¡æœ‰åšContextçš„æ£€æŸ¥ï¼‰ã€‚å¦å¤–AssetPlayerIndexç­‰å‚æ•°éƒ½æ²¡æœ‰è¢«è‡ªåŠ¨å¡«å……ï¼Œè¿™å‡ ä¹æ˜¯æ²¡æ³•ç”¨çš„ï¼Œå› ä¸ºç”¨æˆ·å…¶å®å¹¶ä¸å¤ªæ‡‚å¦‚ä½•å»æ‰‹å¡«è¿™äº›Indexï¼Œæœ€å¥½æ˜¯äº¤ç»™ç¼–è¯‘å™¨æ¥å¡«å……ã€‚
- å›¾é‡Œé«˜äº®çš„æ˜¯å¯ä»¥è°ƒç”¨çš„AnimGetterå‡½æ•°ã€‚ç»†çœ‹çš„è¯ï¼Œå¯ä»¥åˆ†æå‘ç°è§„åˆ™æ˜¯åªæœ‰èƒ½æ­£ç¡®å¡«å……AssetPlayerIndexç­‰å‚æ•°çš„æ‰èƒ½è°ƒç”¨ã€‚å› æ­¤åœ¨Transitioné‡Œèƒ½è°ƒç”¨çš„æœ€å¤šï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™æœ€å¶å­èŠ‚ç‚¹ï¼Œæœ‰åŠ¨ç”»ï¼Œåˆæœ‰çŠ¶æ€æœºå’ŒTransitionèŠ‚ç‚¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\AnimGetter\Untitled.png)

## åŸç†ï¼š

åˆ†æå‡½æ•°ä¸Šçš„AnimGetteræ ‡è®°å¹¶ä¸”ç”Ÿæˆè“å›¾èŠ‚ç‚¹çš„åŠŸèƒ½åŸºæœ¬éƒ½åœ¨UK2Node_AnimGetterè¿™ä¸ªç±»é‡Œã€‚å¤§å®¶å¯è‡ªè¡ŒæŸ¥çœ‹ã€‚

```cpp
void UK2Node_AnimGetter::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
			TArray<UFunction*> AnimGetters;
			for(TFieldIterator<UFunction> FuncIter(BPClass) ; FuncIter ; ++FuncIter)
			{
				UFunction* Func = *FuncIter;

				if(Func->HasMetaData(TEXT("AnimGetter")) && Func->HasAnyFunctionFlags(FUNC_Native))
				{
					AnimGetters.Add(Func);
				}
			}
}
```


ï»¿# AnimNotifyBoneName

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„FNameå±æ€§ä½œä¸ºBoneNameçš„ä½œç”¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAnimNotifyæˆ–UAnimNotifyStateå­ç±»ä¸‹çš„FNameå±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„FNameå±æ€§ä½œä¸ºBoneNameçš„ä½œç”¨ã€‚

åœ¨åŠ¨ç”»é€šçŸ¥çš„æ—¶å€™ï¼Œä¹Ÿå¸¸å¸¸éœ€è¦ä¸€ä¸ªä¼ é€’éª¨éª¼åå­—å‚æ•°ï¼Œç”¨æ™®é€šçš„å­—ç¬¦ä¸²å‚æ•°æ˜¾ç„¶ä¸å¤Ÿå®šåˆ¶åŒ–ã€‚å› æ­¤ç»™ä¸€ä¸ªFNameå±æ€§æ ‡ä¸ŠAnimNotifyBoneNameå°±å¯ä»¥åœ¨é…åˆçš„ç»†èŠ‚é¢æ¿å®šåˆ¶åŒ–é‡Œä¸ºå®ƒåˆ›å»ºä¸“é—¨çš„æ›´ä¾¿äºå¡«å†™BoneNameçš„UIã€‚

## æºç ä¸­ä¾‹å­ï¼š

```cpp
UCLASS(const, hidecategories = Object, collapsecategories, meta = (DisplayName = "Play Niagara Particle Effect"), MinimalAPI)
class UAnimNotify_PlayNiagaraEffect : public UAnimNotify
{
		// SocketName to attach to
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AnimNotify", meta = (AnimNotifyBoneName = "true"))
	FName SocketName;
}

UCLASS(Blueprintable, meta = (DisplayName = "Timed Niagara Effect"), MinimalAPI)
class UAnimNotifyState_TimedNiagaraEffect : public UAnimNotifyState
{
	// The socket within our mesh component to attach to when we spawn the Niagara component
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NiagaraSystem, meta = (ToolTip = "The socket or bone to attach the system to", AnimNotifyBoneName = "true"))
	FName SocketName;
}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UAnimNotify_MyTest:public UAnimNotify
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName MyName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(AnimNotifyBoneName="true"))
	FName MyName_Bone;
};

UCLASS(BlueprintType)
class INSIDER_API UAnimNotifyState_MyTest:public UAnimNotifyState
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FName MyName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(AnimNotifyBoneName="true"))
	FName MyName_Bone;
};
```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨ä¸€ä¸ªåŠ¨ç”»åºåˆ—é‡ŒåŠ ä¸ŠåŠ¨ç”»é€šçŸ¥ï¼Œå¯ä»¥åŠ ä¸¤ç§ï¼šUAnimNotifyæˆ–UAnimNotifyStateã€‚é¦–å…ˆå¼•æ“é‡Œçš„è‡ªå¸¦ä¾‹å­UAnimNotify_PlayNiagaraEffect å’ŒUAnimNotifyState_TimedNiagaraEffect ï¼Œå¯ä»¥çœ‹è§åœ¨å³ä¾§çš„ç»†èŠ‚é¢æ¿ä¸Šçš„SocketNameçš„UIä¸æ˜¯æ™®é€šçš„å­—ç¬¦ä¸²ã€‚

æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„MyBoneNameçš„åŠ¨ç”»é€šçŸ¥ï¼Œä¹Ÿå¯ä»¥è¾¾æˆåŒæ ·çš„æ•ˆæœã€‚MyName_Boneå› ä¸ºåŠ äº†AnimNotifyBoneNameï¼Œå°±å’Œæ™®é€šçš„MyNameä¸ä¸€æ ·äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\AnimNotifyBoneName\Untitled.png)

## åŸç†ï¼š

åœ¨å®šåˆ¶åŒ–çš„æ—¶å€™ï¼Œæ ¹æ®AnimNotifyä¸‹çš„å±æ€§æ˜¯å¦æœ‰è¿™ä¸ªæ ‡è®°ï¼Œç”Ÿæˆä¸“é—¨çš„çš„UIã€‚

```cpp
bool FAnimNotifyDetails::CustomizeProperty(IDetailCategoryBuilder& CategoryBuilder, UObject* Notify, TSharedPtr<IPropertyHandle> Property)
{
	else if (InPropertyHandle->GetBoolMetaData(TEXT("AnimNotifyBoneName")))
	{
		// Convert this property to a bone name property
		AddBoneNameProperty(CategoryBuilder, Notify, InPropertyHandle);
	}
	
	 if (bIsBoneName)
		{
			AddBoneNameProperty(CategoryBuilder, Notify, Property);
			return true;
		}
}
```


ï»¿# AnimNotifyExpand

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„å±æ€§ç›´æ¥å±•å¼€åˆ°ç»†èŠ‚é¢æ¿é‡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAnimNotifyæˆ–UAnimNotifyStateå­ç±»ä¸‹çš„FNameå±æ€§

ä½¿å¾—UAnimNotifyæˆ–UAnimNotifyStateä¸‹çš„å±æ€§ç›´æ¥å±•å¼€åˆ°ç»†èŠ‚é¢æ¿é‡Œã€‚

åœ¨æºç é‡Œä¹Ÿæ²¡æœ‰æ‰¾åˆ°åº”ç”¨çš„ä¾‹å­ã€‚

## åŸç†ï¼š

çœ‹æºç ï¼Œé‡Œé¢å†™æ­»äº†åªå¯¹æœ‰é™çš„å¼•æ“è‡ªå¸¦çš„å‡ ä¸ªç±»èµ·æ•ˆï¼Œå› æ­¤è‡ªå·±çš„æµ‹è¯•ä»£ç å¹¶ä¸èƒ½ç”Ÿæ•ˆã€‚

è¿™ç§å†™æ³•ç¡®å®ä¸åº”è¯¥è¿™ä¹ˆå†™æ­»ï¼Œå¸Œæœ›ä»¥åæ”¹è¿›å§ã€‚åˆ°æ—¶åº”è¯¥å°±æœ‰æºç é‡Œçš„ä¾‹å­äº†ã€‚

```cpp

PropertyModule.RegisterCustomClassLayout( "EditorNotifyObject", FOnGetDetailCustomizationInstance::CreateStatic(&FAnimNotifyDetails::MakeInstance));

bool FAnimNotifyDetails::CustomizeProperty(IDetailCategoryBuilder& CategoryBuilder, UObject* Notify, TSharedPtr<IPropertyHandle> Property)
{
	if(Notify && Notify->GetClass() && Property->IsValidHandle())
{
	FString ClassName = Notify->GetClass()->GetName();
	FString PropertyName = Property->GetProperty()->GetName();
	bool bIsBoneName = Property->GetBoolMetaData(TEXT("AnimNotifyBoneName"));

	if(ClassName.Find(TEXT("AnimNotify_PlayParticleEffect")) != INDEX_NONE && PropertyName == TEXT("SocketName"))
	{
		AddBoneNameProperty(CategoryBuilder, Notify, Property);
		return true;
	}
	else if(ClassName.Find(TEXT("AnimNotifyState_TimedParticleEffect")) != INDEX_NONE && PropertyName == TEXT("SocketName"))
	{
		AddBoneNameProperty(CategoryBuilder, Notify, Property);
		return true;
	}
	else if(ClassName.Find(TEXT("AnimNotify_PlaySound")) != INDEX_NONE && PropertyName == TEXT("AttachName"))
	{
		AddBoneNameProperty(CategoryBuilder, Notify, Property);
		return true;
	}
	else if (ClassName.Find(TEXT("_SoundLibrary")) != INDEX_NONE && PropertyName == TEXT("SoundContext"))
	{
		CategoryBuilder.AddProperty(Property);
		FixBoneNamePropertyRecurse(Property);
		return true;
	}
	else if (ClassName.Find(TEXT("AnimNotifyState_Trail")) != INDEX_NONE)
	{
		if(PropertyName == TEXT("FirstSocketName") || PropertyName == TEXT("SecondSocketName"))
		{
			AddBoneNameProperty(CategoryBuilder, Notify, Property);
			return true;
		}
		else if(PropertyName == TEXT("WidthScaleCurve"))
		{
			AddCurveNameProperty(CategoryBuilder, Notify, Property);
			return true;
		}
	}
	else if (bIsBoneName)
	{
		AddBoneNameProperty(CategoryBuilder, Notify, Property);
		return true;
	}
}
}

```


ï»¿# BlueprintCompilerGeneratedDefaults

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§çš„å€¼æ˜¯ç¼–è¯‘å™¨ç”Ÿæˆçš„ï¼Œå› æ­¤åœ¨ç¼–è¯‘åæ— éœ€å¤åˆ¶ï¼Œå¯ä»¥åŠ é€Ÿä¸€äº›ç¼–è¯‘æ€§èƒ½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNodeé‡Œçš„å±æ€§

æŒ‡å®šè¯¥å±æ€§çš„å€¼æ˜¯ç¼–è¯‘å™¨ç”Ÿæˆçš„ï¼Œå› æ­¤åœ¨ç¼–è¯‘åæ— éœ€å¤åˆ¶ï¼Œå¯ä»¥åŠ é€Ÿä¸€äº›ç¼–è¯‘æ€§èƒ½ã€‚

åœ¨æºç é‡Œå¯»æ‰¾ä¾‹å­ï¼Œå¯ä»¥çœ‹åˆ°åŸºæœ¬æ˜¯åœ¨FAnimNodeä¸‹çš„å±æ€§åœ¨ä½¿ç”¨ã€‚åœ¨åŠ¨ç”»è“å›¾ç¼–è¯‘åï¼Œä¼šè°ƒç”¨UEngine::CopyPropertiesForUnrelatedObjectsæ¥æŠŠä¹‹å‰ç¼–è¯‘çš„æ—§å¯¹è±¡é‡Œçš„å€¼å¤åˆ¶åˆ°æ–°å¯¹è±¡ï¼Œå…¶ä¸­FCopyPropertiesForUnrelatedObjectsParamsçš„bSkipCompilerGeneratedDefaultså†³å®šæ˜¯å¦è¦èµ‹å€¼è¿™ä¸ªå±æ€§çš„å€¼ã€‚å¦‚æœæœ‰æ ‡ä¸Šè¿™ä¸ªå€¼ï¼Œå°±è¯´æ˜ä¸è¦å¤åˆ¶ã€‚è¿™ä¸ªå€¼ä¼šåœ¨åˆ«çš„åœ°æ–¹ç”±ç¼–è¯‘å™¨æ¥å¡«å……å€¼ã€‚

UAnimGraphNode_Base::OnProcessDuringCompilationå‡½æ•°å°±æ˜¯ç¼–è¯‘åå›è°ƒçš„å‡½æ•°ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct INSIDER_API FAnimNode_MyCompilerDefaults : public FAnimNode_Base
{
	GENERATED_USTRUCT_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Links)
	FPoseLink Source;
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CompilerDefaultsTest)
	FString MyString;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CompilerDefaultsTest, meta = (BlueprintCompilerGeneratedDefaults))
	FString MyString_CompilerDefaults;
};

UCLASS()
class INSIDEREDITOR_API UAnimGraphNode_MyCompilerDefaults : public UAnimGraphNode_Base
{
	GENERATED_UCLASS_BODY()
public:
	~UAnimGraphNode_MyCompilerDefaults();

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_MyCompilerDefaults Node;

protected:
	virtual void OnProcessDuringCompilation(IAnimBlueprintCompilationContext& InCompilationContext, IAnimBlueprintGeneratedClassCompiledData& OutCompiledData)
	{
		Node.MyString=TEXT("This is generated by compiler.");
		Node.MyString_CompilerDefaults=TEXT("This is generated by compiler.");
	}
};

```

## æµ‹è¯•æ•ˆæœï¼š

è¿™ä¸ªå› ä¸ºæ˜¯åºåˆ—åŒ–çš„è¿‡ç¨‹ï¼Œå› æ­¤å¹¶æ²¡æœ‰ç›´è§‚çš„ç¤ºæ„å›¾ã€‚

å¯éªŒè¯çš„ç»“æœæ˜¯åœ¨FCPFUOWriter::ShouldSkipPropertyå¯ä»¥è§åˆ°MyString_CompilerDefaultså±æ€§è·³è¿‡äº†å¤åˆ¶ã€‚

## åŸç†ï¼š

è“å›¾ç¼–è¯‘çš„è¿‡ç¨‹ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°çš„Graphå¯¹è±¡ï¼Œç„¶åæŠŠä¸Šä¸€æ¬¡ç¼–è¯‘çš„ç»“æœå¯¹è±¡é‡Œçš„å±æ€§å’Œåªå¯¹è±¡å¤åˆ¶åˆ°è¿™ä¸ªæ–°çš„å¯¹è±¡é‡Œå»ã€‚è¿™ä¸€æ­¥æ“ä½œæ˜¯ç”¨UEngine::CopyPropertiesForUnrelatedObjectsæ¥å®Œæˆçš„ï¼Œå†å†…éƒ¨ä¼šç»§ç»­ç”¨FCPFUOWriter::ShouldSkipPropertyæ¥åˆ¤æ–­æ˜¯å¦è¯¥å¤åˆ¶æŸä¸ªå±æ€§ã€‚è€Œå¯¹äºä¸€äº›å±æ€§çš„å€¼åªæ˜¯ç”±ç¼–è¯‘å™¨ç”Ÿæˆçš„ä¸´æ—¶å€¼ï¼Œåæ­£ä¸‹ä¸€æ¬¡ç¼–è¯‘ä¹Ÿä¼šå†ç”Ÿæˆï¼Œå› æ­¤å°±ä¸éœ€è¦å¤åˆ¶äº†ï¼Œæ ‡ä¸Šä¹‹åå¯ä»¥ç•¥å¾®åŠ é€Ÿä¸€äº›æ€§èƒ½ï¼Œè™½ç„¶å…¶å®ä¹Ÿä¸å¤šã€‚

```cpp
void UK2Node_PropertyAccess::CreateClassVariablesFromBlueprint(IAnimBlueprintVariableCreationContext& InCreationContext)
{
	GeneratedPropertyName = NAME_None;

	const bool bRequiresCachedVariable = !bWasResolvedThreadSafe || UAnimBlueprintExtension_PropertyAccess::ContextRequiresCachedVariable(ContextId);
	
	if(ResolvedPinType != FEdGraphPinType() && ResolvedPinType.PinCategory != UEdGraphSchema_K2::PC_Wildcard && bRequiresCachedVariable)
	{
		// Create internal generated destination property (only if we were not identified as thread safe)
		if(FProperty* DestProperty = InCreationContext.CreateUniqueVariable(this, ResolvedPinType))
		{
			GeneratedPropertyName = DestProperty->GetFName();
			DestProperty->SetMetaData(TEXT("BlueprintCompilerGeneratedDefaults"), TEXT("true"));
		}
	}
}

/* Serializes and stores property data from a specified 'source' object. Only stores data compatible with a target destination object. */
struct FCPFUOWriter : public FObjectWriter, public FCPFUOArchive
{
	#if WITH_EDITOR
	virtual bool ShouldSkipProperty(const class FProperty* InProperty) const override
	{
		return (bSkipCompilerGeneratedDefaults && InProperty->HasMetaData(BlueprintCompilerGeneratedDefaultsName));
	}
#endif 
}
```


ï»¿# CustomizeProperty

- **åŠŸèƒ½æè¿°ï¼š** ä½¿ç”¨åœ¨FAnimNodeçš„æˆå‘˜å±æ€§ä¸Šï¼Œå‘Šè¯‰ç¼–è¾‘å™¨ä¸è¦ä¸ºå®ƒç”Ÿæˆé»˜è®¤Detailsé¢æ¿æ§ä»¶ï¼Œåç»­ä¼šåœ¨DetailsCustomizationé‡Œè‡ªå®šä¹‰åˆ›å»ºç›¸åº”çš„ç¼–è¾‘æ§ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNodeé‡Œçš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ä½¿ç”¨åœ¨FAnimNodeçš„æˆå‘˜å±æ€§ä¸Šï¼Œå‘Šè¯‰ç¼–è¾‘å™¨ä¸è¦ä¸ºå®ƒç”Ÿæˆé»˜è®¤Detailsé¢æ¿æ§ä»¶ï¼Œåç»­ä¼šåœ¨DetailsCustomizationé‡Œè‡ªå®šä¹‰åˆ›å»ºç›¸åº”çš„ç¼–è¾‘æ§ä»¶ã€‚

å’ŒAllowEditInlineCustomizationçš„ä½œç”¨æœ‰ç‚¹åƒï¼Œéƒ½åªæ˜¯åšä¸ªæ ‡è®°æç¤ºç¼–è¾‘å™¨ä¼šåœ¨åˆ«çš„åœ°æ–¹è¿›è¡Œè‡ªå®šä¹‰ï¼Œä¸ç”¨ä¸ºå®ƒç”Ÿæˆé»˜è®¤Detailsé¢æ¿æ§ä»¶ã€‚

## æºç ä¸­ä¾‹å­ï¼š

åœ¨æºç é‡Œèƒ½è§åˆ°æŒºå¤šä¾‹å­ï¼Œå¸¸è§çš„å°±æ˜¯åœ¨AnimBPä¸­çš„èŠ‚ç‚¹ä¸Šçš„å±æ€§ï¼Œå…¶åœ¨ç»†èŠ‚é¢æ¿éœ€è¦ä¸“é—¨çš„å®šåˆ¶åŒ–ç¼–è¾‘ã€‚æœ€å¸¸è§çš„ä¾‹å­æ˜¯Slotè¿™ä¸ªèŠ‚ç‚¹ï¼Œå…¶SlotNameåªæ˜¯ä¸ªFStringç±»å‹ï¼Œä½†æ˜¯åœ¨ç»†èŠ‚é¢æ¿é‡Œæ˜¾ç¤ºçš„å´æ˜¯ä¸ªComboStringã€‚è¿™æ˜¯å› ä¸ºå®ƒæ ‡ä¸Šäº†CustomizePropertyï¼Œå‘ŠçŸ¥é»˜è®¤çš„åŠ¨ç”»èŠ‚ç‚¹ç»†èŠ‚é¢æ¿ç”Ÿæˆå™¨*ï¼ˆFAnimGraphNodeDetailsï¼‰å…ˆä¸è¦ä¸ºè¿™ä¸ªå±æ€§åˆ›å»ºç¼–è¾‘æ§ä»¶ï¼Œä¹‹åä¼šåœ¨è‡ªå·±çš„å®šåˆ¶åŒ–ï¼ˆFAnimGraphNodeSlotDetailsï¼‰é‡Œä¸ºSlotNameå†åˆ›å»ºè‡ªå®šä¹‰UIã€‚

```cpp
struct FAnimNode_Slot : public FAnimNode_Base
{
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Settings, meta=(CustomizeProperty))
	FName SlotName;
}

void FPersonaModule::CustomizeBlueprintEditorDetails(const TSharedRef<class IDetailsView>& InDetailsView, FOnInvokeTab InOnInvokeTab)
{
	InDetailsView->RegisterInstancedCustomPropertyLayout(UAnimGraphNode_Slot::StaticClass(),
		FOnGetDetailCustomizationInstance::CreateStatic(&FAnimGraphNodeSlotDetails::MakeInstance, InOnInvokeTab));

	InDetailsView->SetExtensionHandler(MakeShared<FAnimGraphNodeBindingExtension>());
}

```

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct INSIDER_API FAnimNode_MyCustomProperty : public FAnimNode_Base
{
	GENERATED_USTRUCT_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CustomProperty)
	FString MyString_Default;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CustomProperty, meta = (CustomizeProperty))
	FString MyString_CustomizeProperty;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = CustomProperty, meta = (CustomizeProperty))
	FString MyString_CustomizeProperty_Other;
};

UCLASS()
class INSIDEREDITOR_API UAnimGraphNode_MyCustomProperty : public UAnimGraphNode_Base
{
	GENERATED_UCLASS_BODY()

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_MyCustomProperty Node;
};

//å†åˆ›å»ºä¸€ä¸ªå®šåˆ¶åŒ–ï¼Œç”Ÿæˆè‡ªå®šä¹‰UI
void FMyAnimNode_MyCustomPropertyCustomization::CustomizeDetails(class IDetailLayoutBuilder& DetailBuilder)
{
	TSharedPtr<IPropertyHandle> PropertyHandle = DetailBuilder.GetProperty(TEXT("Node.MyString_CustomProperty"));
	
	//Just for test
	ComboListItems.Empty();
	ComboListItems.Add(MakeShareable(new FString(TEXT("First"))));
	ComboListItems.Add(MakeShareable(new FString(TEXT("Second"))));
	ComboListItems.Add(MakeShareable(new FString(TEXT("Third"))));
	const TSharedPtr<FString> ComboBoxSelectedItem = ComboListItems[0];

	IDetailCategoryBuilder& Group = DetailBuilder.EditCategory(TEXT("CustomProperty"));
	Group.AddCustomRow(INVTEXT("CustomProperty"))
		.NameContent()
		[
			PropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			SNew(STextComboBox)
				.OptionsSource(&ComboListItems)
				.InitiallySelectedItem(ComboBoxSelectedItem)
				.ContentPadding(2.f)
				.ToolTipText(FText::FromString(*ComboBoxSelectedItem))
		];
}

//æ³¨å†Œå®šåˆ¶åŒ–
PropertyModule.RegisterCustomClassLayout(TEXT("AnimGraphNode_MyCustomProperty"), FOnGetDetailCustomizationInstance::CreateStatic(&FMyAnimNode_MyCustomPropertyCustomization::MakeInstance));

```

## æµ‹è¯•æ•ˆæœï¼š

SlotNameçš„æ•ˆæœå¦‚å³ä¾§æ‰€ç¤ºã€‚

æˆ‘ä»¬è‡ªå·±æ¨¡ä»¿çš„ä¾‹å­å¯è§MyString_Defaultä¾ç„¶åªæ˜¯ä¸ªé»˜è®¤Stringï¼Œè€ŒMyString_CustomizePropertyåˆ™ä¸ºå®ƒåˆ›å»ºäº†è‡ªå®šä¹‰UIã€‚

ä½œä¸ºå¯¹æ¯”ï¼ŒMyString_CustomizeProperty_Otheræˆ‘ä»¬æ ‡ä¸Šäº†CustomizePropertyä½†æ˜¯æ²¡æœ‰ä¸ºå®ƒåˆ›å»ºUIï¼Œåˆ™æ²¡æœ‰æ˜¾ç¤ºå‡ºæ¥ï¼Œè¯´æ˜å¼•æ“é»˜è®¤çš„æœºåˆ¶å› æ­¤å°±æŠŠå®ƒçš„UIé»˜è®¤åˆ›å»ºæµç¨‹ç»™è·³è¿‡äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\CustomizeProperty\Untitled.png)

## åŸç†ï¼š

CustomizePropertyå…¶å®ä¼šä¼šæ”¹å˜Pinçš„bPropertyIsCustomized å±æ€§ï¼ˆGetRecordDefaultsä¸­ä½“ç°ï¼‰ï¼Œç„¶ååœ¨åˆ›å»ºæµç¨‹çš„è¿‡ç¨‹ä¸­ä¸åˆ›å»ºé»˜è®¤çš„widgetï¼Œè¿™ä¸ªå¯è§CustomizeDetailsä¸­çš„bPropertyIsCustomizedåˆ¤æ–­å¾—çŸ¥ã€‚

```cpp
void FAnimBlueprintNodeOptionalPinManager::GetRecordDefaults(FProperty* TestProperty, FOptionalPinFromProperty& Record) const
{
	const UAnimationGraphSchema* Schema = GetDefault<UAnimationGraphSchema>();

	// Determine if this is a pose or array of poses
	FArrayProperty* ArrayProp = CastField<FArrayProperty>(TestProperty);
	FStructProperty* StructProp = CastField<FStructProperty>(ArrayProp ? ArrayProp->Inner : TestProperty);
	const bool bIsPoseInput = (StructProp  && StructProp->Struct->IsChildOf(FPoseLinkBase::StaticStruct()));

	//@TODO: Error if they specified two or more of these flags
	const bool bAlwaysShow = TestProperty->HasMetaData(Schema->NAME_AlwaysAsPin) || bIsPoseInput;
	const bool bOptional_ShowByDefault = TestProperty->HasMetaData(Schema->NAME_PinShownByDefault);
	const bool bOptional_HideByDefault = TestProperty->HasMetaData(Schema->NAME_PinHiddenByDefault);
	const bool bNeverShow = TestProperty->HasMetaData(Schema->NAME_NeverAsPin);
	const bool bPropertyIsCustomized = TestProperty->HasMetaData(Schema->NAME_CustomizeProperty);
	const bool bCanTreatPropertyAsOptional = CanTreatPropertyAsOptional(TestProperty);

	Record.bCanToggleVisibility = bCanTreatPropertyAsOptional && (bOptional_ShowByDefault || bOptional_HideByDefault);
	Record.bShowPin = bAlwaysShow || bOptional_ShowByDefault;
	Record.bPropertyIsCustomized = bPropertyIsCustomized;
}

//è¿™ä¸ªæ˜¯åœ¨AnimBPä¸­é€‰ä¸­ä¸€ä¸ªèŠ‚ç‚¹ç„¶ååœ¨å³ä¾§ç»†èŠ‚é¢æ¿ä¸­çš„å±æ€§
void FAnimGraphNodeDetails::CustomizeDetails(class IDetailLayoutBuilder& DetailBuilder)
{
		// sometimes because of order of customization
		// this gets called first for the node you'd like to customize
		// then the above statement won't work
		// so you can mark certain property to have meta data "CustomizeProperty"
		// which will trigger below statement
		if (OptionalPin.bPropertyIsCustomized)
		{
						continue;
		}
		TSharedRef<SWidget> InternalCustomWidget = CreatePropertyWidget(TargetProperty, TargetPropertyHandle.ToSharedRef(), AnimGraphNode->GetClass());
}
```


ï»¿# CustomWidget

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

ä¹Ÿå¯ä»¥æ”¾åœ¨å±æ€§ä¸Š

```cpp
// @param    Scope    Scopes corresponding to an existing scope in a schedule, or "None". Passing "None" will apply the parameter to the whole schedule.
// @param    Ordering Where to apply the parameter in relation to the supplied scope. Ignored for scope "None".
// @param    Name     The name of the parameter to apply
// @param    Value    The value to set the parameter to
UFUNCTION(BlueprintCallable, Category = "AnimNext", CustomThunk, meta = (CustomStructureParam = Value, UnsafeDuringActorConstruction))
void SetParameterInScope(UPARAM(meta = (CustomWidget = "ParamName", AllowedParamType = "FAnimNextScope")) FName Scope, EAnimNextParameterScopeOrdering Ordering, UPARAM(meta = (CustomWidget = "ParamName")) FName Name, int32 Value);
```

åªåœ¨AnimNextå’ŒRigVMé‡Œç”¨åˆ°ã€‚


ï»¿# FoldProperty

- **åŠŸèƒ½æè¿°ï¼š** åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æˆä¸ºFoldPropertyã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNode_Baseä¸‹çš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æˆä¸ºFoldPropertyã€‚

- åœ¨UIè¡¨ç°ä¸ŠPinHiddenByDefaultä¹Ÿæœ‰åŒæ ·çš„æ•ˆæœï¼Œä½†æ˜¯FoldPropertyåœ¨è¡Œä¸ºä¸Šæœ‰åˆ«çš„ä¸åŒã€‚
- æ‰€è°“FoldPropertyï¼ŒæŒ‡çš„æ˜¯è¿™äº›å±æ€§å¾€å¾€ä½¿è¢«WITH_EDITORONLY_DATAåŒ…èµ·æ¥çš„ã€‚è®°å½•ç¼–è¾‘å™¨çŠ¶å†µä¸‹çš„ä¿¡æ¯ã€‚æ¯”å¦‚FAnimNode_SequencePlayerä¸‹çš„PlayRateæ•°æ®ï¼Œå…¶å°±æ˜¯åœ¨ç¼–è¾‘å™¨çŠ¶æ€çš„ä¸‹æ•°æ®ã€‚åˆæˆ–è€…åªæ˜¯åŠ¨ç”»è“å›¾æœ¬èº«çš„ä¿¡æ¯ï¼Œä¸ç®¡åŠ¨ç”»è“å›¾çš„å¤šå°‘ä¸ªå®ä¾‹ï¼Œè¿™äº›å±æ€§çš„å€¼å…¶å®éƒ½æ˜¯åŒæ ·çš„ã€‚è¿™äº›å±æ€§å°±é€‚åˆæˆä¸ºFoldPropertyã€‚
- è¿™äº›å±æ€§éœ€è¦åœ¨èŠ‚ç‚¹ä¸Šç¼–è¾‘ï¼Œä½†åˆä¸æƒ³æš´éœ²æˆå¼•è„šï¼Œå› æ­¤å°±åœ¨å½¢å¼ä¸Šå’ŒPinHiddenByDefaultä¸€æ ·æ”¾åˆ°å³ä¾§çš„ç»†èŠ‚é¢æ¿é‡Œã€‚

åœ¨FAnimNodeData* FAnimNode_Base::NodeDataé‡Œå­˜å‚¨ç€è¯¥åŠ¨ç”»èŠ‚ç‚¹çš„æ‰€æœ‰å®ä¾‹æ‰€ç”¨åˆ°çš„â€œConstant/Foldâ€å±æ€§ä¿¡æ¯ã€‚è¯¥åŠ¨ç”»è“å›¾åœ¨æ¸¸æˆé‡Œå¯èƒ½æœ‰å¤šä¸ªå®ä¾‹ï¼Œåœ¨è¿™äº›å®ä¾‹ä¹‹é—´éƒ½åªå­˜ä¸€ä»½åŠ¨ç”»èŠ‚ç‚¹çš„å¸¸é‡ä¿¡æ¯ï¼Œä¹Ÿåªå­˜ä¸€ä»½FoldPropertyçš„ä¿¡æ¯ã€‚å› æ­¤ç”¨FoldPropertyæ ‡è®°çš„å±æ€§çš„çœŸå®æ•°æ®æ˜¯å­˜åœ¨TArray<FAnimNodeData> UAnimBlueprintGeneratedClass::AnimNodeDataä¸­çš„ã€‚å­˜åœ¨Classä¸­ï¼Œå…¶å®å°±æ˜¯ç±»ä¼¼CDOçš„æ„æ€äº†ã€‚è¿™ä¹ˆåšçš„æ˜¾ç„¶å¥½å¤„ä¹‹ä¸€æ˜¯èŠ‚çœå†…å­˜ã€‚

è‡ªç„¶çš„ï¼Œä¸åŒçš„å­˜å‚¨æ–¹å¼ï¼Œè‡ªç„¶è¦é‡‡ç”¨ä¸åŒçš„è®¿é—®æ–¹å¼ã€‚å› æ­¤è¿™äº›FoldPropertyéƒ½æ˜¯é‡‡ç”¨GET_ANIM_NODE_DATAæ¥è®¿é—®è¯¥æ•°æ®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FoldPropertyTest, meta = (FoldProperty))
	int32 MyInt_FoldProperty = 123;
```

## æµ‹è¯•ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\FoldProperty\Untitled.png)

## åŸç†ï¼š

ç¼–è¯‘çš„æ—¶å€™ä¼šæŠŠè¯¥FoldPropertyæ·»åŠ åˆ°FoldRecordsé‡Œã€‚å¦‚æœè¿™ä¸ªå±æ€§ä¸æ˜¯åŠ¨æ€ï¼Œä¹Ÿæ²¡æœ‰æš´éœ²æˆå¼•è„šè¿æ¥ï¼Œåˆ™ä¼šè¢«å½“ä½œå¸¸é‡ã€‚

```cpp
void FAnimBlueprintCompilerContext::GatherFoldRecordsForAnimationNode(const UScriptStruct* InNodeType, FStructProperty* InNodeProperty, UAnimGraphNode_Base* InVisualAnimNode)
{
	if(SubProperty->HasMetaData(NAME_FoldProperty))
	{
		// Add folding candidate
		AddFoldedPropertyRecord(InVisualAnimNode, InNodeProperty, SubProperty, bAllPinsExposed, !bAllPinsDisconnected, bAlwaysDynamic);
	}
}

void FAnimBlueprintCompilerContext::AddFoldedPropertyRecord(UAnimGraphNode_Base* InAnimGraphNode, FStructProperty* InAnimNodeProperty, FProperty* InProperty, bool bInExposedOnPin, bool bInPinConnected, bool bInAlwaysDynamic)
{
	const bool bConstant = !bInAlwaysDynamic && (!bInExposedOnPin || (bInExposedOnPin && !bInPinConnected));

	if(!InProperty->HasAnyPropertyFlags(CPF_EditorOnly))
	{
		MessageLog.Warning(*FString::Printf(TEXT("Property %s on @@ is foldable, but not editor only"), *InProperty->GetName()), InAnimGraphNode);
	}

	// Create record and add it our lookup map
	TSharedRef<IAnimBlueprintCompilationContext::FFoldedPropertyRecord> Record = MakeShared<IAnimBlueprintCompilationContext::FFoldedPropertyRecord>(InAnimGraphNode, InAnimNodeProperty, InProperty, bConstant);
	TArray<TSharedRef<IAnimBlueprintCompilationContext::FFoldedPropertyRecord>>& Array = NodeToFoldedPropertyRecordMap.FindOrAdd(InAnimGraphNode);
	Array.Add(Record);

	// Record it in the appropriate data area
	if(bConstant)
	{
		ConstantPropertyRecords.Add(Record);
	}
	else
	{
		MutablePropertyRecords.Add(Record);
	}
}
```


ï»¿# GetterContext

- **åŠŸèƒ½æè¿°ï¼š** ç»§ç»­é™å®šAnimGetterå‡½æ•°åœ¨å“ªä¸ªåœ°æ–¹æ‰å¯ä»¥ä½¿ç”¨ï¼Œå¦‚æœä¸å¡«ï¼Œåˆ™é»˜è®¤éƒ½å¯ä»¥ç”¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UAnimInstanceåŠå­ç±»çš„AnimGetterå‡½æ•°
- **å…³è”é¡¹ï¼š** [AnimGetter](../AnimGetter/AnimGetter.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç»§ç»­é™å®šAnimGetterå‡½æ•°åœ¨å“ªä¸ªåœ°æ–¹æ‰å¯ä»¥ä½¿ç”¨ï¼Œå¦‚æœä¸å¡«ï¼Œåˆ™é»˜è®¤éƒ½å¯ä»¥ç”¨ã€‚

é€‰é¡¹æœ‰ï¼šTransitionï¼ŒCustomBlendï¼ŒAnimGraphã€‚

## æºç æ³¨é‡Šï¼š

```cpp
	 * A context string can be provided in the GetterContext metadata and can contain any (or none) of the
	 * following entries separated by a pipe (|)
	 * Transition  - Only available in a transition rule
	 * AnimGraph   - Only available in an animgraph (also covers state anim graphs)
	 * CustomBlend - Only available in a custom blend graph
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintThreadSafe))
float MyGetStateWeight(int32 MachineIndex, int32 StateIndex);
public:
UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintInternalUseOnly = "true", AnimGetter, GetterContext = "Transition", BlueprintThreadSafe))
float MyGetStateWeight_AnimGetter_OnlyTransition(int32 MachineIndex, int32 StateIndex);

UFUNCTION(BlueprintPure, Category = "Animation|Insider", meta = (BlueprintInternalUseOnly = "true", AnimGetter, GetterContext = "CustomBlend", BlueprintThreadSafe))
float MyGetTransitionTimeElapsed_AnimGetter_OnlyCustomBlend(int32 MachineIndex, int32 TransitionIndex);
```

## æµ‹è¯•æ•ˆæœï¼š

è¿™ä¸ªå›¾è¦å¯¹æ¯”AnimGetteré‡Œçš„å›¾æ¥æŸ¥çœ‹ã€‚

å…³æ³¨ç‚¹ä¸€æ˜¯åœ¨AnimGraphé‡Œçš„MyGetStateWeight_AnimGetter_OnlyTransitionï¼Œå¦‚æœä¸æ ‡GetterContext åˆ™æ˜¯å¯ä»¥è°ƒç”¨çš„ï¼Œä½†æ ‡ä¸Šå°±åªèƒ½åœ¨Transitioné‡Œè°ƒç”¨ã€‚åŒæ—¶ä¹Ÿå‘ç°è¯¥å‡½æ•°ä¸èƒ½åœ¨CustomBlendé‡Œè°ƒç”¨ã€‚

äºŒæ˜¯åœ¨CustomBlendé‡Œã€‚æ“ä½œæ­¥éª¤æ˜¯åœ¨Ruleä¸Šå³ä¾§ç»†èŠ‚é¢æ¿æ”¹ä¸ºCustomç„¶åè¿›å…¥CustomBlendçš„è“å›¾ã€‚åœ¨è¯¥è“å›¾ä¸‹ï¼ŒMyGetStateWeightå¯ä»¥è°ƒç”¨ï¼Œå› ä¸ºå¹¶æ²¡æœ‰å¡«å†™GetterContextã€‚è€ŒMyGetTransitionTimeElapsed_AnimGetter_OnlyCustomBlendå¯ä»¥å¼€å§‹è°ƒç”¨äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\GetterContext\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­èƒ½å¦è°ƒç”¨çš„å‡½æ•°å¦‚ä¸‹ã€‚

```cpp
bool UK2Node_AnimGetter::IsContextValidForSchema(const UEdGraphSchema* Schema) const
{
	if(Contexts.Num() == 0)
	{
		// Valid in all graphs
		return true;
	}
	
	for(const FString& Context : Contexts)
	{
		UClass* ClassToCheck = nullptr;
		if(Context == TEXT("CustomBlend"))
		{
			ClassToCheck = UAnimationCustomTransitionSchema::StaticClass();
		}

		if(Context == TEXT("Transition"))
		{
			ClassToCheck = UAnimationTransitionSchema::StaticClass();
		}

		if(Context == TEXT("AnimGraph"))
		{
			ClassToCheck = UAnimationGraphSchema::StaticClass();
		}

		return Schema->GetClass() == ClassToCheck;
	}

	return false;
}
```


ï»¿# NeverAsPin

- **åŠŸèƒ½æè¿°ï¼š** åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§æ€»æ˜¯ä¸æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„š
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNode_Base
- **å…³è”é¡¹ï¼š** [PinShownByDefault](../PinShownByDefault/PinShownByDefault.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

NeverAsPinæºç ä¸­å¹¶æ²¡æœ‰ç”¨åˆ°ï¼Œå› ä¸ºé»˜è®¤æƒ…å†µä¸‹å°±æ˜¯ä¸æ”¯æŒä¸ºå¼•è„šï¼Œæ‰€ä»¥ä¸åŠ ä¹Ÿéƒ½ä¸€æ ·ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct INSIDEREDITOR_API FAnimNode_MyTestPinShown : public FAnimNode_Base
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest)
	int32 MyInt_NotShown = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (PinShownByDefault))
	int32 MyInt_PinShownByDefault = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (AlwaysAsPin))
	int32 MyInt_AlwaysAsPin = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (NeverAsPin))
	int32 MyInt_NeverAsPin = 123;
};
```

## æµ‹è¯•æ•ˆæœï¼š

MyInt_NeverAsPinåªèƒ½å’Œå³è¾¹å’Œé»˜è®¤çš„å±æ€§ä¸€æ ·ï¼Œä¸èƒ½æ˜¾ç¤ºä¸ºå¼•è„šã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\NeverAsPin\PinShown.gif](PinShown.gif)

## åŸç†ï¼š

å‘ç°bNeverShowå¹¶æ²¡æœ‰ç”¨åˆ°ï¼Œå› ä¸ºé»˜è®¤æƒ…å†µä¸‹å°±æ˜¯ä¸æ”¯æŒä¸ºå¼•è„šã€‚

```cpp
void FAnimBlueprintNodeOptionalPinManager::GetRecordDefaults(FProperty* TestProperty, FOptionalPinFromProperty& Record) const
{
	const UAnimationGraphSchema* Schema = GetDefault<UAnimationGraphSchema>();

	// Determine if this is a pose or array of poses
	FArrayProperty* ArrayProp = CastField<FArrayProperty>(TestProperty);
	FStructProperty* StructProp = CastField<FStructProperty>(ArrayProp ? ArrayProp->Inner : TestProperty);
	const bool bIsPoseInput = (StructProp  && StructProp->Struct->IsChildOf(FPoseLinkBase::StaticStruct()));

	//@TODO: Error if they specified two or more of these flags
	const bool bAlwaysShow = TestProperty->HasMetaData(Schema->NAME_AlwaysAsPin) || bIsPoseInput;
	const bool bOptional_ShowByDefault = TestProperty->HasMetaData(Schema->NAME_PinShownByDefault);
	const bool bOptional_HideByDefault = TestProperty->HasMetaData(Schema->NAME_PinHiddenByDefault);
	const bool bNeverShow = TestProperty->HasMetaData(Schema->NAME_NeverAsPin);
	const bool bPropertyIsCustomized = TestProperty->HasMetaData(Schema->NAME_CustomizeProperty);
	const bool bCanTreatPropertyAsOptional = CanTreatPropertyAsOptional(TestProperty);

	Record.bCanToggleVisibility = bCanTreatPropertyAsOptional && (bOptional_ShowByDefault || bOptional_HideByDefault);
	Record.bShowPin = bAlwaysShow || bOptional_ShowByDefault;
	Record.bPropertyIsCustomized = bPropertyIsCustomized;
}
```


ï»¿# OnEvaluate

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph

## åŸç†ï¼š

åœ¨æºç ä¸­å‘ç°ï¼Œè¯´æ˜OnEvaluateå·²ç»æ”¾å¼ƒäº†ã€‚

```cpp
// Dynamic value that needs to be wired up and evaluated each frame
	const FString& EvaluationHandlerStr = SourcePinProperty->GetMetaData(AnimGraphDefaultSchema->NAME_OnEvaluate);
	FName EvaluationHandlerName(*EvaluationHandlerStr);
	if (EvaluationHandlerName != NAME_None)
	{
		// warn that NAME_OnEvaluate is deprecated:
		InCompilationContext.GetMessageLog().Warning(*LOCTEXT("OnEvaluateDeprecated", "OnEvaluate meta data is deprecated, found on @@").ToString(), SourcePinProperty);
	}
```


ï»¿# PinShownByDefault

- **åŠŸèƒ½æè¿°ï¼š** åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§ä¸€å¼€å§‹å°±æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„šï¼Œä½†ä¹Ÿå¯ä»¥æ”¹å˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** AnimationGraph
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FAnimNode_Base
- **å…³è”é¡¹ï¼š** [AlwaysAsPin](../AlwaysAsPin/AlwaysAsPin.md), [NeverAsPin](../NeverAsPin/NeverAsPin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨åŠ¨ç”»è“å›¾ä¸­ä½¿å¾—åŠ¨ç”»èŠ‚ç‚¹çš„æŸä¸ªå±æ€§ä¸€å¼€å§‹å°±æš´éœ²å‡ºæ¥æˆä¸ºå¼•è„šã€‚

å’Œå¸¸è§„çš„è“å›¾ä¸åŒï¼ŒFAnimNode_Baseé‡Œé¢çš„å±æ€§é»˜è®¤æ˜¯ä¸åœ¨èŠ‚ç‚¹ä¸Šæ˜¾ç¤ºå‡ºæ¥çš„ã€‚å› æ­¤æ‰éœ€è¦è¿™ä¸ªmetaæ˜¾å¼çš„æŒ‡å®šå“ªäº›éœ€è¦æ˜¾å¼ã€‚

PinShownByDefaultç›®å‰åªåœ¨åŠ¨ç”»è“å›¾èŠ‚ç‚¹ä¸Šåº”ç”¨ã€‚

ç›¸åçš„ï¼Œå¯ä»¥ç”¨PinHiddenByDefaultæ¥éšè—å±æ€§æˆä¸ºå¼•è„šã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct INSIDEREDITOR_API FAnimNode_MyTestPinShown : public FAnimNode_Base
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest)
	int32 MyInt_NotShown = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (PinShownByDefault))
	int32 MyInt_PinShownByDefault = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (AlwaysAsPin))
	int32 MyInt_AlwaysAsPin = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinShownByDefaultTest, meta = (NeverAsPin))
	int32 MyInt_NeverAsPin = 123;
};

UCLASS()
class INSIDEREDITOR_API UAnimGraphNode_MyTestPinShown : public UAnimGraphNode_Base
{
	GENERATED_UCLASS_BODY()

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_MyTestPinShown Node;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§ï¼ŒåŒæ ·çš„ä¸¤ä¸ªå±æ€§ï¼ŒMyInt_NotShown é»˜è®¤æƒ…å†µä¸æ˜¾ç¤ºæˆèŠ‚ç‚¹ï¼Œåªèƒ½åœ¨ç»†èŠ‚é¢æ¿é‡Œç¼–è¾‘ã€‚è€ŒMyInt_PinShownByDefaulté»˜è®¤æƒ…å†µä¸‹æˆä¸ºå¼•è„šã€‚å½“PinShownByDefaultè¿˜å¯ä»¥æ”¹å˜å»æ‰Pinçš„åŠŸèƒ½ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\AnimationGraph\PinShownByDefault\PinShown.gif](PinShown.gif)

## åŸç†ï¼š

æºç é‡Œå”¯ä¸€ç”¨çš„åœ°æ–¹å°±æ˜¯åœ¨FAnimBlueprintNodeOptionalPinManagerï¼Œå…¶å®å°±æ˜¯å¤„ç†åŠ¨ç”»è“å›¾èŠ‚ç‚¹çš„Pinå¦‚ä½•æ˜¾ç¤ºã€‚

```cpp
void FAnimBlueprintNodeOptionalPinManager::GetRecordDefaults(FProperty* TestProperty, FOptionalPinFromProperty& Record) const
{
	const UAnimationGraphSchema* Schema = GetDefault<UAnimationGraphSchema>();

	// Determine if this is a pose or array of poses
	FArrayProperty* ArrayProp = CastField<FArrayProperty>(TestProperty);
	FStructProperty* StructProp = CastField<FStructProperty>(ArrayProp ? ArrayProp->Inner : TestProperty);
	const bool bIsPoseInput = (StructProp  && StructProp->Struct->IsChildOf(FPoseLinkBase::StaticStruct()));

	//@TODO: Error if they specified two or more of these flags
	const bool bAlwaysShow = TestProperty->HasMetaData(Schema->NAME_AlwaysAsPin) || bIsPoseInput;
	const bool bOptional_ShowByDefault = TestProperty->HasMetaData(Schema->NAME_PinShownByDefault);
	const bool bOptional_HideByDefault = TestProperty->HasMetaData(Schema->NAME_PinHiddenByDefault);
	const bool bNeverShow = TestProperty->HasMetaData(Schema->NAME_NeverAsPin);
	const bool bPropertyIsCustomized = TestProperty->HasMetaData(Schema->NAME_CustomizeProperty);
	const bool bCanTreatPropertyAsOptional = CanTreatPropertyAsOptional(TestProperty);

	Record.bCanToggleVisibility = bCanTreatPropertyAsOptional && (bOptional_ShowByDefault || bOptional_HideByDefault);
	Record.bShowPin = bAlwaysShow || bOptional_ShowByDefault;
	Record.bPropertyIsCustomized = bPropertyIsCustomized;
}
```


ï»¿# DisallowedAssetDataTags

- **åŠŸèƒ½æè¿°ï¼š** åœ¨UObject*å±æ€§ä¸ŠæŒ‡å®šTagsæ¥è¿›è¡Œè¿‡æ»¤ï¼Œå¿…é¡»æ²¡æœ‰æ‹¥æœ‰è¯¥Tagsæ‰å¯ä»¥è¢«é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Asset Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="a=bï¼Œc=dï¼Œe=f"
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [RequiredAssetDataTags](RequiredAssetDataTags/RequiredAssetDataTags.md), [AssetRegistrySearchable](../../Specifier/UPROPERTY/Asset/AssetRegistrySearchable/AssetRegistrySearchable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…


ï»¿# ForceShowEngineContent

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUObject*å±æ€§çš„èµ„æºå¯é€‰åˆ—è¡¨é‡Œå¼ºåˆ¶å¯é€‰å¼•æ“çš„å†…å»ºèµ„æº
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Asset Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [ForceShowPluginContent](ForceShowPluginContent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šUObject*å±æ€§çš„èµ„æºå¯é€‰åˆ—è¡¨é‡Œå¼ºåˆ¶å¯é€‰å¼•æ“çš„å†…å»ºèµ„æºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_ShowContent :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object)
	TObjectPtr<UObject> MyAsset_Default;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object, meta = (ForceShowEngineContent))
	TObjectPtr<UObject> MyAsset_ForceShowEngineContent;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object, meta = (ForceShowPluginContent))
	TObjectPtr<UObject> MyAsset_ForceShowPluginContent;
};
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyAsset_Defaulté»˜è®¤æ˜¯åªåŒ…å«æœ¬é¡¹ç›®çš„èµ„æºã€‚

MyAsset_ForceShowEngineContentçš„ä½œç”¨å…¶å®å°±æ˜¯åœ¨é€‰é¡¹å¡é‡Œå‹¾é€‰ShowEngineContentï¼Œå› æ­¤ç»“æœä¸Šä¼šå‘ç°å¤šäº†éå¸¸å¤šçš„å¯é€‰èµ„æºã€‚

MyAsset_ForceShowPluginContentçš„ä½œç”¨åŒæ ·æ˜¯åœ¨é€‰é¡¹å¡é‡Œå‹¾é€‰ShowPluginContentï¼Œå¯ä»¥é€‰æ‹©åˆ«çš„æ’ä»¶é‡Œçš„èµ„æºã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Asset\ForceShowEngineContent\Untitled.png)

## åŸç†ï¼š

åœ¨å±æ€§çš„èµ„æºé€‰æ‹©å™¨é‡Œä¼šå°è¯•å¯»æ‰¾ForceShowEngineContentå’ŒForceShowPluginContentï¼Œç„¶åè®¾ç½®åˆ°AssetPickerConfigé‡Œï¼Œä»è€Œæ”¹å˜èµ„æºçš„å¯é€‰ç±»å‹ã€‚

```cpp
void SPropertyMenuAssetPicker::Construct( const FArguments& InArgs )
{
		const bool bForceShowEngineContent = PropertyHandle ? PropertyHandle->HasMetaData(TEXT("ForceShowEngineContent")) : false;
		const bool bForceShowPluginContent = PropertyHandle ? PropertyHandle->HasMetaData(TEXT("ForceShowPluginContent")) : false;
		
		FAssetPickerConfig AssetPickerConfig;
		// Force show engine content if meta data says so
		AssetPickerConfig.bForceShowEngineContent = bForceShowEngineContent;
		// Force show plugin content if meta data says so
		AssetPickerConfig.bForceShowPluginContent = bForceShowPluginContent;
}
```


ï»¿# ForceShowPluginContent

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUObject*å±æ€§çš„èµ„æºå¯é€‰åˆ—è¡¨é‡Œå¼ºåˆ¶å¯é€‰å…¶ä»–æ’ä»¶é‡Œçš„å†…å»ºèµ„æº
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Asset Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [ForceShowEngineContent](ForceShowEngineContent.md)


ï»¿# GetAssetFilter

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªUFUNCTIONæ¥å¯¹UObject*å±æ€§çš„å¯é€‰èµ„æºè¿›è¡Œæ’é™¤è¿‡æ»¤ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Asset Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªUFUNCTIONæ¥å¯¹UObject*å±æ€§çš„å¯é€‰èµ„æºè¿›è¡Œæ’é™¤è¿‡æ»¤ã€‚

- æŒ‡å®šçš„å‡½æ•°åå­—å¿…é¡»æ˜¯UFUNCTIONï¼Œåœ¨æœ¬ç±»ä¸­å®šä¹‰ã€‚
- å‡½æ•°çš„åŸå‹æ˜¯bool FuncName(const FAssetData& AssetData) const;ï¼Œè¿”å›trueæ¥æ’é™¤æ‰è¯¥èµ„äº§ã€‚
- è¿™æ˜¯ä¸€ç§è®©ç”¨æˆ·è‡ªå®šä¹‰èµ„äº§è¿‡æ»¤çš„æ–¹å¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_GetAssetFilter :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UObject* MyAsset_Default;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (GetAssetFilter = "IsShouldFilterAsset"))
	UObject* MyAsset_GetAssetFilter;
public:
	UFUNCTION()
	bool IsShouldFilterAsset(const FAssetData& AssetData)
	{
		return !AssetData.IsInstanceOf<UDataAsset>();
	}
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥è§åˆ°ï¼ŒMyAsset_GetAssetFilterè¿›è¡Œè¿‡æ»¤ååªå…è®¸DataAssetç±»å‹çš„èµ„äº§ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Asset\GetAssetFilter\Untitled.png)

## åŸç†ï¼š

åœ¨SPropertyEditorAssetï¼ˆå¯¹åº”UObjectç±»å‹å±æ€§ï¼‰ä¸­æœ‰åˆ¤æ–­GetAssetFilterçš„metaï¼Œå¾—åˆ°å‡½æ•°å¹¶é™„åŠ åˆ°èµ„äº§æ’é™¤çš„å›è°ƒé‡Œå»ã€‚

```cpp
void SPropertyEditorAsset::Construct(const FArguments& InArgs, const TSharedPtr<FPropertyEditor>& InPropertyEditor)
{
	if (Property && Property->GetOwnerProperty()->HasMetaData("GetAssetFilter"))
{
	// Add MetaData asset filter
	const FString GetAssetFilterFunctionName = Property->GetOwnerProperty()->GetMetaData("GetAssetFilter");
	if (!GetAssetFilterFunctionName.IsEmpty())
	{
		TArray<UObject*> ObjectList;
		if (PropertyEditor.IsValid())
		{
			PropertyEditor->GetPropertyHandle()->GetOuterObjects(ObjectList);
		}
		else if (PropertyHandle.IsValid())
		{
			PropertyHandle->GetOuterObjects(ObjectList);
		}
		for (UObject* Object : ObjectList)
		{
			const UFunction* GetAssetFilterFunction = Object ? Object->FindFunction(*GetAssetFilterFunctionName) : nullptr;
			if (GetAssetFilterFunction)
			{
				AppendOnShouldFilterAssetCallback(FOnShouldFilterAsset::CreateUFunction(Object, GetAssetFilterFunction->GetFName()));
			}
		}
	}
}
}
```


ï»¿# RequiredAssetDataTags

- **åŠŸèƒ½æè¿°ï¼š** åœ¨UObject*å±æ€§ä¸ŠæŒ‡å®šTagsæ¥è¿›è¡Œè¿‡æ»¤ï¼Œå¿…é¡»æ‹¥æœ‰è¯¥Tagsæ‰å¯ä»¥è¢«é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Asset Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="a=bï¼Œc=dï¼Œe=f"
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [DisallowedAssetDataTags](../DisallowedAssetDataTags.md), [AssetRegistrySearchable](../../../Specifier/UPROPERTY/Asset/AssetRegistrySearchable/AssetRegistrySearchable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨UObject*å±æ€§ä¸ŠæŒ‡å®šTagsæ¥è¿›è¡Œè¿‡æ»¤ï¼Œå¿…é¡»æ‹¥æœ‰è¯¥Tagsæ‰å¯ä»¥è¢«é€‰æ‹©ã€‚

ç›¸å…³è”çš„å¯å‚è€ƒAssetRegistrySearchableæ ‡è¯†ç¬¦å’ŒGetAssetRegistryTags æ–¹æ³•ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyTableRow_Required :public FTableRowBase
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt = 123;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyTableRow_Disallowed :public FTableRowBase
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat = 123.f;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	UTexture2D* MyTexture;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_AssetDataTags :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object)
	TObjectPtr<UObject> MyAsset_Default;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object, meta = (RequiredAssetDataTags = "MyIdForSearch=MyId456"))
	TObjectPtr<UObject> MyAsset_RequiredAssetDataTags;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Object, meta = (DisallowedAssetDataTags = "MyOtherId=MyOtherId789"))
	TObjectPtr<UObject> MyAsset_DisallowedAssetDataTags;
public:
	UPROPERTY(EditAnywhere, Category = DataTable)
	TObjectPtr<class UDataTable> MyDataTable_Default;

	UPROPERTY(EditAnywhere, Category = DataTable, meta = (RequiredAssetDataTags = "RowStructure=/Script/Insider.MyTableRow_Required"))
	TObjectPtr<class UDataTable> MyDataTable_RequiredAssetDataTags;

	UPROPERTY(EditAnywhere, Category = DataTable, meta = (DisallowedAssetDataTags = "RowStructure=/Script/Insider.MyTableRow_Disallowed"))
	TObjectPtr<class UDataTable> MyDataTable_DisallowedAssetDataTags;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¦‚ä¸Šé¢ä»£ç æ‰€è§ï¼Œå®šä¹‰äº†ä¸¤ä¸ªä¸åŒç±»å‹çš„FTableRowBaseï¼Œå¹¶ä¸”ä¹Ÿåˆ›å»ºäº†ä¸¤ä¸ªDataTableã€‚åŒæ—¶ä¹Ÿæœ‰ä¸¤ä¸ªDataAssetï¼ˆAssetRegistrySearchableçš„ä¾‹å­é‡Œå®šä¹‰çš„ç»“æ„ï¼‰éƒ½æœ‰MyIdForSearchå’ŒMyOtherIdçš„Tagï¼Œä½†æ˜¯æœ‰ä¸åŒçš„å€¼ï¼Œä»¥æ­¤æ¥è¿›è¡ŒåŒºåˆ†ã€‚

- MyAsset_Defaultï¼Œå¯ä»¥ç­›é€‰å‡ºæ‰€æœ‰çš„å¯¹è±¡ï¼Œå›¾ä¸­ç¤ºä¾‹æœ‰730ä¸ªã€‚
- MyAsset_RequiredAssetDataTagsï¼Œå› ä¸ºåŠ äº†RequiredAssetDataTags ï¼Œåªæœ‰DA_MyPropertySearchç¬¦åˆï¼Œå› ä¸ºMyIdForSearch=MyId456ã€‚
- MyAsset_DisallowedAssetDataTagsï¼ŒæŠŠDA_MyPropertySearch_Disallowedè¿‡æ»¤æ‰äº†ï¼Œå› ä¸ºæˆ‘é…ç½®çš„MyOtherId=MyOtherId789ï¼Œå› æ­¤åªå‰©ä¸‹729ä¸ªã€‚
- å…³äºDataTableä¹Ÿæ˜¯åŒç†ã€‚MyDataTable_Defaultå¯ä»¥è·å–æ‰€æœ‰çš„DataTableï¼ˆæœ‰3ä¸ªï¼‰ï¼Œè€ŒMyDataTable_RequiredAssetDataTagsé™åˆ¶äº†RowStructureåªèƒ½æ˜¯FMyTableRow_Required ï¼ˆå› æ­¤åªèƒ½ç­›é€‰å‡ºä¸€ä¸ªï¼‰ã€‚MyDataTable_DisallowedAssetDataTagsæ’é™¤æ‰ä¸€ä¸ªRowStructureä¸ºFMyTableRow_Disallowed çš„ï¼Œå› æ­¤å°±å‰©ä¸‹2ä¸ªã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Asset\RequiredAssetDataTags\Untitled.png)

## æºç ä¸­ä¾‹å­ï¼š

```cpp
	UPROPERTY(Category="StateTree", EditAnywhere, meta=(RequiredAssetDataTags="Schema=/Script/MassAIBehavior.MassStateTreeSchema"))
	TObjectPtr<UStateTree> StateTree;
	
	UPROPERTY(EditAnywhere, Category=Appearance, meta = (RequiredAssetDataTags = "RowStructure=/Script/UMG.RichImageRow"))
	TObjectPtr<class UDataTable> ImageSet;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Compositing, meta = (AllowPrivateAccess, RequiredAssetDataTags = "IsSourceValid=True"), Setter = SetCompositeTexture, Getter = GetCompositeTexture)
	TObjectPtr<class UTexture> CompositeTexture;
```

## åŸç†:

åœ¨UObject*å±æ€§ä¸ŠRequiredAssetDataTagså’ŒDisallowedAssetDataTagsçš„é…ç½®ï¼Œä¼šåœ¨è¿™ä¸ªå±æ€§çš„ç¼–è¾‘å™¨ï¼ˆSPropertyEditorAssetï¼‰åˆå§‹åŒ–çš„æ—¶å€™è§£ææå–åˆ°å…¶æˆå‘˜å˜é‡RequiredAssetDataTagså’ŒDisallowedAssetDataTagsé‡Œï¼Œæœ¬è´¨å°±æ˜¯ä¸ªé”®å€¼å¯¹ã€‚è€Œåç»­åœ¨è¿›è¡ŒAssetè¿‡æ»¤çš„æ—¶å€™ï¼ˆIsAssetFilteredçš„è°ƒç”¨ï¼‰ï¼Œå°±ä¼šå¼€å§‹æŠŠFAssetDataé‡Œçš„Tagså»åŒ¹é…è¯¥å±æ€§çš„Tagséœ€æ±‚ã€‚Disallowedçš„å‡ºç°å°±æ’é™¤æ‰ï¼ŒRequiredçš„å¿…é¡»æ‹¥æœ‰æ‰ä¸ä¼šè¢«è¿‡æ»¤ï¼Œæœ€ç»ˆå®ç°äº†è¿‡æ»¤æ•ˆæœã€‚

å…³äºFAssetDataé‡Œçš„Tagsï¼Œå¯ä»¥å‚è€ƒAssetRegistrySearchableæ ‡è¯†ç¬¦å’ŒGetAssetRegistryTags æ–¹æ³•çš„è°ƒç”¨å’Œå®ç°ï¼Œç®€å•æ¥è¯´å°±æ˜¯åœ¨å¯¹è±¡ä¸Šä¼šæœ‰ä¸ªæ–¹å¼ä¸»åŠ¨æä¾›Tagsç»™AssetRegistryã€‚

å…³äºDataTableä¸ºä½•å¯ä»¥é€šè¿‡RowStructureè¿‡æ»¤ï¼Œé€šè¿‡æŸ¥çœ‹DataTableé‡Œçš„GetAssetRegistryTagsæ–¹æ³•å°±å¯ä»¥çŸ¥é“å®ƒä¸»åŠ¨æä¾›äº†RowStructureçš„Tagsæ³¨å†Œã€‚

```cpp
FAssetDataTagMapBase=TSortedMap<FName, FString, FDefaultAllocator, FNameFastLess>; 

SPropertyEditorAsset::
	/** Tags (and eventually values) that can NOT be used with this property */
	TSharedPtr<FAssetDataTagMap> DisallowedAssetDataTags;

	**/** Tags and values that must be present for an asset to be used with this property */
	TSharedPtr<FAssetDataTagMap> RequiredAssetDataTags;
	
void SPropertyEditorAsset::InitializeAssetDataTags(const FProperty* Property)
{
	if (Property == nullptr)
{
	return;
}

const FProperty* MetadataProperty = GetActualMetadataProperty(Property);
const FString DisallowedAssetDataTagsFilterString = MetadataProperty->GetMetaData("DisallowedAssetDataTags");
if (!DisallowedAssetDataTagsFilterString.IsEmpty())
{
	TArray<FString> DisallowedAssetDataTagsAndValues;
	DisallowedAssetDataTagsFilterString.ParseIntoArray(DisallowedAssetDataTagsAndValues, TEXT(","), true);

	for (const FString& TagAndOptionalValueString : DisallowedAssetDataTagsAndValues)
	{
		TArray<FString> TagAndOptionalValue;
		TagAndOptionalValueString.ParseIntoArray(TagAndOptionalValue, TEXT("="), true);
		size_t NumStrings = TagAndOptionalValue.Num();
		check((NumStrings == 1) || (NumStrings == 2)); // there should be a single '=' within a tag/value pair

		if (!DisallowedAssetDataTags.IsValid())
		{
			DisallowedAssetDataTags = MakeShared<FAssetDataTagMap>();
		}
		DisallowedAssetDataTags->Add(FName(*TagAndOptionalValue[0]), (NumStrings > 1) ? TagAndOptionalValue[1] : FString());
	}
}

const FString RequiredAssetDataTagsFilterString = MetadataProperty->GetMetaData("RequiredAssetDataTags");
if (!RequiredAssetDataTagsFilterString.IsEmpty())
{
	TArray<FString> RequiredAssetDataTagsAndValues;
	RequiredAssetDataTagsFilterString.ParseIntoArray(RequiredAssetDataTagsAndValues, TEXT(","), true);

	for (const FString& TagAndOptionalValueString : RequiredAssetDataTagsAndValues)
	{
		TArray<FString> TagAndOptionalValue;
		TagAndOptionalValueString.ParseIntoArray(TagAndOptionalValue, TEXT("="), true);
		size_t NumStrings = TagAndOptionalValue.Num();
		check((NumStrings == 1) || (NumStrings == 2)); // there should be a single '=' within a tag/value pair

		if (!RequiredAssetDataTags.IsValid())
		{
			RequiredAssetDataTags = MakeShared<FAssetDataTagMap>();
		}
		RequiredAssetDataTags->Add(FName(*TagAndOptionalValue[0]), (NumStrings > 1) ? TagAndOptionalValue[1] : FString());
	}
}
}

bool SPropertyEditorAsset::IsAssetFiltered(const FAssetData& InAssetData)
{
//åˆ¤æ–­åªè¦åŒ…å«å°±ä¸ç¬¦åˆ
	if (DisallowedAssetDataTags.IsValid())
	{
		for (const auto& DisallowedTagAndValue : *DisallowedAssetDataTags.Get())
		{
			if (InAssetData.TagsAndValues.ContainsKeyValue(DisallowedTagAndValue.Key, DisallowedTagAndValue.Value))
			{
				return true;
			}
		}
	}
	//åˆ¤æ–­å¿…é¡»åŒ…å«æ‰ä¸ä¼šè¢«è¿‡æ»¤æ‰
	if (RequiredAssetDataTags.IsValid())
	{
		for (const auto& RequiredTagAndValue : *RequiredAssetDataTags.Get())
		{
			if (!InAssetData.TagsAndValues.ContainsKeyValue(RequiredTagAndValue.Key, RequiredTagAndValue.Value))
			{
				// For backwards compatibility compare against short name version of the tag value.
				if (!FPackageName::IsShortPackageName(RequiredTagAndValue.Value) &&
					InAssetData.TagsAndValues.ContainsKeyValue(RequiredTagAndValue.Key, FPackageName::ObjectPathToObjectName(RequiredTagAndValue.Value)))
				{
					continue;
				}
				return true;
			}
		}
	}
	return false;
}

void UDataTable::GetAssetRegistryTags(FAssetRegistryTagsContext Context) const
{
	if (AssetImportData)
	{
		Context.AddTag( FAssetRegistryTag(SourceFileTagName(), AssetImportData->GetSourceData().ToJson(), FAssetRegistryTag::TT_Hidden) );
	}

	// Add the row structure tag
	{
		static const FName RowStructureTag = "RowStructure";
		Context.AddTag( FAssetRegistryTag(RowStructureTag, GetRowStructPathName().ToString(), FAssetRegistryTag::TT_Alphabetical) );
	}

	Super::GetAssetRegistryTags(Context);
}

```


ï»¿# AdvancedDisplay

- **åŠŸèƒ½æè¿°ï¼š** æŠŠå‡½æ•°çš„ä¸€äº›å‚æ•°æŠ˜å èµ·æ¥ä¸æ˜¾ç¤ºï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å¼€ä¸‹æ‹‰ç®­å¤´æ¥å±•å¼€ç¼–è¾‘ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŠŠå‡½æ•°çš„ä¸€äº›å‚æ•°æŠ˜å èµ·æ¥ä¸æ˜¾ç¤ºï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å¼€ä¸‹æ‹‰ç®­å¤´æ¥å±•å¼€ç¼–è¾‘ã€‚

AdvancedDisplayåŒæ—¶æ”¯æŒä¸¤ç§æ ¼å¼ï¼Œä¸€æ˜¯ç”¨"Parameter1, Parameter2, ..â€æ¥æ˜¾å¼çš„æŒ‡å®šéœ€è¦æŠ˜å çš„å‚æ•°åå­—ï¼Œé€‚ç”¨äºè¦æŠ˜å çš„å‚æ•°ä¸è¿ç»­æˆ–è€…å¤„åœ¨å‡½æ•°å‚æ•°åˆ—è¡¨ä¸­ä¸­å¤®çš„æƒ…å†µä¸‹ã€‚äºŒæ˜¯â€Nâ€æŒ‡å®šä¸€ä¸ªæ•°å­—åºå·ï¼Œç¬¬Nä¹‹åçš„æ‰€æœ‰å‚æ•°å°†æ˜¾ç¤ºä¸ºé«˜çº§å¼•è„šã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (AdvancedDisplay = "2"))
	static int32 MyFunc_HasAdvancedDisplay_WithOrder(int32 First, int32 Second, int32 Third, int32 Fourth, int32 Fifth) { return 0; }
	UFUNCTION(BlueprintCallable, meta = (AdvancedDisplay = "Fourth,Fifth"))
	static int32 MyFunc_HasAdvancedDisplay_WithName(int32 First, int32 Second, int32 Third, int32 Fourth, int32 Fifth) { return 0; }

	UFUNCTION(BlueprintCallable, meta = ())
	static int32 MyFunc_NoAdvancedDisplay(int32 First, int32 Second, int32 Third, int32 Fourth, int32 Fifth) { return 0; }
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\AdvancedDisplay\Untitled.png)

æºç ä¸­å…¸å‹çš„ä¾‹å­æ˜¯PrintStringï¼Œåœ¨ç¬¬2ä¸ªå‚æ•°åçš„å…¶ä»–å‚æ•°å°±éƒ½æŠ˜å äº†èµ·æ¥ã€‚

```cpp
UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", CallableWithoutWorldContext, Keywords = "log print", AdvancedDisplay = "2", DevelopmentOnly), Category="Development")
static ENGINE_API void PrintString(const UObject* WorldContextObject, const FString& InString = FString(TEXT("Hello")), bool bPrintToScreen = true, bool bPrintToLog = true, FLinearColor TextColor = FLinearColor(0.0f, 0.66f, 1.0f), float Duration = 2.f, const FName Key = NAME_None);
```

## åŸç†ï¼š

AdvancedDisplayä½¿å¾—è¢«æ ‡æ³¨çš„å‡½æ•°å‚æ•°å¢åŠ EPropertyFlags.AdvancedDisplayçš„æ ‡è®°ï¼Œä»è€Œä½¿å¾—å…¶è¢«æŠ˜å èµ·æ¥ã€‚è¿™ä¸ªé€»è¾‘æ˜¯åœ¨UHTå¯¹å‡½æ•°è¿›è¡Œè§£æçš„æ—¶å€™è®¾ç½®çš„ã€‚

```cpp
//æ”¯æŒå‚æ•°åå­—å’Œæ•°å­—åºå·ä¸¤ç§æ¨¡å¼
if (_metaData.TryGetValue(UhtNames.AdvancedDisplay, out string? foundString))
{
	_parameterNames = foundString.ToString().Split(',', StringSplitOptions.RemoveEmptyEntries);
	for (int index = 0, endIndex = _parameterNames.Length; index < endIndex; ++index)
	{
		_parameterNames[index] = _parameterNames[index].Trim();
	}
	if (_parameterNames.Length == 1)
	{
		_bUseNumber = Int32.TryParse(_parameterNames[0], out _numberLeaveUnmarked);
	}
}

//è®¾ç½®EPropertyFlags.AdvancedDisplay
		private static void UhtFunctionParser::ParseParameterList(UhtParsingScope topScope, UhtPropertyParseOptions options)
		{
				UhtAdvancedDisplayParameterHandler advancedDisplay = new(topScope.ScopeType.MetaData);

				topScope.TokenReader.RequireList(')', ',', false, () =>
				{
					topScope.HeaderParser.GetCachedPropertyParser().Parse(topScope, disallowFlags, options, propertyCategory,
						(UhtParsingScope topScope, UhtProperty property, ref UhtToken nameToken, UhtLayoutMacroType layoutMacroType) =>
						{
							property.PropertyFlags |= EPropertyFlags.Parm;
							if (advancedDisplay.CanMarkMore() && advancedDisplay.ShouldMarkParameter(property.EngineName))
							{
								property.PropertyFlags |= EPropertyFlags.AdvancedDisplay;
							}
		}

```


ï»¿# AllowPrivateAccess

- **åŠŸèƒ½æè¿°ï¼š** å…è®¸ä¸€ä¸ªåœ¨C++ä¸­privateçš„å±æ€§ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­è®¿é—®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [BlueprintProtected](../BlueprintProtected/BlueprintProtected.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å…è®¸ä¸€ä¸ªåœ¨C++ä¸­privateçš„å±æ€§ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­è®¿é—®ã€‚

AllowPrivateAccessçš„æ„ä¹‰æ˜¯å…è®¸è¿™ä¸ªå±æ€§åœ¨C++æ˜¯privateçš„ï¼Œä¸å…è®¸C++å­ç±»è®¿é—®ï¼Œä½†åˆå…è®¸å…¶æš´éœ²åˆ°è“å›¾ä¸­è®¿é—®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite)
	int32 MyNativeInt_NativePublic;
private:
	//CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	//error : BlueprintReadWrite should not be used on private members
	UPROPERTY()
	int32 MyNativeInt_NativePrivate;

	//(AllowPrivateAccess = TRUE, Category = MyFunction_Access, ModuleRelativePath = Function/MyFunction_Access.h)
	//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	UPROPERTY(BlueprintReadWrite, meta = (AllowPrivateAccess = true))
	int32 MyNativeInt_NativePrivate_AllowPrivateAccess;
```

åœ¨MyNativeInt_NativePrivateä¸Šå¦‚æœå°è¯•åŠ ä¸ŠBlueprintReadWriteæˆ–BlueprintReadOnlyéƒ½ä¼šè§¦å‘UHTç¼–è¯‘æŠ¥é”™ã€‚

## è“å›¾é‡Œçš„æ•ˆæœï¼š

é»˜è®¤æƒ…å†µä¸‹MyNativeInt_NativePrivate_AllowPrivateAccessåœ¨è“å›¾é‡Œçš„è®¿é—®æƒé™å’ŒMyNativeInt_NativePublicä¸€è‡´ã€‚

å¦‚æœè¯»è€…æƒ³è¦ä¿®æ”¹æ”¹å±æ€§åœ¨è“å›¾ä¸­çš„è®¿é—®æƒé™ï¼Œåˆ™å¯ä»¥é…åˆåŠ ä¸ŠBlueprintProtectedå’ŒBlueprintPrivateã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\AllowPrivateAccess\Untitled.png)

## åŸç†ï¼š

UHTåœ¨è¯†åˆ«å±æ€§çš„BlueprintReadWriteæˆ–BlueprintReadOnlyæ ‡è¯†ç¬¦çš„æ—¶å€™ï¼Œä¼šåŒæ—¶æ£€æµ‹æ˜¯å¦æœ‰AllowPrivateAccessï¼Œæ²¡æœ‰çš„è¯ä¼šè§¦å‘æŠ¥é”™ã€‚

å› æ­¤AllowPrivateAccessçš„æ„ä¹‰å…¶å®åªæ˜¯åœ¨é˜»æ­¢UHTçš„æŠ¥é”™ï¼Œè¿™å±‚æ£€æµ‹æŠ¥é”™è¿‡äº†ä¹‹åï¼Œå±æ€§ä¸Šçš„BlueprintReadWriteæˆ–BlueprintReadOnlyå°±ä¼šè¢«è¯†åˆ«å¹¶å‘æŒ¥ä½œç”¨ï¼Œä»è€Œå¯ä»¥åœ¨è“å›¾ä¸­è®¿é—®ã€‚

```cpp
	private static void BlueprintReadWriteSpecifier(UhtSpecifierContext specifierContext)
	{
			bool allowPrivateAccess = context.MetaData.TryGetValue(UhtNames.AllowPrivateAccess, out string? privateAccessMD) && !privateAccessMD.Equals("false", StringComparison.OrdinalIgnoreCase);
			if (specifierContext.AccessSpecifier == UhtAccessSpecifier.Private && !allowPrivateAccess)
			{
				context.MessageSite.LogError("BlueprintReadWrite should not be used on private members");
			}
	}
	
	private static void BlueprintReadOnlySpecifier(UhtSpecifierContext specifierContext)
	{
			bool allowPrivateAccess = context.MetaData.TryGetValue(UhtNames.AllowPrivateAccess, out string? privateAccessMD) && !privateAccessMD.Equals("false", StringComparison.OrdinalIgnoreCase);
			if (specifierContext.AccessSpecifier == UhtAccessSpecifier.Private && !allowPrivateAccess)
			{
				context.MessageSite.LogError("BlueprintReadOnly should not be used on private members");
			}
	}

```


ï»¿# BlueprintAutocast

- **åŠŸèƒ½æè¿°ï¼š** å‘Šè¯‰è“å›¾ç³»ç»Ÿè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ”¯æŒä»Aç±»å‹åˆ°Bç±»å‹çš„è‡ªåŠ¨è½¬æ¢ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å‘Šè¯‰è“å›¾ç³»ç»Ÿè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ”¯æŒä»Aç±»å‹åˆ°Bç±»å‹çš„è‡ªåŠ¨è½¬æ¢ã€‚

æ‰€è°“è‡ªåŠ¨è½¬æ¢æŒ‡çš„æ˜¯ä»Aç±»å‹çš„Pinæ‹–æ‹‰åˆ°Bç±»å‹çš„Pinæ—¶ï¼Œè“å›¾ä¼šåœ¨å…¶ä¸­è‡ªåŠ¨çš„ç”Ÿæˆç±»å‹è½¬æ¢èŠ‚ç‚¹ã€‚

è¿™ç§è½¬æ¢å‡½æ•°å¿…é¡»æ˜¯BlueprintPureï¼Œå› ä¸ºå…¶å®æ˜¯è¢«åŠ¨è°ƒç”¨çš„ï¼Œä¸å¸¦ä¸»åŠ¨æ‰§è¡ŒèŠ‚ç‚¹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FAutoCastFrom
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 X = 0;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Y = 0;
};

USTRUCT(BlueprintType)
struct FAutoCastTo
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Sum = 0;
};

USTRUCT(BlueprintType)
struct FNoAutoCastTo
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Sum = 0;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_AutoCast :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, meta = (BlueprintAutocast))
	static FAutoCastTo Conv_MyTestAutoCast(const FAutoCastFrom& InValue);
};

//è½¬æ¢å‡½æ•°ä¹Ÿç»å¸¸é…åˆCompactNodeTitleä½¿ç”¨ã€‚
UFUNCTION(BlueprintPure, Category="Widget", meta = (CompactNodeTitle = "->", BlueprintAutocast))
static UMG_API FInputEvent GetInputEventFromKeyEvent(const FKeyEvent& Event);
```

## ç¤ºä¾‹æ•ˆæœï¼š

æ”¯æŒè‡ªåŠ¨è½¬æ¢çš„FAutoCastToå°±åœ¨æ‹–æ‹‰è¿çº¿çš„æ—¶å€™å°±ä¼šè‡ªåŠ¨ç”ŸæˆèŠ‚ç‚¹ï¼Œè€Œæ²¡æœ‰è‡ªåŠ¨è½¬æ¢å‡½æ•°çš„FNoAutoCastToå°±ä¼šäº§ç”ŸæŠ¥é”™ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintAutocast\Untitled.png)

## åŸç†ä»£ç ï¼š

ä»è¿™å¯ä»¥çœ‹å‡ºï¼Œè¯¥å‡½æ•°å¿…é¡»æ˜¯staticï¼ŒC++ä¸­çš„Publicå‡½æ•°ï¼Œæ ‡ä¸ŠBlueprintPureï¼Œæ‹¥æœ‰è¿”å›å€¼ï¼Œä¸”æœ‰ä¸€ä¸ªè¾“å…¥å‚æ•°ã€‚å¼•æ“é‡Œç±»å‹çš„è‡ªåŠ¨è½¬æ¢å…³ç³»æ˜¯é FAutocastFunctionMapæ¥ç»´æŠ¤çš„ã€‚

```cpp
static bool IsAutocastFunction(const UFunction* Function)
{
	const FName BlueprintAutocast(TEXT("BlueprintAutocast"));
	return Function
		&& Function->HasMetaData(BlueprintAutocast)
		&& Function->HasAllFunctionFlags(FUNC_Static | FUNC_Native | FUNC_Public | FUNC_BlueprintPure)
		&& Function->GetReturnProperty()
		&& GetFirstInputProperty(Function);
}
```


ï»¿# BlueprintGetter

- **åŠŸèƒ½æè¿°ï¼š** é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„getå‡½æ•°æ¥è¯»å–ã€‚
  å¦‚æœæ²¡æœ‰è®¾ç½®BlueprintSetteræˆ–BlueprintReadWrite, åˆ™ä¼šé»˜è®¤è®¾ç½®BlueprintReadOnly.

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[BlueprintGetter](../../Specifier/UFUNCTION/Blueprint/BlueprintGetter.md)

  UPROPERTYï¼š[BlueprintGetter](../../Specifier/UPROPERTY/Blueprint/BlueprintGetter/BlueprintGetter.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# BlueprintInternalUseOnly

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜è¯¥å…ƒç´ æ˜¯ä½œä¸ºè“å›¾ç³»ç»Ÿçš„å†…éƒ¨è°ƒç”¨æˆ–ä½¿ç”¨ï¼Œä¸æš´éœ²å‡ºæ¥åœ¨ç”¨æˆ·å±‚é¢ç›´æ¥å®šä¹‰æˆ–ä½¿ç”¨ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, USTRUCT

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  Metaï¼š[BlueprintType](BlueprintType.md), [BlueprintInternalUseOnlyHierarchical](BlueprintInternalUseOnlyHierarchical.md)

  UFUNCTIONï¼š[BlueprintInternalUseOnly](../../Specifier/UFUNCTION/UHT/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md)

  USTRUCTï¼š[BlueprintInternalUseOnly](../../Specifier/USTRUCT/Blueprint/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¹Ÿå¯ä»¥ç”¨åœ¨USTRUCTä¸Šï¼Œæ ‡æ˜è¯¥ç»“æ„ä¸å¯ç”¨æ¥å®šä¹‰æ–°BPå˜é‡ï¼Œä½†å¯ä½œä¸ºåˆ«çš„ç±»çš„æˆå‘˜å˜é‡æš´éœ²å’Œå˜é‡ä¼ é€’ã€‚

ç”¨åœ¨UFUNCTIONä¸Šæ—¶ï¼šæ­¤å‡½æ•°æ˜¯ä¸€ä¸ªå†…éƒ¨å®ç°ç»†èŠ‚ï¼Œç”¨äºå®ç°å¦ä¸€ä¸ªå‡½æ•°æˆ–èŠ‚ç‚¹ã€‚å…¶ä»æœªç›´æ¥åœ¨è“å›¾å›¾è¡¨ä¸­å…¬å¼€ã€‚


ï»¿# BlueprintInternalUseOnlyHierarchical

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜è¯¥ç»“æ„åŠå…¶å­ç±»éƒ½ä¸æš´éœ²ç»™ç”¨æˆ·å®šä¹‰å’Œä½¿ç”¨ï¼Œå‡åªèƒ½åœ¨è“å›¾ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨

- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  Metaï¼š[BlueprintInternalUseOnly](BlueprintInternalUseOnly.md), [BlueprintType](BlueprintType.md)

  USTRUCTï¼š[BlueprintInternalUseOnlyHierarchical ](../../Specifier/USTRUCT/Blueprint/BlueprintInternalUseOnlyHierarchical.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡æ˜ä¸€ä¸ªä¸å‘æœ€ç»ˆç”¨æˆ·å…¬å¼€çš„BlueprintTypeç±»å‹çš„ç»“æ„ä»¥åŠå…¶æ´¾ç”Ÿçš„ç»“æ„ã€‚


ï»¿# BlueprintPrivate

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°æˆ–å±æ€§åªèƒ½åœ¨æœ¬ç±»ä¸­è¢«è°ƒç”¨æˆ–è¯»å†™ï¼Œç±»ä¼¼C++ä¸­çš„privateçš„ä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [BlueprintProtected](../BlueprintProtected/BlueprintProtected.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨å‡½æ•°ç»†èŠ‚é¢æ¿ä¸Šå¯ä»¥è®¾ç½®å‡½æ•°çš„è®¿é—®æƒé™ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintPrivate\Untitled.png)

é€ æˆçš„ç»“æœå°±æ˜¯åœ¨å‡½æ•°ä¸Šå¢åŠ BlueprintPrivate=â€œtrueâ€

åœ¨ç»†èŠ‚é¢æ¿ä¸Šå¯ä»¥è®¾ç½®å±æ€§çš„

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintPrivate\Untitled%201.png)

ç»“æœä¹Ÿæ˜¯åœ¨å±æ€§ä¸Šå¢åŠ BlueprintPrivate=â€œtrueâ€


ï»¿# BlueprintProtected

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°æˆ–å±æ€§åªèƒ½åœ¨æœ¬ç±»ä»¥åŠå­ç±»ä¸­è¢«è°ƒç”¨æˆ–è¯»å†™ï¼Œç±»ä¼¼C++ä¸­çš„protectedä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [BlueprintPrivate](../BlueprintPrivate/BlueprintPrivate.md), [AllowPrivateAccess](../AllowPrivateAccess/AllowPrivateAccess.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½œç”¨åœ¨å‡½æ•°ä¸Šï¼š

æ ‡è®°è¯¥å‡½æ•°åªèƒ½åœ¨æœ¬ç±»ä»¥åŠå­ç±»ä¸­è¢«è°ƒç”¨ï¼Œç±»ä¼¼C++ä¸­çš„protectedå‡½æ•°çš„ä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè°ƒç”¨ã€‚

ä½œç”¨åœ¨å±æ€§ä¸Šæ—¶ï¼Œæ ‡æ˜è¯¥å±æ€§åªèƒ½åœ¨æœ¬ç±»æˆ–æ´¾ç”Ÿç±»é‡Œè¿›è¡Œè¯»å†™ï¼Œä½†ä¸èƒ½åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚

æŒ‡å®šè¯¥å‡½æ•°æˆ–å±æ€§åªèƒ½åœ¨æœ¬ç±»ä»¥åŠå­ç±»ä¸­è¢«è°ƒç”¨æˆ–è¯»å†™ï¼Œç±»ä¼¼C++ä¸­çš„protectedå‡½æ•°çš„ä½œç”¨åŸŸé™åˆ¶ã€‚ä¸å¯åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Access :public AActor
{
public:
	GENERATED_BODY()
public:
	//(BlueprintProtected = true, ModuleRelativePath = Function/MyFunction_Access.h)
	//FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable, meta = (BlueprintProtected = "true"))
	void MyNative_HasProtected() {}

	//(BlueprintPrivate = true, ModuleRelativePath = Function/MyFunction_Access.h)
	//FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable, meta = (BlueprintPrivate = "true"))
	void MyNative_HasPrivate() {}
public:
	//FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable)
	void MyNative_NativePublic() {}
protected:
	//FUNC_Final | FUNC_Native | FUNC_Protected | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable)
	void MyNative_NativeProtected() {}
private:
	//FUNC_Final | FUNC_Native | FUNC_Private | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable)
	void MyNative_NativePrivate() {}
};

```

## æµ‹è¯•æ•ˆæœï¼š

è“å›¾ä¸­çš„å­ç±»ï¼ˆBPA_Access_Baseç»§æ‰¿è‡ªAMyFunction_Access ï¼‰æ•ˆæœï¼š

å¯è§BlueprintProtectedå¯ä»¥è¢«å­ç±»è°ƒç”¨ï¼Œä½†æ˜¯BlueprintPrivateåªèƒ½åœ¨æœ¬ç±»ï¼ˆC++ç±»ä¸­å®šä¹‰çš„åªèƒ½åœ¨C++ä¸­è°ƒç”¨ï¼Œè“å›¾ä¸­å®šä¹‰çš„åªèƒ½åœ¨è“å›¾æœ¬ç±»ä¸­è°ƒç”¨ï¼‰ã€‚è€Œåœ¨C++ä¸­ç”¨protectedæˆ–privateä¿®é¥°çš„å‡½æ•°ä¼šç›¸åº”çš„å¢åŠ FUNC_Protectedå’ŒFUNC_Privateï¼Œä½†æ˜¯å®é™…ä¸Šå¹¶ä¸ä¼šå‘ç”Ÿä½œç”¨ã€‚å› ä¸ºæœºåˆ¶çš„è®¾è®¡ç›®çš„å°±æ˜¯å¦‚æ­¤ï¼ˆè¯¦è§åæ–‡è§£é‡Šï¼‰ã€‚

è€Œåœ¨BPA_Access_Baseä¸­ç›´æ¥å®šä¹‰çš„MyBPProtectedå’ŒMyBPPrivateé€šè¿‡åœ¨å‡½æ•°ç»†èŠ‚é¢æ¿ä¸Šç›´æ¥è®¾ç½®AccessSpecifierï¼Œå¯ä»¥åœ¨æœ¬ç±»éƒ½å¯ä»¥è°ƒç”¨ï¼Œä½†æ˜¯MyBPPrivateåœ¨æ›´åŠ çš„è“å›¾å­ç±»æ— æ³•è¢«è°ƒç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled.png)

è“å›¾ä¸­çš„å­ç±»ï¼ˆBPA_Access_Childç»§æ‰¿è‡ªBPA_Access_Baseï¼‰æ•ˆæœï¼š

å¯è§MyNativeå‡½æ•°çš„è®¿é—®ä¸€æ ·ã€‚è€ŒMyBPPrivateåˆ™ä¸èƒ½è¢«è°ƒç”¨äº†ï¼Œè¿™å’Œæˆ‘ä»¬é¢„æƒ³çš„è§„åˆ™ä¸€æ ·ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled%201.png)

è€Œåœ¨å¤–éƒ¨ç±»ä¸­(BPA_Access_Otherï¼Œç»§æ‰¿è‡ªActor)ï¼Œé€šè¿‡BPA_Access_Baseæˆ–BPA_Access_Childå¯¹è±¡å®ä¾‹è®¿é—®å‡½æ•°çš„æ—¶å€™ï¼Œå‘ç°å¸¦æœ‰BlueprintProtectedå’ŒBlueprintPrivateéƒ½ä¸èƒ½è¢«è°ƒç”¨ã€‚BPçš„å‡½æ•°ä¹Ÿåªæœ‰AccessSpecifierä¸ºé»˜è®¤Publicçš„å¯ä»¥è°ƒç”¨ã€‚è¿™ä¸ªè§„åˆ™ä¹Ÿå¾ˆç¬¦åˆé¢„æœŸã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled%202.png)

## åŸç†ï¼š

åœ¨è“å›¾å³é”®ä¸Šæ˜¯å¦å¯ä»¥é€‰æ‹©è¯¥å‡½æ•°çš„è¿‡æ»¤é€»è¾‘ï¼š

å¦‚æœæ˜¯staticå‡½æ•°ï¼Œåˆ™æ€»æ˜¯å¯ä»¥ã€‚å¦åˆ™å¿…é¡»æ²¡æœ‰BlueprintProtectedæˆ–BlueprintPrivateæ‰å¯ä»¥æ˜¯Publicå¯ä»¥è¢«é€‰æ‹©å‡ºæ¥çš„ã€‚

å¦‚æœæ˜¯Privateï¼Œåˆ™å¤–éƒ¨ç±»å¿…é¡»æ˜¯å®šä¹‰çš„ç±»æœ¬èº«ã€‚

å¦‚æœæ˜¯Protectedï¼Œåˆ™å¤–éƒ¨ç±»åªéœ€è¦æ˜¯å®šä¹‰çš„ç±»æˆ–å­ç±»ã€‚

```cpp
static bool BlueprintActionFilterImpl::IsFieldInaccessible(FBlueprintActionFilter const& Filter, FBlueprintActionInfo& BlueprintAction)
{
		bool const bIsProtected = Field.HasMetaData(FBlueprintMetadata::MD_Protected);
		bool const bIsPrivate   = Field.HasMetaData(FBlueprintMetadata::MD_Private);
		bool const bIsPublic    = !bIsPrivate && !bIsProtected;

		if( !bIsPublic )
		{
			UClass const* ActionOwner = BlueprintAction.GetOwnerClass();
			for (UBlueprint const* Blueprint : FilterContext.Blueprints)
			{
				UClass const* BpClass = GetAuthoritativeBlueprintClass(Blueprint);
				if (!ensureMsgf(BpClass != nullptr
					, TEXT("Unable to resolve IsFieldInaccessible() - Blueprint (%s) missing an authoratative class (skel: %s, generated: %s, parent: %s)")
					, *Blueprint->GetName()
					, Blueprint->SkeletonGeneratedClass ? *Blueprint->SkeletonGeneratedClass->GetName() : TEXT("[NULL]")
					, Blueprint->GeneratedClass ? *Blueprint->GeneratedClass->GetName() : TEXT("[NULL]")
					, Blueprint->ParentClass ? *Blueprint->ParentClass->GetName() : TEXT("[NULL]")))
				{
					continue;
				}
			
				// private functions are only accessible from the class they belong to
				if (bIsPrivate && !IsClassOfType(BpClass, ActionOwner, /*bNeedsExactMatch =*/true))
				{
					bIsFilteredOut = true;
					break;
				}
				else if (bIsProtected && !IsClassOfType(BpClass, ActionOwner))
				{
					bIsFilteredOut = true;
					break;
				}
			}
		}
}

bool UEdGraphSchema_K2::ClassHasBlueprintAccessibleMembers(const UClass* InClass) const
{
	// @TODO Don't show other blueprints yet...
	UBlueprint* ClassBlueprint = UBlueprint::GetBlueprintFromClass(InClass);
	if (!InClass->HasAnyClassFlags(CLASS_Deprecated | CLASS_NewerVersionExists) && (ClassBlueprint == NULL))
	{
		// Find functions
		for (TFieldIterator<UFunction> FunctionIt(InClass, EFieldIteratorFlags::IncludeSuper); FunctionIt; ++FunctionIt)
		{
			UFunction* Function = *FunctionIt;
			const bool bIsBlueprintProtected = Function->GetBoolMetaData(FBlueprintMetadata::MD_Protected);
			const bool bHidden = FObjectEditorUtils::IsFunctionHiddenFromClass(Function, InClass);
			if (UEdGraphSchema_K2::CanUserKismetCallFunction(Function) && !bIsBlueprintProtected && !bHidden)
			{
				return true;
			}
		}

		// Find vars
		for (TFieldIterator<FProperty> PropertyIt(InClass, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
		{
			FProperty* Property = *PropertyIt;
			if (CanUserKismetAccessVariable(Property, InClass, CannotBeDelegate))
			{
				return true;
			}
		}
	}

	return false;
}
```

åœ¨BPä¸­å®šä¹‰çš„å‡½æ•°å¦‚æœé€šè¿‡AccessSpecifierè®¾ç½®ä¸ºProtectedæˆ–Privateï¼Œä¹Ÿä¼šç›¸åº”æŠŠè¯¥å‡½æ•°åŠ ä¸ŠFUNC_Protectedæˆ–FUNC_Privateã€‚ä»è€Œå®é™…ä¸Šå½±å“è¯¥å‡½æ•°çš„ä½œç”¨åŸŸã€‚ä½†æºç ä¸­å¾ˆå¤šåˆ¤æ–­ä¼šå…ˆåˆ¤æ–­æ˜¯å¦Nativeå‡½æ•°ï¼Œå¦‚æœæ˜¯å°±ä¸ç»§ç»­åšé™åˆ¶ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ç†è§£è¿™æ˜¯UEæœºåˆ¶çš„æœ‰æ„ä¸ºä¹‹ï¼Œæ•…æ„ä¸æŠŠC++é‡Œçš„protectedå’Œprivateä½œç”¨åŸŸç®—è¿›å»ï¼Œè€Œè¦æ±‚ä½ å¿…é¡»è‡ªå·±æ‰‹åŠ¨æ˜¾å¼çš„å†™ä¸ŠBlueprintProtectedæˆ–BlueprintPrivateï¼Œè¿™æ ·é¿å…æœ‰æ—¶çš„æ¨¡ç³Šä¸æ¸…ã€‚

```cpp
bool UEdGraphSchema_K2::CanFunctionBeUsedInGraph(const UClass* InClass, const UFunction* InFunction, const UEdGraph* InDestGraph, uint32 InAllowedFunctionTypes, bool bInCalledForEach, FText* OutReason) const
{
	const bool bIsNotNative = !FBlueprintEditorUtils::IsNativeSignature(InFunction);
	if(bIsNotNative)
	{
		// Blueprint functions visibility flags can be enforced in blueprints - native functions
		// are often using these flags to only hide functionality from other native functions:
		const bool bIsProtected = (InFunction->FunctionFlags & FUNC_Protected) != 0;
}

bool UK2Node_CallFunction::IsActionFilteredOut(FBlueprintActionFilter const& Filter)
{
	bool bIsFilteredOut = false;
	for(UEdGraph* TargetGraph : Filter.Context.Graphs)
	{
		bIsFilteredOut |= !CanPasteHere(TargetGraph);
	}

	if(const UFunction* TargetFunction = GetTargetFunction())
	{
		const bool bIsProtected = (TargetFunction->FunctionFlags & FUNC_Protected) != 0;
		const bool bIsPrivate = (TargetFunction->FunctionFlags & FUNC_Private) != 0;
		const UClass* OwningClass = TargetFunction->GetOwnerClass();
		if( (bIsProtected || bIsPrivate) && !FBlueprintEditorUtils::IsNativeSignature(TargetFunction) && OwningClass)
		{
			OwningClass = OwningClass->GetAuthoritativeClass();
			// we can filter private and protected blueprints that are unrelated:
			bool bAccessibleInAll = true;
			for (const UBlueprint* Blueprint : Filter.Context.Blueprints)
			{
				UClass* AuthoritativeClass = Blueprint->GeneratedClass;
				if(!AuthoritativeClass)
				{
					continue;
				}

				if(bIsPrivate)
				{
					bAccessibleInAll = bAccessibleInAll && AuthoritativeClass == OwningClass;
				}
				else if(bIsProtected)
				{
					bAccessibleInAll = bAccessibleInAll && AuthoritativeClass->IsChildOf(OwningClass);
				}
			}

			if(!bAccessibleInAll)
			{
				bIsFilteredOut = true;
			}
		}
	}

	return bIsFilteredOut;
}
```

# ä½œç”¨åœ¨å±æ€§ä¸Šï¼š

ä½œç”¨åœ¨å±æ€§ä¸Šæ—¶ï¼Œæ ‡æ˜è¯¥å±æ€§åªèƒ½åœ¨æœ¬ç±»æˆ–æ´¾ç”Ÿç±»é‡Œè¿›è¡Œè¯»å†™ï¼Œä½†ä¸èƒ½åœ¨åˆ«çš„è“å›¾ç±»é‡Œè®¿é—®ã€‚

æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Access :public AActor
{
public:
	GENERATED_BODY()
public:
	//(BlueprintProtected = true, Category = MyFunction_Access, ModuleRelativePath = Function/MyFunction_Access.h)
	//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite,meta = (BlueprintProtected = "true"))
	int32 MyNativeInt_HasProtected;

	//(BlueprintPrivate = true, Category = MyFunction_Access, ModuleRelativePath = Function/MyFunction_Access.h)
	//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite,meta = (BlueprintPrivate = "true"))
	int32 MyNativeInt_HasPrivate;

public:
//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite)
	int32 MyNativeInt_NativePublic;
protected:
	//CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_Protected | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierProtected 
	UPROPERTY(BlueprintReadOnly)
	int32 MyNativeInt_NativeProtected;
private:
	//CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	//error : BlueprintReadWrite should not be used on private members
	UPROPERTY(EditAnywhere)
	int32 MyNativeInt_NativePrivate;
};
```

è“å›¾æ•ˆæœï¼š

åœ¨å…¶å­ç±»BPA_Access_Baseæµ‹è¯•ï¼Œå‘ç°é™¤äº†MyNativeInt_HasPrivateéƒ½å¯ä»¥è®¿é—®ã€‚è¿™ç¬¦åˆé€»è¾‘ï¼Œæ¯•ç«ŸPrivateçš„å«ä¹‰å°±æ˜¯åªæœ‰åœ¨æœ¬ç±»æ‰å¯ä»¥è®¿é—®ã€‚

è€Œåœ¨æœ¬è“å›¾ç±»å®šä¹‰çš„MyBPIntPrivateå› ä¸ºå‹¾ä¸Šäº†Privateï¼Œä¼šå¯¼è‡´è¯¥å±æ€§å¢åŠ äº†BlueprintPrivate = trueçš„metaï¼Œä½†å› ä¸ºæ˜¯æœ¬ç±»é‡Œå®šä¹‰çš„ï¼Œæ‰€ä»¥åœ¨æœ¬ç±»é‡Œä¹Ÿä¾ç„¶å¯ä»¥è¯»å†™è®¿é—®ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled%203.png)

ç»§ç»­åœ¨è“å›¾ä¸­çš„å­ç±»ï¼ˆBPA_Access_Childç»§æ‰¿è‡ªBPA_Access_Baseï¼‰æ•ˆæœï¼š

Protectedçš„å±æ€§ä¾ç„¶éƒ½å¯ä»¥è®¿é—®ï¼Œä½†æ˜¯MyBPIntPrivateå±æ€§å› ä¸ºæ˜¯Privateçš„ï¼Œå› æ­¤éƒ½ä¸èƒ½è¯»å†™ï¼Œå¦‚æœå¼ºåˆ¶ç²˜è´´èŠ‚ç‚¹ï¼Œä¼šåœ¨ç¼–è¯‘çš„æ—¶å€™æŠ¥é”™ã€‚Privateçš„å«ä¹‰æ˜¯åªåœ¨æœ¬ç±»ä¸­æ‰å¯ä»¥è®¿é—®ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled%204.png)

è€Œåœ¨å¤–éƒ¨ç±»ä¸­(BPA_Access_Otherï¼Œç»§æ‰¿è‡ªActor)ï¼Œé€šè¿‡BPA_Access_Baseæˆ–BPA_Access_Childå¯¹è±¡å®ä¾‹è®¿é—®å±æ€§çš„æ—¶å€™ï¼šå¸¦æœ‰BlueprintProtectedå’ŒBlueprintPrivateéƒ½ä¸èƒ½è®¿é—®ã€‚è€ŒC++ä¸­çš„protectedä¿®é¥°å¹¶æ— å½±å“ã€‚

è€ŒMyBPIntPrivateå› ä¸ºæ˜¯Privateæ‰€ä»¥ä¸èƒ½è®¿é—®ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintProtected\Untitled%205.png)

## åŸç†ï¼š

åœ¨æºç é‡Œæœç´¢CPF_NativeAccessSpecifierProtectedï¼Œå‘ç°å¹¶æ— ä½¿ç”¨çš„åœ°æ–¹ã€‚

è€ŒCPF_NativeAccessSpecifierPrivateåªåœ¨IsPropertyPrivateä¸­å¼•ç”¨ï¼Œåè€…ä¹Ÿåªåœ¨è“å›¾ç¼–è¯‘æ£€æµ‹çº¿ç¨‹å®‰å…¨çš„æ—¶å€™è¢«æ£€æµ‹åˆ°ã€‚å› æ­¤CPF_NativeAccessSpecifierPrivateä¹Ÿå®é™…ä¸Šå¹¶æ— çœŸæ­£çš„è¢«ç”¨æ¥åšä½œç”¨åŸŸçš„é™åˆ¶ã€‚

ç»¼åˆäºŒè€…ï¼Œè¿™ä¹Ÿæ˜¯åœ¨C++ä¸­protectedå’Œprivateå¹¶ä¸åœ¨è“å›¾ä¸­é€ æˆå½±å“çš„åŸå› ã€‚ä½†UHTä¼šé˜»æ­¢privateå˜é‡ä¸Šçš„BlueprintReadWriteæˆ–BlueprintReadOnlyï¼Œé€ æˆäº‹å®ä¸Šçš„æ— æ³•åœ¨è“å›¾ä¸­è®¿é—®ï¼Œè¾¾æˆäº†æ— æ³•åœ¨è“å›¾å­ç±»é‡Œè®¿é—®C++åŸºç±»privateå˜é‡çš„æ•ˆæœã€‚

å› æ­¤å®é™…ä¸Šåœ¨è“å›¾ä¸­çš„å˜é‡ä½œç”¨åŸŸæ§åˆ¶ï¼Œé‡‡ç”¨çš„å…ƒæ•°æ®BlueprintProtected å’ŒBlueprintPrivateï¼Œåœ¨è“å›¾å³é”®èƒ½å¦åˆ›å»ºå±æ€§è¯»å†™èŠ‚ç‚¹çš„é€»è¾‘åœ¨ä¸Šé¢çš„BlueprintActionFilterImpl::IsFieldInaccessibleå‡½æ•°ä¸­ä½“ç°ã€‚è€Œç¼–è¯‘çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸ªå±æ€§æ˜¯å¦å¯è¯»å†™çš„é€»è¾‘åœ¨IsPropertyWritableInBlueprintå’ŒIsPropertyReadableInBlueprintè¿™ä¸¤ä¸ªå‡½æ•°ï¼Œå¦‚æœæœ€ç»ˆçš„çŠ¶æ€ç»“æœæ˜¯Privateï¼Œåˆ™è¯´æ˜ä¸å¯è®¿é—®ã€‚åœ¨UK2Node_VariableGetå’ŒUK2Node_VariableSetçš„ValidateNodeDuringCompilationï¼Œä¼šæ£€æµ‹å‡ºæ¥å¹¶æŠ¥é”™ã€‚

```cpp
bool FBlueprintEditorUtils::IsPropertyPrivate(const FProperty* Property)
{
	return Property->HasAnyPropertyFlags(CPF_NativeAccessSpecifierPrivate) || Property->GetBoolMetaData(FBlueprintMetadata::MD_Private); 
}

FBlueprintEditorUtils::EPropertyWritableState FBlueprintEditorUtils::IsPropertyWritableInBlueprint(const UBlueprint* Blueprint, const FProperty* Property)
{
	if (Property)
	{
		if (!Property->HasAnyPropertyFlags(CPF_BlueprintVisible))
		{
			return EPropertyWritableState::NotBlueprintVisible;
		}
		if (Property->HasAnyPropertyFlags(CPF_BlueprintReadOnly))
		{
			return EPropertyWritableState::BlueprintReadOnly;
		}
		if (Property->GetBoolMetaData(FBlueprintMetadata::MD_Private))
		{
			const UClass* OwningClass = Property->GetOwnerChecked<UClass>();
			if (OwningClass->ClassGeneratedBy.Get() != Blueprint)
			{
				return EPropertyWritableState::Private;
			}
		}
	}
	return EPropertyWritableState::Writable;
}

FBlueprintEditorUtils::EPropertyReadableState FBlueprintEditorUtils::IsPropertyReadableInBlueprint(const UBlueprint* Blueprint, const FProperty* Property)
{
	if (Property)
	{
		if (!Property->HasAnyPropertyFlags(CPF_BlueprintVisible))
		{
			return EPropertyReadableState::NotBlueprintVisible;
		}
		if (Property->GetBoolMetaData(FBlueprintMetadata::MD_Private))
		{
			const UClass* OwningClass = Property->GetOwnerChecked<UClass>();
			if (OwningClass->ClassGeneratedBy.Get() != Blueprint)
			{
				return EPropertyReadableState::Private;
			}
		}
	}
	return EPropertyReadableState::Readable;
}
```


ï»¿# BlueprintSetter

- **åŠŸèƒ½æè¿°ï¼š** é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„setå‡½æ•°æ¥è¯»å–ã€‚
  ä¼šé»˜è®¤è®¾ç½®BlueprintReadWrite.

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[BlueprintSetter](../../Specifier/UFUNCTION/Blueprint/BlueprintSetter.md)

  UPROPERTYï¼š[BlueprintSetter](../../Specifier/UPROPERTY/Blueprint/BlueprintSetter.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# BlueprintThreadSafe

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»ä¸Šæˆ–å‡½æ•°ä¸Šï¼Œæ ‡è®°ç±»é‡Œçš„å‡½æ•°éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
è¿™æ ·å°±å¯ä»¥åœ¨åŠ¨ç”»è“å›¾ç­‰éæ¸¸æˆçº¿ç¨‹è¢«è°ƒç”¨äº†ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** ä»å®è·µä¸Šï¼Œç±»ä¸€èˆ¬æ˜¯BlueprintFunctionLibrary
- **å…³è”é¡¹ï¼š** [NotBlueprintThreadSafe](../NotBlueprintThreadSafe.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åŠ¨ç”»è“å›¾çš„AimGraphé»˜è®¤æ˜¯å¼€å¯çº¿ç¨‹å®‰å…¨Updateçš„ã€‚è®¾ç½®åœ¨ClassSettingsé‡Œï¼ˆé»˜è®¤æ˜¯æ‰“å¼€çš„ï¼‰

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintThreadSafe\Untitled.png)

å¯å‚è€ƒå®˜æ–¹æ–‡æ¡£çš„**CPU Thread Usage and Performanceè¿™ä¸€èŠ‚**

[Graphing in Animation Blueprints](https://docs.unrealengine.com/5.3/en-US/graphing-in-animation-blueprints-in-unreal-engine/#cputhreadusageandperformance)

å› æ­¤AimGraphé‡Œçš„å‡½æ•°è¦æ±‚éƒ½å¾—æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä½ çš„C++å‡½æ•°æˆ–è€…æ˜¯è“å›¾é‡Œè“å›¾åº“é‡Œçš„å‡½æ•°éƒ½éœ€è¦æ‰‹åŠ¨æ ‡è®°ä¸ºThreadSafeï¼Œé»˜è®¤ä¸å¸¦ThreadSafeæ ‡è®°çš„éƒ½æ˜¯ä¸çº¿ç¨‹å®‰å…¨çš„ã€‚

åœ¨è“å›¾é‡Œï¼Œå¦‚æœåœ¨è“å›¾å‡½æ•°é¢æ¿ä¸­å‹¾ä¸ŠThreadSafeï¼Œè¿™ä¸ªå‡½æ•°çš„å¯¹è±¡ä¼šè®¾ç½®bThreadSafe=Trueï¼Œä»è€Œåœ¨ç¼–è¯‘ç”Ÿæˆçš„BlueprintGeneratedClassä¸Šé¢è®¾ç½®(BlueprintThreadSafe = true)

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintThreadSafe\Untitled%201.png)

## æµ‹è¯•è“å›¾å‡½æ•°åº“ï¼š

åŒæ ·çš„å‡½æ•°ï¼Œä¸€ä¸ªæ‰“å¼€ThreadSafeï¼Œä¸€ä¸ªæ²¡æœ‰ã€‚æ²¡æœ‰çš„é‚£ä¸ªå‡½æ•°åœ¨åŠ¨ç”»è“å›¾çš„AnimGraphé‡Œä½¿ç”¨çš„æ—¶å€™ï¼Œåœ¨ç¼–è¯‘çš„æ—¶å€™å°±ä¼šè§¦å‘è­¦å‘Šã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintThreadSafe\Untitled%202.png)

æµ‹è¯•ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintThreadSafe\Untitled%203.png)

## åœ¨C++é‡Œï¼ŒC++çš„æµ‹è¯•ä»£ç ï¼š

```cpp
//(BlueprintThreadSafe = , IncludePath = Class/Blueprint/MyClass_ThreadSafe.h, ModuleRelativePath = Class/Blueprint/MyClass_ThreadSafe.h)
UCLASS(meta=(BlueprintThreadSafe))
class INSIDER_API UMyBlueprintFunctionLibrary_ThreadSafe : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure)
	static float MyFunc_ClassThreadSafe_Default(float value) {return value+100;}

	//(ModuleRelativePath = Class/Blueprint/MyClass_ThreadSafe.h, NotBlueprintThreadSafe = )
	UFUNCTION(BlueprintPure,meta=(NotBlueprintThreadSafe))
	static float MyFunc_ClassThreadSafe_FuncNotThreadSafe(float value) {return value+100;}
};

UCLASS()
class INSIDER_API UMyBlueprintFunctionLibrary_NoThreadSafe : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	//(BlueprintThreadSafe = , ModuleRelativePath = Class/Blueprint/MyClass_ThreadSafe.h)
	UFUNCTION(BlueprintPure,meta=(BlueprintThreadSafe))
	static float MyFunc_ClassDefault_FuncThreadSafe(float value) {return value+100;}

	//(ModuleRelativePath = Class/Blueprint/MyClass_ThreadSafe.h, NotBlueprintThreadSafe = )
	UFUNCTION(BlueprintPure,meta=(NotBlueprintThreadSafe))
	static float MyFunc_ClassDefault_FuncNotThreadSafe(float value) {return value+100;}
};

UCLASS()
class INSIDER_API UMyBlueprintFunctionLibrary_Default : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure)
	static float MyFunc_ClassDefault_FuncDefault(float value) {return value+100;}
};
```

## åŠ¨ç”»è“å›¾çš„æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\BlueprintThreadSafe\Untitled%204.png)

## è§£æåŸç†ï¼š

```cpp
bool FBlueprintEditorUtils::HasFunctionBlueprintThreadSafeMetaData(const UFunction* InFunction)
{
	if(InFunction)
	{
		const bool bHasThreadSafeMetaData = InFunction->HasMetaData(FBlueprintMetadata::MD_ThreadSafe);
		const bool bHasNotThreadSafeMetaData = InFunction->HasMetaData(FBlueprintMetadata::MD_NotThreadSafe);
		const bool bClassHasThreadSafeMetaData = InFunction->GetOwnerClass() && InFunction->GetOwnerClass()->HasMetaData(FBlueprintMetadata::MD_ThreadSafe);

		// Native functions need to just have the correct class/function metadata
		const bool bThreadSafeNative = InFunction->HasAnyFunctionFlags(FUNC_Native) && (bHasThreadSafeMetaData || (bClassHasThreadSafeMetaData && !bHasNotThreadSafeMetaData));

		// Script functions get their flag propagated from their entry point, and dont pay heed to class metadata
		const bool bThreadSafeScript = !InFunction->HasAnyFunctionFlags(FUNC_Native) && bHasThreadSafeMetaData;
		
		return bThreadSafeNative || bThreadSafeScript;
	}
	
	return false;
}
```

å¯ä»¥ä»é€»è¾‘ä¸Šçœ‹å‡ºï¼Œå¦‚æœåœ¨UCLASSä¸Šå¸¦ä¸Šäº†BlueprintThreadSafeï¼Œåˆ™å…¶å†…éƒ¨çš„å‡½æ•°å°±é»˜è®¤æ˜¯çº¿ç¨‹å®‰å…¨ï¼Œé™¤éç‰¹æ„æ‰‹åŠ¨åŠ ä¸ŠNotBlueprintThreadSafeæ¥æ’é™¤ã€‚è€Œå¦‚æœUCLASSä¸Šæ²¡æœ‰æ ‡è®°ï¼Œåˆ™éœ€ä¸€ä¸ªä¸ªæ‰‹åŠ¨çš„åœ¨UFUNCTIONä¸Šæ ‡è®°BlueprintThreadSafeã€‚ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥ã€‚

æ³¨æ„UCLASS(meta=(NotBlueprintThreadSafe))è¿™ç§æ˜¯æ²¡æœ‰è¢«è¯†åˆ«åˆ¤æ–­çš„ï¼Œå› æ­¤å¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚


ï»¿# BlueprintType

- **åŠŸèƒ½æè¿°ï¼š** è¡¨æ˜å¯ä»¥ä½œä¸ºä¸€ä¸ªè“å›¾å˜é‡

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UENUM, UINTERFACE, USTRUCT

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[Blueprintable](../../Specifier/UCLASS/Blueprint/Blueprintable/Blueprintable.md), [NotBlueprintable](../../Specifier/UCLASS/Blueprint/NotBlueprintable.md), [BlueprintType](../../Specifier/UCLASS/Blueprint/BlueprintType/BlueprintType.md), [NotBlueprintType](../../Specifier/UCLASS/Blueprint/NotBlueprintType.md)

  Metaï¼š[BlueprintInternalUseOnly](BlueprintInternalUseOnly.md), [BlueprintInternalUseOnlyHierarchical](BlueprintInternalUseOnlyHierarchical.md)

  UENUMï¼š[BlueprintType](../../Specifier/UENUM/BlueprintType.md)

  UFUNCTIONï¼š[BlueprintInternalUseOnly](../../Specifier/UFUNCTION/UHT/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md)

  UINTERFACEï¼š[Blueprintable](../../Specifier/UINTERFACE/Blueprint/Blueprintable/Blueprintable.md), [NotBlueprintable](../../Specifier/UINTERFACE/Blueprint/NotBlueprintable/NotBlueprintable.md)

  USTRUCTï¼š[BlueprintInternalUseOnly](../../Specifier/USTRUCT/Blueprint/BlueprintInternalUseOnly/BlueprintInternalUseOnly.md), [BlueprintType](../../Specifier/USTRUCT/Blueprint/BlueprintType/BlueprintType.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# CallableWithoutWorldContext

- **åŠŸèƒ½æè¿°ï¼š** è®©å‡½æ•°ä¹Ÿå¯ä»¥è„±ç¦»WorldContextObjectè€Œä½¿ç”¨
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [WorldContext](../WorldContext/WorldContext.md)

è®©å‡½æ•°ä¹Ÿå¯ä»¥è„±ç¦»WorldContextObjectè€Œä½¿ç”¨ã€‚

CallableWithoutWorldContext æ˜¯é…åˆWorldContextæˆ–DefaultToSelfæ¥ä½¿ç”¨ï¼Œè¿™äºŒè€…ä¼šä½¿å¾—ä¸€ä¸ªå‡½æ•°ä¼šè¦æ±‚å¤–éƒ¨ä¼ å…¥ä¸€ä¸ªWorldContextå¯¹è±¡æ‰èƒ½è°ƒç”¨ã€‚å› æ­¤è¿™ç§å‡½æ•°åœ¨æ²¡æœ‰å®ç°GetWorldçš„Objectå­ç±»é‡Œå°±ä¸èƒ½è°ƒç”¨ã€‚ä½†æœ‰æ—¶æŸäº›å‡½æ•°åˆä¸ä¸€å®šå¿…é¡»å¾—æœ‰WorldContextObjectæ‰èƒ½å·¥ä½œï¼Œæ¯”å¦‚PrintStringæˆ–VisualLoggeré‡Œçš„å‡½æ•°ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION(BlueprintPure, meta = (WorldContext = "WorldContextObject"))
static FString MyFunc_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);

UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject",CallableWithoutWorldContext))
static FString MyFunc_CallableWithoutWorldContext(const UObject* WorldContextObject, FString name, FString value);

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyObject_NoGetWorld :public UObject
{
	GENERATED_BODY()
};
```

## è“å›¾æµ‹è¯•æ•ˆæœï¼š

åœ¨UMyObject_NoGetWorld çš„å­ç±»å†…ï¼ŒMyFunc_HasWorldContextMetaä¸èƒ½è°ƒç”¨ï¼Œå› ä¸ºå…¶å¤–éƒ¨ç±»å¿…é¡»æä¾›WorldContextObjectã€‚è€ŒMyFunc_CallableWithoutWorldContextå¯ä»¥è°ƒç”¨ï¼Œå¯ä»¥æ¥å—ä¸æä¾›WorldContextObjectã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\CallableWithoutWorldContext\Untitled.png)

## æºç é‡Œå…¸å‹çš„åº”ç”¨æ˜¯ï¼š

```cpp
UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", CallableWithoutWorldContext, Keywords = "log print", AdvancedDisplay = "2", DevelopmentOnly), Category="Development")
static ENGINE_API void PrintString(const UObject* WorldContextObject, const FString& InString = FString(TEXT("Hello")), bool bPrintToScreen = true, bool bPrintToLog = true, FLinearColor TextColor = FLinearColor(0.0f, 0.66f, 1.0f), float Duration = 2.f, const FName Key = NAME_None);
```


ï»¿# CallInEditor

- **åŠŸèƒ½æè¿°ï¼š** å¯ä»¥åœ¨Actorçš„ç»†èŠ‚é¢æ¿ä¸Šä½œä¸ºä¸€ä¸ªæŒ‰é’®æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[CallInEditor](../../Specifier/UFUNCTION/Blueprint/CallInEditor/CallInEditor.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# CannotImplementInterfaceInBlueprint

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥æ¥å£ä¸èƒ½åœ¨è“å›¾ä¸­å®ç°

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UINTERFACEï¼š[NotBlueprintable](../../Specifier/UINTERFACE/Blueprint/NotBlueprintable/NotBlueprintable.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å’ŒUINTERFACE(NotBlueprintable)çš„æ•ˆæœä¸€æ ·ï¼ŒæŒ‡å®šä¸èƒ½åœ¨è“å›¾ä¸­ç»§æ‰¿


ï»¿# CommutativeAssociativeBinaryOperator

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°ä¸€ä¸ªäºŒå…ƒè¿ç®—å‡½æ•°çš„è¿ç®—æ”¯æŒäº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œåœ¨è“å›¾èŠ‚ç‚¹ä¸Šå¢åŠ ä¸€ä¸ªâ€œ+â€å¼•è„šï¼Œå…è®¸åŠ¨æ€çš„ç›´æ¥æ·»åŠ å¤šä¸ªè¾“å…¥å€¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…

æ ‡è®°ä¸€ä¸ªäºŒå…ƒè¿ç®—å‡½æ•°çš„è¿ç®—æ”¯æŒäº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œåœ¨è“å›¾èŠ‚ç‚¹ä¸Šå¢åŠ ä¸€ä¸ªâ€œ+â€å¼•è„šï¼Œå…è®¸åŠ¨æ€çš„ç›´æ¥æ·»åŠ å¤šä¸ªè¾“å…¥å€¼ã€‚è€Œä¸éœ€è¦è‡ªå·±æ‰‹åŠ¨åˆ›å»ºå¤šä¸ªæœ¬å‡½æ•°èŠ‚ç‚¹æ¥è¿ç®—ï¼Œè¿™æ˜¯è“å›¾æä¾›çš„ä¾¿åˆ©åŠŸèƒ½ä¹‹ä¸€ã€‚

CommutativeAssociativeBinaryOperatorçš„é™åˆ¶æ˜¯å‡½æ•°å¿…é¡»æ˜¯BlueprintPureå¹¶ä¸”æœ‰ä¸¤ä¸ªå‚æ•°ã€‚å¦åˆ™ä¼šäº§ç”Ÿç¼–è¯‘æŠ¥é”™æˆ–åŠŸèƒ½å¤±æ•ˆã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (CommutativeAssociativeBinaryOperator))
	static float My_CallableAdd_WithBinaryOperator(float A, float B) { return A + B; }

	UFUNCTION(BlueprintPure, meta = (CommutativeAssociativeBinaryOperator))
	static float My_PureAdd_WithBinaryOperator(float A, float B) { return A + B; }

	UFUNCTION(BlueprintPure, meta = ())
	static float My_Add_NoBinaryOperator(float A, float B) { return A + B; }
	
	// error : Commutative associative binary operators must have exactly 2 parameters of the same type and a return value.
	//UFUNCTION(BlueprintPure, meta = (CommutativeAssociativeBinaryOperator))
//	static float My_PureAdd3_WithBinaryOperator(float A, float B,float C) { return A + B+C; }
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\CommutativeAssociativeBinaryOperator\Untitled.png)

## åŸç†ï¼š

æ ‡è®°CommutativeAssociativeBinaryOperatorçš„å‡½æ•°ä¼šé‡‡ç”¨UK2Node_CommutativeAssociativeBinaryOperatoræ¥ç”ŸæˆèŠ‚ç‚¹ã€‚è¿™ä¸ªäºŒå…ƒè¿ç®—æ»¡è¶³äº¤æ¢ç‡å’Œç»“åˆå¾‹ï¼Œå› æ­¤å¯ä»¥é€šè¿‡å¤šæ¬¡çš„è°ƒç”¨æœ¬å‡½æ•°æ¥æ”¯æŒå¤šä¸ªè¾“å…¥å€¼çš„è¿ç®—ã€‚åœ¨UK2Node_CommutativeAssociativeBinaryOperatorå±•å¼€çš„æ—¶å€™ï¼Œä¼šåˆ›å»ºä¸­é—´çš„å¤šä¸ªUK2Node_CommutativeAssociativeBinaryOperatoræ¥å½¢æˆè°ƒç”¨åºåˆ—ã€‚

åœ¨æºç ä¸­çš„åº”ç”¨æ˜¯ä¸€äº›äºŒå…ƒè¿ç®—ï¼Œåœ¨UKismetMathLibraryä¸­æœ‰å¤§é‡çš„è¿ç”¨ï¼Œå…¸å‹çš„æ¯”å¦‚FVectorçš„äº’ç›¸è¿ç®—ã€‚

```cpp
void UK2Node_CommutativeAssociativeBinaryOperator::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	if (NumAdditionalInputs > 0)
	{
		const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

		UEdGraphPin* LastOutPin = NULL;
		const UFunction* const Function = GetTargetFunction();

		const UEdGraphPin* SrcOutPin = FindOutPin();
		const UEdGraphPin* SrcSelfPin = FindSelfPin();
		UEdGraphPin* SrcFirstInput = GetInputPin(0);
		check(SrcFirstInput);

		for(int32 PinIndex = 0; PinIndex < Pins.Num(); PinIndex++)
		{
			UEdGraphPin* CurrentPin = Pins[PinIndex];
			if( (CurrentPin == SrcFirstInput) || (CurrentPin == SrcOutPin) || (SrcSelfPin == CurrentPin) )
			{
				continue;
			}

			UK2Node_CommutativeAssociativeBinaryOperator* NewOperator = SourceGraph->CreateIntermediateNode<UK2Node_CommutativeAssociativeBinaryOperator>();
			NewOperator->SetFromFunction(Function);
			NewOperator->AllocateDefaultPins();
			CompilerContext.MessageLog.NotifyIntermediateObjectCreation(NewOperator, this);

			UEdGraphPin* NewOperatorInputA = NewOperator->GetInputPin(0);
			check(NewOperatorInputA);
			if(LastOutPin)
			{
				Schema->TryCreateConnection(LastOutPin, NewOperatorInputA);
			}
			else
			{
				// handle first created node (SrcFirstInput is skipped, and has no own node).
				CompilerContext.MovePinLinksToIntermediate(*SrcFirstInput, *NewOperatorInputA);
			}

			UEdGraphPin* NewOperatorInputB = NewOperator->GetInputPin(1);
			check(NewOperatorInputB);
			CompilerContext.MovePinLinksToIntermediate(*CurrentPin, *NewOperatorInputB);

			LastOutPin = NewOperator->FindOutPin();
		}

		check(LastOutPin);

		UEdGraphPin* TrueOutPin = FindOutPin();
		check(TrueOutPin);
		CompilerContext.MovePinLinksToIntermediate(*TrueOutPin, *LastOutPin);

		BreakAllNodeLinks();
	}
}

```


ï»¿# CompactNodeTitle

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—å‡½æ•°çš„å±•ç¤ºå½¢å¼å˜æˆç²¾ç®€å‹ç¼©æ¨¡å¼ï¼ŒåŒæ—¶æŒ‡å®šä¸€ä¸ªæ–°çš„ç²¾ç®€çš„åå­—
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿å¾—å‡½æ•°çš„å±•ç¤ºå½¢å¼å˜æˆç²¾ç®€å‹ç¼©æ¨¡å¼ï¼ŒåŒæ—¶æŒ‡å®šä¸€ä¸ªæ–°çš„ç²¾ç®€çš„åå­—ã€‚æ³¨æ„åˆ°è¯¥æ¨¡å¼ä¸‹å°±ä¼šå¿½ç•¥DisplayNameçš„æ•°æ®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (CompactNodeTitle = "MyCompact",DisplayName="AnotherName"))
	static int32 MyFunc_HasCompactNodeTitle(FString Name) {return 0;}

	UFUNCTION(BlueprintCallable, meta = ())
	static int32 MyFunc_NoCompactNodeTitle(FString Name) {return 0;}

	UFUNCTION(BlueprintPure, meta = (CompactNodeTitle = "MyPure",DisplayName="AnotherName"))
	static int32 MyPure_HasCompactNodeTitle(FString Name) {return 0;}

	UFUNCTION(BlueprintPure, meta = ())
	static int32 MyPure_NoCompactNodeTitle(FString Name) {return 0;}
```

## è“å›¾æ•ˆæœï¼š

æ˜¾ç¤ºæ•ˆæœæ˜æ˜¾å‘ç”Ÿäº†å˜åŒ–ã€‚åŒæ—¶æˆ‘ä»¬åœ¨è“å›¾é‡Œå®šä¹‰çš„å‡½æ•°ä¹Ÿå¯ä»¥é€šè¿‡è¿™ä¸ªç»†èŠ‚é¢æ¿ä¸Šçš„è®¾ç½®å˜æˆå‹ç¼©æ¨¡å¼å±•ç¤ºã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\CompactNodeTitle\Untitled.png)

## åŸç†ï¼š

```cpp
bool UK2Node_CallFunction::ShouldDrawCompact(const UFunction* Function)
{
	return (Function != NULL) && Function->HasMetaData(FBlueprintMetadata::MD_CompactNodeTitle);
}

FString UK2Node_CallFunction::GetCompactNodeTitle(const UFunction* Function)
{
	static const FString ProgrammerMultiplicationSymbol = TEXT("*");
	static const FString CommonMultiplicationSymbol = TEXT("\xD7");

	static const FString ProgrammerDivisionSymbol = TEXT("/");
	static const FString CommonDivisionSymbol = TEXT("\xF7");

	static const FString ProgrammerConversionSymbol = TEXT("->");
	static const FString CommonConversionSymbol = TEXT("\x2022");

	const FString& OperatorTitle = Function->GetMetaData(FBlueprintMetadata::MD_CompactNodeTitle);
	if (!OperatorTitle.IsEmpty())
	{
		if (OperatorTitle == ProgrammerMultiplicationSymbol)
		{
			return CommonMultiplicationSymbol;
		}
		else if (OperatorTitle == ProgrammerDivisionSymbol)
		{
			return CommonDivisionSymbol;
		}
		else if (OperatorTitle == ProgrammerConversionSymbol)
		{
			return CommonConversionSymbol;
		}
		else
		{
			return OperatorTitle;
		}
	}
	
	return Function->GetName();
}
```


ï»¿# CPP_Default_XXX

- **åŠŸèƒ½æè¿°ï¼š** XXX=å‚æ•°åå­—
- **ä½¿ç”¨ä½ç½®ï¼š** UPARAM
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨UFUNCTIONçš„metaä¸Šä¿å­˜å‚æ•°çš„é»˜è®¤å€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//(CPP_Default_intValue = 123, CPP_Default_intValue2 = 456, ModuleRelativePath = Function/Param/MyFunction_TestParam.h)
UFUNCTION(BlueprintCallable)
FString MyFuncTestParam_DefaultInt2(int intValue=123,int intValue2=456);
```

åœ¨Metaé‡Œä¹Ÿå¯ä»¥ç›´æ¥å†™å±æ€§çš„é»˜è®¤å€¼ï¼Œå¦‚Durationã€‚

```cpp
UFUNCTION(BlueprintCallable, Category="Utilities|FlowControl", meta=(Latent, WorldContext="WorldContextObject", LatentInfo="LatentInfo", Duration="0.2", Keywords="sleep"))
static ENGINE_API void	MyDelay(const UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo );
```

## åŸç†ä»£ç ï¼š

åœ¨UEdGraphSchema_K2::FindFunctionParameterDefaultValueé‡Œä¼šå°è¯•æ‰¾è¯¥å‚æ•°åç§°å¯¹åº”çš„Metaã€‚å¦‚æœæ‰¾ä¸åˆ°åˆ™ä¼šç»§ç»­æ‰¾CPP_Default_ParamNameè¿™ä¸ªåç§°ã€‚ç„¶åè®¾ç½®åˆ°Pin->AutogeneratedDefaultValue

```cpp
bool UK2Node_CallFunction::CreatePinsForFunctionCall(const UFunction* Function)
{
			FString ParamValue;
			if (K2Schema->FindFunctionParameterDefaultValue(Function, Param, ParamValue))
			{
				K2Schema->SetPinAutogeneratedDefaultValue(Pin, ParamValue);
			}
			else
			{
				K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
			}
}
```


ï»¿# DefaultToSelf

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨å‡½æ•°ä¸Šï¼ŒæŒ‡å®šä¸€ä¸ªå‚æ•°çš„é»˜è®¤å€¼ä¸ºSelfå€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä½¿å¾—åœ¨è“å›¾è°ƒç”¨çš„æ—¶å€™æ›´åŠ çš„ä¾¿åˆ©ï¼Œå½“ç„¶ä¹Ÿè¦æ ¹æ®è¿™ä¸ªå‡½æ•°çš„éœ€è¦ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS()
class INSIDER_API UMyFunctionLibrary_SelfPinTest :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable)
	static FString PrintProperty_Default(UObject* myOwner,FName propertyName);

	UFUNCTION(BlueprintCallable,meta=(DefaultToSelf="myOwner"))
	static FString PrintProperty_HasDefaultToSelf(UObject* myOwner,FName propertyName);

	UFUNCTION(BlueprintCallable,meta=(DefaultToSelf="myOwner",hidePin="myOwner"))
	static FString PrintProperty_HasDefaultToSelf_ButHide(UObject* myOwner,FName propertyName);
};
```

è“å›¾é‡Œçš„èŠ‚ç‚¹ï¼Œå¯ä»¥çœ‹å‡ºè“å›¾ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨çš„æŠŠDefaultToSelfæŒ‡å®šçš„å‡½æ•°å‚æ•°ï¼Œè‡ªåŠ¨çš„èµ‹å€¼åˆ°Selfï¼Œå½“ç„¶è¿™ä¸ªå’Œæ‰‹åŠ¨çš„è¿åˆ°selfæœ¬è´¨æ˜¯ä¸€æ ·çš„ã€‚é¢å¤–ä¸€ç‚¹ï¼Œå¯ä»¥é€šè¿‡HidePinå†éšè—æ‰è¿™ä¸ªå‡½æ•°å‚æ•°ï¼Œè¿™æ ·å°±é»˜è®¤æŠŠè¯¥è“å›¾èŠ‚ç‚¹æ‰€åœ¨çš„è“å›¾å¯¹è±¡ï¼ˆSelfï¼‰å½“ä½œç¬¬ä¸€ä¸ªå‡½æ•°å‚æ•°ï¼Œæ˜¾å¾—æ›´åŠ ç®€æ´ä¸€äº›ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\DefaultToSelf\Untitled.png)

å¦‚æœæ˜¯BlueprintPureä¹Ÿæ˜¯å¯ä»¥çš„ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\DefaultToSelf\Untitled%201.png)

## åŸç†ï¼š

è“å›¾ä¸­çš„å‡½æ•°è°ƒç”¨åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨çš„åˆ›å»ºSelfPinï¼ˆåå­—ä¸ºTarget)ã€‚å¦‚æœè¯¥å‡½æ•°æ˜¯é™æ€å‡½æ•°æˆ–HideSelfPinçš„æ ‡è®°ï¼Œåˆ™ä¼šæŠŠSelfPinéšè—èµ·æ¥ã€‚å…¶SelfPinçš„å€¼å°±æ˜¯å½“å‰è“å›¾è¿è¡Œæ—¶å¯¹è±¡çš„å€¼ã€‚å› æ­¤DefaultToSelfçš„æ•ˆæœå°±æ˜¯è“å›¾ç³»ç»Ÿä¼šè‡ªåŠ¨çš„æŠŠè¿™ä¸ªå‚æ•°çš„å€¼èµ‹å€¼ä¸ºè¢«è°ƒç”¨å¤„çš„è“å›¾è¿è¡Œæ—¶å¯¹è±¡ï¼Œç›¸å½“äºC++ thisæŒ‡é’ˆçš„æ•ˆæœ

```cpp
bool UK2Node_CallFunction::CreatePinsForFunctionCall(const UFunction* Function)
{
	UEdGraphPin* SelfPin = CreateSelfPin(Function);
	// Renamed self pin to target
	SelfPin->PinFriendlyName = LOCTEXT("Target", "Target");
}

UEdGraphPin* FBlueprintNodeStatics::CreateSelfPin(UK2Node* Node, const UFunction* Function)
{
	// Chase up the function's Super chain, the function can be called on any object that is at least that specific
	const UFunction* FirstDeclaredFunction = Function;
	while (FirstDeclaredFunction->GetSuperFunction() != nullptr)
	{
		FirstDeclaredFunction = FirstDeclaredFunction->GetSuperFunction();
	}

	// Create the self pin
	UClass* FunctionClass = CastChecked<UClass>(FirstDeclaredFunction->GetOuter());
	// we don't want blueprint-function target pins to be formed from the
	// skeleton class (otherwise, they could be incompatible with other pins
	// that represent the same type)... this here could lead to a compiler 
	// warning (the GeneratedClass could not have the function yet), but in
	// that, the user would be reminded to compile the other blueprint
	if (FunctionClass->ClassGeneratedBy)
	{
		FunctionClass = FunctionClass->GetAuthoritativeClass();
	}

	UEdGraphPin* SelfPin = NULL;
	if (FunctionClass == Node->GetBlueprint()->GeneratedClass)
	{
		// This means the function is defined within the blueprint, so the pin should be a true "self" pin
		SelfPin = Node->CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UEdGraphSchema_K2::PSC_Self, nullptr, UEdGraphSchema_K2::PN_Self);
	}
	else if (FunctionClass->IsChildOf(UInterface::StaticClass()))
	{
		SelfPin = Node->CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Interface, FunctionClass, UEdGraphSchema_K2::PN_Self);
	}
	else
	{
		// This means that the function is declared in an external class, and should reference that class
		SelfPin = Node->CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, FunctionClass, UEdGraphSchema_K2::PN_Self);
	}
	check(SelfPin != nullptr);

	return SelfPin;
}
```


ï»¿# DisplayName

- **åŠŸèƒ½æè¿°ï¼š** æ­¤èŠ‚ç‚¹åœ¨è“å›¾ä¸­çš„å‘½åå°†è¢«æ­¤å¤„æä¾›çš„å€¼æ‰€å–ä»£ï¼Œè€Œéä»£ç ç”Ÿæˆçš„å‘½åã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UENUM::UMETA, UFUNCTION, UPARAM, UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UPARAMï¼š[DisplayName](../../Specifier/UPARAM/Blueprint/DisplayName/DisplayName.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# DontUseGenericSpawnObject

- **åŠŸèƒ½æè¿°ï¼š** é˜»æ­¢ä½¿ç”¨è“å›¾ä¸­çš„Generic Create ObjectèŠ‚ç‚¹æ¥ç”Ÿæˆæœ¬ç±»çš„å¯¹è±¡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** æ—¢éActoråˆéActorComponentçš„BluprintTypeç±»æ—¶
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨äºé˜»æ­¢è¯¥ç±»è¢«é€šç”¨çš„ConstructObjectè“å›¾èŠ‚ç‚¹æ‰€æ„é€ å‡ºæ¥ã€‚åœ¨æºç é‡Œå…¸å‹é‡Œä½¿ç”¨ä¾‹å­æ˜¯UDragDropOperationå’ŒUUserWidgetï¼Œå‰è€…ç”±UK2Node_CreateDragDropOperationè¿™ä¸ªä¸“é—¨çš„èŠ‚ç‚¹å»ºå‡ºæ¥ï¼ˆå†…éƒ¨è°ƒç”¨UWidgetBlueprintLibrary::CreateDragDropOperationï¼‰ï¼Œåè€…ç”±CreateWidgetåˆ›å»ºã€‚å› æ­¤è¿™ç§çš„å…¸å‹ç”¨æ³•æ˜¯ä½ è‡ªå·±å†åˆ›å»ºä¸€ä¸ªNewçš„å‡½æ•°æ¥è‡ªå·±åˆ›å»ºè¯¥Objectã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable,meta=(DontUseGenericSpawnObject="true"))
class INSIDER_API UMyClass_CustomSpawnObject :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite,EditAnywhere)
	float MyFloat;

	UFUNCTION(BlueprintCallable)
	static UMyClass_CustomSpawnObject* CreateMyClassObjectByMyOwnSpawn(float value)
	{
		UMyClass_CustomSpawnObject* obj= NewObject<UMyClass_CustomSpawnObject>();
		obj->MyFloat=value;
		return obj;
	}
};
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\DontUseGenericSpawnObject\Untitled.png)

## åŸç†ï¼š

ä¼šæå‰éªŒè¯æ˜¯å¦åŒ…å«DontUseGenericSpawnObjectå…ƒæ•°æ®ï¼Œå› ä¸ºæ˜¯é‡‡ç”¨GetBoolMetaDataï¼Œå› æ­¤å¿…é¡»å†™ä¸Š=â€trueâ€

```cpp
struct FK2Node_GenericCreateObject_Utils
{
	static bool CanSpawnObjectOfClass(TSubclassOf<UObject> ObjectClass, bool bAllowAbstract)
	{
		// Initially include types that meet the basic requirements.
		// Note: CLASS_Deprecated is an inherited class flag, so any subclass of an explicitly-deprecated class also cannot be spawned.
		bool bCanSpawnObject = (nullptr != *ObjectClass)
			&& (bAllowAbstract || !ObjectClass->HasAnyClassFlags(CLASS_Abstract))
			&& !ObjectClass->HasAnyClassFlags(CLASS_Deprecated | CLASS_NewerVersionExists);

		// UObject is a special case where if we are allowing abstract we are going to allow it through even though it doesn't have BlueprintType on it
		if (bCanSpawnObject && (!bAllowAbstract || (*ObjectClass != UObject::StaticClass())))
		{
			static const FName BlueprintTypeName(TEXT("BlueprintType"));
			static const FName NotBlueprintTypeName(TEXT("NotBlueprintType"));
			static const FName DontUseGenericSpawnObjectName(TEXT("DontUseGenericSpawnObject"));

			auto IsClassAllowedLambda = [](const UClass* InClass)
			{
				return InClass != AActor::StaticClass()
					&& InClass != UActorComponent::StaticClass();
			};

			// Exclude all types in the initial set by default.
			bCanSpawnObject = false;
			const UClass* CurrentClass = ObjectClass;

			// Climb up the class hierarchy and look for "BlueprintType." If "NotBlueprintType" is seen first, or if the class is not allowed, then stop searching.
			while (!bCanSpawnObject && CurrentClass != nullptr && !CurrentClass->GetBoolMetaData(NotBlueprintTypeName) && IsClassAllowedLambda(CurrentClass))
			{
				// Include any type that either includes or inherits 'BlueprintType'
				bCanSpawnObject = CurrentClass->GetBoolMetaData(BlueprintTypeName);

				// Stop searching if we encounter 'BlueprintType' with 'DontUseGenericSpawnObject'
				if (bCanSpawnObject && CurrentClass->GetBoolMetaData(DontUseGenericSpawnObjectName))
				{
					bCanSpawnObject = false;
					break;
				}

				CurrentClass = CurrentClass->GetSuperClass();
			}

			// If we validated the given class, continue walking up the hierarchy to make sure we exclude it if it's an Actor or ActorComponent derivative.
			while (bCanSpawnObject && CurrentClass != nullptr)
			{
				bCanSpawnObject &= IsClassAllowedLambda(CurrentClass);

				CurrentClass = CurrentClass->GetSuperClass();
			}
		}

		return bCanSpawnObject;
	}
};
```


ï»¿# ExpandBoolAsExecs

- **åŠŸèƒ½æè¿°ï¼š** æ˜¯ExpandEnumAsExecsçš„åˆ«åï¼Œå®Œå…¨ç­‰ä»·å…¶åŠŸèƒ½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ExpandEnumAsExecs](ExpandEnumAsExecs/ExpandEnumAsExecs.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# ExpandEnumAsExecs

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå¤šä¸ªenumæˆ–boolç±»å‹çš„å‡½æ•°å‚æ•°ï¼Œè‡ªåŠ¨æ ¹æ®æ¡ç›®ç”Ÿæˆç›¸åº”çš„å¤šä¸ªè¾“å…¥æˆ–è¾“å‡ºæ‰§è¡Œå¼•è„šï¼Œå¹¶æ ¹æ®å®å‚å€¼ä¸åŒæ¥ç›¸åº”æ”¹å˜æ§åˆ¶æµã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [ExpandBoolAsExecs](../ExpandBoolAsExecs.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šå¤šä¸ªenumæˆ–boolç±»å‹çš„å‡½æ•°å‚æ•°ï¼Œè‡ªåŠ¨æ ¹æ®æ¡ç›®ç”Ÿæˆç›¸åº”çš„å¤šä¸ªè¾“å…¥æˆ–è¾“å‡ºæ‰§è¡Œå¼•è„šï¼Œå¹¶æ ¹æ®å®å‚å€¼ä¸åŒæ¥ç›¸åº”æ”¹å˜æ§åˆ¶æµã€‚

æ”¯æŒæ”¹å˜è¾“å…¥å’Œè¾“å‡ºçš„Execï¼Œè¾“å…¥Execåªå¯ä»¥ä¸€ä¸ªï¼Œä½†æ˜¯è¾“å‡ºExecEnum Pinå¯ä»¥å¤šä¸ªã€‚ä½†æ˜¯ä¸èƒ½ç”¨åœ¨BlueprintPureä¸Šï¼ˆéƒ½æ²¡Execå¼•è„šäº†ï¼‰ã€‚

ä¹Ÿå¯ä»¥é€šè¿‡â€˜|â€™æ¥åˆ†éš”ã€‚

æ”¯æŒ3ç§å‚æ•°ç±»å‹ï¼Œenum classï¼ŒTEnumAsByte<EMyExecPins2::Type>å’Œboolï¼Œeunumå¿…é¡»ç”¨UENUMæ ‡è®°ã€‚

å¼•ç”¨ç±»å‹çš„å‚æ•°å’Œè¿”å›å€¼ç”¨ä½œè¾“å‡ºPinï¼Œå€¼ç±»å‹çš„å‚æ•°ç”¨ä½œè¾“å…¥Pinã€‚
å¯ä»¥ç”¨â€œReturnValueâ€è¿™ä¸ªåå­—æ¥æŒ‡å®šä½¿ç”¨è¿”å›å€¼å‚æ•°ã€‚

å¦‚æœæœ‰å¤šä¸ªè¾“å‡ºEnumå‚æ•°ï¼Œä¼šåœ¨å‡½æ•°çš„è°ƒç”¨ä¹‹åæ’æˆSequeceneæ¥ä¸€ä¸€åˆ†åˆ«æ ¹æ®è¾“å‡ºEnumçš„å€¼æ¥è§¦å‘è¾“å‡ºExecã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UENUM(BlueprintType)
enum class EMyExecPins : uint8
{
	First,
	Second,
	Third,
};

UENUM(BlueprintType)
namespace EMyExecPins2
{
	enum Type : int
	{
		Found,
		NotFound,
	};
}

UENUM(BlueprintType)
enum class EMyExecAnimalPins : uint8
{
	Cat,
	Dog,
};

public:
	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "Pins"))
	static int32 MyEnumAsExec_Output(FString Name, EMyExecPins& Pins) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "Pins"))
	static int32 MyEnumAsExec_Input(FString Name, TEnumAsByte<EMyExecPins2::Type> Pins) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "ReturnValue"))
	static EMyExecPins MyEnumAsExec_Return(FString Name) { return EMyExecPins::First; }
public:
	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "Pins"))
	static int32 MyBoolAsExec_Output(FString Name, bool& Pins) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "Pins"))
	static int32 MyBoolAsExec_Input(FString Name, bool Pins) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "ReturnValue"))
	static bool MyBoolAsExec_Return(FString Name) { return false; }
public:
	UFUNCTION(BlueprintCallable, meta = (ExpandEnumAsExecs = "InPins,OutAnimal|OutPins|ReturnValue"))
	static bool MyEnumAsExec_MultipleOut(FString Name, EMyExecPins InPins, EMyExecAnimalPins& OutAnimal, TEnumAsByte<EMyExecPins2::Type>& OutPins, FString& Result);
```

## è“å›¾æ•ˆæœï¼š

å¯ä»¥å¯¹ç…§ä¸Šè¿°ä¸Šè¿°çš„å‡½æ•°åŸå‹å’Œè“å›¾èŠ‚ç‚¹ï¼Œå¯ä»¥å‘ç°ExpandEnumAsExecsæ‰§è¡Œ3ç§å‚æ•°ç±»å‹ã€‚åŒæ—¶ä¹ŸéªŒè¯äº†åœ¨åŒæ—¶æ‹¥æœ‰å¤šä¸ªè¾“å‡ºEnumå‚æ•°çš„æ—¶å€™(ä»£ç é‡Œæ˜¯OutAnimal|OutPins|ReturnValue)ï¼Œä¼šæŒ‰é¡ºåºæ‰§è¡Œ3æ¬¡è¾“å‡ºï¼Œå°±åƒç”¨SequenceèŠ‚ç‚¹è¿æ¥åœ¨äº†ä¸€èµ·ä¸€æ ·ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Exec\ExpandEnumAsExecs\Untitled.png)

## åŸç†ï¼š

çœŸæ­£çš„åˆ›å»ºPinæ˜¯åœ¨void UK2Node_CallFunction::CreateExecPinsForFunctionCall(const UFunction* Function)ï¼Œç„¶åè¿™äº›æ–°çš„ExecPinå’Œé…å¥—çš„èµ‹å€¼è¾“å…¥å‚æ•°å€¼ï¼Œä»¥åŠæ ¹æ®è¾“å‡ºå‚æ•°æ‰§è¡Œä¸åŒè¾“å‡ºExecPinçš„é€»è¾‘åœ¨UK2Node_CallFunction::ExpandNodeä¸­ã€‚ä»£ç å¤ªå¤šå°±ä¸è´´å‡ºæ¥äº†ã€‚

æ˜¯å¦‚ä½•æ§åˆ¶Execæµå‘çš„ï¼Ÿåœ¨å‡½æ•°çš„å®ç°é‡Œï¼Œåªè¦æŠŠç›¸åº”çš„å¼•ç”¨è¾“å‡ºå‚æ•°èµ‹å€¼ï¼Œå°±è‡ªç„¶ä¼šæµå‘ä¸åŒçš„Pinã€‚è¿™éƒ¨åˆ†é€»è¾‘æ˜¯åœ¨UK2Node_CallFunction::ExpandNodeä¸­å®ç°ã€‚å¤§æ¦‚é€»è¾‘æ˜¯é’ˆå¯¹Inputå¼•è„šï¼Œä¼šåœ¨ä¸­é—´æ’å…¥UK2Node_AssignmentStatementï¼Œæ‰§è¡Œä¸åŒè¾“å…¥Pinï¼Œä¼šç›¸åº”çš„è®¾ç½®è¾“å…¥enumå‚æ•°çš„çš„å€¼ã€‚è€Œé’ˆå¯¹Outputå¼•è„šï¼Œä¼šåœ¨ä¸­é—´æ’å…¥UK2Node_SwitchEnumï¼Œè¿™æ ·å½“æˆ‘ä»¬åœ¨å‡½æ•°ä¸­è®¾ç½®å¼•ç”¨è¾“å‡ºenumå‚æ•°çš„å€¼åï¼Œå°±å¯ä»¥æ ¹æ®enumçš„å€¼ï¼Œæµå‘ç›¸åº”çš„ä¸åŒè¾“å‡ºPinèŠ‚ç‚¹ã€‚è€Œå¯¹boolå‚æ•°ï¼Œä¹Ÿä¼šåˆ›å»ºç›¸åº”çš„ä¸­é—´è“å›¾èŠ‚ç‚¹æ¥è·å–å’Œè®¾ç½®boolå‚æ•°ã€‚

å‡½æ•°åŸå§‹çš„å‚æ•°Pinä¼šè¢«éšè—èµ·æ¥ï¼Œä»è€Œåªæš´éœ²ç”Ÿæˆåçš„Exec Pinã€‚


ï»¿# ExposedAsyncProxy

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ Async Task èŠ‚ç‚¹ä¸­å…¬å¼€æ­¤ç±»çš„ä¸€ä¸ªä»£ç†å¯¹è±¡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** Async Blueprint node
- **å…³è”é¡¹ï¼š** [HideSpawnParms](../Param/HideSpawnParms/HideSpawnParms.md), [HasDedicatedAsyncNode](../HasDedicatedAsyncNode/HasDedicatedAsyncNode.md), [HideThen](../HideThen/HideThen.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨UK2Node_BaseAsyncTaskä¸­ä½¿ç”¨ï¼Œç”¨æ¥ä¸ºè“å›¾å¼‚æ­¥èŠ‚ç‚¹æš´éœ²ä¸€ä¸ªå¼‚æ­¥å¯¹è±¡å¼•è„šï¼Œä»¥æ”¯æŒå¯¹è¿™ä¸ªå¼‚æ­¥è¡Œä¸ºçš„è¿›ä¸€æ­¥æ“ä½œã€‚

åœ¨æºç é‡Œçš„ç”¨å¤„ä¸€æ˜¯UBlueprintAsyncActionBaseçš„å­ç±»ï¼ŒäºŒæ˜¯UGameplayTaskå­ç±»ï¼Œçš†æ˜¯åˆ†åˆ«ä¼šæœ‰å¦å¤–çš„UK2Node_BaseAsyncTaskä»¥åŠUK2Node_LatentGameplayTaskCallæ¥è§£æç±»çš„å£°æ˜å®šä¹‰å¹¶åŒ…è£…ç”Ÿæˆç›¸åº”çš„å¼‚æ­¥è“å›¾èŠ‚ç‚¹ã€‚

åŸºç±»éƒ½æ˜¯ç»§æ‰¿è‡ªUBlueprintAsyncActionBaseã€‚åˆ©ç”¨ExposedAsyncProxy æŒ‡å®šå¼‚æ­¥ä»»åŠ¡å¯¹è±¡çš„åå­—ã€‚åœ¨å¼‚æ­¥è“å›¾èŠ‚ç‚¹ä¸Šç»§ç»­è¿”å›å¼‚æ­¥å¯¹è±¡ï¼Œå¯ä»¥åœ¨ä¹‹åæ”¯æŒå–æ¶ˆè¯¥å¼‚æ­¥æ“ä½œã€‚

## æµ‹è¯•ä»£ç ï¼š

UCancellableAsyncActionæ˜¯å¼•æ“æä¾›çš„ç»§æ‰¿è‡ªUBlueprintAsyncActionBaseçš„ä¸€ä¸ªä¾¿åˆ©çš„å­ç±»ã€‚UMyFunction_Async å®šä¹‰äº†ä¸€ä¸ªè“å›¾å¼‚æ­¥èŠ‚ç‚¹DelayLoopã€‚

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FDelayOutputPin);
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject))
class INSIDER_API UMyFunction_Async :public UBlueprintAsyncActionBase
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Loop;

	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Complete;

	UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true", WorldContext = "WorldContextObject"), Category = "Flow Control")
	static UMyFunction_Async* DelayLoop(const UObject* WorldContextObject, const float DelayInSeconds, const int Iterations);

	virtual void Activate() override;

	UFUNCTION()
	static void Test();
private:
	const UObject* WorldContextObject = nullptr;
	float MyDelay = 0.f;
	int MyIterations = 0;
	bool Active = false;

	UFUNCTION()
	void ExecuteLoop();

	UFUNCTION()
	void ExecuteComplete();
};
```

## é»˜è®¤çš„è“å›¾èŠ‚ç‚¹æ˜¯ï¼š

å¦‚æœUMyFunction_Async ç›´æ¥ç»§æ‰¿è‡ªUBlueprintAsyncActionBaseï¼Œå¹¶ä¸”æ²¡æœ‰è®¾ç½®ExposedAsyncProxyï¼Œåˆ™ç”Ÿæˆçš„è“å›¾å¼‚æ­¥èŠ‚ç‚¹ä¸ºä¸ºä¸‹å›¾ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ExposedAsyncProxy\Untitled.png)

è€Œå¦‚æœç»§æ‰¿è‡ªUCancellableAsyncAction (æä¾›äº†Cancelæ–¹æ³•)ï¼Œå¹¶ä¸”è®¾ç½®ExposedAsyncProxy ä¸ºè‡ªå·±æƒ³è¦çš„AsyncObjectå¼•è„šåç§°ã€‚

```cpp
UCLASS(Abstract, BlueprintType, meta = (ExposedAsyncProxy = AsyncAction), MinimalAPI)
class UCancellableAsyncAction : public UBlueprintAsyncActionBase
{
	UFUNCTION(BlueprintCallable, Category = "Async Action")
	ENGINE_API virtual void Cancel();
}

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FDelayOutputPin);
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction 
{}
```

## ä¿®æ”¹åçš„æ•ˆæœå¦‚ä¸‹å›¾ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ExposedAsyncProxy\Untitled%201.png)

## è¯¥Metaåœ¨æºç ä¸­å‘ç”Ÿçš„ä½ç½®ï¼š

```cpp
void UK2Node_BaseAsyncTask::AllocateDefaultPins()
{
	bool bExposeProxy = false;
	bool bHideThen = false;
	FText ExposeProxyDisplayName;
	for (const UStruct* TestStruct = ProxyClass; TestStruct; TestStruct = TestStruct->GetSuperStruct())
	{
		bExposeProxy |= TestStruct->HasMetaData(TEXT("ExposedAsyncProxy"));
		bHideThen |= TestStruct->HasMetaData(TEXT("HideThen"));
		if (ExposeProxyDisplayName.IsEmpty())
		{
			ExposeProxyDisplayName = TestStruct->GetMetaDataText(TEXT("ExposedAsyncProxy"));
		}
	}

	if (bExposeProxy)
	{
		UEdGraphPin* ProxyPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Object, ProxyClass, FBaseAsyncTaskHelper::GetAsyncTaskProxyName());
		if (!ExposeProxyDisplayName.IsEmpty())
		{
			ProxyPin->PinFriendlyName = ExposeProxyDisplayName;
		}
	}

}
```


ï»¿# ExposeOnSpawn

- **åŠŸèƒ½æè¿°ï¼š** ä½¿è¯¥å±æ€§åœ¨ContructObjectæˆ–SpawnActorç­‰åˆ›å»ºå¯¹è±¡çš„æ—¶å€™æš´éœ²å‡ºæ¥ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä½¿è¯¥å±æ€§åœ¨ContructObjectæˆ–SpawnActorç­‰åˆ›å»ºå¯¹è±¡çš„æ—¶å€™æš´éœ²å‡ºæ¥ã€‚

- å…·ä½“æ¥è¯´ï¼Œé€šè¿‡åœ¨æºç æœç´¢ï¼Œè¿™ä¸ªæ ‡è®°åœ¨UK2Node_AddComponentï¼ŒUK2Node_ConstructObjectFromClassï¼ŒUK2Node_SpawnActorï¼ŒUK2Node_LatentGameplayTaskCallçš„æ—¶å€™ç”¨åˆ°ã€‚
- åœ¨C++é‡Œè®¾ç½®çš„æ•ˆæœç­‰åŒäºåœ¨è“å›¾é‡Œå‹¾ä¸ŠExposeOnSpawnã€‚
- è¯¥metaçš„è®¾ç½®ä¹Ÿä¼šåŒæ—¶è®¾ç½®åˆ°PropertyFlagsé‡Œçš„CPF_ExposeOnSpawn

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_ExposeOnSpawn :public UObject
{
	GENERATED_BODY()
public:
	//	(Category = MyProperty_ExposeOnSpawn, ModuleRelativePath = Property/Blueprint/MyProperty_ExposeOnSpawn.h)
	//	PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FString MyString = TEXT("First");

	//	(Category = MyProperty_ExposeOnSpawn, ExposeOnSpawn = , ModuleRelativePath = Property/Blueprint/MyProperty_ExposeOnSpawn.h)
	//	PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_ExposeOnSpawn | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ExposeOnSpawn))
	FString MyString_ExposeOnSpawn = TEXT("Second");
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyString_ExposeOnSpawn æš´éœ²äº†å‡ºæ¥ï¼Œè€ŒMyString æ²¡æœ‰ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ExposeOnSpawn\Untitled.png)

## åŸç†ï¼š

åœ¨UHTçš„æ—¶å€™ä¼šåˆ†æå¦‚æœåŒ…å«ExposeOnSpawnå°±ä¼šåŒæ­¥è®¾ç½®CPF_ExposeOnSpawnã€‚

è€Œåœ¨IsPropertyExposedOnSpawnè¿™ä¸ªå‡½æ•°é‡Œå…·ä½“åˆ¤æ–­æ˜¯å¦è¦æš´éœ²ï¼Œè¿™ä¸ªå‡½æ•°è¢«ä¸Šè¿°çš„4ä¸ªå‡½æ•°èŠ‚ç‚¹å¼•ç”¨ã€‚æºç é‡Œä¸¾UK2Node_ConstructObjectFromClassé‡Œçš„CreatePinsForClassä½œä¸ºä¾‹å­ï¼Œå¯è§åªæœ‰bIsExposedToSpawn çš„æ—¶å€™æ‰ä¼šä¸ºè“å›¾èŠ‚ç‚¹å¼€å§‹åˆ›å»ºé¢å¤–çš„Pinå¼•è„šã€‚

```cpp
if (propertySettings.MetaData.ContainsKey(UhtNames.ExposeOnSpawn))
{
	propertySettings.PropertyFlags |= EPropertyFlags.ExposeOnSpawn;
}

bool UEdGraphSchema_K2::IsPropertyExposedOnSpawn(const FProperty* Property)
{
	Property = FBlueprintEditorUtils::GetMostUpToDateProperty(Property);
	if (Property)
	{
		const bool bMeta = Property->HasMetaData(FBlueprintMetadata::MD_ExposeOnSpawn);
		const bool bFlag = Property->HasAllPropertyFlags(CPF_ExposeOnSpawn);
		if (bMeta != bFlag)
		{
			const FCoreTexts& CoreTexts = FCoreTexts::Get();

			UE_LOG(LogBlueprint, Warning
				, TEXT("ExposeOnSpawn ambiguity. Property '%s', MetaData '%s', Flag '%s'")
				, *Property->GetFullName()
				, bMeta ? *CoreTexts.True.ToString() : *CoreTexts.False.ToString()
				, bFlag ? *CoreTexts.True.ToString() : *CoreTexts.False.ToString());
		}
		return bMeta || bFlag;
	}
	return false;
}

void UK2Node_ConstructObjectFromClass::CreatePinsForClass(UClass* InClass, TArray<UEdGraphPin*>* OutClassPins)
{
	for (TFieldIterator<FProperty> PropertyIt(InClass, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
{
	FProperty* Property = *PropertyIt;
	UClass* PropertyClass = CastChecked<UClass>(Property->GetOwner<UObject>());
	const bool bIsDelegate = Property->IsA(FMulticastDelegateProperty::StaticClass());
	const bool bIsExposedToSpawn = UEdGraphSchema_K2::IsPropertyExposedOnSpawn(Property);
	const bool bIsSettableExternally = !Property->HasAnyPropertyFlags(CPF_DisableEditOnInstance);

	if(	bIsExposedToSpawn &&
		!Property->HasAnyPropertyFlags(CPF_Parm) && 
		bIsSettableExternally &&
		Property->HasAllPropertyFlags(CPF_BlueprintVisible) &&
		!bIsDelegate &&
		(nullptr == FindPin(Property->GetFName()) ) &&
		FBlueprintEditorUtils::PropertyStillExists(Property))
	{
		if (UEdGraphPin* Pin = CreatePin(EGPD_Input, NAME_None, Property->GetFName()))
		{
}
```


ï»¿# ForceAsFunction

- **åŠŸèƒ½æè¿°ï¼š** æŠŠC++é‡Œç”¨BlueprintImplementableEventæˆ–NativeEventå®šä¹‰çš„äº‹ä»¶å¼ºåˆ¶æ”¹ä¸ºå‡½æ•°åœ¨å­ç±»ä¸­è¦†å†™ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠC++é‡Œç”¨BlueprintImplementableEventæˆ–NativeEventå®šä¹‰çš„äº‹ä»¶å¼ºåˆ¶æ”¹ä¸ºå‡½æ•°åœ¨å­ç±»ä¸­è¦†å†™ã€‚

ä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦æŠŠEventæ”¹æˆå‡½æ•°ï¼Ÿ

- å˜æˆå‡½æ•°åï¼Œåœ¨å®ç°çš„æ—¶å€™å°±å¯ä»¥å®šä¹‰å†…éƒ¨çš„å±€éƒ¨å˜é‡ã€‚å½“ç„¶ä¹Ÿå°±å¤±å»äº†è°ƒç”¨Delayç­‰å»¶æ—¶å‡½æ•°çš„èƒ½åŠ›ã€‚
- äº‹ä»¶ä¸èƒ½æœ‰è¾“å‡ºçš„å‚æ•°ï¼Œä½†æ˜¯å¦‚æœæƒ³è¦ä¸€ä¸ªæœ‰è¾“å‡ºçš„å‡½æ•°åœ¨è“å›¾ç±»é‡Œè¦†å†™ï¼ˆå¾—BlueprintImplementableEventæˆ–NativeEventï¼‰ï¼Œåˆ™é»˜è®¤çš„ä»¥äº‹ä»¶æ–¹å¼é‡è½½æ˜¯ä¸è¡Œçš„ã€‚å› æ­¤è¿™ä¸ªæ—¶å€™æŠŠè¿™ä¸ªäº‹ä»¶å¼ºè¿«æ”¹ä¸ºå‡½æ•°çš„å½¢å¼ï¼Œå°±å¯ä»¥æ­£å¸¸çš„è¦†å†™ã€‚
- å¸¦æœ‰è¾“å‡ºæˆ–è¿”å›å‚æ•°çš„Eventä¼šé»˜è®¤è¢«æ”¹ä¸ºfunctionï¼Œå³ä½¿æ²¡æœ‰åŠ ä¸ŠForceAsFunctionã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_ForceAsFunction :public AActor
{
public:
	GENERATED_BODY()
public:
//FUNC_Native | FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
	void MyNativeEvent_Default(const FString& name);

	//FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	void MyImplementableEvent_Default(const FString& name);

public:
	//(ForceAsFunction = , ModuleRelativePath = Function/MyFunction_ForceAsFunction.h)
	//FUNC_Native | FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, meta = (ForceAsFunction))
	void MyNativeEvent_ForceAsFunction(const FString& name);

	////(ForceAsFunction = , ModuleRelativePath = Function/MyFunction_ForceAsFunction.h)
	//FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent, meta = (ForceAsFunction))
	void MyImplementableEvent_ForceAsFunction(const FString& name);

public:
	//FUNC_Native | FUNC_Event | FUNC_Public | FUNC_HasOutParms | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
	bool MyNativeEvent_Output(const FString& name, int32& OutValue);

	//FUNC_Event | FUNC_Public | FUNC_HasOutParms | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	bool MyImplementableEvent_Output(const FString& name, int32& OutValue);

	//(ForceAsFunction = , ModuleRelativePath = Function/MyFunction_ForceAsFunction.h)
	//FUNC_Native | FUNC_Event | FUNC_Public | FUNC_HasOutParms | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintNativeEvent, meta = (ForceAsFunction))
	bool MyNativeEvent_Output_ForceAsFunction(const FString& name, int32& OutValue);

	//(ForceAsFunction = , ModuleRelativePath = Function/MyFunction_ForceAsFunction.h)
	//FUNC_Event | FUNC_Public | FUNC_HasOutParms | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent, meta = (ForceAsFunction))
	bool MyImplementableEvent_Output_ForceAsFunction(const FString& name, int32& OutValue);
};
```

## è“å›¾ä¸­æ•ˆæœï¼š

åœ¨å‡½æ•°ä¸Šè¦†å†™çš„æ—¶å€™ï¼Œä¼šå‘ç°åªæœ‰MyNativeEvent_Defaultå’ŒMyImplementableEvent_Defaultè¢«é»˜è®¤è¦†å†™ä¸ºäº‹ä»¶ï¼Œå…¶ä»–éƒ½ä»¥å‡½æ•°çš„æ–¹å¼è¢«è¦†å†™ã€‚

å›¾é‡Œå±•ç¤ºäº†MyImplementableEvent_ForceAsFunctionè¢«æ”¹ä¸ºå‡½æ•°åï¼Œå¯ä»¥åœ¨å†…éƒ¨å®šä¹‰å±€éƒ¨å˜é‡ã€‚

ä¹Ÿå±•ç¤ºäº†MyNativeEvent_Outputè¿™ç§æ‹¥æœ‰è¾“å‡ºå‚æ•°çš„äº‹ä»¶è¢«è¦†å†™æˆå‡½æ•°åçš„å‡½æ•°ä½“ã€‚

ä½†æ— è®ºæ˜¯è¦†å†™ä¸ºäº‹ä»¶è¿˜æ˜¯å‡½æ•°ï¼Œè¢«è°ƒç”¨çš„æ—¶å€™ç”¨æ³•å¹¶æ— åŒºåˆ«ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ForceAsFunction\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­ä¸€ä¸ªå‡½æ•°æ˜¯å¦æ˜¯äº‹ä»¶çš„é€»è¾‘ä¸ºä»¥ä¸‹å‡½æ•°ï¼š

ä¸»è¦çœ‹ç¬¬äºŒifå’Œæœ€ååˆ¤æ–­ï¼ŒBlueprintImplementableEventæˆ–NativeEventçš„å‡½æ•°ä¸Šéƒ½ä¼šåŠ ä¸ŠFUNC_BlueprintEventæ ‡ç­¾ï¼Œå› æ­¤å¦‚æœå¸¦æœ‰ForceAsFunctionå…ƒæ•°æ®æˆ–è€…æœ‰è¾“å‡ºå‚æ•°ï¼ˆè¿”å›å€¼ä¹Ÿç®—ï¼‰ï¼Œå°±åªèƒ½æ˜¾ç¤ºä¸ºå‡½æ•°ã€‚

```cpp
bool UEdGraphSchema_K2::FunctionCanBePlacedAsEvent(const UFunction* InFunction)
{
	// First check we are override-able, non-static, non-const and not marked thread safe
	if (!InFunction || !CanKismetOverrideFunction(InFunction) || InFunction->HasAnyFunctionFlags(FUNC_Static|FUNC_Const) || FBlueprintEditorUtils::HasFunctionBlueprintThreadSafeMetaData(InFunction))
	{
		return false;
	}

	// Check if meta data has been set to force this to appear as blueprint function even if it doesn't return a value.
	if (InFunction->HasAllFunctionFlags(FUNC_BlueprintEvent) && InFunction->HasMetaData(FBlueprintMetadata::MD_ForceAsFunction))
	{
		return false;
	}

	// Then look to see if we have any output, return, or reference params
	return !HasFunctionAnyOutputParameter(InFunction);
}
```


ï»¿# GetByRef

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTä¸ºè¯¥å±æ€§ç”Ÿæˆè¿”å›å¼•ç”¨çš„C++ä»£ç 
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** åªç”¨åœ¨SparseClassDataTypes æŒ‡å®šçš„ç»“æ„é‡Œçš„å±æ€§ã€‚
- **å…³è”é¡¹ï¼š** [SparseClassDataTypes](SparseClassDataTypes.md)

æŒ‡å®šUHTä¸ºè¯¥å±æ€§ç”Ÿæˆè¿”å›å¼•ç”¨çš„C++ä»£ç ã€‚

åªç”¨åœ¨SparseClassDataTypes æŒ‡å®šçš„ç»“æ„é‡Œçš„å±æ€§ã€‚

## ä»£ç ä¾‹å­ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMySparseClassData
{
	GENERATED_BODY()

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FString MyString_EditDefault = TEXT("MyName");	
	//FString GetMyString_EditDefault() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault; } \

	// "GetByRef" means that Blueprint graphs access a const ref instead of a copy.
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (GetByRef))
	FString MyString_EditDefault_ReadOnly = TEXT("MyName");	
	//const FString& GetMyString_EditDefault_ReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault_ReadOnly; }
};

UCLASS(Blueprintable, BlueprintType, SparseClassDataTypes = MySparseClassData)
class INSIDER_API AMyActor_SparseClassDataTypes :public AActor
{
	GENERATED_BODY()
}
```

## ç”Ÿæˆçš„ä»£ç ï¼š

å¯è§ï¼Œåè€…ç”Ÿæˆè¿”å›å€¼æ˜¯const FString&è€Œä¸æ˜¯FStringã€‚

```cpp
#define FID_Hello_Source_Insider_Class_Trait_MyClass_SparseClassDataTypes_h_36_SPARSE_DATA_PROPERTY_ACCESSORS \
FString GetMyString_EditDefault() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault; } \
const FString& GetMyString_EditDefault_ReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault_ReadOnly; }
```

## åŸç†ï¼š

UHTä¸­ä¸ºSparseDataTypeç”Ÿæˆä»£ç çš„æ—¶å€™ä¼šåˆ¤æ–­GetByRefæ¥åˆ†åˆ«ç”Ÿæˆä¸åŒçš„æ ¼å¼ä»£ç ã€‚

```cpp
private StringBuilder AppendSparseDeclarations(StringBuilder builder, UhtClass classObj, IEnumerable<UhtScriptStruct> sparseScriptStructs, UhtUsedDefineScopes<UhtProperty> sparseProperties)
{
	if (property.MetaData.ContainsKey(UhtNames.GetByRef))
	{
				builder.Append("const ").AppendSparse(property).Append("& Get").Append(cleanPropertyName).Append("() const");
	}
	else
	{
				builder.AppendSparse(property).Append(" Get").Append(cleanPropertyName).Append("() const");
	}
}
```


ï»¿# HasDedicatedAsyncNode

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [ExposedAsyncProxy](../ExposedAsyncProxy/ExposedAsyncProxy.md)

éšè—UBlueprintAsyncActionBaseå­ç±»é‡Œå·¥å‚æ–¹æ³•è‡ªåŠ¨ç”Ÿæˆçš„è“å›¾å¼‚æ­¥èŠ‚ç‚¹ï¼Œä»¥ä¾¿è‡ªå·±å¯ä»¥æ‰‹åŠ¨è‡ªå®šä¹‰åˆ›å»ºä¸€ä¸ªç›¸åº”çš„UK2Node_XXXã€‚

```cpp
/**
* BlueprintCallable factory functions for classes which inherit from UBlueprintAsyncActionBase will have a special blueprint node created for it: UK2Node_AsyncAction
* You can stop this node spawning and create a more specific one by adding the UCLASS metadata "HasDedicatedAsyncNode"
*/

UCLASS(MinimalAPI)
class UBlueprintAsyncActionBase : public UObject
{}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject,HasDedicatedAsyncNode))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction
{}

//å¯ä»¥è‡ªå®šä¹‰ä¸€ä¸ªK2Node
UCLASS()
class INSIDER_API UK2Node_MyFunctionAsyncAction : public UK2Node_AsyncAction
{
	GENERATED_BODY()

	// UK2Node interface
	virtual void GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const override;
	virtual void AllocateDefaultPins() override;
	// End of UK2Node interface

protected:
	virtual bool HandleDelegates(
		const TArray<FBaseAsyncTaskHelper::FOutputPinAndLocalVariable>& VariableOutputs, UEdGraphPin* ProxyObjectPin,
		UEdGraphPin*& InOutLastThenPin, UEdGraph* SourceGraph, FKismetCompilerContext& CompilerContext) override;
};

void UK2Node_MyFunctionAsyncAction::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	struct GetMenuActions_Utils
	{
		static void SetNodeFunc(UEdGraphNode* NewNode, bool /*bIsTemplateNode*/, TWeakObjectPtr<UFunction> FunctionPtr)
		{
			UK2Node_MyFunctionAsyncAction* AsyncTaskNode = CastChecked<UK2Node_MyFunctionAsyncAction>(NewNode);
			if (FunctionPtr.IsValid())
			{
				UFunction* Func = FunctionPtr.Get();
				FObjectProperty* ReturnProp = CastFieldChecked<FObjectProperty>(Func->GetReturnProperty());

				AsyncTaskNode->ProxyFactoryFunctionName = Func->GetFName();
				AsyncTaskNode->ProxyFactoryClass = Func->GetOuterUClass();
				AsyncTaskNode->ProxyClass = ReturnProp->PropertyClass;
				AsyncTaskNode->NodeComment = TEXT("This is MyCustomK2Node");
			}
		}
	};

	UClass* NodeClass = GetClass();
	ActionRegistrar.RegisterClassFactoryActions<UMyFunction_Async>(FBlueprintActionDatabaseRegistrar::FMakeFuncSpawnerDelegate::CreateLambda([NodeClass](const UFunction* FactoryFunc)->UBlueprintNodeSpawner*
		{
			UBlueprintNodeSpawner* NodeSpawner = UBlueprintFunctionNodeSpawner::Create(FactoryFunc);
			check(NodeSpawner != nullptr);
			NodeSpawner->NodeClass = NodeClass;

			TWeakObjectPtr<UFunction> FunctionPtr = MakeWeakObjectPtr(const_cast<UFunction*>(FactoryFunc));
			NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(GetMenuActions_Utils::SetNodeFunc, FunctionPtr);

			return NodeSpawner;
		}));
}

void UK2Node_MyFunctionAsyncAction::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();
}

bool UK2Node_MyFunctionAsyncAction::HandleDelegates(const TArray<FBaseAsyncTaskHelper::FOutputPinAndLocalVariable>& VariableOutputs, UEdGraphPin* ProxyObjectPin, UEdGraphPin*& InOutLastThenPin, UEdGraph* SourceGraph, FKismetCompilerContext& CompilerContext)
{
	bool bIsErrorFree = true;

	for (TFieldIterator<FMulticastDelegateProperty> PropertyIt(ProxyClass); PropertyIt && bIsErrorFree; ++PropertyIt)
	{
		UEdGraphPin* LastActivatedThenPin = nullptr;
		bIsErrorFree &= FBaseAsyncTaskHelper::HandleDelegateImplementation(*PropertyIt, VariableOutputs, ProxyObjectPin, InOutLastThenPin, LastActivatedThenPin, this, SourceGraph, CompilerContext);
	}

	return bIsErrorFree;
}

```

## è“å›¾æ•ˆæœï¼š

å·¦ä¾§æ˜¯å¼•æ“è‡ªå¸¦çš„UK2Node_AsyncActionç”ŸæˆèŠ‚ç‚¹ï¼Œå³è¾¹æ˜¯è‡ªå®šä¹‰çš„UK2Node_MyFunctionAsyncActionç”Ÿæˆçš„è“å›¾èŠ‚ç‚¹ï¼Œè™½ç„¶åŠŸèƒ½ä¸€è‡´ï¼Œä½†æ˜¯å³è¾¹é¢å¤–åŠ äº†ä¸ªæ³¨é‡Šä»¥ä¾¿åŒºåˆ†ã€‚æœ‰äº†è¿™ä¸ªåŸºç¡€ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨å…¶ä¸­ç»§ç»­é‡è½½æ–¹æ³•è¿›ä¸€æ­¥è‡ªå®šä¹‰ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\HasDedicatedAsyncNode\Untitled.png)

## å½“å‰åœ¨æºç é‡Œæœ‰ä¸¤å¤„åœ°æ–¹ä½¿ç”¨ï¼š

```cpp
UCLASS(BlueprintType, meta = (ExposedAsyncProxy = "AsyncTask", HasDedicatedAsyncNode))
class GAMEPLAYMESSAGES_API UAsyncAction_RegisterGameplayMessageReceiver : public UBlueprintAsyncActionBase
{
	UFUNCTION(BlueprintCallable, Category = Messaging, meta=(WorldContext="WorldContextObject", BlueprintInternalUseOnly="true"))
	static UAsyncAction_RegisterGameplayMessageReceiver* RegisterGameplayMessageReceiver(UObject* WorldContextObject, FEventMessageTag Channel, UScriptStruct* PayloadType, EGameplayMessageMatchType MatchType = EGameplayMessageMatchType::ExactMatch, AActor* ActorContext = nullptr);

}
//ç”±UK2Node_GameplayMessageAsyncActionæ¥è´Ÿè´£åˆ›å»º
void UK2Node_GameplayMessageAsyncAction::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	//...
	UClass* NodeClass = GetClass();
	ActionRegistrar.RegisterClassFactoryActions<UAsyncAction_RegisterGameplayMessageReceiver>(FBlueprintActionDatabaseRegistrar::FMakeFuncSpawnerDelegate::CreateLambda([NodeClass](const UFunction* FactoryFunc)->UBlueprintNodeSpawner*
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintFunctionNodeSpawner::Create(FactoryFunc);
		check(NodeSpawner != nullptr);
		NodeSpawner->NodeClass = NodeClass;

		TWeakObjectPtr<UFunction> FunctionPtr = MakeWeakObjectPtr(const_cast<UFunction*>(FactoryFunc));
		NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(GetMenuActions_Utils::SetNodeFunc, FunctionPtr);

		return NodeSpawner;
	}) );
}

UCLASS(BlueprintType, meta=(ExposedAsyncProxy = "AsyncTask", HasDedicatedAsyncNode))
class UMovieSceneAsyncAction_SequencePrediction : public UBlueprintAsyncActionBase
{
	UFUNCTION(BlueprintCallable, Category=Cinematics)
	static UMovieSceneAsyncAction_SequencePrediction* PredictWorldTransformAtTime(UMovieSceneSequencePlayer* Player, USceneComponent* TargetComponent, float TimeInSeconds);
}
```

## ç”Ÿæˆçš„è“å›¾ï¼š

UAsyncAction_RegisterGameplayMessageReceiverç”±è‡ªå®šä¹‰çš„UK2Node_GameplayMessageAsyncActionæ¥åˆ›å»ºè“å›¾èŠ‚ç‚¹ï¼Œä»è€Œæä¾›äº†ä¸€ä¸ªæ³›å‹çš„Payloadè¾“å‡ºå¼•è„šã€‚è€ŒUMovieSceneAsyncAction_SequencePrediction é‡Œçš„å·¥å‚æ–¹æ³•PredictWorldTransformAtTimeï¼Œç”±äºéšè—äº†è‡ªåŠ¨ç”Ÿæˆçš„ç‰ˆæœ¬ï¼Œåˆæ²¡æœ‰åŠ ä¸ŠBlueprintInternalUseOnlyæ¥æŠ‘åˆ¶UHTç”Ÿæˆçš„ç‰ˆæœ¬ï¼Œå› æ­¤æœ€ç»ˆå‘ˆç°çš„æ˜¯æ™®é€šç‰ˆæœ¬çš„é™æ€å‡½æ•°è“å›¾èŠ‚ç‚¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\HasDedicatedAsyncNode\Untitled%201.png)

## æºç é‡Œçš„ä½œç”¨æœºåˆ¶ï¼š

å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœåœ¨ç±»ä¸Šæœ‰æ‰¾åˆ°HasDedicatedAsyncNodeï¼Œç›´æ¥å°±è¿”å›nullptrï¼Œä¸å†ç”ŸæˆNodeSpawnerï¼Œå› æ­¤å°±é˜»æ­¢äº†è“å›¾èŠ‚ç‚¹çš„ç”Ÿæˆã€‚

```cpp
void UK2Node_AsyncAction::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	ActionRegistrar.RegisterClassFactoryActions<UBlueprintAsyncActionBase>(FBlueprintActionDatabaseRegistrar::FMakeFuncSpawnerDelegate::CreateLambda([NodeClass](const UFunction* FactoryFunc)->UBlueprintNodeSpawner*
	{
		UClass* FactoryClass = FactoryFunc ? FactoryFunc->GetOwnerClass() : nullptr;
		if (FactoryClass && FactoryClass->HasMetaData(TEXT("HasDedicatedAsyncNode")))
		{
			// Wants to use a more specific blueprint node to handle the async action
			return nullptr;
		}
	
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintFunctionNodeSpawner::Create(FactoryFunc);
		check(NodeSpawner != nullptr);
		NodeSpawner->NodeClass = NodeClass;
	
		TWeakObjectPtr<UFunction> FunctionPtr = MakeWeakObjectPtr(const_cast<UFunction*>(FactoryFunc));
		NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateStatic(GetMenuActions_Utils::SetNodeFunc, FunctionPtr);
	
		return NodeSpawner;
	}) );
}
```


ï»¿# HiddenNode

- **åŠŸèƒ½æè¿°ï¼š** æŠŠæŒ‡å®šçš„UBTNodeéšè—ä¸åœ¨å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UBTNode
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŠŠæŒ‡å®šçš„UBTNodeéšè—ä¸åœ¨å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(MinimalAPI,meta = ())
class UMyBT_NotHiddenNode : public UBTDecorator
{
	GENERATED_UCLASS_BODY()

	UPROPERTY(Category = Node, EditAnywhere)
	float MyFloat;
};

UCLASS(MinimalAPI,meta = (HiddenNode))
class UMyBT_HiddenNode : public UBTDecorator
{
	GENERATED_UCLASS_BODY()

	UPROPERTY(Category = Node, EditAnywhere)
	float MyFloat;
};

```

## æµ‹è¯•ç»“æœï¼š

å¯è§åªæœ‰UMyBT_NotHiddenNode æ˜¾ç¤ºäº†å‡ºæ¥ï¼Œè€ŒUMyBT_HiddenNode è¢«éšè—äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\HiddenNode\Untitled.png)

## åŸç†ï¼š

åŸç†æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯åšæŒå…ƒæ•°æ®æ ‡è®°ï¼Œç„¶åè®¾ç½®bIsHidden ã€‚

```cpp
bool FGraphNodeClassHelper::IsHidingClass(UClass* Class)
{
	static FName MetaHideInEditor = TEXT("HiddenNode");

	return 
		Class && 
		((Class->HasAnyClassFlags(CLASS_Native) && Class->HasMetaData(MetaHideInEditor))
		|| ForcedHiddenClasses.Contains(Class));
}

//D:\github\UnrealEngine\Engine\Source\Editor\AIGraph\Private\AIGraphTypes.cpp
void FGraphNodeClassHelper::BuildClassGraph()
{
		for (TObjectIterator<UClass> It; It; ++It)
		{
			UClass* TestClass = *It;
			if (TestClass->HasAnyClassFlags(CLASS_Native) && TestClass->IsChildOf(RootNodeClass))
			{
				
				NewData.bIsHidden = IsHidingClass(TestClass);
		
				NewNode->Data = NewData;
		
				if (TestClass == RootNodeClass)
				{
					RootNode = NewNode;
				}
		
				NodeList.Add(NewNode);
			}
		}
}
```


ï»¿# HideFunctions

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å±æ€§æŸ¥çœ‹å™¨ä¸­ä¸æ˜¾ç¤ºæŒ‡å®šç±»åˆ«ä¸­çš„æ‰€æœ‰å‡½æ•°ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[HideFunctions](../../Specifier/UCLASS/Blueprint/HideFunctions/HideFunctions.md), [ShowFunctions](../../Specifier/UCLASS/Blueprint/ShowFunctions.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# HideThen

- **åŠŸèƒ½æè¿°ï¼š** éšè—å¼‚æ­¥è“å›¾èŠ‚ç‚¹çš„Thenå¼•è„š
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** è“å›¾å¼‚æ­¥èŠ‚ç‚¹
- **å…³è”é¡¹ï¼š** [ExposedAsyncProxy](../ExposedAsyncProxy/ExposedAsyncProxy.md)

åœ¨æºç ä¸­HideThenåªåœ¨UK2Node_BaseAsyncTaskä¸­åˆ¤æ–­ï¼Œå› æ­¤è¿™ä¸ªæ ‡ç­¾åªä½œç”¨äºè“å›¾å¼‚æ­¥èŠ‚ç‚¹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction
{}

UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject,HideThen))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction
{}
```

## ä½¿ç”¨HideThenå‰åå¯¹æ¯”ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\HideThen\Untitled.png)

## æºç ä½ç½®ï¼š

```cpp
void UK2Node_BaseAsyncTask::AllocateDefaultPins()
{
	bool bExposeProxy = false;
	bool bHideThen = false;
	FText ExposeProxyDisplayName;
	for (const UStruct* TestStruct = ProxyClass; TestStruct; TestStruct = TestStruct->GetSuperStruct())
	{
		bExposeProxy |= TestStruct->HasMetaData(TEXT("ExposedAsyncProxy"));
		bHideThen |= TestStruct->HasMetaData(TEXT("HideThen"));
		if (ExposeProxyDisplayName.IsEmpty())
		{
			ExposeProxyDisplayName = TestStruct->GetMetaDataText(TEXT("ExposedAsyncProxy"));
		}
	}

	if (!bHideThen)
	{
		CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);
	}

}
```


ï»¿# IgnoreTypePromotion

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°è¯¥å‡½æ•°ä¸æ”¶å½•è¿›ç±»å‹æå‡å‡½æ•°åº“
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UBlueprintFunctionLibraryå†…çš„BlueprintPureï¼Œä»¥OP_XXXå½¢å¼çš„å‡½æ•°
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æ ‡è®°è¯¥å‡½æ•°ä¸æ”¶å½•è¿›ç±»å‹æå‡å‡½æ•°åº“ã€‚

## è¿™é‡Œæœ‰ä¸‰ä¸ªå…³é”®ç‚¹ï¼š

ä¸€æ˜¯è¯¥å‡½æ•°æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿæˆ–è€…è¯´ä¸€ä¸ªç±»å‹æå‡å‡½æ•°æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿæ ¹æ®IsPromotableFunctionæºç å®šä¹‰ï¼Œè¯¥å‡½æ•°å¿…é¡»å®šä¹‰åœ¨UBlueprintFunctionLibraryä¸­ï¼Œå¿…é¡»æ˜¯BlueprintPureï¼Œä¸”æ˜¯ä»¥æ“ä½œç¬¦â€OP_XXXâ€è¿™ç§åå­—æ ¼å¼çš„å‡½æ•°ï¼Œå…¶ä¸­OPçš„åå­—åœ¨OperatorNamesè¿™ä¸ªå‘½åç©ºé—´ä¸­å¯è§ã€‚ç¤ºä¾‹å¯è§KismetMathLibraryä¸­æœ‰å¤§é‡çš„è¿™ç§ç±»å‹å‡½æ•°ã€‚

äºŒæ˜¯ä»€ä¹ˆæ˜¯ç±»å‹æå‡å‡½æ•°åº“ï¼Ÿæºç ä¸­æœ‰FTypePromotionçš„ç±»ï¼Œé‡Œé¢çš„OperatorTableè®°å½•äº†ä»OPåå­—åˆ°å‡½æ•°åˆ—è¡¨çš„ä¸€ä¸ªMapæ˜ å°„ï¼Œæ¯”å¦‚æ”¯æŒAdd(+)çš„æœ‰å¤šä¸ªAdd_Vectorï¼ŒAdd_Floatç­‰ã€‚å½“æˆ‘ä»¬åœ¨è“å›¾ä¸­å³é”®è¾“å…¥+æˆ–AddèŠ‚ç‚¹çš„æ—¶å€™ï¼Œå‡ºç°çš„é¦–å…ˆæ˜¯ä¸€ä¸ªæ³›å‹çš„+èŠ‚ç‚¹ã€‚ç„¶åå†è¿æ¥åˆ°å…·ä½“çš„å˜é‡ç±»å‹ï¼Œè“å›¾ç³»ç»Ÿæ ¹æ®Pinç±»å‹ä¼šåœ¨FTypePromotion::OperatorTableé‡Œæ‰¾åˆ°æœ€åŒ¹é…çš„Funcæ¥æœ€ç»ˆè°ƒç”¨ï¼Œæˆ–è€…è‡ªåŠ¨çš„åœ¨å†…éƒ¨åšç±»å‹æå‡ã€‚æ¯”å¦‚ä¸‹å›¾çš„+æœ€ç»ˆè°ƒç”¨çš„å°±æ˜¯UKismetMathLibrary::Add_VectorFloatã€‚è¿™ç§æ³›å‹çš„è¿ç®—ç¬¦è°ƒç”¨ï¼Œä½¿å¾—å„ç§åŸºæœ¬ç±»å‹ä¹‹é—´çš„åŸºæœ¬è¿ç®—åœ¨è“å›¾èŠ‚ç‚¹åˆ›å»ºä¸Šæ›´åŠ çš„ä¾¿åˆ©å’Œç»Ÿä¸€ï¼Œä¹Ÿæ–¹ä¾¿ç›´æ¥Add Pinå’Œåœ¨Pinä¸Šç›´æ¥Convertåˆ°å¯å…¼å®¹çš„å…¶ä»–Pinç±»å‹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\IgnoreTypePromotion\Untitled.png)

ä¸‰æ˜¯ä¸ºä»€ä¹ˆæœ‰äº›å‡½æ•°ä¸æƒ³è¢«æ”¶å½•è¿›FTypePromotioné‡Œï¼Ÿåœ¨æºç ä¸­æœç´¢ï¼Œåœ¨KismetMathLibraryä¸­å‘ç°åªæœ‰FDateTimeåŠ ä¸Šäº†IgnoreTypePromotionæ ‡è®°ã€‚è™½ç„¶FDateTimeä¹Ÿå®šä¹‰äº†ä¸€ç³»åˆ—çš„å„ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œæ¯”å¦‚Addï¼ŒSubtractå’Œå…¶ä»–å„ç§æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œä½†æ˜¯FDateTimeåœ¨æ„ä¹‰ä¸Šå’Œå…¶ä»–çš„åŸºæœ¬ç±»å‹å¯äº’ç›¸è¿ç®—ä¸åŒï¼ŒFDateTime+floatæˆ–FDateTime+vectorå¹¶æ— ä»€ä¹ˆæ„ä¹‰ã€‚FDateTimeåªå…è®¸+FDateTimeæˆ–+FTimeSpanã€‚å› æ­¤ç±»ä¼¼FDateTimeè¿™ç§å¹¶ä¸æƒ³å‚ä¸åˆ°å…¶ä»–ç±»å‹çš„ç±»å‹æå‡è½¬æ¢å…³ç³»ä¸­ï¼Œåªæƒ³å®‰é™çš„è‡ªæˆä¸€æ´¾åœ¨è‡ªå·±å°èŒƒå›´å†…è¿ç®—ï¼Œå°±å¯ä»¥åŠ ä¸ŠIgnoreTypePromotionï¼Œä¸å‚ä¸è¿›FTypePromotionè¿™ä¸ªä½“ç³»ã€‚

## æµ‹è¯•ä»£ç ï¼š

å‡è®¾æˆ‘ä»¬æœ‰ä¸ªFGamePropç»“æ„ï¼Œå®šä¹‰äº†æ¸¸æˆé‡Œçš„æˆ˜æ–—å±æ€§ï¼ˆHPï¼ŒAttackï¼ŒDefenseï¼‰è¿™äº›ï¼Œç„¶åæ¸¸æˆä¸­é€šå¸¸è¦ç©¿è£…å¤‡å’ŒåŠ Buffç­‰ç­‰æ“ä½œä¼šè®¡ç®—ä¸ªæœ€ç»ˆçš„å±æ€§ã€‚è¿™ç§FGamePropç»“æ„æˆ‘ä»¬å°±å¯ä»¥ä¸ºä¹‹å®šä¹‰ä¸€ç³»åˆ—çš„åŸºæœ¬è¿ç®—å‡½æ•°ã€‚å¹¶åŠ ä¸ŠIgnoreTypePromotionï¼Œå› ä¸ºè‚¯å®šä¸æƒ³å‚ä¸è¿›TypePromotionï¼Œä¸åˆ«çš„åŸºæœ¬ç±»å‹ç›´æ¥è¿ç®—ï¼ˆfloatï¼Œvectorç­‰è¿™äº›ï¼‰ã€‚

ä¸ºäº†å¯¹æ¯”ï¼Œä»£ç é‡Œä¹Ÿå®šä¹‰ä¸€æ¨¡ä¸€æ ·FGameProp2å’Œä¸€æ ·çš„è¿ç®—å‡½æ•°ï¼Œå”¯ä¸€åŒºåˆ«æ˜¯ä¸åŠ IgnoreTypePromotionï¼Œç„¶åè§‚å¯Ÿæœ€ç»ˆçš„è“å›¾èŠ‚ç‚¹ä¸Šçš„å·®å¼‚ã€‚

```cpp
USTRUCT(BlueprintType)
struct FGameProp
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	double HP;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	double Attack;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	double Defense;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_IgnoreTypePromotion :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	/** Makes a GameProp struct */
	UFUNCTION(BlueprintPure, Category = "Math|GameProp", meta = (IgnoreTypePromotion, NativeMakeFunc))
	static FGameProp MakeGameProp(double HP, double Attack, double Defense) { return FGameProp(); }

	/** Breaks a GameProp into its components */
	UFUNCTION(BlueprintPure, Category = "Math|GameProp", meta = (IgnoreTypePromotion, NativeBreakFunc))
	static void BreakGameProp(FGameProp InGameProp, double& HP, double& Attack, double& Defense) {}

	/** Addition (A + B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp + GameProp", CompactNodeTitle = "+", Keywords = "+ add plus"), Category = "Math|GameProp")
	static FGameProp Add_GameProp(FGameProp A, FGameProp B);

	/** Subtraction (A - B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp - GameProp", CompactNodeTitle = "-", Keywords = "- subtract minus"), Category = "Math|GameProp")
	static FGameProp Subtract_GameProp(FGameProp A, FGameProp B) { return FGameProp(); }

	/** Returns true if the values are equal (A == B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "Equal (GameProp)", CompactNodeTitle = "==", Keywords = "== equal"), Category = "Math|GameProp")
	static bool EqualEqual_GameProp(FGameProp A, FGameProp B) { return true; }

	/** Returns true if the values are not equal (A != B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "Not Equal (GameProp)", CompactNodeTitle = "!=", Keywords = "!= not equal"), Category = "Math|GameProp")
	static bool NotEqual_GameProp(FGameProp A, FGameProp B) { return true; }

	/** Returns true if A is greater than B (A > B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp > GameProp", CompactNodeTitle = ">", Keywords = "> greater"), Category = "Math|GameProp")
	static bool Greater_GameProp(FGameProp A, FGameProp B) { return true; }

	/** Returns true if A is greater than or equal to B (A >= B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp >= GameProp", CompactNodeTitle = ">=", Keywords = ">= greater"), Category = "Math|GameProp")
	static bool GreaterEqual_GameProp(FGameProp A, FGameProp B) { return true; }

	/** Returns true if A is less than B (A < B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp < GameProp", CompactNodeTitle = "<", Keywords = "< less"), Category = "Math|GameProp")
	static bool Less_GameProp(FGameProp A, FGameProp B) { return true; }

	/** Returns true if A is less than or equal to B (A <= B) */
	UFUNCTION(BlueprintPure, meta = (IgnoreTypePromotion, DisplayName = "GameProp <= GameProp", CompactNodeTitle = "<=", Keywords = "<= less"), Category = "Math|GameProp")
	static bool LessEqual_GameProp(FGameProp A, FGameProp B) { return true; }
	};
	

```

## è“å›¾æ•ˆæœï¼š

åŠ äº†IgnoreTypePromotionçš„FGamePropï¼ŒAddçš„æ—¶å€™å°±æ˜¯ç›´æ¥æœ€åŸå§‹çš„Add_GamePropèŠ‚ç‚¹ã€‚è€Œä¸åŠ IgnoreTypePromotionçš„FGameProp2ï¼ŒAddçš„æ—¶å€™äº§ç”Ÿçš„èŠ‚ç‚¹æ˜¯æ³›å‹çš„+ï¼Œå¯ä»¥ç»§ç»­AddPinï¼Œç”šè‡³åœ¨Pinä¸Šå³é”®è¿˜ä¼šå°è¯•å¯»æ‰¾å‘å…¶ä»–ç±»å‹çš„è½¬æ¢ï¼ˆè™½ç„¶è¿™é‡Œç»“æœæ‰¾ä¸åˆ°ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬æ²¡æœ‰å®šä¹‰FGameProp2å’Œå…¶ä»–ç±»å‹çš„è¿ç®—å‡½æ•°ï¼‰ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\IgnoreTypePromotion\Untitled%201.png)

å¦å¤–ä¸€ç‚¹æ˜¯ï¼Œå¦‚æœæ˜¯åœ¨ä¸€ä¸ªç©ºçš„æ³›å‹AddèŠ‚ç‚¹ä¸Šå³é”®ï¼Œä¼šå‘ç°å‡ºç°è½¬æ¢åˆ°FGameProp2çš„é€‰é¡¹ï¼ˆä½†æ˜¯FGamePropå¹¶æ²¡æœ‰ï¼‰ã€‚è¿™ä¹Ÿæ˜¯æ ‡æ˜FGameProp2å­˜åœ¨äºTypePromotionè¿™ä¸ªä½“ç³»é‡Œã€‚ä½†æ˜¯å®é™…ä¸Šæˆ‘ä»¬å¹¶ä¸å¸Œæœ›FGameProp2å‡ºç°è¿™é‡Œï¼Œè¿˜æ˜¯é‚£å¥è¯ï¼Œè¿™ç§ç©æ³•çš„æˆ˜æ–—å±æ€§ï¼Œæœ‰è‡ªå·±çš„è¿ç®—è§„åˆ™ï¼Œå¹¶ä¸æƒ³æºå’Œè¿›åŸºæœ¬ç±»å‹çš„æ•°å­¦è¿ç®—é‡Œã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\IgnoreTypePromotion\Untitled%202.png)

## åŸç†ï¼š

åœ¨ç¼–è¾‘å™¨è®¾ç½®ä¸­ï¼Œæœ‰ä¸ªé€‰é¡¹EnableTypePromotionæ‰“å¼€åï¼Œ å°±ä¼šä½¿å¾—FTypePromotionå¼€å§‹æ”¶é›†å¼•æ“å†…å®šä¹‰çš„æ‰€æœ‰å‡½æ•°ï¼Œå¹¶åˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸ªç±»å‹æå‡å‡½æ•°ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\IgnoreTypePromotion\Untitled%203.png)

ä¸€ä¸ªå‡½æ•°åå¦‚æœå‰é¢åŒ…å«è¿ç®—ç¬¦å‰ç¼€ï¼ˆOperatorNamesé‡Œå®šä¹‰çš„è¿™äº›ï¼‰ï¼Œä¾‹å¦‚Add_XXXï¼Œåˆ™ä¼šè¢«æå–æ“ä½œç¬¦ã€‚è¢«æ³¨å†ŒåŠ å…¥åˆ°è¿™ä¸ªFTypePromotion::OperatorTableæ˜ å°„è¡¨é‡Œçš„å‡½æ•°ï¼Œè¿™æ ·åœ¨è“å›¾é‡Œå³é”®ä¸€äº›æ“ä½œç¬¦çš„æ—¶å€™ï¼ˆæ¯”å¦‚+ï¼‰ï¼Œå°±ä¼šåœ¨è¿™ä¸ªæ˜ å°„è¡¨é‡Œæ‰¾åˆ°æœ€åŒ¹é…çš„å‡½æ•°ã€‚

```cpp
namespace OperatorNames
{
	static const FName NoOp			= TEXT("NO_OP");

	static const FName Add			= TEXT("Add");
	static const FName Multiply		= TEXT("Multiply");
	static const FName Subtract		= TEXT("Subtract");
	static const FName Divide		= TEXT("Divide");
	
	static const FName Greater		= TEXT("Greater");
	static const FName GreaterEq	= TEXT("GreaterEqual");
	static const FName Less			= TEXT("Less");
	static const FName LessEq		= TEXT("LessEqual");
	static const FName NotEq		= TEXT("NotEqual");
	static const FName Equal		= TEXT("EqualEqual");
}

bool const bIsPromotableFunction = TypePromoDebug::IsTypePromoEnabled() && FTypePromotion::IsFunctionPromotionReady(Function);
if (bIsPromotableFunction)
{
	NodeClass = UK2Node_PromotableOperator::StaticClass();
}

bool FTypePromotion::IsPromotableFunction(const UFunction* Function)
{
	TRACE_CPUPROFILER_EVENT_SCOPE(FTypePromotion::IsPromotableFunction);

	// Ensure that we don't have an invalid OpName as well for extra safety when this function 
	// is called outside of this class, not during the OpTable creation process
	FName OpName = GetOpNameFromFunction(Function);
	return Function &&
		Function->HasAnyFunctionFlags(FUNC_BlueprintPure) &&
		Function->GetReturnProperty() &&
		OpName != OperatorNames::NoOp && 
		!IsPinTypeDeniedForTypePromotion(Function) &&
		// Users can deny specific functions from being considered for type promotion
		!Function->HasMetaData(FBlueprintMetadata::MD_IgnoreTypePromotion);
}
```

FTypePromotionæ”¶é›†çš„OperatorTableé‡Œé¢å†…å®¹ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\IgnoreTypePromotion\Untitled%204.png)

ä¸€ä¸ªå‡½æ•°å¦‚æœIsPromotableFunctionï¼Œåœ¨è°ƒç”¨çš„æ—¶å€™å°±ä¼šç”¨UK2Node_PromotableOperatoræ¥ä½œä¸ºè“å›¾èŠ‚ç‚¹ï¼ˆé»˜è®¤æ˜¯UK2Node_CallFunctionï¼‰ï¼ŒUK2Node_PromotableOperatoræ˜¯å…¸å‹çš„ç”¨äºWildcardæ³›å‹çš„äºŒå…ƒè¿ç®—ç¬¦ã€‚å¦‚ä¸‹å›¾çš„Add(+)ã€‚åœ¨è¿™ç§Add çš„å¼•è„šä¸Šå³é”®å¯ä»¥å¼¹å‡ºPinçš„ç±»å‹è½¬æ¢ä»Wildcardåˆ°ç‰¹å®šçš„ç±»å‹ï¼Œå› ä¸ºè¯¥ç»“æ„æœ‰å®šä¹‰Add_XXXçš„å‡½æ•°ï¼Œå¹¶ä¸”æ²¡æœ‰IgnoreTypePromotionï¼Œå› æ­¤å°±è¢«åŒ…å«è¿›äº†TypePromotionçš„æ˜ å°„è¡¨é‡Œã€‚

ä¸Šé¢çš„è¿™ä¸ªPinè½¬æ¢èœå•å°±æ˜¯åœ¨UK2Node_PromotableOperator::CreateConversionMenué‡Œæ”¶é›†çš„ã€‚


ï»¿# IsBlueprintBase

- **åŠŸèƒ½æè¿°ï¼š** è¯´æ˜æ­¤ç±»æ˜¯å¦ä¸ºåˆ›å»ºè“å›¾çš„ä¸€ä¸ªå¯æ¥å—åŸºç±»ï¼Œä¸ UCLASS è¯´æ˜ç¬¦ã€Blueprintable æˆ– 'NotBlueprintable` ç›¸ä¼¼ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UINTERFACE

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[Blueprintable](../../Specifier/UCLASS/Blueprint/Blueprintable/Blueprintable.md), [NotBlueprintable](../../Specifier/UCLASS/Blueprint/NotBlueprintable.md)

  UINTERFACEï¼š[Blueprintable](../../Specifier/UINTERFACE/Blueprint/Blueprintable/Blueprintable.md), [NotBlueprintable](../../Specifier/UINTERFACE/Blueprint/NotBlueprintable/NotBlueprintable.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# IsConversionRoot

- **åŠŸèƒ½æè¿°ï¼š** å…è®¸Actoråœ¨è‡ªèº«ä»¥åŠå­ç±»ä¹‹é—´åšè½¬æ¢

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UINTERFACE

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[ConversionRoot](../../Specifier/UCLASS/Scene/ConversionRoot/ConversionRoot.md)

  UINTERFACEï¼š[ConversionRoot](../../Specifier/UINTERFACE/UHT/ConversionRoot.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# Keywords

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ç³»åˆ—å…³é”®å­—ç”¨äºåœ¨è“å›¾å†…å³é”®æ‰¾åˆ°è¯¥å‡½æ•°
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

Keywordsé‡Œçš„å•è¯å¯ä»¥ç”¨ç©ºæ ¼éš”å¼€ï¼Œä¹Ÿå¯ä»¥é€—å·éš”å¼€ã€‚è¿™é‡Œé¢çš„æ–‡æœ¬æ˜¯ä¼šè¢«è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…æœç´¢ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Keywords :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable,meta=(Keywords="This is a SuperFunc,OtherFunc"))
	static void MyFunc_HasKeyworlds();
};
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Keywords\Untitled.png)

## åŸç†ï¼š

è¯¥Keywordsçš„å†…å®¹ï¼Œæœ€ç»ˆä¼šè¢«FEdGraphSchemaActionæ‰€åº”ç”¨ï¼Œç”¨äºè“å›¾å†…å³é”®èœå•çš„æ–‡æœ¬æœç´¢ã€‚

å¦å¤–æ¯ä¸ªK2Nodeéƒ½å¯ä»¥è¿”å›ä¸€ä¸ªKeywordsã€‚æ•ˆæœåº”è¯¥è·Ÿå‡½æ•°ä¸Šçš„Keywordsä¸€æ ·ã€‚

```cpp
FText UEdGraphNode::GetKeywords() const
{
	return GetClass()->GetMetaDataText(TEXT("Keywords"), TEXT("UObjectKeywords"), GetClass()->GetFullGroupName(false));
}
```


ï»¿# KismetHideOverrides

- **åŠŸèƒ½æè¿°ï¼š** ä¸å…è®¸è¢«è¦†ç›–çš„è“å›¾äº‹ä»¶çš„åˆ—è¡¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

åœ¨æºç ä¸­å‘ç°ALevelScriptActorä¸Šé¢å®šä¹‰äº†å¾ˆå¤šï¼Œç”¨æ¥é˜»æ­¢è¢«è¦†ç›–ã€‚

## æ ·ä¾‹ï¼š

```cpp
UCLASS(notplaceable, meta=(ChildCanTick, KismetHideOverrides = "ReceiveAnyDamage,ReceivePointDamage,ReceiveRadialDamage,ReceiveActorBeginOverlap,ReceiveActorEndOverlap,ReceiveHit,ReceiveDestroyed,ReceiveActorBeginCursorOver,ReceiveActorEndCursorOver,ReceiveActorOnClicked,ReceiveActorOnReleased,ReceiveActorOnInputTouchBegin,ReceiveActorOnInputTouchEnd,ReceiveActorOnInputTouchEnter,ReceiveActorOnInputTouchLeave"), HideCategories=(Collision,Rendering,Transformation), MinimalAPI)
class ALevelScriptActor : public AActor
{}
```

ä½†æ˜¯å®é™…åœ¨LevelScriptActorçš„å­ç±»ä¸­ä¾ç„¶å¯ä»¥è¦†ç›–è¯¥äº‹ä»¶ã€‚æœ‰ä¸€äº›è¢«éšè—çš„Eventæ˜¯å…¶å®é€šè¿‡HideCategoriesæ¥åšåˆ°çš„ã€‚å› æ­¤è¯¥Metaå…¶å®å¹¶æ²¡æœ‰å®ç°ï¼Œå¦‚æœè¦è¾¾åˆ°è¯¥æ•ˆæœï¼Œè¿˜æ˜¯è¦é€šè¿‡HideFunctionsæˆ–HideCategoriesæ¥è¾¾æˆã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\KismetHideOverrides\Untitled.png)

## åŸç†ï¼š

å¯ä»¥çœ‹åˆ°è¿™é‡Œé¢çš„åˆ¤æ–­ï¼Œå¹¶æ²¡æœ‰ç”¨åˆ°è¯¥Meta

```cpp
void SMyBlueprint::CollectAllActions(FGraphActionListBuilderBase& OutAllActions)
{
// Cache potentially overridable functions
UClass* ParentClass = BlueprintObj->SkeletonGeneratedClass ? BlueprintObj->SkeletonGeneratedClass->GetSuperClass() : *BlueprintObj->ParentClass;
for ( TFieldIterator<UFunction> FunctionIt(ParentClass, EFieldIteratorFlags::IncludeSuper); FunctionIt; ++FunctionIt )
{
	const UFunction* Function = *FunctionIt;
	const FName FunctionName = Function->GetFName();

	UClass *OuterClass = CastChecked<UClass>(Function->GetOuter());
	// ignore skeleton classes and convert them into their "authoritative" types so they
	// can be found in the graph
	if(UBlueprintGeneratedClass *GeneratedOuterClass = Cast<UBlueprintGeneratedClass>(OuterClass))
	{
		OuterClass = GeneratedOuterClass->GetAuthoritativeClass();
	}

	if (    UEdGraphSchema_K2::CanKismetOverrideFunction(Function) 
		 && !OverridableFunctionNames.Contains(FunctionName) 
		 && !ImplementedFunctionCache.Contains(FunctionName) 
		 && !FObjectEditorUtils::IsFunctionHiddenFromClass(Function, ParentClass)
		 && !FBlueprintEditorUtils::FindOverrideForFunction(BlueprintObj, OuterClass, Function->GetFName())
		 && Blueprint->AllowFunctionOverride(Function)
	   )
	{
		FText FunctionTooltip = FText::FromString(UK2Node_CallFunction::GetDefaultTooltipForFunction(Function));
		FText FunctionDesc = K2Schema->GetFriendlySignatureName(Function);
		if ( FunctionDesc.IsEmpty() )
		{
			FunctionDesc = FText::FromString(Function->GetName());
		}

		if (Function->HasMetaData(FBlueprintMetadata::MD_DeprecatedFunction))
		{
			FunctionDesc = FBlueprintEditorUtils::GetDeprecatedMemberMenuItemName(FunctionDesc);
		}

		FText FunctionCategory = FObjectEditorUtils::GetCategoryText(Function);

		TSharedPtr<FEdGraphSchemaAction_K2Graph> NewFuncAction = MakeShareable(new FEdGraphSchemaAction_K2Graph(EEdGraphSchemaAction_K2Graph::Function, FunctionCategory, FunctionDesc, FunctionTooltip, 1, NodeSectionID::FUNCTION_OVERRIDABLE));
		NewFuncAction->FuncName = FunctionName;

		OverridableFunctionActions.Add(NewFuncAction);
		OverridableFunctionNames.Add(FunctionName);
	}
}
}
```


ï»¿# Latent

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜ä¸€ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªå»¶è¿Ÿå¼‚æ­¥æ“ä½œ
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [LatentInfo](LatentInfo.md), [NeedsLatentFixup](NeedsLatentFixup.md), [LatentCallbackTarget](LatentCallbackTarget.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æ ‡æ˜ä¸€ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªå»¶è¿Ÿå¼‚æ­¥æ“ä½œï¼Œéœ€è¦é…åˆLatentInfoæ¥ä½¿ç”¨ã€‚

ä¼šå¯¼è‡´åœ¨é€»è¾‘æ‰§è¡Œä¸ŠThenï¼ˆä¹Ÿå«Completeï¼‰å¼•è„šéœ€è¦æ‰‹åŠ¨è§¦å‘ï¼ˆå¼•æ“å†…éƒ¨è§¦å‘ï¼‰ï¼Œä¸”å‡½æ•°å³ä¸Šè§’å¢åŠ æ—¶é’Ÿçš„å›¾æ ‡ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
class FMySleepAction : public FPendingLatentAction
{
public:
	float TimeRemaining;
	FName ExecutionFunction;
	int32 OutputLink;
	FWeakObjectPtr CallbackTarget;

	FMySleepAction(float Duration, const FLatentActionInfo& LatentInfo)
		: TimeRemaining(Duration)
		, ExecutionFunction(LatentInfo.ExecutionFunction)
		, OutputLink(LatentInfo.Linkage)
		, CallbackTarget(LatentInfo.CallbackTarget)
	{
	}

	virtual void UpdateOperation(FLatentResponse& Response) override
	{
		TimeRemaining -= Response.ElapsedTime();
		Response.FinishAndTriggerIf(TimeRemaining <= 0.0f, ExecutionFunction, OutputLink, CallbackTarget);
	}
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Latent :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, meta = (Latent, WorldContext = "WorldContextObject", LatentInfo = "LatentInfo", Duration = "5"))
	static void	MySleep(const UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo)
	{
			if (UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull))
			{
				FLatentActionManager& LatentActionManager = World->GetLatentActionManager();
				if (LatentActionManager.FindExistingAction<FMySleepAction>(LatentInfo.CallbackTarget, LatentInfo.UUID) == NULL)
				{
					LatentActionManager.AddNewAction(LatentInfo.CallbackTarget, LatentInfo.UUID, new FMySleepAction(Duration, LatentInfo));
				}
			}
}

	UFUNCTION(BlueprintCallable, meta = (Latent, WorldContext = "WorldContextObject", Duration = "5"))
	static void	MySleep2(const UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
};
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Latent\Untitled.png)

MySleepå¯ä»¥åƒDelayä¸€æ ·æ­£å¸¸å·¥ä½œã€‚ä½†æ˜¯MySleep2å› ä¸ºæ²¡æœ‰æ ‡æ˜LatentInfoï¼Œå› æ­¤LatentInfoå‡½æ•°å‚æ•°æ²¡æœ‰è¢«è“å›¾ç³»ç»Ÿèµ‹å€¼ï¼Œå¯¼è‡´æ— æ³•å·¥ä½œã€‚

åœ¨æºç é‡ŒLatentä½¿ç”¨çš„éå¸¸é¢‘ç¹ï¼Œæœ€å¸¸è§çš„ä¾‹å­ï¼š

```cpp
UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", Latent = "", LatentInfo = "LatentInfo", DisplayName = "Load Stream Level (by Name)"), Category="Game")
static ENGINE_API void LoadStreamLevel(const UObject* WorldContextObject, FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
	
UFUNCTION(BlueprintCallable, meta = (Latent, LatentInfo = "LatentInfo", WorldContext = "WorldContextObject", BlueprintInternalUseOnly = "true"), Category = "Utilities")
static ENGINE_API void LoadAsset(const UObject* WorldContextObject, TSoftObjectPtr<UObject> Asset, FOnAssetLoaded OnLoaded, FLatentActionInfo LatentInfo);

UFUNCTION(BlueprintCallable, Category="Utilities|FlowControl", meta=(Latent, WorldContext="WorldContextObject", LatentInfo="LatentInfo", Duration="0.2", Keywords="sleep"))
static ENGINE_API void	Delay(const UObject* WorldContextObject, float Duration, struct FLatentActionInfo LatentInfo );
```

å…³äºä½¿ç”¨Latentè¿˜æ˜¯ç»§æ‰¿è‡ªUBlueprintAsyncActionBaseæ¥åˆ›å»ºè“å›¾å¼‚æ­¥èŠ‚ç‚¹çš„å·®å¼‚ï¼Œå¯ä»¥åœ¨ç½‘ä¸Šåˆ«çš„æ–‡ç« æŸ¥çœ‹ã€‚


ï»¿# LatentCallbackTarget

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨FLatentActionInfo::CallbackTargetå±æ€§ä¸Šï¼Œå‘Šè¯‰è“å›¾VMåœ¨å“ªä¸ªå¯¹è±¡ä¸Šè°ƒç”¨å‡½æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [Latent](Latent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ç”¨åœ¨FLatentActionInfo::CallbackTargetå±æ€§ä¸Šï¼Œå‘Šè¯‰è“å›¾VMåœ¨å“ªä¸ªå¯¹è±¡ä¸Šè°ƒç”¨å‡½æ•°ã€‚

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct FLatentActionInfo
{
	GENERATED_USTRUCT_BODY()

	/** Object to execute the function on. */ 
	UPROPERTY(meta=(LatentCallbackTarget = true))
	TObjectPtr<UObject> CallbackTarget;

	//...
};

```

## æºç é‡Œä½œç”¨çš„åœ°æ–¹ï¼š

```cpp
void EmitLatentInfoTerm(FBPTerminal* Term, FProperty* LatentInfoProperty, FBlueprintCompiledStatement* TargetLabel)
{
	// Special case of the struct property emitter.  Needs to emit a linkage property for fixup
	FStructProperty* StructProperty = CastFieldChecked<FStructProperty>(LatentInfoProperty);
	check(StructProperty->Struct == LatentInfoStruct);

	int32 StructSize = LatentInfoStruct->GetStructureSize();
	uint8* StructData = (uint8*)FMemory_Alloca(StructSize);
	StructProperty->InitializeValue(StructData);

	// Assume that any errors on the import of the name string have been caught in the function call generation
	StructProperty->ImportText_Direct(*Term->Name, StructData, NULL, 0, GLog);

	Writer << EX_StructConst;
	Writer << LatentInfoStruct;
	Writer << StructSize;

	checkSlow(Schema);
	for (FProperty* Prop = LatentInfoStruct->PropertyLink; Prop; Prop = Prop->PropertyLinkNext)
	{
		if (TargetLabel && Prop->GetBoolMetaData(FBlueprintMetadata::MD_NeedsLatentFixup))
		{
			// Emit the literal and queue a fixup to correct it once the address is known
			Writer << EX_SkipOffsetConst;
			CodeSkipSizeType PatchUpNeededAtOffset = Writer.EmitPlaceholderSkip();
			JumpTargetFixupMap.Add(PatchUpNeededAtOffset, FCodeSkipInfo(FCodeSkipInfo::Fixup, TargetLabel));
		}
		else if (Prop->GetBoolMetaData(FBlueprintMetadata::MD_LatentCallbackTarget))
		{
			FBPTerminal CallbackTargetTerm;
			CallbackTargetTerm.bIsLiteral = true;
			CallbackTargetTerm.Type.PinSubCategory = UEdGraphSchema_K2::PN_Self;
			EmitTermExpr(&CallbackTargetTerm, Prop);
		}
		else
		{
			// Create a new term for each property, and serialize it out
			FBPTerminal NewTerm;
			if(Schema->ConvertPropertyToPinType(Prop, NewTerm.Type))
			{
				NewTerm.bIsLiteral = true;
				Prop->ExportText_InContainer(0, NewTerm.Name, StructData, StructData, NULL, PPF_None);

				EmitTermExpr(&NewTerm, Prop);
			}
			else
			{
				// Do nothing for unsupported/unhandled property types. This will leave the value unchanged from its constructed default.
				Writer << EX_Nothing;
			}
		}
	}

	Writer << EX_EndStructConst;
}
```


ï»¿# LatentInfo

- **åŠŸèƒ½æè¿°ï¼š** å’ŒLatenté…åˆï¼ŒæŒ‡æ˜å“ªä¸ªå‡½æ•°å‚æ•°æ˜¯LatentInfoå‚æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [Latent](Latent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

Latentçš„å‡½æ•°éœ€è¦FLatentActionInfoæ‰èƒ½å·¥ä½œã€‚FLatentActionInfoé‡Œè®°å½•ç€è¿™ä¸ªå»¶è¿Ÿæ“ä½œçš„IDä»¥åŠä¸‹ä¸€æ­¥è¦æ‰§è¡Œçš„å‡½æ•°åç§°ç­‰ã€‚åœ¨è“å›¾çš„è™šæ‹Ÿæœºè¿è¡Œç¯å¢ƒä¸‹ï¼Œä¸€ä¸ªLatentå‡½æ•°æ‰§è¡Œçš„æ—¶å€™ï¼Œè“å›¾VMä¼šæ”¶é›†å½“å‰çš„å‡½æ•°ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆå…¸å‹çš„æ¯”å¦‚ä¸‹Latentå‡½æ•°è¿æ¥çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œç„¶åç»§ç»­èµ‹å€¼åˆ°Latentå‡½æ•°çš„FLatentActionInfoå‚æ•°ä¸Šï¼Œå†é…åˆFPendingLatentActionæ³¨å†Œåˆ°FLatentActionManageré‡Œé¢å»ã€‚ç­‰æ—¶é—´åˆ°è¾¾æˆ–è€…è§¦å‘æ¡ä»¶è¾¾æˆåï¼ŒFLatentActionManagerä¼šè§¦å‘CallbackTarget->ProcessEvent(ExecutionFunction, &(LinkInfo.LinkID))ï¼Œä»è€Œç»§ç»­æ‰§è¡Œä¸‹å»ã€‚

å¦‚æœæ²¡æœ‰ç”¨LatentInfoæ¥æŒ‡å®šå‡½æ•°å‚æ•°ï¼Œåˆ™å› ä¸ºæ–­äº†LatentInfoçš„èµ‹å€¼æ“ä½œï¼Œå› æ­¤å°±æ— æ³•æ­£å¸¸å·¥ä½œï¼Œè“å›¾æ•ˆæœå›¾è§Latenté¡µé¢ã€‚

LatentInfoå€¼å°±åƒWorldContextä¸€æ ·ï¼Œä¼šè¢«è“å›¾VMç³»ç»Ÿè‡ªåŠ¨çš„å¡«å……å€¼ã€‚å¡«å……å€¼çš„æ“ä½œæ˜¯åœ¨EmitLatentInfoTermé‡Œæ‰§è¡Œçš„ã€‚æŠŠLatentInfoStructçš„å€¼å¡«å……åˆ°LatentInfoçš„å‡½æ•°å‚æ•°é‡Œå»ã€‚LatentInfoçš„å‚æ•°ä½ç½®å¹¶ä¸é‡è¦ã€‚LatentInfoæŒ‡å®šçš„å‡½æ•°å‚æ•°Pinä¼šè¢«éšè—ã€‚

```cpp
void EmitFunctionCall(FKismetCompilerContext& CompilerContext, FKismetFunctionContext& FunctionContext, FBlueprintCompiledStatement& Statement, UEdGraphNode* SourceNode)
{
	if (bIsUbergraph && FuncParamProperty->GetName() == FunctionToCall->GetMetaData(FBlueprintMetadata::MD_LatentInfo))
	{
				EmitLatentInfoTerm(Term, FuncParamProperty, Statement.TargetLabel);
	}
}

void EmitLatentInfoTerm(FBPTerminal* Term, FProperty* LatentInfoProperty, FBlueprintCompiledStatement* TargetLabel)
{
	// Special case of the struct property emitter.  Needs to emit a linkage property for fixup
	FStructProperty* StructProperty = CastFieldChecked<FStructProperty>(LatentInfoProperty);
	check(StructProperty->Struct == LatentInfoStruct);

	int32 StructSize = LatentInfoStruct->GetStructureSize();
	uint8* StructData = (uint8*)FMemory_Alloca(StructSize);
	StructProperty->InitializeValue(StructData);

	// Assume that any errors on the import of the name string have been caught in the function call generation
	StructProperty->ImportText_Direct(*Term->Name, StructData, NULL, 0, GLog);

	Writer << EX_StructConst;
	Writer << LatentInfoStruct;
	Writer << StructSize;

	checkSlow(Schema);
	for (FProperty* Prop = LatentInfoStruct->PropertyLink; Prop; Prop = Prop->PropertyLinkNext)
	{
		if (TargetLabel && Prop->GetBoolMetaData(FBlueprintMetadata::MD_NeedsLatentFixup))
		{
			// Emit the literal and queue a fixup to correct it once the address is known
			Writer << EX_SkipOffsetConst;
			CodeSkipSizeType PatchUpNeededAtOffset = Writer.EmitPlaceholderSkip();
			JumpTargetFixupMap.Add(PatchUpNeededAtOffset, FCodeSkipInfo(FCodeSkipInfo::Fixup, TargetLabel));
		}
		else if (Prop->GetBoolMetaData(FBlueprintMetadata::MD_LatentCallbackTarget))
		{
			FBPTerminal CallbackTargetTerm;
			CallbackTargetTerm.bIsLiteral = true;
			CallbackTargetTerm.Type.PinSubCategory = UEdGraphSchema_K2::PN_Self;
			EmitTermExpr(&CallbackTargetTerm, Prop);
		}
		else
		{
			// Create a new term for each property, and serialize it out
			FBPTerminal NewTerm;
			if(Schema->ConvertPropertyToPinType(Prop, NewTerm.Type))
			{
				NewTerm.bIsLiteral = true;
				Prop->ExportText_InContainer(0, NewTerm.Name, StructData, StructData, NULL, PPF_None);

				EmitTermExpr(&NewTerm, Prop);
			}
			else
			{
				// Do nothing for unsupported/unhandled property types. This will leave the value unchanged from its constructed default.
				Writer << EX_Nothing;
			}
		}
	}

	Writer << EX_EndStructConst;
}
```

LatentInfoä¿¡æ¯çš„æ”¶é›†æ˜¯åœ¨FKCHandler_CallFunction::CreateFunctionCallStatementé‡Œ


ï»¿# NeedsLatentFixup

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨FLatentActionInfo::Linkageå±æ€§ä¸Šï¼Œå‘Šè¯‰è“å›¾VMç”Ÿæˆè·³è½¬ä¿¡æ¯
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [Latent](Latent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

## åœ¨æºç é‡Œæ‰¾åˆ°çš„ç”¨å¤„ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct FLatentActionInfo
{
	GENERATED_USTRUCT_BODY()

	/** The resume point within the function to execute */
	UPROPERTY(meta=(NeedsLatentFixup = true))
	int32 Linkage;

	//...
};

```

## æºç é‡Œå‘æŒ¥ä½œç”¨çš„åœ°æ–¹ï¼š

çœ‹ç€å°±æ˜¯æŠŠLinkageè¿™ä¸ªå±æ€§è¿›è¡Œå•ç‹¬çš„å¤„ç†ã€‚ç”¨æ¥åœ¨JumpTargetFixupMapé‡Œè¿›è¡Œä¸“é—¨çš„è·³è½¬

```cpp
void EmitLatentInfoTerm(FBPTerminal* Term, FProperty* LatentInfoProperty, FBlueprintCompiledStatement* TargetLabel)
{
	// Special case of the struct property emitter.  Needs to emit a linkage property for fixup
	FStructProperty* StructProperty = CastFieldChecked<FStructProperty>(LatentInfoProperty);
	check(StructProperty->Struct == LatentInfoStruct);

	int32 StructSize = LatentInfoStruct->GetStructureSize();
	uint8* StructData = (uint8*)FMemory_Alloca(StructSize);
	StructProperty->InitializeValue(StructData);

	// Assume that any errors on the import of the name string have been caught in the function call generation
	StructProperty->ImportText_Direct(*Term->Name, StructData, NULL, 0, GLog);

	Writer << EX_StructConst;
	Writer << LatentInfoStruct;
	Writer << StructSize;

	checkSlow(Schema);
	for (FProperty* Prop = LatentInfoStruct->PropertyLink; Prop; Prop = Prop->PropertyLinkNext)
	{
		if (TargetLabel && Prop->GetBoolMetaData(FBlueprintMetadata::MD_NeedsLatentFixup))
		{
			// Emit the literal and queue a fixup to correct it once the address is known
			Writer << EX_SkipOffsetConst;
			CodeSkipSizeType PatchUpNeededAtOffset = Writer.EmitPlaceholderSkip();
			JumpTargetFixupMap.Add(PatchUpNeededAtOffset, FCodeSkipInfo(FCodeSkipInfo::Fixup, TargetLabel));
		}
		else if (Prop->GetBoolMetaData(FBlueprintMetadata::MD_LatentCallbackTarget))
		{
			FBPTerminal CallbackTargetTerm;
			CallbackTargetTerm.bIsLiteral = true;
			CallbackTargetTerm.Type.PinSubCategory = UEdGraphSchema_K2::PN_Self;
			EmitTermExpr(&CallbackTargetTerm, Prop);
		}
		else
		{
			// Create a new term for each property, and serialize it out
			FBPTerminal NewTerm;
			if(Schema->ConvertPropertyToPinType(Prop, NewTerm.Type))
			{
				NewTerm.bIsLiteral = true;
				Prop->ExportText_InContainer(0, NewTerm.Name, StructData, StructData, NULL, PPF_None);

				EmitTermExpr(&NewTerm, Prop);
			}
			else
			{
				// Do nothing for unsupported/unhandled property types. This will leave the value unchanged from its constructed default.
				Writer << EX_Nothing;
			}
		}
	}

	Writer << EX_EndStructConst;
}
```


ï»¿# NativeBreakFunc

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°é‡‡ç”¨BreakStructçš„å›¾æ ‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [NativeMakeFunc](NativeMakeFunc/NativeMakeFunc.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å…¶åŠŸèƒ½åœ¨NativeMakeFuncé‡Œå·²ç»è¯´æ˜


ï»¿# NativeConst

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæœ‰C++é‡Œçš„constæ ‡å¿—

- **ä½¿ç”¨ä½ç½®ï¼š** UPARAM

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UPARAMï¼š[Const](../../Specifier/UPARAM/Blueprint/Const/Const.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…


ï»¿# NativeMakeFunc

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°é‡‡ç”¨MakeStructçš„å›¾æ ‡
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [NativeBreakFunc](../NativeBreakFunc.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šä¸€ä¸ªå‡½æ•°é‡‡ç”¨MakeStructçš„å›¾æ ‡ã€‚

è¿™ä¸ªå‡½æ•°çš„å®é™…é€»è¾‘æ˜¯å¦ç¬¦åˆMakeStructçš„è§„èŒƒå¹¶æ²¡æœ‰åšæ£€æµ‹ï¼Œè¯¥æ ‡è®°åªæ˜¯é€ æˆæ˜¾ç¤ºå›¾æ ‡çš„ä¸åŒã€‚å› æ­¤è™½ç„¶æ­£å¸¸æƒ…å†µä¸‹éƒ½æ˜¯æ­é…BlueprintPureï¼Œä½†æ˜¯BlueprintCallableä¹Ÿæ— æ‰€è°“ã€‚ç”šè‡³MakeMyStructNative_Wrongå‡½æ•°çš„ç‰ˆæœ¬æ²¡æœ‰è¿”å›å€¼ä¹Ÿå¯ä»¥ç¼–è¯‘é€šè¿‡ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMyStruct_ForNative
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 X = 0;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Y = 0;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Z = 0;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_NativeMakeBreak :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, meta = (NativeMakeFunc))
	static FMyStruct_ForNative MakeMyStructNative(FString ValueString);

	UFUNCTION(BlueprintPure)
	static FMyStruct_ForNative MakeMyStructNative_NoMeta(FString ValueString);

	UFUNCTION(BlueprintPure, meta = (NativeBreakFunc))
	static void BreakMyStructNative(const FMyStruct_ForNative& InValue, int32& X, int32& Y, int32& Z);
	
	UFUNCTION(BlueprintCallable, meta = (NativeMakeFunc))
	static void MakeMyStructNative_Wrong(FString ValueString);
};
```

## è“å›¾é‡Œæ•ˆæœï¼š

å¯ä»¥çœ‹åˆ°å¦‚æœæ˜¯NoMetaï¼Œåˆ™å‡½æ•°çš„å›¾æ ‡å°±æ˜¯æ ‡å‡†æ˜¯få›¾æ ‡ï¼Œå¦åˆ™åˆ™æ˜¯å¦å¤–çš„å›¾æ ‡ã€‚åŒæ—¶ä¹Ÿæ³¨æ„åˆ°Structå¯ä»¥æœ‰å¤šä¸ªMakeå’ŒBreakå‡½æ•°ï¼Œéƒ½å¯ä»¥åŒæ—¶æ­£å¸¸ä½¿ç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\NativeMakeFunc\Untitled.png)

## åŸç†ï¼š

åœ¨å¼•æ“æºç é‡Œå”¯ä¸€æ‰¾åˆ°çš„åœ°æ–¹æ˜¯å¦‚ä¸‹ä»£ç ã€‚å› æ­¤è¯¥æ ‡è®°å®é™…ä¸Šå¹¶æ²¡æœ‰é€»è¾‘ä¸Šçš„å·®åˆ«ï¼Œä½†æ˜¯åœ¨æ˜¾ç¤ºä¸Šä¼šæœ‰å·®åˆ«ã€‚

å¯ä»¥çœ‹è§é’ˆå¯¹NativeMakeFuncå’ŒNativeBrakeFuncé‡‡ç”¨äº†ä¸åŒçš„å›¾æ ‡ã€‚

```cpp
FSlateIcon UK2Node_CallFunction::GetPaletteIconForFunction(UFunction const* Function, FLinearColor& OutColor)
{
	static const FName NativeMakeFunc(TEXT("NativeMakeFunc"));
	static const FName NativeBrakeFunc(TEXT("NativeBreakFunc"));

	if (Function && Function->HasMetaData(NativeMakeFunc))
	{
		static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "GraphEditor.MakeStruct_16x");
		return Icon;
	}
	else if (Function && Function->HasMetaData(NativeBrakeFunc))
	{
		static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "GraphEditor.BreakStruct_16x");
		return Icon;
	}
	// Check to see if the function is calling an function that could be an event, display the event icon instead.
	else if (Function && UEdGraphSchema_K2::FunctionCanBePlacedAsEvent(Function))
	{
		static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "GraphEditor.Event_16x");
		return Icon;
	}
	else
	{
		OutColor = GetPalletteIconColor(Function);

		static FSlateIcon Icon(FAppStyle::GetAppStyleSetName(), "Kismet.AllClasses.FunctionIcon");
		return Icon;
	}
}

```


ï»¿# NotBlueprintThreadSafe

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨å‡½æ•°ä¸Šï¼Œæ ‡è®°è¿™ä¸ªå‡½æ•°æ˜¯ä¸çº¿ç¨‹å®‰å…¨çš„
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [BlueprintThreadSafe](BlueprintThreadSafe.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…


ï»¿# NotInputConfigurable

- **åŠŸèƒ½æè¿°ï¼š** è®©ä¸€äº›UInputModifierå’ŒUInputTriggerä¸èƒ½åœ¨ProjectSettingsé‡Œé…ç½®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UInputModifierå’ŒUInputTriggerçš„å­ç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

è®©ä¸€äº›UInputModifierå’ŒUInputTriggerä¸èƒ½åœ¨ProjectSettingsé‡Œé…ç½®ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(NotBlueprintable, meta = (DisplayName = "Chorded Action", NotInputConfigurable = "true"))
class ENHANCEDINPUT_API UInputTriggerChordAction : public UInputTrigger
{}

UCLASS(NotBlueprintable, meta = (DisplayName = "Combo (Beta)", NotInputConfigurable = "true"))
class ENHANCEDINPUT_API UInputTriggerCombo : public UInputTrigger
{}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS( meta = (NotInputConfigurable = "true"))
class INSIDER_API UMyInputTrigger_NotInputConfigurable :public UInputTrigger
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere)
	float MyFloat = 123;
};

UCLASS( meta = ())
class INSIDER_API UMyInputTrigger_Configurable :public UInputTrigger
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere)
	float MyFloatConfigurable = 123;
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åªæœ‰UMyInputTrigger_Configurable å¯ä»¥ç¼–è¾‘é»˜è®¤å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\NotInputConfigurable\Untitled.png)

## åŸç†ï¼š

UEnhancedInputDeveloperSettingsçš„UIå®šåˆ¶åŒ–ä¼šæ”¶é›†UInputModifierå’ŒUInputTriggerçš„CDOå¯¹è±¡ï¼Œç„¶åæ ¹æ®NotInputConfigurableè¿‡æ»¤æ‰ä¸€äº›ä¸èƒ½é…ç½®çš„ã€‚

```cpp

	GatherNativeClassDetailsCDOs(UInputModifier::StaticClass(), ModifierCDOs);
	GatherNativeClassDetailsCDOs(UInputTrigger::StaticClass(), TriggerCDOs);
	
	
void FEnhancedInputDeveloperSettingsCustomization::GatherNativeClassDetailsCDOs(UClass* Class, TArray<UObject*>& CDOs)
{
			// Strip objects with no config stored properties
		CDOs.RemoveAll([Class](UObject* Object) {
			UClass* ObjectClass = Object->GetClass();
			if (ObjectClass->GetMetaData(TEXT("NotInputConfigurable")).ToBool())
			{
				return true;
			}
			while (ObjectClass)
			{
				for (FProperty* Property : TFieldRange<FProperty>(ObjectClass, EFieldIteratorFlags::ExcludeSuper, EFieldIteratorFlags::ExcludeDeprecated))
				{
					if (Property->HasAnyPropertyFlags(CPF_Config))
					{
						return false;
					}
				}
		
				// Stop searching at the base type. We don't care about configurable properties lower than that.
				ObjectClass = ObjectClass != Class ? ObjectClass->GetSuperClass() : nullptr;
			}
			return true;
		});
}
```


ï»¿# ObjectSetType

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šç»Ÿè®¡é¡µé¢çš„å¯¹è±¡é›†åˆç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šç»Ÿè®¡é¡µé¢çš„å¯¹è±¡é›†åˆç±»å‹ã€‚

å±äºStatVieweræ¨¡å—ï¼Œåªåœ¨å›ºå®šçš„å†…éƒ¨å‡ ä¸ªç±»ä¸Šä½¿ç”¨ã€‚

## æºç ä¾‹å­ï¼š

```cpp

/** Enum defining the object sets for this stats object */
UENUM()
enum EPrimitiveObjectSets : int
{
	PrimitiveObjectSets_AllObjects			UMETA( DisplayName = "All Objects" , ToolTip = "View primitive statistics for all objects in all levels" ),
	PrimitiveObjectSets_CurrentLevel		UMETA( DisplayName = "Current Level" , ToolTip = "View primitive statistics for objects in the current level" ),
	PrimitiveObjectSets_SelectedObjects		UMETA( DisplayName = "Selected Objects" , ToolTip = "View primitive statistics for selected objects" ),
};

/** Statistics page for primitives.  */
UCLASS(Transient, MinimalAPI, meta=( DisplayName = "Primitive Stats", ObjectSetType = "EPrimitiveObjectSets" ) )
class UPrimitiveStats : public UObject
{}
```

## ç›¸åº”æ•ˆæœï¼š

åœ¨ç»Ÿè®¡é¡µé¢ï¼Œå¯è§å³ä¸Šè§’çš„ç±»å‹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ObjectSetType\Untitled.png)

## åŸç†ï¼š

```cpp
template <typename Entry>
class FStatsPage : public IStatsPage
{
public:
	FStatsPage()
	{
		FString EnumName = Entry::StaticClass()->GetName();
		EnumName += TEXT(".");
		EnumName += Entry::StaticClass()->GetMetaData( TEXT("ObjectSetType") );
		ObjectSetEnum = FindObject<UEnum>( nullptr, *EnumName );
		bRefresh = false;
		bShow = false;
		ObjectSetIndex = 0;
	}
};
```


ï»¿# ArrayParm

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨Array<*>çš„å‡½æ•°ï¼Œæ•°ç»„å…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [ArrayTypeDependentParams](../ArrayTypeDependentParams/ArrayTypeDependentParams.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨Array<*>çš„å‡½æ•°ï¼Œæ•°ç»„å…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚

åœ¨å†…éƒ¨é€»è¾‘ä¸Šçš„å¤„ç†åŒºåˆ«æ˜¯æœ‰ArrayParmçš„ä¼šé‡‡ç”¨UK2Node_CallArrayFunctionæ¥ç”ŸæˆèŠ‚ç‚¹ï¼Œè€Œä¸æ˜¯UK2Node_CallFunctionã€‚

ArrayParamå¯ä»¥æŒ‡å®šå¤šä¸ªï¼Œç”¨é€—å·åˆ†éš”å¼€ã€‚

åœ¨æºç é‡Œåªåœ¨UKismetArrayLibraryé‡Œä½¿ç”¨ï¼Œä½†å¦‚æœè‡ªå·±ä¹Ÿæƒ³é¡¶ä¸€ä¸ªæ•°ç»„çš„æ“ä½œï¼Œåˆ™ä¹Ÿå¯ä»¥åŠ ä¸ŠArrayParamã€‚

å› ä¸ºæ•°ç»„å…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ï¼Œå› æ­¤åœ¨C++ä¸­å®ç°çš„æ—¶å€™ï¼Œè¦é…åˆCustomThunkæ¥è‡ªå·±å†™ä¸€äº›è“å›¾é€»è¾‘èƒ¶æ°´ä»£ç æ‰å¥½æ­£ç¡®å¤„ç†ä¸åŒçš„æ•°ç»„ç±»å‹ã€‚è¿™éƒ¨åˆ†å¯ä»¥å‚ç…§æºç é‡ŒUKismetArrayLibraryçš„æ ·ä¾‹æ¨¡ä»¿ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Param :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
//Array
	UFUNCTION(BlueprintPure, CustomThunk, meta = (ArrayParm = "TargetArray"))
	static int32 MyArray_Count(const TArray<int32>& TargetArray);
	static int32 GenericMyArray_Count(const void* TargetArray, const FArrayProperty* ArrayProp);
	DECLARE_FUNCTION(execMyArray_Count);

	UFUNCTION(BlueprintPure, CustomThunk, meta = (ArrayParm = "ArrayA,ArrayB", ArrayTypeDependentParams = "ArrayB"))
	static int32 MyArray_CompareSize(const TArray<int32>& ArrayA, const TArray<int32>& ArrayB);
	static int32 GenericMyArray_CompareSize(void* ArrayA, const FArrayProperty* ArrayAProp, void* ArrayB, const FArrayProperty* ArrayBProp);
	DECLARE_FUNCTION(execMyArray_CompareSize);
};
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\ArrayParm\Untitled.png)

å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æ²¡æœ‰è¿æ¥å…·ä½“æ•°ç»„ç±»å‹çš„æ—¶å€™ï¼ŒArrayæ˜¯ç°è‰²çš„é€šé…ç¬¦ç±»å‹ã€‚è€Œè¿æ¥ä¸Šä¸åŒçš„æ•°ç»„ç±»å‹ï¼ŒArrayå‚æ•°å¼•è„šå°±ä¼šè‡ªåŠ¨å˜æˆç›¸åº”çš„ç±»å‹ï¼Œè¿™äº›é€»è¾‘æ˜¯åœ¨UK2Node_CallArrayFunctionä¸­å®ç°çš„ï¼Œæœ‰å…´è¶£çš„å»è‡ªè¡Œç¿»é˜…ã€‚


ï»¿# ArrayTypeDependentParams

- **åŠŸèƒ½æè¿°ï¼š** å½“ArryParamæŒ‡å®šçš„å‡½æ•°æ‹¥æœ‰ä¸¤ä¸ªæˆ–ä»¥ä¸ŠArrayå‚æ•°çš„æ—¶å€™ï¼ŒæŒ‡å®šå“ªäº›æ•°ç»„å‚æ•°çš„ç±»å‹ä¹Ÿåº”è¯¥ç›¸åº”çš„è¢«æ›´æ–°æ”¹å˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ArrayParm](../ArrayParm/ArrayParm.md)

å½“ArryParamæŒ‡å®šçš„å‡½æ•°æ‹¥æœ‰ä¸¤ä¸ªæˆ–ä»¥ä¸ŠArrayå‚æ•°çš„æ—¶å€™ï¼ŒæŒ‡å®šå“ªäº›æ•°ç»„å‚æ•°çš„ç±»å‹ä¹Ÿåº”è¯¥ç›¸åº”çš„è¢«æ›´æ–°æ”¹å˜ã€‚

æŒ‡æ˜ä¸€ä¸ªå‚æ•°çš„ç±»å‹ï¼Œç”¨äºç¡®å®šArrayParamçš„å€¼ç±»å‹

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Param :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
//Array

	UFUNCTION(BlueprintPure, CustomThunk, meta = (ArrayParm = "ArrayA,ArrayB", ArrayTypeDependentParams = "ArrayB"))
	static int32 MyArray_CompareSize(const TArray<int32>& ArrayA, const TArray<int32>& ArrayB);
	static int32 GenericMyArray_CompareSize(void* ArrayA, const FArrayProperty* ArrayAProp, void* ArrayB, const FArrayProperty* ArrayBProp);
	DECLARE_FUNCTION(execMyArray_CompareSize);
};
```

å¦‚æœæ²¡æœ‰ArrayTypeDependentParamsï¼Œåœ¨è¿æ¥ArrayAåï¼ŒArrayBçš„ç±»å‹ä¾ç„¶æ²¡æœ‰ç¡®å®šï¼Œå³ä½¿è¿æ¥ä¸Šäº†ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œè¿™åº”è¯¥æ˜¯å¼•æ“çš„å®ç°æ‰€é™åˆ¶ã€‚ç¼–è¯‘ä¼šé€ æˆç¼–è¯‘é”™è¯¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\ArrayTypeDependentParams\Untitled.png)

å› æ­¤ArrayTypeDependentParamså¯ä»¥æŒ‡å®šå¦å¤–çš„æ•°ç»„å‚æ•°ï¼Œå…¶ç±»å‹ä¼šç”±åˆ«çš„ï¼ˆç¬¬ä¸€ä¸ªï¼‰æ•°ç»„å®é™…å‚æ•°æ‰€å†³å®šï¼Œå³typeof(ArrayB)=typeof(ArrayA)ã€‚åœ¨ç¤ºä¾‹ä»£ç é‡Œæ‰€ç¤ºåŠ ä¸ŠArrayBä½œä¸ºArrayTypeDependentParams ä¹‹åï¼ŒMyArrayBæ— è®ºæ˜¯å…ˆè¿æ¥åˆ°ArrayAè¿˜æ˜¯ArrayBéƒ½å¯ä»¥è§¦å‘äºŒè€…æ”¹å˜ä¸ºä¸€è‡´çš„æ•°ç»„ç±»å‹ã€‚è¿™æ˜¯å› ä¸ºArrayAä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¤©ç”Ÿåœ¨å¼•æ“å†…å·²ç»å®ç°äº†ç¬¬ä¸€ä¸ªå‚æ•°çš„åŠ¨æ€ç±»å‹å®æ—¶å˜åŒ–ã€‚å› æ­¤æˆ‘ä»¬åªè¦å†åŠ ä¸ŠArrayBå°±å¥½äº†ã€‚

## åŸç†ï¼š

å¼•æ“å†…å·²ç»å®ç°äº†ç¬¬ä¸€ä¸ªå‚æ•°çš„åŠ¨æ€ç±»å‹å®æ—¶å˜åŒ–ï¼š

```cpp
void UK2Node_CallArrayFunction::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	UEdGraphPin* TargetArrayPin = GetTargetArrayPin();
	if (ensureMsgf(TargetArrayPin, TEXT("%s"), *GetFullName()))
	{
		TargetArrayPin->PinType.ContainerType = EPinContainerType::Array;
		TargetArrayPin->PinType.bIsReference = true;
		TargetArrayPin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
		TargetArrayPin->PinType.PinSubCategory = NAME_None;
		TargetArrayPin->PinType.PinSubCategoryObject = nullptr;
	}

	TArray< FArrayPropertyPinCombo > ArrayPins;
	GetArrayPins(ArrayPins);
	for(auto Iter = ArrayPins.CreateConstIterator(); Iter; ++Iter)
	{
		if(Iter->ArrayPropPin)
		{
			Iter->ArrayPropPin->bHidden = true;
			Iter->ArrayPropPin->bNotConnectable = true;
			Iter->ArrayPropPin->bDefaultValueIsReadOnly = true;
		}
	}

	PropagateArrayTypeInfo(TargetArrayPin);
}
```

å…³äºArrayDependentParamçš„ä½œç”¨æœºåˆ¶ï¼Œå¯ä»¥å‚ç…§UK2Node_CallArrayFunctioné‡Œçš„NotifyPinConnectionListChangedå’ŒPropagateArrayTypeInfoè¿™ä¸¤ä¸ªå‡½æ•°çš„å®ç°ï¼Œå¯ä»¥çœ‹åˆ°å…¶ä»–çš„æ•°ç»„å‚æ•°Pinç±»å‹è¢«åŠ¨æ€çš„ä¿®æ”¹ä¸ºSourcePinçš„ç±»å‹ã€‚


ï»¿# AutoCreateRefTerm

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå‡½æ•°çš„å¤šä¸ªè¾“å…¥å¼•ç”¨å‚æ•°åœ¨æ²¡æœ‰è¿æ¥çš„æ—¶å€™è‡ªåŠ¨ä¸ºå…¶åˆ›å»ºé»˜è®¤å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šå‡½æ•°çš„å¤šä¸ªè¾“å…¥å¼•ç”¨å‚æ•°åœ¨æ²¡æœ‰è¿æ¥çš„æ—¶å€™è‡ªåŠ¨ä¸ºå…¶åˆ›å»ºé»˜è®¤å€¼ã€‚

è¦æ³¨æ„â€œè¾“å…¥â€+â€œå¼•ç”¨â€ï¼Œè¿™ä¸¤ä¸ªå‰æé¡¹ã€‚

å½“æœ‰äº›æƒ…å†µä½ æƒ³æŠŠå‡½æ•°çš„å‚æ•°é‡‡ç”¨å¼•ç”¨æ¥ä¼ é€’ï¼Œä½†æ˜¯åˆä¸æƒ³æ¯æ¬¡éƒ½å¾—å¿…é¡»è¿æ¥ä¸€ä¸ªå˜é‡ï¼Œæƒ³åœ¨ä¸è¿æ¥çš„æ—¶å€™æä¾›ä¸€ä¸ªå†…è”ç¼–è¾‘çš„é»˜è®¤å€¼ï¼Œå› æ­¤è“å›¾ç³»ç»Ÿå°±æä¾›äº†è¿™ä¹ˆä¸€ä¸ªä¾¿åˆ©åŠŸèƒ½ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (AutoCreateRefTerm = "Location,Value"))
	static bool MyFunc_HasAutoCreateRefTerm(const FVector& Location, const int32& Value) { return false; }

	UFUNCTION(BlueprintCallable)
	static bool MyFunc_NoAutoCreateRefTerm(const FVector& Location, const int32& Value) { return false; }

	UFUNCTION(BlueprintCallable)
	static bool MyFunc_NoRef(FVector Location, int32 Value) { return false; }
```

## è“å›¾æ•ˆæœï¼š

å¯ä»¥è§åˆ°MyFunc_NoAutoCreateRefTermçš„å‡½æ•°ä¼šäº§ç”Ÿç¼–è¯‘çš„æŠ¥é”™ï¼Œå› ä¸ºæ˜¯å¼•ç”¨å‚æ•°ä½†æ˜¯å´æ²¡æœ‰è¿æ¥ï¼Œå¯¼è‡´å¼•ç”¨ç¼ºå°‘å®å‚ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\AutoCreateRefTerm\Untitled.png)

## åŸç†ä»£ç ï¼š

```cpp
void UEdGraphSchema_K2::GetAutoEmitTermParameters(const UFunction* Function, TArray<FString>& AutoEmitParameterNames)
{
	AutoEmitParameterNames.Reset();

	const FString& MetaData = Function->GetMetaData(FBlueprintMetadata::MD_AutoCreateRefTerm);
	if (!MetaData.IsEmpty())
	{
		MetaData.ParseIntoArray(AutoEmitParameterNames, TEXT(","), true);

		for (int32 NameIndex = 0; NameIndex < AutoEmitParameterNames.Num();)
		{
			FString& ParameterName = AutoEmitParameterNames[NameIndex];
			ParameterName.TrimStartAndEndInline();
			if (ParameterName.IsEmpty())
			{
				AutoEmitParameterNames.RemoveAtSwap(NameIndex);
			}
			else
			{
				++NameIndex;
			}
		}
	}

	// Allow any params that are blueprint defined to be autocreated:
	if (!FBlueprintEditorUtils::IsNativeSignature(Function))
	{
		for (	TFieldIterator<FProperty> ParamIter(Function, EFieldIterationFlags::Default); 
				ParamIter && (ParamIter->PropertyFlags & CPF_Parm); 
				++ParamIter)
		{
			FProperty* Param = *ParamIter;
			if(Param->HasAnyPropertyFlags(CPF_ReferenceParm))
			{
				AutoEmitParameterNames.Add(Param->GetName());
			}
		}
	}
}

è¿˜æœ‰åœ¨
void UK2Node_CallFunction::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
if ( Function )
{
	TArray<FString> AutoCreateRefTermPinNames;
	CompilerContext.GetSchema()->GetAutoEmitTermParameters(Function, AutoCreateRefTermPinNames);
	const bool bHasAutoCreateRefTerms = AutoCreateRefTermPinNames.Num() != 0;

	for (UEdGraphPin* Pin : Pins)
	{
		const bool bIsRefInputParam = Pin && Pin->PinType.bIsReference && (Pin->Direction == EGPD_Input) && !CompilerContext.GetSchema()->IsMetaPin(*Pin);
		if (!bIsRefInputParam)
		{
			continue;
		}

		const bool bHasConnections = Pin->LinkedTo.Num() > 0;
		const bool bCreateDefaultValRefTerm = bHasAutoCreateRefTerms && 
			!bHasConnections && AutoCreateRefTermPinNames.Contains(Pin->PinName.ToString());

		if (bCreateDefaultValRefTerm)
		{
			const bool bHasDefaultValue = !Pin->DefaultValue.IsEmpty() || Pin->DefaultObject || !Pin->DefaultTextValue.IsEmpty();

			// copy defaults as default values can be reset when the pin is connected
			const FString DefaultValue = Pin->DefaultValue;
			UObject* DefaultObject = Pin->DefaultObject;
			const FText DefaultTextValue = Pin->DefaultTextValue;
			bool bMatchesDefaults = Pin->DoesDefaultValueMatchAutogenerated();

			UEdGraphPin* ValuePin = InnerHandleAutoCreateRef(this, Pin, CompilerContext, SourceGraph, bHasDefaultValue);
			if ( ValuePin )
			{
				if (bMatchesDefaults)
				{
					// Use the latest code to set default value
					Schema->SetPinAutogeneratedDefaultValueBasedOnType(ValuePin);
				}
				else
				{
					ValuePin->DefaultValue = DefaultValue;
					ValuePin->DefaultObject = DefaultObject;
					ValuePin->DefaultTextValue = DefaultTextValue;
				}
			}
		}
		// since EX_Self does not produce an addressable (referenceable) FProperty, we need to shim
		// in a "auto-ref" term in its place (this emulates how UHT generates a local value for 
		// native functions; hence the IsNative() check)
		else if (bHasConnections && Pin->LinkedTo[0]->PinType.PinSubCategory == UEdGraphSchema_K2::PSC_Self && Pin->PinType.bIsConst && !Function->IsNative())
		{
			InnerHandleAutoCreateRef(this, Pin, CompilerContext, SourceGraph, /*bForceAssignment =*/true);
		}
	}
}
}
```


ï»¿# CustomStructureParam

- **åŠŸèƒ½æè¿°ï¼š** è¢«CustomStructureParamæ ‡è®°çš„å‡½æ•°å‚æ•°ä¼šå˜æˆWildcardçš„é€šé…ç¬¦å‚æ•°ï¼Œå…¶å¼•è„šçš„ç±»å‹ä¼šç­‰äºè¿æ¥çš„å˜é‡ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

è¢«CustomStructureParamæ ‡è®°çš„å¤šä¸ªå‡½æ•°å‚æ•°ä¼šå˜æˆWildcardçš„é€šé…ç¬¦å‚æ•°ï¼Œå…¶å¼•è„šçš„ç±»å‹ä¼šç­‰äºè¿æ¥çš„å˜é‡ç±»å‹ã€‚

CustomStructureParamæ€»æ˜¯å’ŒCustomThunkä¸€èµ·é…åˆä½¿ç”¨ï¼Œè¿™æ ·æ‰èƒ½åœ¨è‡ªå·±çš„å‡½æ•°ä½“å†…æ¥å¤„ç†æ³›å‹çš„å‚æ•°ç±»å‹ã€‚

```cpp
UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = "PrintStructFields", CustomStructureParam = "inputStruct"))
static FString PrintStructFields(const int32& inputStruct) { return TEXT(""); }

DECLARE_FUNCTION(execPrintStructFields);
static FString Generic_PrintStructFields(const UScriptStruct* ScriptStruct, const void* StructData);

DEFINE_FUNCTION(UMyFunction_Custom::execPrintStructFields)
{
	FString result;
	Stack.MostRecentPropertyAddress = nullptr;
	Stack.StepCompiledIn<FStructProperty>(nullptr);

	void* StructData = Stack.MostRecentPropertyAddress;
	FStructProperty* StructProperty = CastField<FStructProperty>(Stack.MostRecentProperty);
	UScriptStruct* ScriptStruct = StructProperty->Struct;
	P_FINISH;
	P_NATIVE_BEGIN;

	result = Generic_PrintStructFields(ScriptStruct, StructData);

	P_NATIVE_END;
	*(FString*)RESULT_PARAM = result;
}

FString UMyFunction_Custom::Generic_PrintStructFields(const UScriptStruct* ScriptStruct, const void* StructData)
{
	FString str;
	for (TFieldIterator<FProperty> i(ScriptStruct); i; ++i)
	{
		FString propertyValueString;
		const void* propertyValuePtr = i->ContainerPtrToValuePtr<const void*>(StructData);
		i->ExportTextItem_Direct(propertyValueString, propertyValuePtr, nullptr, (UObject*)ScriptStruct, PPF_None);

		str += FString::Printf(TEXT("%s:%s\n"), *i->GetFName().ToString(), *propertyValueString);
	}

	return str;
}

```

## è“å›¾ä¸­çš„æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\CustomStructureParam\Untitled.png)

å¯ä»¥çœ‹åˆ°å®šä¹‰äº†ä¸€ä¸ªæ¥å—é€šç”¨ç»“æ„å‚æ•°çš„èŠ‚ç‚¹ï¼Œç„¶åæ‰“å°å‡ºå†…éƒ¨æ‰€æœ‰çš„å±æ€§ã€‚å…¶ä¸­CustomStructureParam æŒ‡å®šå‡½æ•°çš„å‚æ•°æ˜¯è‡ªå®šä¹‰çš„ç±»å‹ã€‚

æºç ä¸­çš„å…¸å‹ä¾‹å­æ˜¯

```cpp
UFUNCTION(BlueprintCallable, CustomThunk, Category = "DataTable", meta=(CustomStructureParam = "OutRow", BlueprintInternalUseOnly="true"))
static ENGINE_API bool GetDataTableRowFromName(UDataTable* Table, FName RowName, FTableRowBase& OutRow);
```

## åŸç†ï¼š

é¦–å…ˆæ‹¥æœ‰CustomStructureParamçš„å‚æ•°ä¼šè¢«è¯†åˆ«ä¸ºWildcardå±æ€§ã€‚ç„¶åé€šè¿‡FCustomStructureParamHelperæ¥æ§åˆ¶Pin->PinType = LinkedTo->PinType;ï¼Œä»è€Œæ”¹å˜Pinçš„å®é™…ç±»å‹ã€‚

```cpp
bool UEdGraphSchema_K2::IsWildcardProperty(const FProperty* Property)
{
	UFunction* Function = Property->GetOwner<UFunction>();

	return Function && ( UK2Node_CallArrayFunction::IsWildcardProperty(Function, Property)
		|| UK2Node_CallFunction::IsStructureWildcardProperty(Function, Property->GetFName())
		|| UK2Node_CallFunction::IsWildcardProperty(Function, Property)
		|| FEdGraphUtilities::IsArrayDependentParam(Function, Property->GetFName()) );
}

static void FCustomStructureParamHelper::HandleSinglePin(UEdGraphPin* Pin)
{
	if (Pin)
	{
		if (Pin->LinkedTo.Num() > 0)
		{
			UEdGraphPin* LinkedTo = Pin->LinkedTo[0];
			check(LinkedTo);

			if (UK2Node* Node = Cast<UK2Node>(Pin->GetOwningNode()))
			{
				ensure(
					!LinkedTo->PinType.IsContainer() ||
					Node->DoesWildcardPinAcceptContainer(Pin)
				);
			}
			else
			{
				ensure( !LinkedTo->PinType.IsContainer() );
			}

			Pin->PinType = LinkedTo->PinType;
		}
		else
		{
			// constness and refness are controlled by our declaration
			// but everything else needs to be reset to default wildcard:
			const bool bWasRef = Pin->PinType.bIsReference;
			const bool bWasConst = Pin->PinType.bIsConst;

			Pin->PinType = FEdGraphPinType();
			Pin->PinType.bIsReference = bWasRef;
			Pin->PinType.bIsConst = bWasConst;
			Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			Pin->PinType.PinSubCategory = NAME_None;
			Pin->PinType.PinSubCategoryObject = nullptr;
		}
	}
}
```


ï»¿# DeterminesOutputType

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‚æ•°çš„ç±»å‹ä½œä¸ºå‡½æ•°åŠ¨æ€è°ƒæ•´è¾“å‡ºå‚æ•°ç±»å‹çš„å‚è€ƒç±»å‹
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** Classæˆ–ObjectæŒ‡é’ˆç±»å‹ï¼Œæˆ–å®¹å™¨ç±»å‹
- **å…³è”é¡¹ï¼š** [DynamicOutputParam](../DynamicOutputParam.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªå‚æ•°çš„ç±»å‹ä½œä¸ºå‡½æ•°è¾“å‡ºå‚æ•°çš„ç±»å‹ã€‚

å‡å®šè¿™ä¹ˆä¸€ä¸ªå‡½æ•°åŸå‹ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "A",DynamicOutputParam="P1,P2"))
	TypeR MyFunc(TypeA A,Type1 P1,Type2 P2,Type3 P3);
```

DeterminesOutputTypeçš„å€¼æŒ‡å®šäº†ä¸€ä¸ªå‡½æ•°å‚æ•°åç§°ï¼Œå³Aã€‚å…¶TypeAçš„ç±»å‹å¿…é¡»æ˜¯Classæˆ–Objectï¼Œä¸€èˆ¬æ˜¯TSubClassOf<XXX> æˆ–è€…XXX* ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥æ˜¯TArray<XXX*>ï¼Œè¿˜å¯ä»¥æ˜¯æŒ‡å‘å‚æ•°ç»“æ„é‡Œçš„æŸä¸ªå±æ€§ã€‚å¦‚Args_ActorClassTypeã€‚TSoftObjectPtr<XXX>ä¹Ÿæ˜¯å¯ä»¥çš„ï¼ŒæŒ‡å‘ä¸€ä¸ªå­ç±»Assetå¯¹è±¡ï¼Œç„¶åè¾“å‡ºçš„åŸºç±»Asset*å°±å¯ä»¥ç›¸åº”æ”¹å˜ã€‚

æ‰€è°“è¾“å‡ºå‚æ•°åŒ…æ‹¬è¿”å›å€¼å’Œå‡½æ•°çš„è¾“å‡ºå‚æ•°ï¼Œå› æ­¤ä¸Šè¿°å‡½æ•°åŸå‹é‡Œçš„TypeR,P1,P2éƒ½æ˜¯è¾“å‡ºå‚æ•°ã€‚ä¸ºäº†è®©è¾“å‡ºå‚æ•°çš„ç±»å‹ä¹Ÿç›¸åº”å˜åŒ–ï¼ŒTypeRã€Type1å’ŒType2çš„ç±»å‹ä¹Ÿå¾—æ˜¯Classæˆ–Objectç±»å‹ï¼Œä¸”Aå‚æ•°åœ¨è“å›¾èŠ‚ç‚¹ä¸Šå®é™…é€‰æ‹©çš„ç±»å‹å¿…é¡»æ˜¯è¾“å‡ºå‚æ•°ç±»å‹çš„å­ç±»ï¼Œè¿™æ ·æ‰èƒ½è‡ªåŠ¨è½¬æ¢è¿‡å»ã€‚

å¦‚æœæ²¡æœ‰P1å’ŒP2ï¼ŒåªæŠŠè¿”å›å€¼å½“ä½œTypeRï¼Œåˆ™å¯ä»¥ä¸æŒ‡å®šDynamicOutputParamä¹Ÿå¯ä»¥è‡ªåŠ¨é»˜è®¤æŠŠè¿”å›å€¼å½“ä½œåŠ¨æ€çš„è¾“å‡ºå‚æ•°ã€‚å¦åˆ™åˆ™éœ€è¦æ‰‹åŠ¨ä¹¦å†™DynamicOutputParamæ¥æŒ‡å®šå“ªäº›å‡½æ•°å‚æ•°æ¥æ”¯æŒåŠ¨æ€ç±»å‹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyAnimalActor :public AActor
{
public:
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyCatActor :public AMyAnimalActor
{
public:
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyDogActor :public AMyAnimalActor
{
public:
	GENERATED_BODY()
};

USTRUCT(BlueprintType)
struct FMyOutputTypeArgs
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt = 1;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TSubclassOf<AMyAnimalActor> ActorClassType;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunctionLibrary_OutputTypeTest :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	//class
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ActorClassType"))
	static TArray<AActor*> MyGetAnimals(TSubclassOf<AMyAnimalActor> ActorClassType);

	//have to add DynamicOutputParam
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ActorClassType", DynamicOutputParam = "OutActors"))
	static void MyGetAnimalsOut(TSubclassOf<AMyAnimalActor> ActorClassType, TArray<AActor*>& OutActors);

	//have to add DynamicOutputParam
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ActorClassType", DynamicOutputParam = "FirstOutActor,OutActors"))
	static void MyGetAnimalsOut2(TSubclassOf<AMyAnimalActor> ActorClassType, AActor*& FirstOutActor, TArray<AActor*>& OutActors);

	//object
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ExampleActor"))
	static TArray<AActor*> MyGetAnimalsWithActor(AMyAnimalActor* ExampleActor);

	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "ExampleActorArray"))
	static TArray<AActor*> MyGetAnimalsWithActorArray(TArray<AMyAnimalActor*> ExampleActorArray);

	//struct property
	UFUNCTION(BlueprintCallable, meta = (DeterminesOutputType = "Args_ActorClassType"))
	static TArray<AActor*> MyGetAnimalsWithStructProperty(const FMyOutputTypeArgs& Args);
};

```

## è“å›¾ä¸­æ•ˆæœï¼š

ç”¨è¿”å›å€¼å½“ä½œè¾“å‡ºå‚æ•°çš„ä¾‹å­ï¼Œæ³¨æ„åˆ°è¿”å›å€¼ç±»å‹å®é™…å˜æˆäº†TArray<AMyCatActor*>ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\DeterminesOutputType\1.png](1.png)

ä¹Ÿå¯ä»¥åŠ ä¸ŠDynamicOutputParamæ¥æŒ‡å®šè¾“å‡ºå‚æ•°ä½œä¸ºåŠ¨æ€ç±»å‹å‚æ•°ï¼š

![D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\DeterminesOutputType\2.png](2.png)

DynamicOutputParamå¯ä»¥æŒ‡å®šå¤šä¸ªå‚æ•°

![D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\DeterminesOutputType\3.png](3.png)

DeterminesOutputType çš„å‚æ•°ç±»å‹ä¹Ÿå¯ä»¥æ˜¯Objectæˆ–è€…Objectçš„å®¹å™¨ï¼š

![D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\DeterminesOutputType\4.png](4.png)

DeterminesOutputType çš„å‚æ•°ç”šè‡³å¯ä»¥æ˜¯ç»“æ„é‡Œçš„æŸä¸ªå±æ€§ï¼Œä½†æ˜¯åªæœ‰SplitStructçš„æ—¶å€™æ‰ç”Ÿæ•ˆï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™ç»“æ„çš„å±æ€§å˜é‡æ‰å˜æˆå‡½æ•°çš„Pinï¼Œæ‰å¯ä»¥è¿›è¡ŒDeterminesOutputTypeçš„åç§°æ¯”å¯¹ã€‚è¿™ä¸ªæ—¶å€™è¦ä¹¦å†™æˆâ€œA_Bâ€ï¼Œè€Œä¸æ˜¯â€œA.Bâ€ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\DeterminesOutputType\5.png](5.png)

## åŸç†ï¼š

DeterminesOutputTypeçš„ä½œç”¨æœºåˆ¶æ˜¯æ ¹æ®è¿™ä¸ªåç§°å»å‡½æ•°è“å›¾èŠ‚ç‚¹ä¸ŠæŸ¥æ‰¾Pinï¼Œè¿™ä¸ªPinå¾—æ˜¯Classæˆ–Objectç±»å‹çš„ï¼ˆå®¹å™¨ä¹Ÿè¡Œï¼‰ï¼Œå› ä¸ºå¿…é¡»æ˜¯è¿™äºŒè€…æ‰æ”¯æŒæŒ‡é’ˆç±»å‹çš„è½¬æ¢ã€‚è¿™ä¸ªPinåœ¨è“å›¾èŠ‚ç‚¹ä¸Šæ˜¯ä¼šç”±å„ç§TypePickeræ¥å®é™…æŒ‡å®šå€¼ï¼Œæ¯”å¦‚ClassPickeræˆ–ObjectPickerã€‚ä¹‹åæ ¹æ®TypePickeré€‰æ‹©çš„å€¼ï¼Œå°±å¯ä»¥ç›¸åº”çš„è°ƒæ•´DynamicOutputParamæŒ‡å®šçš„å‚æ•°çš„ç±»å‹ï¼ˆæˆ–è¿”å›å‚æ•°ï¼‰ï¼ŒçœŸæ­£å‘æŒ¥ç±»å‹æ”¹å˜çš„æ˜¯

Pin->PinType.PinSubCategoryObject = PickedClass;è¿™ä¸€å¥ã€‚

```cpp
void FDynamicOutputHelper::ConformOutputType() const
{
	if (IsTypePickerPin(MutatingPin))
	{
		UClass* PickedClass = GetPinClass(MutatingPin);
		UK2Node_CallFunction* FuncNode = GetFunctionNode();

		// See if there is any dynamic output pins
		TArray<UEdGraphPin*> DynamicPins;
		GetDynamicOutPins(FuncNode, DynamicPins);
		
		// Set the pins class
		for (UEdGraphPin* Pin : DynamicPins)
		{
			if (ensure(Pin != nullptr))
		{
					Pin->PinType.PinSubCategoryObject = PickedClass;//è®¾å®šæ¯ä¸ªåŠ¨æ€å‚æ•°çš„å­ç±»å‹
			}
		}
	}
}
```


ï»¿# DynamicOutputParam

- **åŠŸèƒ½æè¿°ï¼š** é…åˆDeterminesOutputTypeï¼ŒæŒ‡å®šå¤šä¸ªæ”¯æŒåŠ¨æ€ç±»å‹çš„è¾“å‡ºå‚æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** Classæˆ–ObjectæŒ‡é’ˆç±»å‹ï¼Œæˆ–å®¹å™¨ç±»å‹
- **å…³è”é¡¹ï¼š** [DeterminesOutputType](DeterminesOutputType/DeterminesOutputType.md)

å¸¸å¸¸å’ŒDeterminesOutputTypeä¸€èµ·é…åˆã€‚åŠ¨æ€å‚æ•°çš„æ•°é‡å¯ä»¥ä¸ºå¤šä¸ªã€‚


ï»¿# HideSpawnParms

- **åŠŸèƒ½æè¿°ï¼š** åœ¨UGamelayTaskå­ç±»ç”Ÿæˆçš„è“å›¾å¼‚æ­¥èŠ‚ç‚¹ä¸Šéšè—UGamelayTaskå­ç±»ç»§æ‰¿é“¾ä¸­æŸäº›å±æ€§ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [ExposedAsyncProxy](../../ExposedAsyncProxy/ExposedAsyncProxy.md)

åœ¨UGamelayTaskå­ç±»ç”Ÿæˆçš„è“å›¾å¼‚æ­¥èŠ‚ç‚¹ä¸Šéšè—UGamelayTaskå­ç±»ç»§æ‰¿é“¾ä¸­æŸäº›å±æ€§ã€‚

HideSpawnParms åªåœ¨UK2Node_LatentGameplayTaskCallä¸­åˆ¤æ–­ï¼Œå› æ­¤åªä½œç”¨äºUGameplayTaskçš„å­ç±»ã€‚åœ¨æºç ä¸­æ‰¾åˆ°çš„å”¯ä¸€ç”¨æ³•æ˜¯ HideSpawnParms = "Instigatorâ€ï¼Œä½†æ˜¯å…¶UGamelayTaskå­ç±»ç»§æ‰¿é“¾ä¸­å¹¶æ— è¯¥å±æ€§ï¼Œå› æ­¤å…¶å®æ˜¯ä¸å‘æŒ¥ä½œç”¨çš„ã€‚

```cpp
	UFUNCTION(BlueprintCallable, Meta = (HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "true", HideSpawnParms = "Instigator"), Category = "Ability|Tasks")
	static UAbilityTask_StartAbilityState* StartAbilityState(UGameplayAbility* OwningAbility, FName StateName, bool bEndCurrentState = true);
```

ä¿ç•™å’Œå»æ‰HideSpawnParms çš„è“å›¾çš„èŠ‚ç‚¹éƒ½ä¸ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\HideSpawnParms\Untitled.png)

## æºç é‡Œå‘ç”Ÿçš„ä½ç½®ï¼š

```cpp
void UK2Node_LatentGameplayTaskCall::CreatePinsForClass(UClass* InClass)
{
	// Tasks can hide spawn parameters by doing meta = (HideSpawnParms="PropertyA,PropertyB")
	// (For example, hide Instigator in situations where instigator is not relevant to your task)

	TArray<FString> IgnorePropertyList;
	{
		UFunction* ProxyFunction = ProxyFactoryClass->FindFunctionByName(ProxyFactoryFunctionName);
	
		const FString& IgnorePropertyListStr = ProxyFunction->GetMetaData(FName(TEXT("HideSpawnParms")));
	
		if (!IgnorePropertyListStr.IsEmpty())
		{
			IgnorePropertyListStr.ParseIntoArray(IgnorePropertyList, TEXT(","), true);
		}
	}
}
```


ï»¿# MapKeyParam

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºMapçš„Keyï¼Œå…¶æ ¹æ®MapParamæŒ‡å®šçš„å®é™…Mapå‚æ•°çš„Keyç±»å‹è€Œç›¸åº”æ”¹å˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TMap
- **å…³è”é¡¹ï¼š** [MapParam](MapParam.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# MapParam

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨TMap<TKey,TValue>çš„å‡½æ•°ï¼Œå…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TMap
- **å…³è”é¡¹ï¼š** [MapKeyParam](MapKeyParam.md), [MapValueParam](MapValueParam.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨TMap<TKey,TValue>çš„å‡½æ•°ï¼Œå…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚

åªèƒ½æ”¯æŒä¸€ä¸ªMapParamï¼Œæºç ä¸­çš„å®ç°æ˜¯åªæ ¹æ®ä¸€ä¸ªåå­—æ¥FindPinã€‚

åœ¨æºç ä¸­ï¼Œä¾‹å­éƒ½æ˜¯åœ¨UBlueprintMapLibraryä¸­ä½¿ç”¨ã€‚

## æµ‹è¯•ä»£ç 1ï¼š

```cpp
	UFUNCTION(BlueprintPure, CustomThunk, meta = (MapParam = "TargetMap"))
	static int32 MyMap_Count(const TMap<int32, int32>& TargetMap);
	static int32 GenericMyMap_Count(const void* TargetMap, const FMapProperty* MapProperty);
	DECLARE_FUNCTION(execMyMap_Count);
```

## è“å›¾ä¸­æ•ˆæœ1ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\MapParam\Untitled.png)

å› ä¸ºåªæ”¯æŒä¸€ä¸ªMapParamï¼Œå› æ­¤å¦‚æœä½ ä¹¦å†™è¿™ç§ä»£ç  ã€‚

## æµ‹è¯•ä»£ç 2ï¼š

```cpp
	UFUNCTION(BlueprintPure, CustomThunk, meta = (MapParam = "MapA,MapB"))
	static int32 MyMap_CompareSize(const TMap<int32, int32>& MapA, const TMap<int32, int32>& MapB);
	static int32 GenericMyMap_CompareSize(void* MapA, const FMapProperty* MapAProp, void* MapB, const FMapProperty* MapBProp);
	DECLARE_FUNCTION(execMyMap_CompareSize);
```

ä¼šå¯¼è‡´MapParamæœç´¢ä¸åˆ°Pinï¼Œä»è€Œå¤±å»é€šé…ç¬¦çš„åŠŸèƒ½ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\MapParam\Untitled%201.png)

è€Œå¦‚æœè¦å®ç°ç±»ä¼¼Addçš„åŠŸèƒ½ï¼Œè¾¾åˆ°Keyå’ŒValueçš„Pinç±»å‹ä¹Ÿå¯ä»¥åŠ¨æ€çš„æ ¹æ®Mapçš„ç±»å‹è€Œè‡ªåŠ¨çš„æ”¹å˜ã€‚åˆ™éœ€è¦åŠ ä¸ŠMapKeyParam å’ŒMapValueParam åˆ†åˆ«çš„æŒ‡å®šå¦å¤–çš„å‡½æ•°å‚æ•°ä»¥ä¾¿èƒ½æ‰¾åˆ°æ­£ç¡®çš„Pinï¼Œä»è€Œå®ç°åŠ¨æ€çš„æ ¹æ®Mapç±»å‹è€Œæ›´æ”¹KeyValue Pinç±»å‹ã€‚MapKeyParam å’ŒMapValueParam æŒ‡å®šçš„å‚æ•°ä¹Ÿå¯ä»¥ä¸ºæ•°ç»„ç­‰å®¹å™¨ï¼Œå¯ä»¥å‚ç…§UBlueprintMapLibraryä¸­çš„Keyså’ŒValueså‚æ•°ã€‚

```cpp
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = "TargetMap",MapKeyParam = "Key", MapValueParam = "Value"))
	static bool MyMap_FindOrAdd(const TMap<int32, int32>& TargetMap, const int32& Key, const int32& Value);
	static bool GenericMyMap_FindOrAdd(const void* TargetMap, const FMapProperty* MapProperty, const void* KeyPtr, const void* ValuePtr);
	DECLARE_FUNCTION(execMyMap_FindOrAdd);
```

## è“å›¾ä¸­çš„æ•ˆæœ2ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\Param\MapParam\Untitled%202.png)

## åŸç†ä»£ç :

```cpp
void UK2Node_CallFunction::ConformContainerPins()
{
		//åœ¨è¿™å…¶ä¸­æ£€æµ‹å®¹å™¨Pin
		const FString& MapPinMetaData = TargetFunction->GetMetaData(FBlueprintMetadata::MD_MapParam);
		const FString& MapKeyPinMetaData = TargetFunction->GetMetaData(FBlueprintMetadata::MD_MapKeyParam);
		const FString& MapValuePinMetaData = TargetFunction->GetMetaData(FBlueprintMetadata::MD_MapValueParam);
		
		if(!MapPinMetaData.IsEmpty() || !MapKeyPinMetaData.IsEmpty() || !MapValuePinMetaData.IsEmpty() )
		{
			// if the map pin has a connection infer from that, otherwise use the information on the key param and value param:
			bool bReadyToPropagateKeyType = false;
			FEdGraphTerminalType KeyTypeToPropagate;
			bool bReadyToPropagateValueType = false;
			FEdGraphTerminalType ValueTypeToPropagate;
		
			UEdGraphPin* MapPin = MapPinMetaData.IsEmpty() ? nullptr : FindPin(MapPinMetaData);
			UEdGraphPin* MapKeyPin = MapKeyPinMetaData.IsEmpty() ? nullptr : FindPin(MapKeyPinMetaData);
			UEdGraphPin* MapValuePin = MapValuePinMetaData.IsEmpty() ? nullptr : FindPin(MapValuePinMetaData);
		
			TryReadTypeToPropagate(MapPin, bReadyToPropagateKeyType, KeyTypeToPropagate);//è¯»å–MapPinçš„Keyè¿æ¥ç±»å‹
			TryReadValueTypeToPropagate(MapPin, bReadyToPropagateValueType, ValueTypeToPropagate);//è¯»å–MapPinä¸Šè¿æ¥çš„Map Valueç±»å‹
			TryReadTypeToPropagate(MapKeyPin, bReadyToPropagateKeyType, KeyTypeToPropagate);//è¯»å–KeyPinä¸Šçš„è¿æ¥ç±»å‹
			TryReadTypeToPropagate(MapValuePin, bReadyToPropagateValueType, ValueTypeToPropagate);//è¯»å–ValuePinä¸Šçš„è¿æ¥ç±»å‹
		
			TryPropagateType(MapPin, KeyTypeToPropagate, bReadyToPropagateKeyType);//æ”¹å˜MapPinçš„Keyå½“å‰ç±»å‹
			TryPropagateType(MapKeyPin, KeyTypeToPropagate, bReadyToPropagateKeyType);//æ”¹å˜KeyPinçš„å½“å‰ç±»å‹
		
			TryPropagateValueType(MapPin, ValueTypeToPropagate, bReadyToPropagateValueType);//æ”¹å˜MapPinçš„Valueå½“å‰ç±»å‹
			TryPropagateType(MapValuePin, ValueTypeToPropagate, bReadyToPropagateValueType);//æ”¹å˜ValuePinçš„å½“å‰ç±»å‹
		}
}
```


ï»¿# MapValueParam

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºMapçš„Valueï¼Œå…¶æ ¹æ®MapParamæŒ‡å®šçš„å®é™…Mapå‚æ•°çš„Valueç±»å‹è€Œç›¸åº”æ”¹å˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TMap
- **å…³è”é¡¹ï¼š** [MapParam](../MapParam/MapParam.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# ProhibitedInterfaces

- **åŠŸèƒ½æè¿°ï¼š** åˆ—å‡ºä¸è“å›¾ç±»ä¸å…¼å®¹çš„æ¥å£ï¼Œé˜»æ­¢å®ç°
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
UINTERFACE(Blueprintable,MinimalAPI)
class UMyInterface_First:public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class INSIDER_API IMyInterface_First
{
	GENERATED_IINTERFACE_BODY()
public:
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	void FirstFunc() const;
};

UINTERFACE(Blueprintable,MinimalAPI)
class UMyInterface_Second:public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class INSIDER_API IMyInterface_Second
{
	GENERATED_IINTERFACE_BODY()
public:
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	void SecondFunc() const;
};

UCLASS(Blueprintable,meta=(ProhibitedInterfaces="UMyInterface_Second"))
class INSIDER_API UMyClass_ProhibitedInterfaces :public UObject
{
	GENERATED_BODY()
public:
};
```

## æµ‹è¯•ç»“æœï¼š

å‘ç°UMyInterface_Secondè¢«é˜»æ­¢å®ç°äº†ï¼Œä½†æ˜¯UMyInterface_Firstä¾ç„¶å¯ä»¥è¢«å®ç°

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ProhibitedInterfaces\Untitled.png)

## åŸç†ä»£ç ï¼š

å¯ä»¥çœ‹åˆ°åœ¨æ„é€ åˆ—è¡¨çš„æ—¶å€™ï¼Œè¿›è¡Œäº†è¿‡æ»¤ç­›é€‰ã€‚åŒæ—¶å‘ç°äº†.RightChop(1);çš„ä½¿ç”¨ï¼Œå› æ­¤å¡«çš„æ¥å£åç§°ï¼Œè¦åŠ ä¸ŠUçš„å‰ç¼€ã€‚å¦‚æœUMyInterface_Second

```cpp
TSharedRef<SWidget> FBlueprintEditorUtils::ConstructBlueprintInterfaceClassPicker( const TArray< UBlueprint* >& Blueprints, const FOnClassPicked& OnPicked)
{
	//...
		
		UClass const* const ParentClass = Blueprint->ParentClass;
		// see if the parent class has any prohibited interfaces
		if ((ParentClass != nullptr) && ParentClass->HasMetaData(FBlueprintMetadata::MD_ProhibitedInterfaces))
		{
			FString const& ProhibitedList = Blueprint->ParentClass->GetMetaData(FBlueprintMetadata::MD_ProhibitedInterfaces);

			TArray<FString> ProhibitedInterfaceNames;
			ProhibitedList.ParseIntoArray(ProhibitedInterfaceNames, TEXT(","), true);

			// loop over all the prohibited interfaces
			for (int32 ExclusionIndex = 0; ExclusionIndex < ProhibitedInterfaceNames.Num(); ++ExclusionIndex)
			{
				ProhibitedInterfaceNames[ExclusionIndex].TrimStartInline();
				FString const& ProhibitedInterfaceName = ProhibitedInterfaceNames[ExclusionIndex].RightChop(1);
				UClass* ProhibitedInterface = UClass::TryFindTypeSlow<UClass>(ProhibitedInterfaceName);
				if(ProhibitedInterface)
				{
					Filter->DisallowedClasses.Add(ProhibitedInterface);
					Filter->DisallowedChildrenOfClasses.Add(ProhibitedInterface);
				}
			}
		}

		// Do not allow adding interfaces that are already added to the Blueprint
		TArray<UClass*> InterfaceClasses;
		FindImplementedInterfaces(Blueprint, true, InterfaceClasses);
		for(UClass* InterfaceClass : InterfaceClasses)
		{
			Filter->DisallowedClasses.Add(InterfaceClass);
		}

		// Include a class viewer filter for imported namespaces if the class picker is being hosted in an editor context
		TSharedPtr<IToolkit> AssetEditor = FToolkitManager::Get().FindEditorForAsset(Blueprint);
		if (AssetEditor.IsValid() && AssetEditor->IsBlueprintEditor())
		{
			TSharedPtr<IBlueprintEditor> BlueprintEditor = StaticCastSharedPtr<IBlueprintEditor>(AssetEditor);
			TSharedPtr<IClassViewerFilter> ImportedClassViewerFilter = BlueprintEditor->GetImportedClassViewerFilter();
			if (ImportedClassViewerFilter.IsValid())
			{
				Options.ClassFilters.AddUnique(ImportedClassViewerFilter.ToSharedRef());
			}
		}
	}

	// never allow parenting to children of itself
	for (UClass*  BPClass : BlueprintClasses)
	{
		Filter->DisallowedChildrenOfClasses.Add(BPClass);
	}

	return FModuleManager::LoadModuleChecked<FClassViewerModule>("ClassViewer").CreateClassViewer(Options, OnPicked);
}
```


ï»¿# RestrictedToClasses

- **åŠŸèƒ½æè¿°ï¼š** é™åˆ¶è“å›¾å‡½æ•°åº“ä¸‹çš„å‡½æ•°åªèƒ½åœ¨RestrictedToClassesæŒ‡å®šçš„ç±»è“å›¾ä¸­å³é”®åˆ›å»ºå‡ºæ¥
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** BlueprintFunctionLibrary
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨è“å›¾å‡½æ•°åº“ä¸Šä½¿ç”¨ï¼ŒæŒ‡å®šè¯¥å‡½æ•°åº“ä¸­çš„å‡½æ•°åªèƒ½ç”¨åœ¨RestrictedToClassesæŒ‡å®šçš„ç±»çš„è“å›¾ä¸­ï¼Œä¸èƒ½åœ¨åˆ«çš„è“å›¾ç±»ä¸­è¢«å³é”®å‡ºæ¥ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable)
class INSIDER_API UMyClass_RestrictedToClasses :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite,EditAnywhere)
	float MyFloat;
};

UCLASS(meta=(RestrictedToClasses="MyClass_RestrictedToClasses"))
class INSIDER_API UMyClass_RestrictedToClassesLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	static float GetMyClassRestrictedFloat(UMyClass_RestrictedToClasses* myObject) {return myObject->MyFloat;}
};
```

åœ¨UMyClass_RestrictedToClasses çš„å­ç±»è“å›¾ä¸­æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\RestrictedToClasses\Untitled.png)

åœ¨åˆ«çš„åœ°æ–¹ï¼Œæ¯”å¦‚å…³å¡è“å›¾ä¸­æµ‹è¯•æ•ˆæœï¼š

å› æ­¤å³é”®åˆ›å»ºä¸å‡ºæ¥ï¼Œä½†æ˜¯ç›´æ¥ç²˜è´´èŠ‚ç‚¹å…¶å®è¿˜æ˜¯å¯ä»¥è°ƒç”¨çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\RestrictedToClasses\Untitled%201.png)

## æºç ä¸­çš„ä¾‹å­ï¼š

æŒ‡å®šUBTFunctionLibraryä¸­çš„èŠ‚ç‚¹ï¼Œåªèƒ½åœ¨BTNodeä¸­ä½¿ç”¨ï¼Œå¦åˆ™æ²¡æœ‰æ„ä¹‰ã€‚

```cpp
UCLASS(meta=(RestrictedToClasses="BTNode"), MinimalAPI)
class UBTFunctionLibrary : public UBlueprintFunctionLibrary
{
UFUNCTION(BlueprintPure, Category="AI|BehaviorTree", Meta=(HidePin="NodeOwner", DefaultToSelf="NodeOwner"))
	static AIMODULE_API UBlackboardComponent* GetOwnersBlackboard(UBTNode* NodeOwner);
//....
}
```

## åŸç†ï¼š

```cpp
static bool BlueprintActionFilterImpl::IsRestrictedClassMember(FBlueprintActionFilter const& Filter, FBlueprintActionInfo& BlueprintAction)
{
	bool bIsFilteredOut = false;
	FBlueprintActionContext const& FilterContext = Filter.Context;
	
	if (UClass const* ActionClass = BlueprintAction.GetOwnerClass())
	{
		if (ActionClass->HasMetaData(FBlueprintMetadata::MD_RestrictedToClasses))
		{
			FString const& ClassRestrictions = ActionClass->GetMetaData(FBlueprintMetadata::MD_RestrictedToClasses);
			
			// Parse the the metadata into an array that is delimited by ',' and trim whitespace
			TArray<FString> ParsedClassRestrictions;
			ClassRestrictions.ParseIntoArray(ParsedClassRestrictions, TEXT(","));
			for (FString& ValidClassName : ParsedClassRestrictions)
			{
				ValidClassName = ValidClassName.TrimStartAndEnd();
			}

			for (UBlueprint const* TargetContext : FilterContext.Blueprints)
			{
				UClass* TargetClass = TargetContext->GeneratedClass;
				if(!TargetClass)
				{
					// Skip possible null classes (e.g. macros, etc)
					continue;
				}

				bool bIsClassListed = false;
				
				UClass const* QueryClass = TargetClass;
				// walk the class inheritance chain to see if this class is one
				// of the allowed
				while (!bIsClassListed && (QueryClass != nullptr))
				{
					FString const ClassName = QueryClass->GetName();
					// If this class is on the list of valid classes
					for (const FString& ValidClassName : ParsedClassRestrictions)
					{
						bIsClassListed = (ClassName == ValidClassName);
						if (bIsClassListed)
						{
							break;
						}
					}
					
					QueryClass = QueryClass->GetSuperClass();
				}
				
				// if the blueprint class wasn't listed as one of the few
				// classes that this can be accessed from, then filter it out
				if (!bIsClassListed)
				{
					bIsFilteredOut = true;
					break;
				}
			}
		}
	}
	
	return bIsFilteredOut;
}
```


ï»¿# ReturnDisplayName

- **åŠŸèƒ½æè¿°ï¼š** æ”¹å˜å‡½æ•°è¿”å›å€¼çš„åå­—ï¼Œé»˜è®¤æ˜¯ReturnValue
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å‡½æ•°çš„è¿”å›å€¼å¼•è„šåå­—é»˜è®¤æ˜¯ReturnValueï¼Œå¦‚æœæƒ³è‡ªå·±æä¾›ä¸€ä¸ªæ›´æœ‰æ„ä¹‰çš„åå­—ï¼Œåˆ™å¯ä»¥ç”¨ReturnDisplayName æ¥è‡ªå®šä¹‰ä¸€ä¸ªåå­—ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (ReturnDisplayName = "IsSuccess"))
	static bool MyFunc_HasReturnDisplayName(FString Name) { return true; }

	UFUNCTION(BlueprintCallable, meta = ())
	static bool MyFunc_NoReturnDisplayName(FString Name) { return true; }
```

## è“å›¾æ•ˆæœï¼š

å¯¹æ¯”è¿”å›å€¼çš„åå­—å¯ä»¥éªŒè¯æ•ˆæœã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ReturnDisplayName\Untitled.png)

## åŸç†ï¼š

åŸç†ä¹Ÿå¾ˆç®€å•ï¼Œåœ¨Pinä¸Šåˆ¤æ–­Metaå¹¶è®¾ç½®PinFriendlyName 

```cpp
if (Function->GetReturnProperty() == Param && Function->HasMetaData(FBlueprintMetadata::MD_ReturnDisplayName))
{
	Pin->PinFriendlyName = Function->GetMetaDataText(FBlueprintMetadata::MD_ReturnDisplayName);
}
```


ï»¿# SetParam

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°ä¸ºä½¿ç”¨Set<TItem>çš„å‡½æ•°ï¼Œå…ƒç´ ç±»å‹ä¸ºé€šé…ç¬¦çš„æ³›å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="A | B | C"
- **é™åˆ¶ç±»å‹ï¼š** TSet
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æºç åœ¨UBlueprintSetLibraryã€‚

SetParamæ”¯æŒå¤šä¸ªSetå’Œå…ƒç´ å‚æ•°ï¼Œä»¥â€˜,â€™åˆ†éš”å¼€ï¼Œç„¶åPinçš„å¼•è„šå¯ä»¥é€šè¿‡â€˜|â€™ç»§ç»­åˆ†éš”ï¼Œå½¢æˆâ€SetA | ItemA, SetB | ItemBâ€çš„å¤šç»„æ•°æ®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = "SetA|ItemA,SetB|ItemB"))
	static void MySet_Add2(const TSet<int32>& SetA, const int32& ItemA, const TSet<int32>& SetB, const int32& ItemB);
	static void GenericMySet_Add2(const void* TargetSet, const FSetProperty* SetA, const void* ItemA, const FSetProperty* SetB, const void* ItemB);
	DECLARE_FUNCTION(execMySet_Add2);
```

## è“å›¾é‡Œæ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\SetParam\Untitled.png)

## åŸç†ï¼š

ç”¨â€˜,â€™åˆ†éš”çš„æ˜¯ç»„ï¼Œç»„å†…ç”¨â€™|â€™åˆ†éš”çš„å‚æ•°Pinéƒ½æ˜¯åŒä¸€ç§ç±»å‹çš„ã€‚

```cpp
void UK2Node_CallFunction::ConformContainerPins()
{
		// find any pins marked as SetParam
		const FString& SetPinMetaData = TargetFunction->GetMetaData(FBlueprintMetadata::MD_SetParam);
		
		// useless copies/allocates in this code, could be an optimization target...
		TArray<FString> SetParamPinGroups;
		{
			SetPinMetaData.ParseIntoArray(SetParamPinGroups, TEXT(","), true);
		}
		
		for (FString& Entry : SetParamPinGroups)
		{
			// split the group:
			TArray<FString> GroupEntries;
			Entry.ParseIntoArray(GroupEntries, TEXT("|"), true);
			// resolve pins
			TArray<UEdGraphPin*> ResolvedPins;
			for(UEdGraphPin* Pin : Pins)
			{
				if (GroupEntries.Contains(Pin->GetName()))
				{
					ResolvedPins.Add(Pin);
				}
			}
		
			// if nothing is connected (or non-default), reset to wildcard
			// else, find the first type and propagate to everyone else::
			bool bReadyToPropagatSetType = false;
			FEdGraphTerminalType TypeToPropagate;
			for (UEdGraphPin* Pin : ResolvedPins)
			{
				TryReadTypeToPropagate(Pin, bReadyToPropagatSetType, TypeToPropagate);
				if(bReadyToPropagatSetType)
				{
					break;
				}
			}
		
			for (UEdGraphPin* Pin : ResolvedPins)
			{
				TryPropagateType( Pin, TypeToPropagate, bReadyToPropagatSetType );
			}
		}
	}
```


ï»¿# ShowWorldContextPin

- **åŠŸèƒ½æè¿°ï¼š** æ”¾åœ¨UCLASSä¸Šï¼ŒæŒ‡å®šæœ¬ç±»é‡Œçš„å‡½æ•°è°ƒç”¨éƒ½å¿…é¡»æ˜¾ç¤ºWorldContextå¼•è„šï¼Œæ— è®ºå…¶æœ¬æ¥æ˜¯å¦é»˜è®¤éšè—
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [WorldContext](../WorldContext/WorldContext.md)

æ”¾åœ¨UCLASSä¸Šï¼ŒæŒ‡å®šæœ¬ç±»é‡Œçš„å‡½æ•°è°ƒç”¨éƒ½å¿…é¡»æ˜¾ç¤ºWorldContextå¼•è„šï¼Œæ— è®ºå…¶æœ¬æ¥æ˜¯å¦é»˜è®¤éšè—ï¼Œå› ä¸ºæœ¬Objectç±»æ— æ³•è¢«å½“ä½œWorldContextObjectï¼Œå³ä½¿å®ç°äº†GetWorld()ä¹Ÿè¦å½“ä½œæ— æ³•è‡ªåŠ¨è·å¾—ä»¥æ­¤æ¥è®©ç”¨æˆ·å¿…é¡»æ‰‹åŠ¨æŒ‡å®šWorldContextObjectã€‚

ä¸€èˆ¬æ”¾åœ¨UObjectä¸Šï¼Œä½†åœ¨æºç é‡Œå‘ç°åœ¨AGameplayCueNotify_Actorï¼ŒAEditorUtilityActorä¸Šä¹Ÿæœ‰ã€‚AEditorUtilityActoræ˜¯å› ä¸ºæœ¬èº«ä¸ä¼šåœ¨Runtimeé‡Œè¿è¡Œï¼Œå› æ­¤æ²¡æœ‰Worldã€‚AGameplayCueNotify_Actoræœ‰å¯èƒ½åœ¨CDOä¸Šè¢«ä½¿ç”¨å’ŒRecycleï¼Œå› æ­¤å¯ä¹Ÿä¸èƒ½å‡å®šå¿…é¡»æœ‰WorldContextã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunctionLibrary_WorldContextTest :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	static FString MyFunc_NoWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
	static FString MyFunc_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);
};

UCLASS(Blueprintable, BlueprintType, meta = (ShowWorldContextPin = "true"))
class INSIDER_API UMyObject_ShowWorldContextPin :public UObject
{
	GENERATED_BODY()
	UWorld* WorldPrivate = nullptr;
public:
	UFUNCTION(BlueprintCallable)
	void RegisterWithOuter()
	{
		if (UObject* outer = GetOuter())
		{
			WorldPrivate = outer->GetWorld();
		}
	}

	virtual UWorld* GetWorld() const override final { return WorldPrivate; }
};
```

## è“å›¾æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥è§åˆ°è™½ç„¶UMyObject_ShowWorldContextPinç±»å®ç°äº†GetWorld()æ–¹æ³•ï¼Œä½†æ˜¯å³ä½¿æ˜¯MyFunc_HasWorldContextMetaï¼ŒWorldContextObjectæœ¬æ¥åº”è¯¥è¢«è‡ªåŠ¨èµ‹å€¼ä¸”éšè—çš„ï¼Œä½†æ˜¯åœ¨æœ¬ç±»é‡Œä¹Ÿæ˜¾å¼æ˜¾ç¤ºäº†å‡ºæ¥ã€‚åŒæ—¶æ³¨æ„åˆ°PrintStringä¹Ÿæ˜¾ç¤ºå‡ºäº†WorldContextObjectã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\ShowWorldContextPin\Untitled.png)

## åŸç†ï¼š

åœ¨CallFunctionçš„è“å›¾èŠ‚ç‚¹ä¸Šï¼Œå¦‚æœæœ‰bShowWorldContextPinï¼Œåˆ™ä¸éšè—WorldContextMetaValueæˆ–DefaultToSelfMetaValueæŒ‡å®šçš„å‡½æ•°å‚æ•°ã€‚

```cpp
bool UK2Node_CallFunction::CreatePinsForFunctionCall(const UFunction* Function)
{
	const bool bShowWorldContextPin = ((PinsToHide.Num() > 0) && BP && BP->ParentClass && BP->ParentClass->HasMetaDataHierarchical(FBlueprintMetadata::MD_ShowWorldContextPin));
	//...
	if (PinsToHide.Contains(Pin->PinName))
	{
		const FString PinNameStr = Pin->PinName.ToString();
		const FString& DefaultToSelfMetaValue = Function->GetMetaData(FBlueprintMetadata::MD_DefaultToSelf);
		const FString& WorldContextMetaValue  = Function->GetMetaData(FBlueprintMetadata::MD_WorldContext);
		bool bIsSelfPin = ((PinNameStr == DefaultToSelfMetaValue) || (PinNameStr == WorldContextMetaValue));
	
		if (!bShowWorldContextPin || !bIsSelfPin)
		{
			Pin->bHidden = true;
			Pin->bNotConnectable = InternalPins.Contains(Pin->PinName);
		}
	}

}
```


ï»¿# SparseClassDataTypes

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** [GetByRef](GetByRef.md)

  UCLASSï¼š[SparseClassDataType](../../Specifier/UCLASS/Blueprint/SparseClassDataType/SparseClassDataType.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# UnsafeDuringActorConstruction

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜è¯¥å‡½æ•°ä¸èƒ½åœ¨Actorçš„æ„é€ å‡½æ•°é‡Œè°ƒç”¨
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æ ‡æ˜è¯¥å‡½æ•°ä¸èƒ½åœ¨Actorçš„æ„é€ å‡½æ•°é‡Œè°ƒç”¨ã€‚ä¸€èˆ¬æ˜¯æ¶‰åŠæ¸²æŸ“åŠç‰©ç†çš„å‡½æ•°ï¼Œåœ¨Actorçš„æ„é€ æœŸé—´ä¸å…è®¸è¢«è°ƒç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Unsafe :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	static void MySafeFunction();
	UFUNCTION(BlueprintCallable, meta=(UnsafeDuringActorConstruction = "true"))
	static void MyUnsafeFunction();
};
```

åœ¨è“å›¾é‡Œå‡½æ•°çš„ç»†èŠ‚é¢æ¿ä¸Šä¹Ÿå¯ä»¥è®¾ç½®è¯¥Metaï¼šUnsafeDuringActorConstructionï¼Œå’Œåœ¨C++é‡Œè®¾ç½®æ˜¯ä¸€æ ·çš„æ•ˆæœã€‚

å¯ä»¥å‘ç°MyUnsafeFunctionå‡½æ•°ä¸èƒ½åœ¨Actoræ„é€ å‡½æ•°é‡Œè¢«è°ƒç”¨å‡ºæ¥ï¼Œè€Œè“å›¾é‡Œè‡ªå®šä¹‰çš„å‡½æ•°åŠ ä¸ŠUnsafeDuringActorConstruction æ ‡å¿—åä¹Ÿä¼šç”Ÿæˆç›¸åº”çš„è­¦å‘Šå’Œç¼–è¯‘é”™è¯¯ä¿¡æ¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\UnsafeDuringActorConstruction\Untitled.png)

## åŸç†ï¼š

åœ¨è“å›¾ä¸­æœ‰è¯¥ç³»åˆ—çš„åˆ¤æ–­ï¼Œä¸€ç›®äº†ç„¶ã€‚

```cpp
bool UEdGraphSchema_K2::CanFunctionBeUsedInGraph(const UClass* InClass, const UFunction* InFunction, const UEdGraph* InDestGraph, uint32 InAllowedFunctionTypes, bool bInCalledForEach, FText* OutReason) const
{
const bool bIsUnsafeForConstruction = InFunction->GetBoolMetaData(FBlueprintMetadata::MD_UnsafeForConstructionScripts);	
if (bIsUnsafeForConstruction && bIsConstructionScript)
{
	if(OutReason != nullptr)
	{
		*OutReason = LOCTEXT("FunctionUnsafeForConstructionScript", "Function cannot be used in a Construction Script.");
	}

	return false;
}
}
```


ï»¿# Variadic

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°æ¥å—å¤šä¸ªå‚æ•°

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION

- **å¼•æ“æ¨¡å—ï¼š** Blueprint

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[Variadic](../../Specifier/UFUNCTION/UHT/Variadic/Variadic.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# WorldContext

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå‡½æ•°çš„ä¸€ä¸ªå‚æ•°è‡ªåŠ¨æ¥æ”¶WorldContextå¯¹è±¡ï¼Œä»¥ä¾¿ç¡®å®šå½“å‰è¿è¡Œæ‰€å¤„äºçš„World
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [CallableWithoutWorldContext](../CallableWithoutWorldContext/CallableWithoutWorldContext.md), [ShowWorldContextPin](../ShowWorldContextPin/ShowWorldContextPin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šå‡½æ•°çš„ä¸€ä¸ªå‚æ•°è‡ªåŠ¨æ¥æ”¶WorldContextå¯¹è±¡ï¼Œä»¥ä¾¿ç¡®å®šå½“å‰è¿è¡Œæ‰€å¤„äºçš„Worldã€‚å‡½æ•°æ˜¯BlueprintCallableæˆ–BlueprintPureéƒ½å¯ä»¥ï¼Œé™æ€å‡½æ•°æˆ–æˆå‘˜å‡½æ•°ä¹Ÿéƒ½å¯ä»¥ã€‚ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ç”¨äºå‡½æ•°åº“é‡Œçš„é™æ€å‡½æ•°ï¼Œå…¸å‹çš„ä¾‹å­æ˜¯UGameplayStaticsä¸­çš„ä¼—å¤šstaticå‡½æ•°ã€‚

```cpp
UFUNCTION(BlueprintPure, Category="Game", meta=(WorldContext="WorldContextObject"))
static ENGINE_API class UGameInstance* GetGameInstance(const UObject* WorldContextObject)
{
		UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);
		return World ? World->GetGameInstance() : nullptr;
}

//åœ¨Runtimeä¸‹è·å¾—Worldçš„æ–¹å¼ä¸€èˆ¬æ˜¯ï¼š
UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull);
//åœ¨Editorä¸‹(å¦‚CallInEditorå‡½æ•°)è·å¾—Worldçš„æ–¹å¼ä¸€èˆ¬æ˜¯ï¼š
UObject* WorldContextObject = EditorEngine->GetEditorWorldContext().World();
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunctionLibrary_WorldContextTest :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	static FString MyFunc_NoWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);

	UFUNCTION(BlueprintCallable, meta = (WorldContext = "WorldContextObject"))
	static FString MyFunc_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);

	UFUNCTION(BlueprintPure)
	static FString MyPure_NoWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);

	UFUNCTION(BlueprintPure, meta = (WorldContext = "WorldContextObject"))
	static FString MyPure_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value);
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyObject_NoGetWorld :public UObject
{
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyObject_HasGetWorld :public UObject
{
	GENERATED_BODY()

	UWorld* WorldPrivate = nullptr;
public:
	UFUNCTION(BlueprintCallable)
	void RegisterWithOuter()
	{
		if (UObject* outer = GetOuter())
		{
			WorldPrivate = outer->GetWorld();
		}
	}

	virtual UWorld* GetWorld() const override final { return WorldPrivate; }
};

//.cpp

FString UMyFunctionLibrary_WorldContextTest::MyFunc_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value)
{
	UWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);
	if (World != nullptr)
	{
		return WorldContextObject->GetName();
	}
	return TEXT("None");
}

FString UMyFunctionLibrary_WorldContextTest::MyFunc_NoWorldContextMeta(const UObject* WorldContextObject, FString name, FString value)
{
	return MyFunc_HasWorldContextMeta(WorldContextObject, name, value);
}

FString UMyFunctionLibrary_WorldContextTest::MyPure_NoWorldContextMeta(const UObject* WorldContextObject, FString name, FString value)
{
	return MyFunc_HasWorldContextMeta(WorldContextObject, name, value);
}

FString UMyFunctionLibrary_WorldContextTest::MyPure_HasWorldContextMeta(const UObject* WorldContextObject, FString name, FString value)
{
	return MyFunc_HasWorldContextMeta(WorldContextObject, name, value);
}
```

## è“å›¾ä¸­çš„æµ‹è¯•æ•ˆæœï¼š

åœ¨Actorä¸­è°ƒç”¨ï¼Œå¯ä»¥å‘ç°æ²¡æŒ‡å®šWorldContext çš„å‡½æ•°ï¼Œä¼šæš´éœ²å‡ºè¿™ä¸ªObjectå‚æ•°ï¼Œè®©ä½ å¿…é¡»æ‰‹åŠ¨æŒ‡å®šã€‚è€Œå¸¦ä¸ŠWorldContext çš„å‡½æ•°ï¼Œåˆ™é»˜è®¤éšè—äº†èµ·æ¥WorldContextObjectå‚æ•°ï¼Œå› ä¸ºWorldContextObjectå¯¹è±¡åœ¨Actorä¸­å¯ä»¥è‡ªåŠ¨è¢«èµ‹å€¼ï¼ˆå…¶å€¼å°±æ˜¯å½“å‰Actor)ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\WorldContext\Untitled.png)

åœ¨UMyObject_NoGetWorldçš„å­ç±»é‡Œï¼Œå› ä¸ºå¹¶æ²¡æœ‰å®ç°GetWorldï¼Œå› æ­¤æ— æ³•è·å¾—Worldï¼Œä»è€Œæ²¡åŠæ³•è‡ªåŠ¨èµ‹å€¼WorldContextObjectï¼Œæ‰€ä»¥å¹¶ä¸èƒ½è°ƒç”¨å‡ºMyFunc_HasWorldContextMetaã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\WorldContext\Untitled%201.png)

è€Œåœ¨UMyObject_HasGetWorldçš„å­ç±»ä¸­è°ƒç”¨ï¼Œå› ä¸ºUMyObject_HasGetWorldå®ç°äº†GetWorldï¼Œå› æ­¤å°±å¯ä»¥å…è®¸è°ƒç”¨MyFunc_HasWorldContextMetaï¼Œå…¶WorldContextObjectçš„å€¼ä¸ºUMyObject_HasGetWorldå­ç±»å¯¹è±¡ï¼Œåœ¨å…¶èº«ä¸Šä¼šè°ƒç”¨GetWorld()ï¼Œä»è€Œè·å¾—ä¹‹å‰æ³¨å†Œè¿›å»çš„WorldPrivateå¯¹è±¡ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Blueprint\WorldContext\Untitled%202.png)

## åŸç†ï¼š

å½“ä¸€ä¸ªå‡½æ•°éœ€è¦å’ŒWorldäº§ç”Ÿäº¤äº’ï¼Œè€Œè¿™ä¸ªå‡½æ•°ï¼ˆé€šå¸¸æ˜¯staticå‡½æ•°ï¼‰åˆæ— æ³•ç›´æ¥å¯»æ‰¾åˆ°Worldå¯¹è±¡çš„æ—¶å€™ï¼Œéœ€è¦åœ¨å‡½æ•°çš„å‚æ•°ä¸Šæ‰‹åŠ¨ä»å¤–éƒ¨ä¼ å…¥ä¸€ä¸ªé¢å¤–å‚æ•°ï¼Œæ ¹æ®è¿™ä¸ªå‚æ•°æ¥é¡ºè—¤æ‘¸ç“œå¯»åˆ°OuterWorldã€‚è¿™ä¸ªå‚æ•°å°±å«åšWorldContextObjectï¼Œä¸€èˆ¬æ˜¯UObject*ç±»å‹ï¼Œæ–¹ä¾¿ä¼ å…¥å„ç§ç±»å‹çš„å¯¹è±¡ã€‚

è¿™ä¸ªWorldContextObjectä½ å¯ä»¥æ‰‹åŠ¨ä¼ å…¥ã€‚ä¹Ÿå¯ä»¥è‡ªåŠ¨è¢«èµ‹å€¼ï¼Œåªè¦è¿™ä¸ªObjectç±»å®ç°äº†virutal GetWorld()æ¥å£å¹¶ä¸”ä¸è¿”å›nullptrï¼Œå°±å¯ä»¥æ­£å¸¸çš„è·å¾—Worldå¯¹è±¡ï¼Œä»è€Œå¯ä»¥åŒruntimeæ¸¸æˆä¸–ç•Œäº§ç”Ÿäº¤äº’ã€‚

åœ¨å¹³å¸¸çš„ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬çš„è“å›¾å¯¹è±¡å¤§éƒ¨åˆ†å·²ç»æ˜¯çŸ¥é“è‡ªèº«å¤„äºå“ªä¸ªWorldçš„ï¼Œæ¯”å¦‚Actorè‚¯å®šå°±çŸ¥é“è‡ªå·±å±äºå“ªä¸ªWorldã€‚

```cpp
UWorld* AActor::GetWorld() const
{
	// CDO objects do not belong to a world
	// If the actors outer is destroyed or unreachable we are shutting down and the world should be nullptr
	if (!HasAnyFlags(RF_ClassDefaultObject) && ensureMsgf(GetOuter(), TEXT("Actor: %s has a null OuterPrivate in AActor::GetWorld()"), *GetFullName())
		&& !GetOuter()->HasAnyFlags(RF_BeginDestroyed) && !GetOuter()->IsUnreachable())
	{
		if (ULevel* Level = GetLevel())
		{
			return Level->OwningWorld;
		}
	}
	return nullptr;
}
```

åœ¨è¿™ç§Actorå†…éƒ¨è°ƒç”¨staticå‡½æ•°ï¼Œå¦‚æœæ¯æ¬¡è¿˜å¾—æ‰‹åŠ¨è®¾ç½®WorldContextObjectå°±æ˜¾å¾—éº»çƒ¦åˆæœ‰ç‚¹æ˜çŸ¥æ•…é—®äº†ã€‚å› æ­¤WorldContextè¿™ä¸ªmetaå°±æŒ‡å®šè“å›¾ç³»ç»Ÿè‡ªåŠ¨ä¸ºæˆ‘ä»¬çš„WorldContextObjectèµ‹å€¼ï¼Œå…¶å€¼å°±æ˜¯è¯¥Actoræœ¬èº«ï¼Œçœå»äº†æˆ‘ä»¬æ‰‹åŠ¨ä¼ å‚çš„éº»çƒ¦ï¼Œåˆéšè—äº†è¿™ä¸ªä¸ä¸šåŠ¡é€»è¾‘æ— å…³çš„åŠŸèƒ½èƒ¶æ°´å‚æ•°ï¼Œçœ‹èµ·æ¥ä¼˜é›…ä¸€äº›ã€‚

è€Œå¦‚æœæ˜¯åœ¨æ™®é€šçš„Objectå¯¹è±¡å†…éƒ¨è°ƒç”¨å‡½æ•°ï¼Œåˆ™ä¸çŸ¥é“å…¶æ‰€å±äºå“ªä¸ªWorldã€‚è¿™ä¸ªæ—¶å€™å°±éœ€è¦è¿™ä¸ªObjectç±»å®ç°äº†GetWorld()ã€‚ç¼–è¾‘å™¨ä¸‹ç”¨bGetWorldOverriddenè¿™ä¸ªå˜é‡æ¥åˆ¤æ–­ä¸€ä¸ªUObjectå­ç±»æ˜¯å¦å·²ç»è¦†ç›–äº†GetWorldã€‚å¦‚æœå­ç±»æœ‰è¦†ç›–ï¼Œåœ¨æ¢æµ‹çš„æ—¶å€™ï¼Œåªè¦åœ¨CDOä¸Šè°ƒç”¨ä¸€ä¸‹ImplementsGetWorldå°±å¯ä»¥è·å¾—bGetWorldOverridden==trueçš„ç»“æœï¼Œç»“æœå°±å¯ä»¥å…è®¸è‡ªåŠ¨æŒ‡å®šWorldContextObjectçš„å‡½æ•°ç‰ˆæœ¬è¢«è°ƒç”¨ã€‚ç¨å¾®å¤šæä¸€ä¸‹ï¼ŒbGetWorldOverridden ä¸æ˜¯UObjectæˆå‘˜å˜é‡ï¼Œå…¶åªæ˜¯åœ¨ImplementsGetWorld()è°ƒç”¨çš„æ—¶ç”¨åˆ°çš„ä¸´æ—¶å˜é‡ï¼Œå› æ­¤ä¸éœ€è¦ä¿å­˜ã€‚

```cpp
#if DO_CHECK || WITH_EDITOR
// Used to check to see if a derived class actually implemented GetWorld() or not
thread_local bool bGetWorldOverridden = false;
#endif // #if DO_CHECK || WITH_EDITOR

class UWorld* UObject::GetWorld() const
{
	if (UObject* Outer = GetOuter())
	{
		return Outer->GetWorld();
	}

#if DO_CHECK || WITH_EDITOR
	bGetWorldOverridden = false;
#endif
	return nullptr;
}

#if WITH_EDITOR

bool UObject::ImplementsGetWorld() const
{
	bGetWorldOverridden = true;
	GetWorld();
	return bGetWorldOverridden;
}

#endif // #if WITH_EDITOR
```

æ›´è¿›ä¸€æ­¥è§£é‡Šï¼Œåœ¨é™æ€è“å›¾å‡½æ•°ä¸Šï¼ˆBPTYPE_FunctionLibraryé‡Œçš„å‡½æ•°ï¼Œæˆ–è€…ä¸ºFUNC_Staticçš„å‡½æ•°ï¼‰éƒ½æœ‰ä¸€ä¸ªéšè—çš„å‚æ•°â€œ__WorldContextâ€ï¼Œåœ¨UK2Node_CallFunctionçš„ExpandNodeçš„æ—¶å€™ï¼Œä¼šæŠŠ__WorldContextä¸Šçš„å€¼ï¼Œèµ‹å€¼ç»™DefaultToSelfæˆ–WorldContextåˆ™ä¸¤ä¸ªMetaæ ‡ç­¾æŒ‡å®šçš„å‡½æ•°å‚æ•°ï¼Œä»è€Œå®ç°è‡ªåŠ¨æŠŠSelfèµ‹å€¼åˆ°DefaultToSelfå’ŒWorldContextã€‚

```cpp
void UK2Node_CallFunction::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)

else if (UEdGraphPin* BetterSelfPin = EntryPoints[0]->GetAutoWorldContextPin())
{
	const FString& DefaultToSelfMetaValue = Function->GetMetaData(FBlueprintMetadata::MD_DefaultToSelf);
	const FString& WorldContextMetaValue = Function->GetMetaData(FBlueprintMetadata::MD_WorldContext);

	struct FStructConnectHelper
	{
		static void Connect(const FString& PinName, UK2Node* Node, UEdGraphPin* BetterSelf, const UEdGraphSchema_K2* InSchema, FCompilerResultsLog& MessageLog)
		{
			UEdGraphPin* Pin = Node->FindPin(PinName);
			if (!PinName.IsEmpty() && Pin && !Pin->LinkedTo.Num())
			{
				const bool bConnected = InSchema->TryCreateConnection(Pin, BetterSelf);
				if (!bConnected)
				{
					MessageLog.Warning(*LOCTEXT("DefaultToSelfNotConnected", "DefaultToSelf pin @@ from node @@ cannot be connected to @@").ToString(), Pin, Node, BetterSelf);
				}
			}
		}
	};
	FStructConnectHelper::Connect(DefaultToSelfMetaValue, this, BetterSelfPin, Schema, CompilerContext.MessageLog);
	if (!Function->HasMetaData(FBlueprintMetadata::MD_CallableWithoutWorldContext))
	{
		FStructConnectHelper::Connect(WorldContextMetaValue, this, BetterSelfPin, Schema, CompilerContext.MessageLog);
	}
}
```


ï»¿# AllowAnyActor

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œåœ¨UseComponentPickerçš„æƒ…å†µä¸‹ä½¿å¾—ç»„ä»¶é€‰å–å™¨æ‰©å¤§åˆ°åœºæ™¯é‡Œå…¶ä»–Actorä¸‹çš„å…¶ä»–ç»„ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Component Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FComponentReferenceï¼ŒFSoftComponentReference
- **å…³è”é¡¹ï¼š** [UseComponentPicker](UseComponentPicker/UseComponentPicker.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œåœ¨UseComponentPickerçš„æƒ…å†µä¸‹ä½¿å¾—ç»„ä»¶é€‰å–å™¨æ‰©å¤§åˆ°åœºæ™¯é‡Œå…¶ä»–Actorä¸‹çš„å…¶ä»–ç»„ä»¶ã€‚

- ä¹Ÿè¦æ³¨æ„åˆ°ï¼Œè¿™ä¸ªAllowAnyActorå½±å“çš„åªæ˜¯UIä¸Šçš„ç»„ä»¶é€‰æ‹©ã€‚ä¸€ä¸ªComponentReferenceå³ä½¿ä¸åŠ AllowAnyActorï¼Œä¹Ÿå¯ä»¥é€šè¿‡ReferencedActorå¼•ç”¨åˆ°åˆ«çš„Actorï¼Œç„¶åæ‰‹å¡«å…¶å±ä¸‹çš„ç»„ä»¶åå­—ã€‚ç„¶åå¯ä»¥æ­£å¸¸çš„åœ¨C++é‡ŒGetComponenté‡Œå‡ºæ¥æ­£ç¡®çš„ç»„ä»¶å¯¹è±¡ã€‚å› æ­¤AllowAnyActorè·Ÿé€»è¾‘æ— å…³ã€‚

æµ‹è¯•ä»£ç å’Œæ•ˆæœè§UseComponentPickerã€‚

## åŸç†ï¼š

ä¸»è¦æ˜¯FComponentReferenceCustomizationã€‚æ ¹æ®æºç æŸ¥çœ‹ï¼ŒbAllowAnyActor åªåœ¨å·²ç»æœ‰bUseComponentPickerçš„æƒ…å†µä¸‹ç”Ÿæ•ˆï¼Œä¸”ç”¨æ¥å¯¹Actoråˆ—è¡¨è¿›è¡Œè¿‡æ»¤ã€‚

```cpp
void FComponentReferenceCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& CustomizationUtils)
{
	PropertyHandle = InPropertyHandle;

	CachedComponent.Reset();
	CachedFirstOuterActor.Reset();
	CachedPropertyAccess = FPropertyAccess::Fail;

	bAllowClear = false;
	bAllowAnyActor = false;
	bUseComponentPicker = PropertyHandle->HasMetaData(NAME_UseComponentPicker);
	bIsSoftReference = false;

	if (bUseComponentPicker)
	{
		FProperty* Property = InPropertyHandle->GetProperty();
		check(CastField<FStructProperty>(Property) &&
				(FComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct ||
				FSoftComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct));

		bAllowClear = !(InPropertyHandle->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
		bAllowAnyActor = InPropertyHandle->HasMetaData(NAME_AllowAnyActor);
		bIsSoftReference = FSoftComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct;

		BuildClassFilters();
		BuildComboBox();

		InPropertyHandle->SetOnPropertyValueChanged(FSimpleDelegate::CreateSP(this, &FComponentReferenceCustomization::OnPropertyValueChanged));

		// set cached values
		{
			CachedComponent.Reset();
			CachedFirstOuterActor = GetFirstOuterActor();

			FComponentReference TmpComponentReference;
			CachedPropertyAccess = GetValue(TmpComponentReference);
			if (CachedPropertyAccess == FPropertyAccess::Success)
			{
				CachedComponent = TmpComponentReference.GetComponent(CachedFirstOuterActor.Get());
				if (!IsComponentReferenceValid(TmpComponentReference))
				{
					CachedComponent.Reset();
				}
			}
		}

		HeaderRow.NameContent()
		[
			InPropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			ComponentComboButton.ToSharedRef()
		]
		.IsEnabled(MakeAttributeSP(this, &FComponentReferenceCustomization::CanEdit));
	}
	else
	{
		HeaderRow.NameContent()
		[
			InPropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			InPropertyHandle->CreatePropertyValueWidget()
		]
		.IsEnabled(MakeAttributeSP(this, &FComponentReferenceCustomization::CanEdit));
	}
}

bool FComponentReferenceCustomization::IsFilteredActor(const AActor* const Actor) const
{
	return bAllowAnyActor || Actor == CachedFirstOuterActor.Get();
}

```


ï»¿# BlueprintSpawnableComponent

- **åŠŸèƒ½æè¿°ï¼š** å…è®¸è¯¥ç»„ä»¶å‡ºç°åœ¨Actorè“å›¾é‡ŒAddç»„ä»¶çš„é¢æ¿é‡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Component Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Componentç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…

å…è®¸è¯¥ç»„ä»¶å‡ºç°åœ¨Actorè“å›¾é‡ŒAddç»„ä»¶çš„é¢æ¿é‡Œã€‚

åœ¨è“å›¾èŠ‚ç‚¹ä¸Šï¼Œä¸ç®¡æœ‰æ²¡æœ‰BlueprintSpawnableComponentåˆ™éƒ½æ˜¯å¯ä»¥æ·»åŠ è¯¥ç»„ä»¶çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, meta = (BlueprintSpawnableComponent))
class INSIDER_API UMyActorComponent_Spawnable : public UActorComponent
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
};

UCLASS(Blueprintable)
class INSIDER_API UMyActorComponent_NotSpawnable : public UActorComponent
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
};
```

## è“å›¾ä¸­æ•ˆæœï¼š

å¯ä»¥çœ‹åˆ°ï¼Œåœ¨Actorçš„å·¦è¾¹Addçš„æŒ‰é’®ä¸‹ï¼ŒUMyActorComponent_Spawnable å¯ä»¥è¢«æ·»åŠ è¿›å»ï¼Œä½†æ˜¯UMyActorComponent_NotSpawnable è¢«é˜»æ­¢äº†ã€‚ä½†åŒæ—¶ä¹Ÿè¦æ³¨æ„åˆ°å¦‚æœåœ¨è“å›¾ä¸­AddComponentèŠ‚ç‚¹åˆ™æ˜¯éƒ½å¯ä»¥çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Component\BlueprintSpawnableComponent\Untitled.png)

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Component\BlueprintSpawnableComponent\Untitled%201.png)

## åŸç†ï¼š

```cpp
bool FKismetEditorUtilities::IsClassABlueprintSpawnableComponent(const UClass* Class)
{
	// @fixme: Cooked packages don't have any metadata (yet; they might become available via the sidecar editor data)
	// However, all uncooked BPs that derive from ActorComponent have the BlueprintSpawnableComponent metadata set on them
	// (see FBlueprintEditorUtils::RecreateClassMetaData), so include any ActorComponent BP that comes from a cooked package
	return (!Class->HasAnyClassFlags(CLASS_Abstract) &&
			Class->IsChildOf<UActorComponent>() &&
			(Class->HasMetaData(FBlueprintMetadata::MD_BlueprintSpawnableComponent) || Class->GetPackage()->bIsCookedForEditor));
}
```


ï»¿# UseComponentPicker

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œä½¿å¾—é€‰å–å™¨çš„åˆ—è¡¨é‡Œå±•ç¤ºå‡ºActorå±ä¸‹çš„Componentä»¥ä¾¿é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Component Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FComponentReferenceï¼ŒFSoftComponentReference
- **å…³è”é¡¹ï¼š** [AllowAnyActor](../AllowAnyActor.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨åœ¨ComponentReferenceå±æ€§ä¸Šï¼Œä½¿å¾—é€‰å–å™¨çš„åˆ—è¡¨é‡Œå±•ç¤ºå‡ºActorå±ä¸‹çš„Componentä»¥ä¾¿é€‰æ‹©ã€‚

- é»˜è®¤æƒ…å†µä¸‹ï¼ŒFComponentReferenceçš„Referenced Actorå±æ€§å±•å¼€çš„é€‰æ‹©å™¨åˆ—è¡¨æ˜¯è®©ä½ é€‰æ‹©åœºæ™¯é‡Œçš„Actorï¼Œå› æ­¤å¹¶ä¸ä¼šæŠŠè¯¥Actorä¸‹çš„ç»„ä»¶ä¹Ÿéƒ½æ˜¾ç¤ºå‡ºæ¥ã€‚è€ŒComponentReferenceä¸‹çš„ComponentNameå±æ€§éœ€è¦ç©å®¶æ‰‹åŠ¨å¡«å†™ã€‚è¿™ç§æ–¹å¼æ¯”è¾ƒåŸå§‹ï¼Œä¹Ÿå®¹æ˜“å‡ºé”™ã€‚
- å› æ­¤åŠ ä¸ŠUseComponentPickeråï¼Œå°±å¯ä»¥æ˜¾ç¤ºå‡ºç»„ä»¶åˆ—è¡¨æ¥é€‰æ‹©ã€‚ä½†æ˜¯åˆé»˜è®¤é™åˆ¶æ˜¯å½“å‰Actorå±ä¸‹çš„æ‰€æœ‰ç»„ä»¶ï¼Œä¸åŒ…æ‹¬åœºæ™¯é‡Œå…¶ä»–Actoré‡Œçš„ç»„ä»¶ã€‚
- å¦‚æœæƒ³è¦è¿›ä¸€æ­¥æŠŠåœºæ™¯é‡Œæ‰€æœ‰Actorä¸‹çš„æ‰€æœ‰ç»„ä»¶éƒ½åˆ—å‡ºæ¥ï¼Œåˆ™éœ€è¦è¿›ä¸€æ­¥åŠ ä¸ŠAllowAnyActorï¼Œä»¥æ‰©å¤§ç­›é€‰èŒƒå›´ã€‚
- ComponentReferenceçš„å±æ€§ç±»å‹æœ‰ä¸¤ç§ï¼ŒFComponentReferenceå’ŒFSoftComponentReferenceï¼ŒäºŒè€…éƒ½å¯¹åº”äº†FComponentReferenceCustomizationã€‚æµ‹è¯•ä»£ç ä¸ºç®€æ´å°±æ²¡æœ‰åˆ—å‡ºFSoftComponentReferenceã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "UseComponentPickerTest")
	FComponentReference MyComponentReference_NoUseComponentPicker;

	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "UseComponentPickerTest", meta = (UseComponentPicker))
	FComponentReference MyComponentReference_UseComponentPicker;

	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "UseComponentPicker_AllowAnyActor_Test", meta = (UseComponentPicker,AllowAnyActor))
	FComponentReference MyComponentReference_UseComponentPicker_AllowAnyActor;
```

## æµ‹è¯•æ•ˆæœï¼š

- å¯è§é»˜è®¤çš„ç¬¬ä¸€ä¸ªåˆ—å‡ºäº†æ‰€æœ‰Actorï¼Œä½†æ˜¯ComponentNameéœ€è¦æ‰‹å†™ã€‚
- ç¬¬äºŒä¸ªåŠ ä¸ŠUseComponentPickeråï¼Œåˆ—å‡ºäº†å½“å‰Actorä¸‹çš„æ‰€æœ‰ç»„ä»¶ï¼Œä½†æ˜¯ä¸èƒ½é€‰æ‹©åˆ°å…¶ä»–Actorçš„ç»„ä»¶ã€‚
- ç¬¬ä¸‰ä¸ªç»§ç»­åŠ ä¸ŠAllowAnyActoråï¼Œåˆ—å‡ºäº†æ‰€æœ‰Actorçš„æ‰€æœ‰ç»„ä»¶ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Component\UseComponentPicker\UseComponentPicker.jpg](UseComponentPicker.jpg)

## åŸç†:

FComponentReferenceå’ŒFSoftComponentReferenceï¼ŒäºŒè€…éƒ½å¯¹åº”äº†FComponentReferenceCustomizationã€‚çœ‹æºç å¯å‘ç°ç”¨ä¸ŠbUseComponentPickeråï¼Œä¼šä¸“é—¨åˆ›å»ºClassFilterså’ŒComboBoxï¼Œå°±æ˜¯é‡‡ç”¨ä¸åŒçš„ç±»å‹è¿‡æ»¤å™¨å’Œä¸åŒçš„UIæ¥é€‰æ‹©ç»„ä»¶ã€‚å¦åˆ™elseåˆ†æ”¯å°±æ˜¯å¾ˆæœ´ç´ çš„ç»“æ„å±æ€§å±•å¼€ç¼–è¾‘ã€‚

```cpp
void FComponentReferenceCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& CustomizationUtils)
{
	PropertyHandle = InPropertyHandle;

	CachedComponent.Reset();
	CachedFirstOuterActor.Reset();
	CachedPropertyAccess = FPropertyAccess::Fail;

	bAllowClear = false;
	bAllowAnyActor = false;
	bUseComponentPicker = PropertyHandle->HasMetaData(NAME_UseComponentPicker);
	bIsSoftReference = false;

	if (bUseComponentPicker)
	{
		FProperty* Property = InPropertyHandle->GetProperty();
		check(CastField<FStructProperty>(Property) &&
				(FComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct ||
				FSoftComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct));

		bAllowClear = !(InPropertyHandle->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
		bAllowAnyActor = InPropertyHandle->HasMetaData(NAME_AllowAnyActor);
		bIsSoftReference = FSoftComponentReference::StaticStruct() == CastFieldChecked<const FStructProperty>(Property)->Struct;

		BuildClassFilters();
		BuildComboBox();

		InPropertyHandle->SetOnPropertyValueChanged(FSimpleDelegate::CreateSP(this, &FComponentReferenceCustomization::OnPropertyValueChanged));

		// set cached values
		{
			CachedComponent.Reset();
			CachedFirstOuterActor = GetFirstOuterActor();

			FComponentReference TmpComponentReference;
			CachedPropertyAccess = GetValue(TmpComponentReference);
			if (CachedPropertyAccess == FPropertyAccess::Success)
			{
				CachedComponent = TmpComponentReference.GetComponent(CachedFirstOuterActor.Get());
				if (!IsComponentReferenceValid(TmpComponentReference))
				{
					CachedComponent.Reset();
				}
			}
		}

		HeaderRow.NameContent()
		[
			InPropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			ComponentComboButton.ToSharedRef()
		]
		.IsEnabled(MakeAttributeSP(this, &FComponentReferenceCustomization::CanEdit));
	}
	else
	{
		HeaderRow.NameContent()
		[
			InPropertyHandle->CreatePropertyNameWidget()
		]
		.ValueContent()
		[
			InPropertyHandle->CreatePropertyValueWidget()
		]
		.IsEnabled(MakeAttributeSP(this, &FComponentReferenceCustomization::CanEdit));
	}
}
```


ï»¿# ConfigHierarchyEditable

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—ä¸€ä¸ªå±æ€§å¯ä»¥åœ¨Configçš„å„ä¸ªå±‚çº§é…ç½®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿å¾—ä¸€ä¸ªå±æ€§å¯ä»¥åœ¨Configçš„å„ä¸ªå±‚çº§é…ç½®ã€‚

- æ‰€è°“Configçš„å±‚çº§ï¼ŒæŒ‡çš„æ˜¯Baseï¼ŒProjectDefaultï¼ŒEnginePlatformï¼ŒProjectPlatformè¿™äº›é€çº§è¢«æ›´é«˜ä¼˜å…ˆçº§çš„è¦†ç›–ã€‚è¿™éƒ¨åˆ†çŸ¥è¯†å¤§å®¶å¯ä»¥å‚è€ƒç½‘ä¸Šå…¶ä»–çš„configè¯¦è§£æ–‡ç« ã€‚
- ä¸€èˆ¬çš„å¸¦æœ‰Configçš„å±æ€§ï¼Œå…¶é…ç½®å€¼åªå­˜åœ¨äºUCLASSä¸Šçš„configæ ‡è¯†ç¬¦æŒ‡å®šçš„configæ–‡ä»¶ä¸­ã€‚ä½†å¦‚æœè¯¥å±æ€§åŠ ä¸ŠConfigHierarchyEditableè¿™ä¸ªæ ‡è®°ï¼Œå°±å…è®¸å®ƒåœ¨å„ä¸ªå±‚çº§éƒ½å¯ä»¥è¿›è¡Œä¸åŒçš„é…ç½®ã€‚è¿™ç§å±æ€§ä¸€èˆ¬æ˜¯æœ‰æ ¹æ®ä¸åŒå¹³å°è€Œè¦é…ç½®ä¸åŒçš„å€¼çš„éœ€æ±‚ï¼Œæ¯”å¦‚ä¸€äº›å¹³å°ç›¸å…³çš„æ€§èƒ½å‚æ•°ç­‰ã€‚

## æµ‹è¯•ä¾‹å­ï¼š

```cpp
UCLASS(config = InsiderSettings, defaultconfig)
class UMyProperty_InsiderSettings :public UDeveloperSettings
{
	GENERATED_BODY()
public:
	UPROPERTY(Config, EditAnywhere, BlueprintReadWrite, Category = ConfigHierarchy)
	FString MyString;

	UPROPERTY(Config, EditAnywhere, BlueprintReadWrite, Category = ConfigHierarchy, meta = (ConfigHierarchyEditable))
	FString MyString_ConfigHierarchyEditable;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥è§åˆ°MyString_ConfigHierarchyEditableè¾“å…¥æ¡†çš„å³è¾¹å‡ºç°äº†ä¸ªå±‚çº§æŒ‰é’®ï¼Œå¯æ‰“å¼€ä¸€ä¸ªä¸“é—¨çš„ConfigEditorï¼Œæ–¹ä¾¿ä½ åˆ†åˆ«åœ¨ä¸åŒçš„å¹³å°å’Œä¸åŒçš„å±‚çº§é…ç½®ä¸åŒçš„å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Config\ConfigHierarchyEditable\Untitled.png)

## æºç ä¾‹å­ï¼š

```cpp

UCLASS(config = Game, defaultconfig)
class COMMONUI_API UCommonUISettings : public UObject
{
		/** The set of traits defined per-platform (e.g., the default input mode, whether or not you can exit the application, etc...) */
		UPROPERTY(config, EditAnywhere, Category = "Visibility", meta=(Categories="Platform.Trait", ConfigHierarchyEditable))
		TArray<FGameplayTag> PlatformTraits;
}
```

## åŸç†ï¼š

é€»è¾‘å¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨ç»†èŠ‚é¢æ¿ç”ŸæˆValueWidgetçš„æ—¶å€™ï¼Œæ ¹æ®ConfigHierarchyEditableé…ç½®é¢å¤–å†ç”Ÿæˆä¸€ä¸ªå±‚çº§é…ç½®æŒ‰é’®ã€‚

```cpp
void FDetailPropertyRow::MakeValueWidget( FDetailWidgetRow& Row, const TSharedPtr<FDetailWidgetRow> InCustomRow, bool bAddWidgetDecoration ) const
{
	// Don't add config hierarchy to container children, can't edit child properties at the hiearchy's per file level
	TSharedPtr<IPropertyHandle> ParentHandle = PropertyHandle->GetParentHandle();
	bool bIsChildProperty = ParentHandle && (ParentHandle->AsArray() || ParentHandle->AsMap() || ParentHandle->AsSet());
		
	if (!bIsChildProperty && PropertyHandle->HasMetaData(TEXT("ConfigHierarchyEditable")))
	{
		ValueWidget->AddSlot()
		.AutoWidth()
		.VAlign(VAlign_Center)
		.HAlign(HAlign_Left)
		.Padding(4.0f, 0.0f, 4.0f, 0.0f)
		[
			PropertyCustomizationHelpers::MakeEditConfigHierarchyButton(FSimpleDelegate::CreateSP(PropertyEditor.ToSharedRef(), &FPropertyEditor::EditConfigHierarchy))
		];
	}
}
```


ï»¿# ConfigRestartRequired

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å±æ€§åœ¨è®¾ç½®é‡Œæ”¹å˜åå¼¹å‡ºé‡å¯ç¼–è¾‘å™¨çš„å¯¹è¯æ¡†ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿å±æ€§åœ¨è®¾ç½®é‡Œæ”¹å˜åå¼¹å‡ºé‡å¯ç¼–è¾‘å™¨çš„å¯¹è¯æ¡†ã€‚

è‡ªç„¶çš„ï¼Œä¸€èˆ¬æ˜¯ç”¨äºçœŸçš„éœ€è¦é‡å¯ç¼–è¾‘å™¨çš„è®¾ç½®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(Config, EditAnywhere, BlueprintReadWrite, Category = ConfigRestartRequired, meta = (ConfigRestartRequired="true"))
	FString MyString_ConfigRestartRequired;
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Config\ConfigRestartRequired\Untitled.png)

## åŸç†ï¼š

åœ¨SSettingsEditorç”Ÿæ•ˆï¼Œå¯è§å¾—æ˜¯åœ¨UIçª—å£å‘ç”Ÿæ”¹å˜ã€‚ç„¶åå¼¹å‡ºå¯¹è¯æ¡†ã€‚

```cpp
void SSettingsEditor::NotifyPostChange( const FPropertyChangedEvent& PropertyChangedEvent, class FEditPropertyChain* PropertyThatChanged )
{
		static const FName ConfigRestartRequiredKey = "ConfigRestartRequired";
		if (PropertyChangedEvent.Property->GetBoolMetaData(ConfigRestartRequiredKey) || PropertyChangedEvent.MemberProperty->GetBoolMetaData(ConfigRestartRequiredKey))
		{
						OnApplicationRestartRequiredDelegate.ExecuteIfBound();
		}
}
```


ï»¿# ConsoleVariable

- **åŠŸèƒ½æè¿°ï¼š** æŠŠä¸€ä¸ªConifgå±æ€§çš„å€¼åŒæ­¥åˆ°ä¸€ä¸ªåŒåçš„æ§åˆ¶å°å˜é‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŠŠä¸€ä¸ªConifgå±æ€§çš„å€¼åŒæ­¥åˆ°ä¸€ä¸ªåŒåçš„æ§åˆ¶å°å˜é‡ã€‚

- Configå€¼å¾€å¾€ä¹Ÿç¡®å®éœ€è¦åœ¨æ§åˆ¶å°ï¼ˆæŒ‰~ï¼‰ä¸­æ›´æ”¹ï¼Œè¿™ç§éœ€æ±‚æŒºå¸¸è§çš„ï¼Œå› æ­¤å°±æœ‰äº†è¿™ä¸ªæ ‡è®°ã€‚å…¸å‹çš„ä¾‹å­æ˜¯æºç ä¸­çš„URendererSettingsæœ‰ç›¸åŒ¹é…çš„ä¸€ç³»åˆ—â€œr.â€å¼€å¤´çš„æ§åˆ¶å˜é‡ã€‚
- Configæ–‡ä»¶ä¸­çš„å€¼ä¹Ÿä¼šå˜æˆè¿™ä¸ªConsoleVariable çš„åå­—ï¼ˆä¸€èˆ¬å½¢å¦‚ r.XXX.XXä¹‹ç±»çš„æ ¼å¼ï¼‰ï¼Œè€Œä¸æ˜¯å±æ€§åã€‚
- ä½†å•å•åŠ ä¸Šè¿™ä¸ªæ ‡è®°æ˜¯ä¸å¤Ÿçš„ï¼Œè¿™ä¸ªæ§åˆ¶å°å˜é‡æ˜¯ä¸ä¼šè¢«è‡ªåŠ¨åˆ›å»ºå‡ºæ¥çš„ã€‚å› æ­¤éœ€è¦è‡ªå·±å†ç”¨ä»£ç åˆ›å»ºï¼Œç”¨ç±»ä¼¼TAutoConsoleVariableè¿™ç§æ³¨å†ŒåŒåçš„æ§åˆ¶å°å˜é‡ã€‚
- æœ‰äº†æ§åˆ¶å°å˜é‡ä¹‹åï¼Œä¹Ÿéœ€è¦ä¸“é—¨çš„ä»£ç æ¥å¯¹äºŒè€…çš„å€¼è¿›è¡ŒåŒæ­¥ã€‚è§ä¸‹è¿°æµ‹è¯•ä»£ç ImportConsoleVariableValueså’ŒExportValuesToConsoleVariablesçš„è°ƒç”¨ã€‚
- å¦å¤–è¦æ ¼å¤–æ³¨æ„ï¼ŒConsoleVariable çš„è®¾ç½®æ˜¯æœ‰ä¼˜å…ˆçº§çš„ã€‚Consoleçš„ä¼˜å…ˆçº§æ¯”ProjectSettingsé«˜ï¼Œå› æ­¤å¦‚æœåœ¨Consoleä¸­æ”¹å˜åå†å°è¯•åœ¨ProjectSettingsä¸­æ›´æ”¹å€¼ï¼Œå°±ä¼šæŠ¥é”™ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(config = InsiderSettings, defaultconfig)
class UMyProperty_InsiderSettings :public UDeveloperSettings
{
	GENERATED_BODY()
public:
	UPROPERTY(Config, EditAnywhere, BlueprintReadWrite, Category = Console, meta = (ConsoleVariable = "i.Insider.MyStringConsole"))
	FString MyString_ConsoleVariable;
public:
	virtual void PostInitProperties() override;
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
};

//.cpp
static TAutoConsoleVariable<FString> CVarInsiderMyStringConsole(
	TEXT("i.Insider.MyStringConsole"),
	TEXT("Hello"),
	TEXT("Insider test config to set MyString."));

void UMyProperty_InsiderSettings::PostInitProperties()
{
	Super::PostInitProperties();

#if WITH_EDITOR
	if (IsTemplate())
	{
		ImportConsoleVariableValues();
	}
#endif // #if WITH_EDITOR
}

#if WITH_EDITOR
void UMyProperty_InsiderSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);	

	if (PropertyChangedEvent.Property)
	{
		ExportValuesToConsoleVariables(PropertyChangedEvent.Property);		
	}
}
#endif // #if WITH_EDITOR
```

## æµ‹è¯•ç»“æœï¼š

å¯è§ä¸€å¼€å§‹çš„æ—¶å€™æ§åˆ¶å°å’Œé…ç½®æ–‡ä»¶çš„å€¼éƒ½æ˜¯å’ŒProjectSettingsä¸­çš„å€¼åŒæ­¥ã€‚

å¦‚æœåœ¨Consoleä¸­æ”¹å˜åå†å°è¯•åœ¨ProjectSettingsä¸­æ›´æ”¹å€¼ï¼Œå°±ä¼šæŠ¥é”™ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Config\ConsoleVariable\Untitled.png)

## åŸç†ï¼š

å…·ä½“çš„å€¼åŒæ­¥é€»è¾‘å¯è§ä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°å°±çŸ¥é“äº†ï¼Œæ— éæ˜¯æ ¹æ®åå­—å»å¯»æ‰¾ç›¸åº”çš„ConsoleVariable ç„¶åget/setå€¼ã€‚

```cpp
void UDeveloperSettings::ImportConsoleVariableValues()
{}

void UDeveloperSettings::ExportValuesToConsoleVariables(FProperty* PropertyThatChanged)
{}
```


ï»¿# EditorConfig

- **åŠŸèƒ½æè¿°ï¼š** ä¿å­˜ç¼–è¾‘å™¨çš„é…ç½®

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** Config

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[EditorConfig](../../Specifier/UCLASS/Config/EditorConfig/EditorConfig.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# ArraySizeEnum

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºå›ºå®šæ•°ç»„æä¾›ä¸€ä¸ªæšä¸¾ï¼Œä½¿å¾—æ•°ç»„å…ƒç´ æŒ‰ç…§æšä¸¾å€¼æ¥ä½œä¸ºç´¢å¼•å’Œæ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Container Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** T Array[Size]
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºå›ºå®šæ•°ç»„æä¾›ä¸€ä¸ªæšä¸¾ï¼Œä½¿å¾—æ•°ç»„å…ƒç´ æŒ‰ç…§æšä¸¾å€¼æ¥ä½œä¸ºç´¢å¼•å’Œæ˜¾ç¤ºã€‚

- æ‰€è°“å›ºå®šæ•°ç»„ï¼Œæ˜¯åŒºåˆ«äºTArrayè¿™ç§å¯ä»¥åŠ¨æ€æ”¹å˜å¤§å°çš„æ•°ç»„ï¼Œè€Œæ˜¯å¹³å‡¡çš„ç”¨[size]ç›´æ¥å®šä¹‰çš„æ•°ç»„ã€‚è¿™ç§å›ºå®šæ•°ç»„ï¼ˆstatic arrayï¼‰å› ä¸ºä¸ä¼šå¢åˆ ï¼Œå› æ­¤æ‰æœ‰æ—¶é€‚åˆç”¨æšä¸¾é‡Œçš„æ‰€æœ‰å€¼ç”¨ä½œä¸‹æ ‡ï¼Œè¾¾æˆæ›´é«˜çš„ä¾¿åˆ©æ€§ã€‚
- æšä¸¾é‡Œä¸€èˆ¬ä¼šæŠŠæœ€åä¸€ä¸ªæšä¸¾é¡¹ï¼ˆä¸€èˆ¬å«åšMaxæˆ–è€…Sizeï¼Œcountä¹‹ç±»ï¼‰ä½œä¸ºæ•°æ®å¤§å°å€¼ã€‚
- æšä¸¾é‡Œä¸æƒ³æ˜¾ç¤ºçš„æšä¸¾å€¼å¯ä»¥ç”¨Hiddenéšè—èµ·æ¥ï¼Œä½†å› ä¸ºæ•°ç»„ä¸‹æ ‡å¯¹åº”çš„æ˜¯æšä¸¾é¡¹çš„ä¸‹æ ‡ï¼ˆå°±æ˜¯ç¬¬å‡ ä¸ªæšä¸¾å€¼ï¼‰è€Œä¸æ˜¯æšä¸¾é¡¹çš„å€¼ï¼Œå› æ­¤ä¼šå‘ç°æ•°ç»„çš„å®é™…æ˜¾ç¤ºé¡¹ç›®æ¯”å®šä¹‰çš„Sizeè¦å°ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UENUM(BlueprintType)
enum class EMyArrayEnumNormal :uint8
{
	First,
	Second,
	Third,
	Max,
};

UENUM(BlueprintType)
enum class EMyArrayEnumHidden :uint8
{
	First,
	Second,
	Cat = 5 UMETA(Hidden),
	Third = 2,
	Max = 3,
};

UPROPERTY(EditAnywhere, Category = ArraySizeEnumTest)
int32 MyIntArray_NoArraySizeEnum[3];

UPROPERTY(EditAnywhere, Category = ArraySizeEnumTest, meta = (ArraySizeEnum = "MyArrayEnumNormal"))
int32 MyIntArray_Normal_HasArraySizeEnum[(int)EMyArrayEnumNormal::Max];

UPROPERTY(EditAnywhere, Category = ArraySizeEnumTest, meta = (ArraySizeEnum = "MyArrayEnumHidden"))
int32 MyIntArray_Hidden_HasArraySizeEnum[(int)EMyArrayEnumHidden::Max];
```

## æµ‹è¯•æ•ˆæœï¼š

éƒ½æ˜¯å¤§å°ä¸º3çš„å›ºå®šæ•°ç»„ã€‚

- MyIntArray_NoArraySizeEnumï¼Œæ˜¯æœ€æ™®é€šçš„æ•°ç»„æ¨¡æ ·ã€‚
- MyIntArray_Normal_HasArraySizeEnumï¼Œæ­£ç»Ÿçš„ä½¿ç”¨æšä¸¾é¡¹æ¥å½“æ•°ç»„ä¸‹æ ‡çš„ä¾‹å­ã€‚å¯ä»¥å‘ç°ä¸‹æ ‡åå­—ä¸æ˜¯012ï¼Œè€Œæ˜¯æšä¸¾é¡¹åç§°äº†ã€‚
- MyIntArray_Hidden_HasArraySizeEnumé‡‡ç”¨çš„æšä¸¾é¡¹é‡Œæœ‰éšè—çš„ä¸€é¡¹Catï¼Œä½†å®ƒçš„ä¸‹æ ‡æ˜¯2ï¼ˆå› ä¸ºå®šä¹‰çš„é¡ºåºï¼‰ï¼Œå› æ­¤æ•°ç»„çš„ç¬¬3ä¸ªè¢«éšè—äº†èµ·æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Container\ArraySizeEnum\Untitled.png)

## åŸç†ï¼š

å¯ä»¥å‘ç°ä¸€å¼€å§‹åˆ¤æ–­æ˜¯å¦æ˜¯å›ºå®šæ•°ç»„ï¼ˆArrayDim>1å…¶å®å°±æ˜¯å›ºå®šæ•°ç»„äº†ï¼‰ï¼Œç„¶åé€šè¿‡åå­—æ‰¾æšä¸¾ï¼Œä»¥åŠä¸ºæ•°ç»„çš„æ¯ä¸€é¡¹å»æšä¸¾é‡Œæ‰¾æšä¸¾é¡¹ä»è€Œç”Ÿæˆç»†èŠ‚é¢æ¿é‡Œçš„å­è¡Œã€‚

```cpp
void FItemPropertyNode::InitChildNodes()
{
		if( MyProperty->ArrayDim > 1 && ArrayIndex == -1 )
		{
			// Do not add array children which are defined by an enum but the enum at the array index is hidden
			// This only applies to static arrays
			static const FName NAME_ArraySizeEnum("ArraySizeEnum");
			UEnum* ArraySizeEnum = NULL; 
			if (MyProperty->HasMetaData(NAME_ArraySizeEnum))
			{
				ArraySizeEnum	= FindObject<UEnum>(NULL, *MyProperty->GetMetaData(NAME_ArraySizeEnum));
			}
		
			// Expand array.
			for( int32 Index = 0 ; Index < MyProperty->ArrayDim ; Index++ )
			{
				bool bShouldBeHidden = false;
				if( ArraySizeEnum )
				{
					// The enum at this array index is hidden
					bShouldBeHidden = ArraySizeEnum->HasMetaData(TEXT("Hidden"), Index );
				}
		
				if( !bShouldBeHidden )
				{
					TSharedPtr<FItemPropertyNode> NewItemNode( new FItemPropertyNode);
					FPropertyNodeInitParams InitParams;
					InitParams.ParentNode = SharedThis(this);
					InitParams.Property = MyProperty;
					InitParams.ArrayOffset = Index*MyProperty->ElementSize;
					InitParams.ArrayIndex = Index;
					InitParams.bAllowChildren = true;
					InitParams.bForceHiddenPropertyVisibility = bShouldShowHiddenProperties;
					InitParams.bCreateDisableEditOnInstanceNodes = bShouldShowDisableEditOnInstance;
		
					NewItemNode->InitNode( InitParams );
					AddChildNode(NewItemNode);
				}
			}
		}
}
```


ï»¿# EditFixedOrder

- **åŠŸèƒ½æè¿°ï¼š** ä½¿æ•°ç»„çš„å…ƒç´ æ— æ³•é€šè¿‡æ‹–æ‹½æ¥é‡æ–°æ’åºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Container Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TArray
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest)
	TArray<int32> MyIntArray_NoEditFixedOrder;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest, meta = (EditFixedOrder))
	TArray<int32> MyIntArray_EditFixedOrder;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest)
	TSet<int32> MyIntSet_NoEditFixedOrder;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest, meta = (EditFixedOrder))
	TSet<int32> MyIntSet_EditFixedOrder;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest)
	TMap<int32,FString> MyIntMap_NoEditFixedOrder;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = EditFixedOrderTest, meta = (EditFixedOrder))
	TMap<int32,FString> MyIntMap_EditFixedOrder;
```

## æµ‹è¯•æ•ˆæœï¼š

- å¯è§åªæœ‰ç¬¬ä¸€ä¸ªMyIntArray_NoEditFixedOrderï¼Œåœ¨æ•°ç»„å…ƒç´ ä¸Šå‡ºç°å¯æ‹–æ‹½çš„æ ‡è®°ï¼Œç„¶åå¯ä»¥æ”¹å˜é¡ºåºã€‚
- åŠ ä¸ŠEditFixedOrderçš„TArrayå°±æ— æ³•æ”¹å˜é¡ºåºäº†ã€‚
- å…¶ä»–TSetï¼ŒTMapæ˜¯ä¸æ”¯æŒè¯¥metaçš„ï¼Œå› ä¸ºå…¶å†…éƒ¨æœ¬èº«é¡ºåºä¹Ÿæ— å…³ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Container\EditFixedOrder\EditFixedOrder.gif](EditFixedOrder.gif)

## åŸç†ï¼š

å¯ä»¥çœ‹è§ï¼Œç»†èŠ‚é¢æ¿é‡Œä¸€ä¸ªå±æ€§è¡Œæ˜¯å¦å¯é‡æ’åºçš„åˆ¤æ–­æ˜¯å¤–éƒ¨æ˜¯ä¸ªæ•°ç»„ï¼Œä¸”æ²¡æœ‰EditFixedOrderå’ŒArraySizeEnumï¼ˆå›ºå®šæ•°ç»„ï¼‰ã€‚å½“ç„¶æœ¬èº«è¿™ä¸ªå±æ€§ä¹Ÿè¦åœ¨å¯ç¼–è¾‘çŠ¶æ€ï¼ˆæ¯”å¦‚è¢«ç¦ç”¨ç°æ‰å°±æ˜¾ç„¶ä¸å¯ç¼–è¾‘äº†ï¼‰

```cpp
bool FPropertyNode::IsReorderable()
{
	FProperty* NodeProperty = GetProperty();
	if (NodeProperty == nullptr)
	{
		return false;
	}
	// It is reorderable if the parent is an array and metadata doesn't prohibit it
	const FArrayProperty* OuterArrayProp = NodeProperty->GetOwner<FArrayProperty>();

	static const FName Name_DisableReordering("EditFixedOrder");
	static const FName NAME_ArraySizeEnum("ArraySizeEnum");
	return OuterArrayProp != nullptr 
		&& !OuterArrayProp->HasMetaData(Name_DisableReordering)
		&& !IsEditConst()
		&& !OuterArrayProp->HasMetaData(NAME_ArraySizeEnum)
		&& !FApp::IsGame();
}
```


ï»¿# NoElementDuplicate

- **åŠŸèƒ½æè¿°ï¼š** å»é™¤TArrayå±æ€§é‡Œæ•°æ®é¡¹çš„Duplicateèœå•é¡¹æŒ‰é’®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Container Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TArray
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å»é™¤TArrayå±æ€§é‡Œæ•°æ®é¡¹çš„Duplicateèœå•é¡¹æŒ‰é’®ã€‚

ç”¨äºTArrayå±æ€§ï¼Œå€¼å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œå¯ä»¥æ˜¯æ•°å€¼ï¼Œç»“æ„ï¼Œä¹Ÿå¯ä»¥æ˜¯Object*ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IntArray)
	TArray<int32> MyIntArray;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = IntArray, meta = (NoElementDuplicate))
	TArray<int32> MyIntArray_NoElementDuplicate;
```

## æ•ˆæœï¼š

å¯ä»¥çœ‹åˆ°å¸¦æœ‰NoElementDuplicateçš„æ•°ç»„ï¼Œåœ¨å€¼çš„å³ä¾§ä¸‹æ‹‰ç®­å¤´çš„èœå•é¡¹é‡Œåªæœ‰ä¸¤é¡¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Container\NoElementDuplicate\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­å¦‚æœ‰NoElementDuplicateï¼Œåˆ™åªç”ŸæˆInsert_Delete èœå•ï¼Œå¦åˆ™æ˜¯é»˜è®¤çš„Insert_Delete_Duplicate ã€‚å½“ç„¶è¦æ±‚å½“å‰å±æ€§æ˜¯æ•°ç»„å±æ€§ï¼Œä¸”ä¸æ˜¯EditFixedSizeå›ºå®šå¤§å°çš„ã€‚

```cpp
void GetRequiredPropertyButtons( TSharedRef<FPropertyNode> PropertyNode, TArray<EPropertyButton::Type>& OutRequiredButtons, bool bUsingAssetPicker )
{
		const FArrayProperty* OuterArrayProp = NodeProperty->GetOwner<FArrayProperty>();
		
		if( OuterArrayProp )
		{
			if( PropertyNode->HasNodeFlags(EPropertyNodeFlags::SingleSelectOnly) && !(OuterArrayProp->PropertyFlags & CPF_EditFixedSize) )
			{
				if (OuterArrayProp->HasMetaData(TEXT("NoElementDuplicate")))
				{
					OutRequiredButtons.Add( EPropertyButton::Insert_Delete );
				}
				else
				{
					OutRequiredButtons.Add( EPropertyButton::Insert_Delete_Duplicate );
				}
			}
		}
}
```


ï»¿# ReadOnlyKeys

- **åŠŸèƒ½æè¿°ï¼š** ä½¿TMapå±æ€§çš„Keyä¸èƒ½ç¼–è¾‘ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Container Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TMapå±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿TMapå±æ€§çš„Keyä¸èƒ½ç¼–è¾‘ã€‚

æ„å‘³ç€è¿™ä¸ªTMapé‡Œçš„å…ƒç´ æ˜¯åœ¨è¿™ä¹‹å‰ï¼ˆæ„é€ å‡½æ•°é‡Œåˆå§‹åŒ–ç­‰ï¼‰å°±è®¾ç½®å¥½çš„ï¼Œä½†æˆ‘ä»¬åªå¸Œæœ›ç”¨æˆ·æ›´æ”¹å€¼çš„å†…å®¹ï¼Œè€Œä¸æ”¹Keyçš„åå­—ã€‚è¿™åœ¨æŸäº›æƒ…å†µä¸‹æ¯”è¾ƒæœ‰ç”¨ï¼Œæ¯”å¦‚ä»¥Platformä½œä¸ºKeyï¼Œè¿™æ ·Platformçš„åˆ—è¡¨æ˜¯å›ºå®šçš„å°±ä¸å¸Œæœ›ç”¨æˆ·æ›´æ”¹äº†ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ReadOnlyKeysTest)
	TMap<int32, FString> MyIntMap_NoReadOnlyKeys;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ReadOnlyKeysTest, meta = (ReadOnlyKeys))
	TMap<int32, FString> MyIntMap_ReadOnlyKeys;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyIntMap_ReadOnlyKeysçš„Keyæ˜¯ç°è‰²çš„ï¼Œä¸å¯ç¼–è¾‘ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Container\ReadOnlyKeys\Untitled.png)

## æºç é‡Œæœåˆ°ï¼š

```cpp
void FDetailPropertyRow::MakeNameOrKeyWidget( FDetailWidgetRow& Row, const TSharedPtr<FDetailWidgetRow> InCustomRow ) const
{
	if (PropertyHandle->HasMetaData(TEXT("ReadOnlyKeys")))
	{
		PropertyKeyEditor->GetPropertyNode()->SetNodeFlags(EPropertyNodeFlags::IsReadOnly, true);
	}
}
```


ï»¿# TitleProperty

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šç»“æ„æ•°ç»„é‡Œçš„ç»“æ„æˆå‘˜å±æ€§å†…å®¹æ¥ä½œä¸ºç»“æ„æ•°ç»„å…ƒç´ çš„æ˜¾ç¤ºæ ‡é¢˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Container Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TArray<FStruct>
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šç»“æ„æ•°ç»„é‡Œçš„ç»“æ„æˆå‘˜å±æ€§å†…å®¹æ¥ä½œä¸ºç»“æ„æ•°ç»„å…ƒç´ çš„æ˜¾ç¤ºæ ‡é¢˜ã€‚

## é‡ç‚¹æ˜¯ï¼š

- ä½œç”¨ç›®æ ‡ä¸ºç»“æ„æ•°ç»„TArray<FStruct>ï¼Œå…¶ä»–çš„TSetï¼ŒTMapä¸æ”¯æŒã€‚
- TitlePropertyé¡¾åæ€ä¹‰æ˜¯ç”¨ä½œæ ‡é¢˜çš„å±æ€§ã€‚ä½†è¦æ›´æ˜ç¡®ä¸€äº›ï¼Œæ ‡é¢˜æŒ‡çš„æ˜¯ç»“æ„æ•°ç»„å…ƒç´ åœ¨ç»†èŠ‚é¢æ¿é‡Œæ˜¾ç¤ºçš„æ ‡é¢˜ã€‚å±æ€§æŒ‡çš„æ˜¯ç»“æ„æ•°ç»„é‡Œçš„ç»“æ„é‡Œé¢çš„å±æ€§ã€‚
- ç„¶åä¸‹ä¸€æ­¥æ˜¯TitlePropertyçš„æ ¼å¼è¦æ€ä¹ˆå†™ã€‚æ ¹æ®å¼•æ“æºç ï¼ŒTitlePropertyæœ€åæ˜¯ç”¨FTitleMetadataFormatteræ¥è§£æè®¡ç®—å†…å®¹ã€‚é€šè¿‡æŸ¥çœ‹å…¶å†…éƒ¨ä»£ç ï¼Œå¯çŸ¥å…¶TitlePropertyæ ¼å¼å¯ä»¥ä¸ºï¼š
    - å¦‚æœTitlePropertyé‡ŒåŒ…å«â€œ{â€ï¼Œåˆ™ä¼šæŠŠé‡Œé¢çš„å­—ç¬¦ä¸²å½“ä½œä¸€ä¸ªFTextFormatï¼ˆä»¥â€œ{ArgName}â€¦â€ç»„ç»‡çš„æ ¼å¼å­—ç¬¦ä¸²ï¼‰ã€‚æœ€ç»ˆæ ¼å¼æ˜¯ä»¥â€œ{PropertyName}â€¦â€ç»„ç»‡çš„å­—ç¬¦ä¸²å»æ‰¾å¤šä¸ªå¯¹åº”çš„å±æ€§ã€‚
    - å¦åˆ™å°±ä¼šæŠŠTitlePropertyçš„å…¨éƒ¨å½“ä½œPropertyNameï¼Œç›´æ¥å»æ‰¾å¯¹åº”çš„å±æ€§åç§°ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyArrayTitleStruct
{
	GENERATED_BODY()
public:
	FMyArrayTitleStruct() = default;
	FMyArrayTitleStruct(int32 id) :MyInt(id) {}
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt = 123;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString=TEXT("Hello");
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat=456.f;
};

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = TitlePropertyTest)
TArray<FMyArrayTitleStruct> MyStructArray_NoTitleProperty;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = TitlePropertyTest, meta = (TitleProperty="{MyString}[{MyInt}]"))
TArray<FMyArrayTitleStruct> MyStructArray_HasTitleProperty;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°ï¼Œä¸‹é¢çš„æ•°ç»„å…ƒç´ çš„æ ‡é¢˜å˜ä¸ºäº†â€œHello[x]â€ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„â€œ3 membersâ€ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Container\TitleProperty\Untitled.png)

## åŸç†ï¼š

å±æ€§ç¼–è¾‘å™¨é‡Œå±æ€§èŠ‚ç‚¹å¦‚æœå‘ç°æœ‰TitlePropertyï¼Œåˆ™ä¼šç”Ÿæˆä¸€ä¸ªFTitleMetadataFormatterçš„TitlePropertyFormatter æ¥è¿›è¡Œå­—ç¬¦ä¸²æ ¼å¼çš„è§£æå’Œè¾“å‡ºç»“æœå†…å®¹ã€‚å…¶å†…éƒ¨å…¶å®çœŸæ­£ç”¨çš„åˆæ˜¯FTextFormatï¼Œè¿™æ ·æ‰å¯ä»¥æŠŠå¤šä¸ªå±æ€§çš„å†…å®¹æ‹¼æ¥æˆä¸€ä¸ªç›®æ ‡å­—ç¬¦ä¸²ã€‚

å½“ç„¶SPropertyEditorTitleè¿˜æ³¨æ„åˆ°äº†å¦‚æœæœ‰TitlePropertyï¼Œå¯èƒ½ä¼šå®æ—¶çš„æ”¹å˜ï¼Œå› æ­¤ç»‘å®šäº†ä¸€ä¸ªå‡½æ•°æ¥è¿›è¡ŒTickæ›´æ–°ã€‚

```cpp
//ç»‘å®šä¸€ä¸ªå‡½æ•°æ¥æ¯tickè·å–åå­—
void SPropertyEditorTitle::Construct( const FArguments& InArgs, const TSharedRef<FPropertyEditor>& InPropertyEditor )
{
	// If our property has title support we want to fetch the value every tick, otherwise we can just use a static value
	static const FName NAME_TitleProperty = FName(TEXT("TitleProperty"));
	const bool bHasTitleProperty = InPropertyEditor->GetProperty() && InPropertyEditor->GetProperty()->HasMetaData(NAME_TitleProperty);
	if (bHasTitleProperty)
	{
		NameTextBlock =
			SNew(STextBlock)
			.Text(InPropertyEditor, &FPropertyEditor::GetDisplayName)
			.Font(NameFont);
	}		
	else
	{
		NameTextBlock =
			SNew(STextBlock)
			.Text(InPropertyEditor->GetDisplayName())
			.Font(NameFont);
	}
}

FText FPropertyEditor::GetDisplayName() const
{
	FItemPropertyNode* ItemPropertyNode = PropertyNode->AsItemPropertyNode();

	if ( ItemPropertyNode != NULL )
	{
		return ItemPropertyNode->GetDisplayName();
	}

	if (const FComplexPropertyNode* ComplexPropertyNode = PropertyNode->AsComplexNode())
	{
		const FText DisplayName = ComplexPropertyNode->GetDisplayName();

		// Does this property define its own name?
		if (!DisplayName.IsEmpty())
		{
			return DisplayName;
		}
	}

	FString DisplayName;
	PropertyNode->GetQualifiedName( DisplayName, true );
	return FText::FromString(DisplayName);
}

//ç”ŸæˆTitleFormatteræ¥è§£æTitlePropertyé‡Œé¢çš„å†…å®¹ï¼Œæœ€åå¾—å‡ºæ–‡å­—ã€‚å‘ç°ä¸æ”¯æŒMapï¼ŒSetï¼Œå› æ­¤åªæ”¯æŒarrayã€‚ç­¾åè¿˜æœ‰ä¸ªåˆ¤æ–­ArrayIndex()==1çš„åˆ†æ”¯ï¼Œèµ°è¿›æ™®é€šå±æ€§
FText FItemPropertyNode::GetDisplayName() const
{
	if (CastField<FSetProperty>(ParentProperty) == nullptr &&  CastField<FMapProperty>(ParentProperty) == nullptr)
	{
		// Check if this property has Title Property Meta
			static const FName NAME_TitleProperty = FName(TEXT("TitleProperty"));
			FString TitleProperty = PropertyPtr->GetMetaData(NAME_TitleProperty);
			if (!TitleProperty.IsEmpty())
			{
				// Find the property and get the right property handle
				if (PropertyStruct != nullptr)
				{
					const TSharedPtr<IPropertyHandle> ThisAsHandle = PropertyEditorHelpers::GetPropertyHandle(NonConstThis->AsShared(), nullptr, nullptr);
					TSharedPtr<FTitleMetadataFormatter> TitleFormatter = FTitleMetadataFormatter::TryParse(ThisAsHandle, TitleProperty);
					if (TitleFormatter)
					{
						TitleFormatter->GetDisplayText(FinalDisplayName);
					}
				}
			}
		}
}

//ç”Ÿæˆä¸€ä¸ªTitlePropertyFormatter 
void SPropertyEditorArrayItem::Construct( const FArguments& InArgs, const TSharedRef< class FPropertyEditor>& InPropertyEditor )
{
		static const FName TitlePropertyFName = FName(TEXT("TitleProperty"));

	// if this is a struct property, try to find a representative element to use as our stand in
		if (PropertyEditor->PropertyIsA( FStructProperty::StaticClass() ))
		{
			const FProperty* MainProperty = PropertyEditor->GetProperty();
			const FProperty* ArrayProperty = MainProperty ? MainProperty->GetOwner<const FProperty>() : nullptr;
			if (ArrayProperty) // should always be true
			{
				TitlePropertyFormatter = FTitleMetadataFormatter::TryParse(PropertyEditor->GetPropertyHandle(), ArrayProperty->GetMetaData(TitlePropertyFName));
			}
		}
}
```

æºç ä¸­ä¾‹å­ï¼š

è¯»è€…è¿˜å¯ä»¥åœ¨UPropertyEditorTestObjecté‡Œæ‰¾åˆ°åº”ç”¨çš„ä¾‹å­ã€‚ç”¨testpropså‘½ä»¤è¡Œå°±å¯ä»¥æ‰“å¼€ã€‚

```cpp
	UPROPERTY(EditAnywhere, Category=ArraysOfProperties, meta=(TitleProperty=IntPropertyInsideAStruct))
	TArray<FPropertyEditorTestBasicStruct> StructPropertyArrayWithTitle;

	UPROPERTY(EditAnywhere, Category=ArraysOfProperties, meta=(TitleProperty="{IntPropertyInsideAStruct} + {FloatPropertyInsideAStruct}"))
	TArray<FPropertyEditorTestBasicStruct> StructPropertyArrayWithFormattedTitle;

	UPROPERTY(EditAnywhere, Category=ArraysOfProperties, meta=(TitleProperty=ErrorProperty))
	TArray<FPropertyEditorTestBasicStruct> StructPropertyArrayWithTitleError;

	UPROPERTY(EditAnywhere, Category=ArraysOfProperties, meta=(TitleProperty="{ErrorProperty}"))
	TArray<FPropertyEditorTestBasicStruct> StructPropertyArrayWithFormattedTitleError;
```


ï»¿# DebugTreeLeaf

- **åŠŸèƒ½æè¿°ï¼š** é˜»æ­¢BlueprintDebuggerå±•å¼€è¯¥ç±»çš„å±æ€§ä»¥åŠ é€Ÿç¼–è¾‘å™¨é‡Œè°ƒè¯•å™¨çš„æ€§èƒ½
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Debug
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

é˜»æ­¢BlueprintDebuggerå±•å¼€è¯¥ç±»çš„å±æ€§ä»¥åŠ é€Ÿç¼–è¾‘å™¨é‡Œè°ƒè¯•å™¨çš„æ€§èƒ½ã€‚å½“ä¸€ä¸ªç±»æ‹¥æœ‰è¿‡å¤šçš„å±æ€§ï¼ˆæˆ–é€’å½’åµŒå¥—å¤ªå¤šå±æ€§ï¼‰çš„æ—¶å€™ï¼ŒBlueprintDebuggeråœ¨å±•ç¤ºè¯¥ç±»çš„å±æ€§æ•°æ®çš„æ—¶å€™ä¾¿ä¼šæ¶ˆè€—è¿‡å¤šçš„æ€§èƒ½ï¼Œé€ æˆç¼–è¾‘å™¨å¡é¡¿ã€‚å› æ­¤å¯¹äºè¿™ç§ç±»ï¼Œæˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨çš„åŠ ä¸Šè¯¥æ ‡å¿—æ¥é˜»æ­¢ç»§ç»­å±•å¼€å±æ€§æ ‘ï¼Œåªåˆ°æ­¤ä¸ºæ­¢ã€‚å› æ­¤é¡¾åæ€ä¹‰ï¼Œæœ¬ç±»å˜æˆäº†è°ƒè¯•æ—¶å±æ€§æ ‘çš„å¶å­ã€‚

åœ¨æºç ä¸­åªæœ‰UAnimDataModelç”¨åˆ°äº†è¯¥æ ‡è®°ï¼Œä¸è¿‡æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨è‡ªå·±çš„ç±»ä¸ŠåŠ ä¸Šè¯¥æ ‡è®°ï¼Œå½“å®ƒæ‹¥æœ‰éå¸¸å¤šçš„å±æ€§å¹¶ä¸”åˆä¸æƒ³è°ƒè¯•å®ƒçš„æ•°æ®çš„æ—¶å€™ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(BlueprintType, meta = (DebugTreeLeaf))
class INSIDER_API UMyClass_DebugTreeLeaf :public UObject
{
	GENERATED_BODY()
	UMyClass_DebugTreeLeaf();
public:
	UPROPERTY(BlueprintReadWrite)
	TArray<int32> IntArray;
	UPROPERTY(BlueprintReadWrite)
	TMap<int32, FString> IntStringMap;
	UPROPERTY(BlueprintReadWrite)
	TSet<int32> IntSet;
};

```

## è“å›¾ä¸­çš„æ•ˆæœï¼š

UMyClass_DebugTreeLeafå¯¹è±¡ä½œä¸ºä¸€ä¸ªç±»çš„æˆå‘˜å˜é‡ï¼ˆæˆ–è€…å…¶ä»–ï¼‰ï¼Œåœ¨è“å›¾ä¸­è°ƒè¯•æŸ¥çœ‹å˜é‡ï¼Œå¼€å¯BlueprintDebuggeræŸ¥çœ‹å˜é‡å±æ€§æ—¶ã€‚å¦‚æœæ²¡æœ‰åŠ ä¸ŠDebugTreeLeafï¼Œåˆ™ä¼šé»˜è®¤çš„å±•å¼€æ‰€æœ‰å†…éƒ¨å±æ€§ã€‚è€Œå¦‚æœåŠ ä¸ŠDebugTreeLeafæ ‡å¿—ï¼Œåˆ™ä¼šåœæ­¢é€’å½’ï¼Œé˜»æ­¢å±æ€§å˜é‡çš„å±•å¼€ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Debug\DebugTreeLeaf\Snipaste_2024-02-29_21-17-51.png](Snipaste_2024-02-29_21-17-51.png)


ï»¿# AdvancedClassDisplay

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç±»å‹çš„å˜é‡åœ¨é«˜çº§æ˜¾ç¤ºé‡Œæ˜¾ç¤º

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[AdvancedClassDisplay](../../Specifier/UCLASS/Category/AdvancedClassDisplay/AdvancedClassDisplay.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# AllowEditInlineCustomization

- **åŠŸèƒ½æè¿°ï¼š** å…è®¸EditInlineçš„å¯¹è±¡å±æ€§å¯ä»¥è‡ªå®šä¹‰å±æ€§ç»†èŠ‚é¢æ¿æ¥ç¼–è¾‘è¯¥å¯¹è±¡å†…çš„æ•°æ®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [EditInline](../EditInline/EditInline.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å…è®¸EditInlineçš„å¯¹è±¡å±æ€§å¯ä»¥è‡ªå®šä¹‰å±æ€§ç»†èŠ‚é¢æ¿æ¥ç¼–è¾‘è¯¥å¯¹è±¡å†…çš„æ•°æ®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyCommonObject :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt = 123;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyCustomAsset :public UObject
{
	GENERATED_BODY()
public:
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline))
	UMyCommonObject* MyCommonObject;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline,AllowEditInlineCustomization))
	UMyCommonObject* MyCommonObject_Customization;
};

```

## æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\AllowEditInlineCustomization\Untitled.png)

è¦åšåˆ°è‡ªå®šä¹‰EditInlineçš„æ•ˆæœï¼Œé‡‡ç”¨è‡ªå®šä¹‰çš„IPropertyTypeCustomizationå’ŒRegisterCustomPropertyTypeLayoutä¹Ÿèƒ½åšåˆ°ã€‚åŒºåˆ«æ˜¯ï¼Œæ­£å¦‚ä¸Šé¢ä»£ç é‡Œçš„UMyCustomAsseté‡Œé¢æœ‰ä¸¤ä¸ªåŒç±»å‹çš„UMyCommonObject*å¯¹è±¡ï¼Œå‡å¦‚ç”¨IPropertyTypeCustomizationçš„æ–¹å¼ï¼Œå°±ä¼šå¯¼è‡´ä¸¤ä¸ªå˜é‡éƒ½å˜æˆè‡ªå®šä¹‰çš„UIæ¨¡å¼ã€‚è€Œç”¨AllowEditInlineCustomizationå°±å¯ä»¥ä½¿å¾—å…¶ä¸­ä½ æƒ³è¦çš„é‚£ä¸ªå˜æˆè‡ªå®šä¹‰æ–¹å¼ï¼Œè€Œå…¶ä»–çš„ä¸åšæ”¹å˜ã€‚

åœ¨ç”¨æ³•ä¸Šï¼ŒAllowEditInlineCustomizationå¿…é¡»é…åˆè‡ªå®šä¹‰çš„FAssetEditorToolkitæ¥è‡ªå·±å®šä¹‰ä¸€ä¸ªDetailViewï¼ˆè€Œä¸æ˜¯åªè‡ªå®šä¹‰æŸä¸ªç±»å‹åœ¨å¼•æ“ç»Ÿä¸€çš„DetailViewçš„æ˜¾ç¤ºï¼‰ï¼Œç„¶åå†è‡ªå®šä¹‰IDetailCustomizationæ¥æä¾›å…·ä½“çš„Widgetï¼Œæœ€åç”¨RegisterInstancedCustomPropertyLayoutæ¥å…³è”èµ·æ¥ã€‚

```cpp
DetailsView->RegisterInstancedCustomPropertyLayout(UMyCommonObject::StaticClass(),FOnGetDetailCustomizationInstance::CreateStatic(&FMyCommonObjectDetailsCustomization::MakeInstance));
```

ï¼ˆè¿™éƒ¨åˆ†ä»£ç å¯å‚è€ƒMyCustomAssetçš„ç›¸å…³å®ç°ï¼‰

## æºç ï¼š

```cpp
FDetailPropertyRow::FDetailPropertyRow(TSharedPtr<FPropertyNode> InPropertyNode, TSharedRef<FDetailCategoryImpl> InParentCategory, TSharedPtr<FComplexPropertyNode> InExternalRootNode)
{
		static FName InlineCustomizationKeyMeta("AllowEditInlineCustomization");
		if (PropertyNode->AsComplexNode() && ExternalRootNode.IsValid()) // AsComplexNode works both for objects and structs
		{
			// We are showing an entirely different object inline.  Generate a layout for it now.
			if (IDetailsViewPrivate* DetailsView = InParentCategory->GetDetailsView())
			{
				ExternalObjectLayout = MakeShared<FDetailLayoutData>();
				DetailsView->UpdateSinglePropertyMap(InExternalRootNode, *ExternalObjectLayout, true);
			}
		}
		else if (PropertyNode->HasNodeFlags(EPropertyNodeFlags::EditInlineNew) && PropertyNode->GetProperty()->HasMetaData(InlineCustomizationKeyMeta))
		{
			// Allow customization of 'edit inline new' objects if the metadata key has been specified.
			// The child of this node, if set, will be an object node that we will want to treat as an 'external object layout'
			TSharedPtr<FPropertyNode> ChildNode = PropertyNode->GetNumChildNodes() > 0 ? PropertyNode->GetChildNode(0) : nullptr;
			TSharedPtr<FComplexPropertyNode> ComplexChildNode = StaticCastSharedPtr<FComplexPropertyNode>(ChildNode);
			if (ComplexChildNode.IsValid())
			{
				// We are showing an entirely different object inline.  Generate a layout for it now.
				if (IDetailsViewPrivate* DetailsView = InParentCategory->GetDetailsView())
				{
					ExternalObjectLayout = MakeShared<FDetailLayoutData>();
					DetailsView->UpdateSinglePropertyMap(ComplexChildNode, *ExternalObjectLayout, true);
				}
			}
		}
		
}
```

ä½œç”¨çš„åŸç†æ˜¯åœ¨åˆ›å»ºFDetailPropertyRowçš„æ—¶å€™ï¼Œå³ä¸€ä¸ªå±æ€§çš„åœ¨ç»†èŠ‚é¢æ¿é‡Œçš„ä¸€è¡Œï¼Œå¦‚æœæœ‰AllowEditInlineCustomizationï¼Œå°±ä¼šåˆ›å»ºExternalObjectLayout ï¼Œä¹‹ååœ¨FDetailPropertyRowçš„åˆ›å»ºå­©å­çš„æ—¶å€™ï¼Œå°±ä¼šåˆ¤æ–­æ˜¯å¦æœ‰ExternalObjectLayoutï¼Œå¦‚æœæœ‰å°±å¯ä»¥åº”ç”¨ä¸Šæˆ‘ä»¬ä¹‹å‰çš„Customizationï¼Œå¦‚æœæ²¡æœ‰å°±ä¼šåº”ç”¨é»˜è®¤çš„è®¾ç½®ã€‚å¦‚ä¸‹æ˜¯ä½¿ç”¨ExternalObjectLayoutçš„ä»£ç ï¼š

```cpp
void FDetailPropertyRow::GenerateChildrenForPropertyNode( TSharedPtr<FPropertyNode>& RootPropertyNode, FDetailNodeList& OutChildren )
{
	// Children should be disabled if we are disabled
	TAttribute<bool> ParentEnabledState = TAttribute<bool>::CreateSP(this, &FDetailPropertyRow::GetEnabledState);

	if( PropertyTypeLayoutBuilder.IsValid() && bShowCustomPropertyChildren )
	{
		const TArray< FDetailLayoutCustomization >& ChildRows = PropertyTypeLayoutBuilder->GetChildCustomizations();

		for( int32 ChildIndex = 0; ChildIndex < ChildRows.Num(); ++ChildIndex )
		{
			TSharedRef<FDetailItemNode> ChildNodeItem = MakeShared<FDetailItemNode>(ChildRows[ChildIndex], ParentCategory.Pin().ToSharedRef(), ParentEnabledState);
			ChildNodeItem->Initialize();
			OutChildren.Add( ChildNodeItem );
		}
	}
	else if (ExternalObjectLayout.IsValid() && ExternalObjectLayout->DetailLayout->HasDetails())
	{
		OutChildren.Append(ExternalObjectLayout->DetailLayout->GetAllRootTreeNodes());
		//è‡ªå®šä¹‰çš„é¢æ¿
	}
	else if ((bShowCustomPropertyChildren || !CustomPropertyWidget.IsValid()) && RootPropertyNode->GetNumChildNodes() > 0)
{
	//æ­£å¸¸çš„é»˜è®¤åˆ›å»ºå­©å­
}
```

æºç é‡Œä½¿ç”¨çš„ä¸€ä¸ªä¾‹å­æ˜¯LevelSequenceä¸ŠBind Actorä¸Šçš„Binding Propertyçš„ç»†èŠ‚é¢æ¿ã€‚

å‡å¦‚æˆ‘ä»¬é‡‡ç”¨ä¸€äº›ä»£ç å»æ‰

```cpp
USTRUCT()
struct FMovieSceneBindingPropertyInfo
{
	GENERATED_BODY()

	// Locator for the entry
	UPROPERTY(EditAnywhere, Category = "Default", meta=(AllowedLocators="Actor", DisplayName="Actor"))
	FUniversalObjectLocator Locator;

	// Flags for how to resolve the locator
	UPROPERTY()
	ELocatorResolveFlags ResolveFlags = ELocatorResolveFlags::None;

	UPROPERTY(Instanced, VisibleAnywhere, Category = "Default", meta=(EditInline, AllowEditInlineCustomization, DisplayName="Custom Binding Type"))
	UMovieSceneCustomBinding* CustomBinding = nullptr;
};

//è‡ªå·±Hack ä»£ç 
UObject* obj = UInsiderLibrary::FindObjectWithNameSmart(TEXT("MovieSceneBindingPropertyInfo"));
UScriptStruct* ss = Cast<UScriptStruct>(obj);
FProperty* prop = ss->FindPropertyByName(TEXT("CustomBinding"));
prop->RemoveMetaData(TEXT("AllowEditInlineCustomization"));
```

æ•ˆæœå°±ä¼šä»å·¦å˜åˆ°å³è¾¹ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\AllowEditInlineCustomization\AllowEditInlineCustomization\Untitled%201.png)

æ³¨å†Œçš„æ–¹å¼ä¹Ÿä¸åŒï¼š

```cpp
void ULevelSequenceEditorSubsystem::AddBindingDetailCustomizations(TSharedRef<IDetailsView> DetailsView, TSharedPtr<ISequencer> ActiveSequencer, FGuid BindingGuid)
{
	// TODO: Do we want to create a generalized way for folks to add instanced property layouts for other custom binding types so they can have access to sequencer context?
	if (ActiveSequencer.IsValid())
	{
		UMovieSceneSequence* Sequence = ActiveSequencer->GetFocusedMovieSceneSequence();
		UMovieScene* MovieScene = Sequence ? Sequence->GetMovieScene() : nullptr;
		if (MovieScene)
		{
			FPropertyEditorModule& PropertyEditor = FModuleManager::Get().LoadModuleChecked<FPropertyEditorModule>(TEXT("PropertyEditor"));
			DetailsView->RegisterInstancedCustomPropertyTypeLayout(FMovieSceneBindingPropertyInfo::StaticStruct()->GetFName(), FOnGetPropertyTypeCustomizationInstance::CreateLambda([](TWeakPtr<ISequencer> InSequencer, UMovieScene* InMovieScene, FGuid InBindingGuid, ULevelSequenceEditorSubsystem* LevelSequenceEditorSubsystem)
				{
					return MakeShared<FMovieSceneBindingPropertyInfoDetailCustomization>(InSequencer, InMovieScene, InBindingGuid, LevelSequenceEditorSubsystem);
				}, ActiveSequencer.ToWeakPtr(), MovieScene, BindingGuid, this));
			
			DetailsView->RegisterInstancedCustomPropertyLayout(UMovieSceneSpawnableActorBinding::StaticClass(), FOnGetDetailCustomizationInstance::CreateStatic(&FMovieSceneSpawnableActorBindingBaseCustomization::MakeInstance, ActiveSequencer.ToWeakPtr(), MovieScene, BindingGuid));
		}
	}
}
```


ï»¿# AutoCollapseCategories

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šç±»å†…éƒ¨çš„å±æ€§ç›®å½•è‡ªåŠ¨æŠ˜å èµ·æ¥

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[AutoCollapseCategories](../../Specifier/UCLASS/Category/AutoCollapseCategories/AutoCollapseCategories.md), [DontAutoCollapseCategories](../../Specifier/UCLASS/Category/DontAutoCollapseCategories.md), [AutoExpandCategories](../../Specifier/UCLASS/Category/AutoExpandCategories/AutoExpandCategories.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# AutoExpandCategories

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šç±»å†…éƒ¨çš„å±æ€§ç›®å½•è‡ªåŠ¨å±•å¼€èµ·æ¥

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[AutoExpandCategories](../../Specifier/UCLASS/Category/AutoExpandCategories/AutoExpandCategories.md), [AutoCollapseCategories](../../Specifier/UCLASS/Category/AutoCollapseCategories/AutoCollapseCategories.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# bShowOnlyWhenTrue

- **åŠŸèƒ½æè¿°ï¼š** æ ¹æ®ç¼–è¾‘å™¨configé…ç½®æ–‡ä»¶é‡Œå­—æ®µå€¼æ¥å†³å®šå½“å‰å±æ€§æ˜¯å¦æ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ¹æ®ç¼–è¾‘å™¨configé…ç½®æ–‡ä»¶é‡Œå­—æ®µå€¼æ¥å†³å®šå½“å‰å±æ€§æ˜¯å¦æ˜¾ç¤ºã€‚

- è¿™ä¸ªç¼–è¾‘å™¨configé…ç½®æ–‡ä»¶ï¼ŒæŒ‡çš„æ˜¯GEditorPerProjectIniï¼Œå› æ­¤ä¸€èˆ¬æ˜¯Config\DefaultEditorPerProjectUserSettings.ini
- å…¶ä¸­Sectionçš„åå­—æ˜¯â€œUnrealEd.PropertyFiltersâ€
- ç„¶åKeyçš„å€¼å°±å¯ä»¥å®šäº†ã€‚

åœ¨æºç é‡Œæ²¡æœ‰æ‰¾åˆ°ä½¿ç”¨çš„ä¾‹å­ï¼Œä½†è¿™ä¾ç„¶æ˜¯å¯ä»¥å·¥ä½œçš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
D:\github\GitWorkspace\Hello\Config\DefaultEditorPerProjectUserSettings.ini
[UnrealEd.PropertyFilters]
ShowMyInt=true
ShowMyString=false

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Show :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (bShowOnlyWhenTrue = "ShowMyInt"))
	int32 MyInt_WithShowOnly = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (bShowOnlyWhenTrue = "ShowMyString"))
	FString MyString_WithShowOnly;
};
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyString_WithShowOnlyå°±æ²¡æœ‰æ˜¾ç¤ºå‡ºæ¥ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨DefaultEditorPerProjectUserSettingsä¸­é…ç½®äº†ShowMyString=falseã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\bShowOnlyWhenTrue\Untitled.png)

## åŸç†ï¼š

å°±æ˜¯å–å¾—configä¸­çš„å€¼ç”¨æ¥å†³å®šå±æ€§æ¡†æ˜¯å¦æ˜¾ç¤ºã€‚

```cpp
void FObjectPropertyNode::GetCategoryProperties(const TSet<UClass*>& ClassesToConsider, const FProperty* CurrentProperty, bool bShouldShowDisableEditOnInstance, bool bShouldShowHiddenProperties,
	const TSet<FName>& CategoriesFromBlueprints, TSet<FName>& CategoriesFromProperties, TArray<FName>& SortedCategories)
{
	bool bMetaDataAllowVisible = true;
	const FString& ShowOnlyWhenTrueString = CurrentProperty->GetMetaData(Name_bShowOnlyWhenTrue);
	if (ShowOnlyWhenTrueString.Len())
	{
		//ensure that the metadata visibility string is actually set to true in order to show this property
		GConfig->GetBool(TEXT("UnrealEd.PropertyFilters"), *ShowOnlyWhenTrueString, bMetaDataAllowVisible, GEditorPerProjectIni);
	}
	
	if (bMetaDataAllowVisible)
	{
		if (PropertyEditorHelpers::ShouldBeVisible(*this, CurrentProperty) && !HiddenCategories.Contains(CategoryName))
		{
			if (!CategoriesFromBlueprints.Contains(CategoryName) && !CategoriesFromProperties.Contains(CategoryName))
			{
				SortedCategories.AddUnique(CategoryName);
			}
			CategoriesFromProperties.Add(CategoryName);
		}
	}

}

void FCategoryPropertyNode::InitChildNodes()
{
		bool bMetaDataAllowVisible = true;
		if (!bShowHiddenProperties)
		{
						static const FName Name_bShowOnlyWhenTrue("bShowOnlyWhenTrue");
						const FString& MetaDataVisibilityCheckString = It->GetMetaData(Name_bShowOnlyWhenTrue);
						if (MetaDataVisibilityCheckString.Len())
						{
							//ensure that the metadata visibility string is actually set to true in order to show this property
							// @todo Remove this
							GConfig->GetBool(TEXT("UnrealEd.PropertyFilters"), *MetaDataVisibilityCheckString, bMetaDataAllowVisible, GEditorPerProjectIni);
						}
		}

}
```


ï»¿# Category

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­çš„åˆ†ç±»

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="A | B | C"

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[Category](../../Specifier/UFUNCTION/Category/Category.md)
  UPROPERTYï¼š[Category](../../Specifier/UPROPERTY/DetaisPanel/Category/Category.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# ClassGroupNames

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šClassGroupçš„åå­—

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

- **é™åˆ¶ç±»å‹ï¼š** TArray<FString>

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[ClassGroup](../../Specifier/UCLASS/Category/ClassGroup/ClassGroup.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# DeprecatedNode

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºBehaviorTreeNodeæˆ–EnvQueryNodeï¼Œè¯´æ˜è¯¥ç±»å·²åºŸå¼ƒï¼Œåœ¨ç¼–è¾‘å™¨ä¸­çº¢è‰²é”™è¯¯å±•ç¤ºå¹¶æœ‰é”™è¯¯ToolTipæç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** BehaviorTreeNodeï¼ŒEnvQueryNode
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨AIè¡Œä¸ºæ ‘æˆ–EQSçš„èŠ‚ç‚¹ä¸Šè®¾ç½®ï¼Œæ ‡è®°è¯¥èŠ‚ç‚¹å·²ç»å¼ƒç”¨ã€‚

## æºç ä¸­çš„ä¾‹å­ï¼š

```cpp
UCLASS(meta = (DeprecatedNode, DeprecationMessage = "Please use IsAtLocation decorator instead."), MinimalAPI)
class UBTDecorator_ReachedMoveGoal : public UBTDecorator
{
	GENERATED_UCLASS_BODY()
};

UCLASS(MinimalAPI, meta=(DeprecatedNode, DeprecationMessage = "This class is now deprecated, please use RunMode supporting random results instead."))
class UEnvQueryTest_Random : public UEnvQueryTest
{
	GENERATED_UCLASS_BODY()
};
```

## C++æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(meta = (DeprecatedNode, DeprecationMessage = "This BT node is deprecated. Don't use this anymore."), MinimalAPI)
class UBTTask_MyDeprecatedNode : public UBTTaskNode
{
	GENERATED_UCLASS_BODY()
};
```

è¡Œä¸ºæ ‘é‡Œçš„ç»“æœï¼Œå¦‚æœåŠ ä¸ŠDeprecatedNodeï¼Œå°±ä¼šçº¢è‰²æ˜¾ç¤ºï¼Œå¹¶æç¤ºé”™è¯¯ä¿¡æ¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\DeprecatedNode\Untitled.png)

## æºç é‡Œæµ‹è¯•çš„ä»£ç ï¼š

```cpp
FString FGraphNodeClassHelper::GetDeprecationMessage(const UClass* Class)
{
	static FName MetaDeprecated = TEXT("DeprecatedNode");
	static FName MetaDeprecatedMessage = TEXT("DeprecationMessage");
	FString DefDeprecatedMessage("Please remove it!");
	FString DeprecatedPrefix("DEPRECATED");
	FString DeprecatedMessage;

	if (Class && Class->HasAnyClassFlags(CLASS_Native) && Class->HasMetaData(MetaDeprecated))
	{
		DeprecatedMessage = DeprecatedPrefix + TEXT(": ");
		DeprecatedMessage += Class->HasMetaData(MetaDeprecatedMessage) ? Class->GetMetaData(MetaDeprecatedMessage) : DefDeprecatedMessage;
	}

	return DeprecatedMessage;
}
```


ï»¿# DisplayAfter

- **åŠŸèƒ½æè¿°ï¼š** ä½¿æœ¬å±æ€§åœ¨æŒ‡å®šçš„å±æ€§ä¹‹åæ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿æœ¬å±æ€§åœ¨æŒ‡å®šçš„å±æ€§ä¹‹åæ˜¾ç¤ºã€‚

- é»˜è®¤æƒ…å†µä¸‹ï¼Œå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­çš„é¡ºåºæ˜¯ä¾ç…§å¤´æ–‡ä»¶ä¸­çš„å®šä¹‰é¡ºåºã€‚ä½†å¦‚æœæˆ‘ä»¬æƒ³è‡ªå·±è°ƒèŠ‚è¿™ä¸ªé¡ºåºï¼Œå°±å¯ä»¥ç”¨è¯¥æ ‡è®°ã€‚
- é™åˆ¶æ¡ä»¶æ˜¯è¿™ä¸¤ä¸ªå±æ€§å¿…é¡»å¾—æ˜¯åœ¨åŒä¸€ä¸ªCategoryä¸‹ã€‚è¿™ä¹Ÿå¾ˆå¥½ç†è§£ï¼ŒCategoryç»„ç»‡çš„ä¼˜å…ˆçº§è‚¯å®šæ›´å¤§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Priority :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AfterTest)
	int32 MyInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AfterTest)
	FString MyString;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AfterTest, meta = (DisplayAfter = "MyInt"))
	int32 MyInt_After = 123;
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = AfterTest2, meta = (DisplayAfter = "MyInt"))
	int32 MyInt_After2 = 123;

};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyInt_Afterç›´æ¥åœ¨Intåæ˜¾ç¤ºã€‚

è€ŒMyInt_After2 å› ä¸ºåœ¨ä¸åŒçš„Categoryä¸‹ï¼Œå› æ­¤å°±ä¿ç•™åŸæ ·ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\DisplayAfter\Untitled.png)

## åŸç†ï¼š

æ£€æŸ¥è¯¥å±æ€§å¦‚æœæœ‰DisplayAfterï¼Œå°±æŠŠå®ƒæ’å…¥åœ¨æŒ‡å®šçš„å±æ€§ä¹‹åã€‚

```cpp
	void PropertyEditorHelpers::OrderPropertiesFromMetadata(TArray<FProperty*>& Properties)
	{
		const FString& DisplayAfterPropertyName = Prop->GetMetaData(NAME_DisplayAfter);
		if (DisplayAfterPropertyName.IsEmpty())
		{
			InsertProperty(OrderedProperties);
		}
		else
		{
			TArray<TPair<FProperty*, int32>>& DisplayAfterProperties = DisplayAfterPropertyMap.FindOrAdd(FName(*DisplayAfterPropertyName));
			InsertProperty(DisplayAfterProperties);
		}
	}
```


ï»¿# DisplayPriority

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæœ¬å±æ€§åœ¨ç»†èŠ‚é¢æ¿çš„æ˜¾ç¤ºé¡ºåºä¼˜å…ˆçº§ï¼Œè¶Šå°çš„ä¼˜å…ˆçº§è¶Šé«˜ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** int32
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šæœ¬å±æ€§åœ¨ç»†èŠ‚é¢æ¿çš„æ˜¾ç¤ºé¡ºåºä¼˜å…ˆçº§ï¼Œè¶Šå°çš„ä¼˜å…ˆçº§è¶Šé«˜ã€‚

- å¦‚æœæœ‰DisplayAfterçš„è®¾ç½®ï¼Œåˆ™DisplayAfterçš„ä¼˜å…ˆçº§æ›´é«˜ã€‚
- åŒæ ·çš„é™åˆ¶å¾—æ˜¯åœ¨åŒCategoryé‡Œã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PriorityTest, meta = (DisplayPriority = 3))
	int32 MyInt_P3 = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PriorityTest, meta = (DisplayPriority = 1))
	int32 MyInt_P1 = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PriorityTest, meta = (DisplayPriority = 2))
	int32 MyInt_P2 = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PriorityTest, meta = (DisplayPriority = 4,DisplayAfter="MyInt_P1"))
	int32 MyInt_P4 = 123;
```

## æµ‹è¯•ç»“æœï¼š

P4å³ä½¿ä¼˜å…ˆçº§æ¯”è¾ƒä½ï¼Œä½†å› ä¸ºDisplayAfterä¹Ÿä»ç„¶æ’åœ¨äº†P1ä¹‹åã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\DisplayPriority\Untitled.png)

## åŸç†ï¼š

æ’åºçš„é€»è¾‘åœ¨è¿™ä¸ªå‡½æ•°å†…ï¼Œè‡ªè¡ŒæŸ¥çœ‹å°±å¥½ã€‚ä¸€ä¸ªç®€å•çš„æ’å…¥æ’åºç®—æ³•ã€‚

```cpp
void PropertyEditorHelpers::OrderPropertiesFromMetadata(TArray<FProperty*>& Properties)
{}
```


ï»¿# EditCondition

- **åŠŸèƒ½æè¿°ï¼š** ç»™ä¸€ä¸ªå±æ€§æŒ‡å®šå¦å¤–ä¸€ä¸ªå±æ€§æˆ–è€…è¡¨è¾¾å¼æ¥ä½œä¸ºæ˜¯å¦å¯ç¼–è¾‘çš„æ¡ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [EditConditionHides](../EditConditionHides/EditConditionHides.md), [InlineEditConditionToggle](../InlineEditConditionToggle/InlineEditConditionToggle.md), [HideEditConditionToggle](../HideEditConditionToggle/HideEditConditionToggle.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ç»™ä¸€ä¸ªå±æ€§æŒ‡å®šå¦å¤–ä¸€ä¸ªå±æ€§æˆ–è€…è¡¨è¾¾å¼æ¥ä½œä¸ºæ˜¯å¦å¯ç¼–è¾‘çš„æ¡ä»¶ã€‚

- è¡¨è¾¾å¼é‡Œå¼•ç”¨çš„å±æ€§å¿…é¡»å¾—æ˜¯åŒä¸€ä¸ªç±»æˆ–ç»“æ„èŒƒå›´å†…çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_EditCondition_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property)
	bool MyBool;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property)
	int32 MyInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property, meta = (EditCondition = "MyBool"))
	int32 MyInt_EditCondition = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property, meta = (EditCondition = "!MyBool"))
	int32 MyInt_EditCondition_Not = 123;

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression)
	int32 MyFirstInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression)
	int32 MySecondInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression, meta = (EditCondition = "(MyFirstInt+MySecondInt)==500"))
	int32 MyInt_EditConditionExpression = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression, meta = (EditCondition = "!((MyFirstInt+MySecondInt)==500)"))
	int32 MyInt_EditConditionExpression_Not = 123;
};
```

## æµ‹è¯•ç»“æœï¼š

- å¯ä»¥é€šè¿‡boolå•ä¸ªå±æ€§æ¥æ§åˆ¶å…¶ä»–å±æ€§æ˜¯å¦å¯ä»¥ç¼–è¾‘
- ä¹Ÿå¯ä»¥é€šè¿‡ä¸€ä¸ªè¡¨è¾¾å¼å¼•å…¥æ›´å¤æ‚çš„è®¡ç®—æœºåˆ¶æ¥å†³å®šæ˜¯å¦æ¥ç¼–è¾‘ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\EditCondition\EditCondition.gif](EditCondition.gif)

## åŸç†ï¼š

åœ¨ç»†èŠ‚é¢æ¿çš„å±æ€§åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­è¯¥å±æ€§EditConditionè®¾ç½®ï¼Œå¦‚æœæœ‰å€¼ï¼Œä¼šåˆ›å»ºFEditConditionParseræ¥è§£æè¡¨è¾¾å¼ç„¶åæ±‚å€¼ã€‚

```cpp
void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
	const FString& EditConditionString = MyProperty->GetMetaData(TEXT("EditCondition"));

	// see if the property supports some kind of edit condition and this isn't the "parent" property of a static array
	const bool bIsStaticArrayParent = MyProperty->ArrayDim > 1 && GetArrayIndex() != -1;
	if (!EditConditionString.IsEmpty() && !bIsStaticArrayParent)
	{
		EditConditionExpression = EditConditionParser.Parse(EditConditionString);
		if (EditConditionExpression.IsValid())
		{
			EditConditionContext = MakeShareable(new FEditConditionContext(*this));
		}
	}
		
}
```


ï»¿# EditConditionHides

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å·²ç»æœ‰EditConditionçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šè¯¥å±æ€§åœ¨EditConditionä¸æ»¡è¶³çš„æƒ…å†µä¸‹éšè—èµ·æ¥ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [EditCondition](../EditCondition/EditCondition.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨å·²ç»æœ‰EditConditionçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šè¯¥å±æ€§åœ¨EditConditionä¸æ»¡è¶³çš„æƒ…å†µä¸‹éšè—èµ·æ¥ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_EditCondition_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property)
	bool MyBool;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Property, meta = (EditConditionHides, EditCondition = "MyBool"))
	int32 MyInt_EditCondition_Hides = 123;

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression)
	int32 MyFirstInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression)
	int32 MySecondInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PropertyExpression, meta = (EditConditionHides, EditCondition = "(MyFirstInt+MySecondInt)==500"))
	int32 MyInt_EditConditionExpression_Hides = 123;
};
```

## æµ‹è¯•æ•ˆæœï¼š

ä¸‹é¢çš„å›¾ä¸­å¯ä»¥æ˜æ˜¾è§åˆ°ä¸¤ä¸ªå±æ€§éšç€æ¡ä»¶çš„æ»¡è¶³æ˜¾ç¤ºäº†å‡ºæ¥ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\EditConditionHides\EditConditionHides.gif](EditConditionHides.gif)

## åŸç†ï¼š

å…¶å®å°±æ˜¯åŠ äº†ä¸ªæ˜¯å¦æ˜¾ç¤ºçš„åˆ¤æ–­ã€‚

```cpp
bool FPropertyNode::IsOnlyVisibleWhenEditConditionMet() const
{
	static const FName Name_EditConditionHides("EditConditionHides");
	if (Property.IsValid() && Property->HasMetaData(Name_EditConditionHides))
	{
		return HasEditCondition();
	}

	return false;
}
```


ï»¿# EditInline

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºå¯¹è±¡å±æ€§åˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä½œä¸ºå­å¯¹è±¡ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** [NoEditInline](../NoEditInline.md), [AllowEditInlineCustomization](../AllowEditInlineCustomization/AllowEditInlineCustomization.md), [ForceInlineRow](../ForceInlineRow/ForceInlineRow.md)

  UPROPERTYï¼š[Instanced](../../../Specifier/UPROPERTY/Instance/Instanced/Instanced.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºå¯¹è±¡å±æ€§åˆ›å»ºä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä½œä¸ºå­å¯¹è±¡ã€‚

ä¹Ÿå¯ä»¥æ‰‹åŠ¨è®¾ç½®ã€‚å¦‚æœUClassä¸Šæœ‰EditInlineNewï¼Œä½†æ˜¯å±æ€§ä¸Šæ²¡æœ‰Instancedï¼Œè¿™ä¸ªæ—¶å€™å¯ä»¥æ‰‹åŠ¨çš„è®¾ç½®EditInlineç„¶åé€šè¿‡è‡ªå·±æ‰‹åŠ¨èµ‹å€¼å¯¹è±¡å¼•ç”¨å±æ€§æ¥ä½¿å¾—è¿™ä¸ªå¯¹è±¡å¯ä»¥ç›´æ¥ç¼–è¾‘ã€‚

å’ŒShowInnerPropertiesæ˜¯å¦ç­‰ä»·ï¼ŸEditInlineåœ¨å¯¹è±¡å®¹å™¨ï¼ˆArray,Map,Setï¼‰çš„æƒ…å†µä¸‹ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚ä½†ShowInnerPropertiesåªèƒ½åœ¨å•ä¸ªå¯¹è±¡å±æ€§ä¸Šç”Ÿæ•ˆã€‚

å¯ä»¥è®¾ç½®åœ¨Structä¸Šï¼Ÿçœ‹æºç é‡Œä¹Ÿæœ‰è¯¥è®¾ç½®ã€‚ä½†å…¶å®å¹¶æ²¡æœ‰æ•ˆæœã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UMyProperty_EditInline_Sub* MyObject;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline))
	UMyProperty_EditInline_Sub* MyObject_EditInline;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (NoEditInline))
	UMyProperty_EditInline_Sub* MyObject_NoEditInline;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<UMyProperty_EditInline_Sub*> MyObjectArray;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline))
	TArray<UMyProperty_EditInline_Sub*> MyObjectArray_EditInline;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (NoEditInline))
	TArray<UMyProperty_EditInline_Sub*> MyObjectArray_NoEditInline;
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\EditInline\Untitled.png)

## åŸç†ï¼š

ä¼šç›¸åº”çš„è®¾ç½®EPropertyNodeFlags::EditInlineNewã€‚

```cpp
void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
		// we are EditInlineNew if this property has the flag, or if inside a container that has the flag.
		bIsEditInlineNew = GotReadAddresses && bIsObjectOrInterface && !MyProperty->HasMetaData(Name_NoEditInline) && 
			(MyProperty->HasMetaData(Name_EditInline) || (bIsInsideContainer && OwnerProperty->HasMetaData(Name_EditInline)));
		bShowInnerObjectProperties = bIsObjectOrInterface && MyProperty->HasMetaData(Name_ShowInnerProperties);
		
		if (bIsEditInlineNew)
		{
			SetNodeFlags(EPropertyNodeFlags::EditInlineNew, true);
		}
		else if (bShowInnerObjectProperties)
		{
			SetNodeFlags(EPropertyNodeFlags::ShowInnerObjectProperties, true);
		}
}

bool SPropertyEditorEditInline::Supports( const FPropertyNode* InTreeNode, int32 InArrayIdx )
{
	return InTreeNode
		&& InTreeNode->HasNodeFlags(EPropertyNodeFlags::EditInlineNew)
		&& InTreeNode->FindObjectItemParent()
		&& !InTreeNode->IsPropertyConst();
}

void FItemPropertyNode::InitExpansionFlags(void)
{
	FProperty* MyProperty = GetProperty();

	if (TSharedPtr<FPropertyNode>& ValueNode = GetOrCreateOptionalValueNode())
	{
		// This is a set optional, so check its SetValue instead.
		MyProperty = ValueNode->GetProperty();
	}

	bool bExpandableType = CastField<FStructProperty>(MyProperty)
		|| (CastField<FArrayProperty>(MyProperty) || CastField<FSetProperty>(MyProperty) || CastField<FMapProperty>(MyProperty));

	if (bExpandableType
		|| HasNodeFlags(EPropertyNodeFlags::EditInlineNew)
		|| HasNodeFlags(EPropertyNodeFlags::ShowInnerObjectProperties)
		|| (MyProperty->ArrayDim > 1 && ArrayIndex == -1))
	{
		SetNodeFlags(EPropertyNodeFlags::CanBeExpanded, true);
	}
}
```


ï»¿# ForceInlineRow

- **åŠŸèƒ½æè¿°ï¼š** å¼ºåˆ¶TMapå±æ€§é‡Œçš„ç»“æ„keyå’Œå…¶ä»–Valueåˆå¹¶åˆ°åŒä¸€è¡Œæ¥æ˜¾ç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [EditInline](../EditInline/EditInline.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å¼ºåˆ¶TMapå±æ€§é‡Œçš„ç»“æ„keyå’Œå…¶ä»–Valueåˆå¹¶åˆ°åŒä¸€è¡Œæ¥æ˜¾ç¤ºã€‚è¿™é‡Œè¦æ³¨æ„çš„ç‚¹æ˜¯ï¼š

- æœ¬å±æ€§æ˜¯TMapå±æ€§ï¼Œè¿™æ ·æ‰æœ‰Keyã€‚TArrayæˆ–TSetæ˜¯æ²¡æœ‰ç”¨çš„ã€‚
- FStructä½œä¸ºKeyï¼Œè¿™æ ·æºç é‡Œçš„æœºåˆ¶æ‰èƒ½ç”Ÿæ•ˆï¼Œå› ä¸ºåˆ¤æ–­çš„å°±æ˜¯Key Property
- è¯¥FStructæœ‰æ³¨å†Œç›¸å…³çš„IPropertyTypeCustomizationï¼Œè¿™æ ·æ‰èƒ½è‡ªå®šä¹‰è¯¥ç»“æ„çš„æ˜¾ç¤ºUI
- è¯¥IPropertyTypeCustomizationçš„ShouldInlineKeyè¿”å›falseï¼ˆé»˜è®¤å°±æ˜¯ï¼‰ï¼Œå¦åˆ™trueçš„è¯åˆ™ä¸ç®¡æœ‰æ²¡æœ‰æ ‡ForceInlineRowï¼Œéƒ½ä¼šåˆå¹¶æˆä¸€è¡Œ

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TMap<FMyCommonStruct, int32> MyStructMap;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ForceInlineRow))
	TMap<FMyCommonStruct, int32> MyStructMap_ForceInlineRow;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TMap<int32, FMyCommonStruct> MyStructMap2;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ForceInlineRow))
	TMap<int32, FMyCommonStruct> MyStructMap_ForceInlineRow2;
	
	

void FMyCommonStructCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> PropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& CustomizationUtils)
{
	HeaderRow.NameContent()[SNew(STextBlock).Text(INVTEXT("This is MyCommonStruct"))];

	TSharedPtr<IPropertyHandle> IntPropertyHandle = PropertyHandle->GetChildHandle(GET_MEMBER_NAME_CHECKED(FMyCommonStruct, MyInt));
	TSharedPtr<IPropertyHandle> StringPropertyHandle = PropertyHandle->GetChildHandle(GET_MEMBER_NAME_CHECKED(FMyCommonStruct, MyString));

	HeaderRow.ValueContent()
		[
			SNew(SHorizontalBox)
				+ SHorizontalBox::Slot()
				.Padding(5.0f, 0.0f).AutoWidth()
				[
					IntPropertyHandle->CreatePropertyNameWidget()
				]
				+ SHorizontalBox::Slot()
				.Padding(5.0f, 0.0f).AutoWidth()
				[
					IntPropertyHandle->CreatePropertyValueWidget()
				]
				+ SHorizontalBox::Slot()
				.Padding(5.0f, 0.0f).AutoWidth()
				[
					StringPropertyHandle->CreatePropertyNameWidget()
				]
				+ SHorizontalBox::Slot()
				.Padding(5.0f, 0.0f).AutoWidth()
				[
					StringPropertyHandle->CreatePropertyValueWidget()
				]
		];

}
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥è§åˆ°MyStructMapçš„æ•°æ®é¡¹å±•ç¤ºå°±åˆ†ä¸ºäº†ä¸¤è¡Œã€‚è€Œå¸¦æœ‰ForceInlineRowä¹‹åï¼Œæ•°æ®é¡¹UIå°±åˆå¹¶ä¸ºä¸€è¡Œï¼Œæ˜¾å¾—æ›´åŠ çš„ç®€æ´ã€‚

åœ¨ä¸‹é¢ä¹Ÿç‰¹åˆ«è§‚å¯Ÿåˆ°å¦‚æœæŠŠFStructä½œä¸ºValueï¼Œåˆ™æ˜¯æ²¡æœ‰è¿™ä¸ªåŒºåˆ«çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\ForceInlineRow\Untitled.png)

å‡å¦‚ä¸æ³¨å†ŒFMyCommonStructç›¸åº”çš„IPropertyTypeCustomizationçš„è¯ï¼Œåˆ™ç»“æ„çš„å±æ€§UIé‡‡ç”¨é»˜è®¤æ–¹å¼æ˜¾ç¤ºï¼Œåˆ™éƒ½æ˜¯åˆ†ä¸ºä¸¤è¡Œã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\ForceInlineRow\Untitled%201.png)

è€Œå‡å¦‚FMyCommonStructçš„IPropertyTypeCustomizationçš„ShouldInlineKeyè¿”å›trueï¼Œåˆ™ä¼šå¯¼è‡´å³ä½¿æ²¡æœ‰ForceInlineRowä¹Ÿä¼šæŠŠè¯¥æ‹¥æœ‰è¯¥ç»“æ„ä½œä¸ºKeyçš„å±æ€§ç»™éƒ½åˆå¹¶ä¸ºä¸€è¡Œæ˜¾ç¤ºï¼Œè¿™ä¸ªæ—¶å€™å°±å¤±å»ForceInlineRowçš„ä½œç”¨å’ŒåŒºåˆ«äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\ForceInlineRow\Untitled%202.png)

## åŸç†ï¼š

è¯¥éƒ¨åˆ†é€»è¾‘ä¹ŸåŒæ ·å¤„äºåœ¨FDetailPropertyRowçš„æ„é€ å‡½æ•°åˆ›å»ºè¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰GetPropertyKeyNodeï¼Œåˆ™å…¶å®æ˜¯åœ¨è¦æ±‚TMapå±æ€§ã€‚

æ¥ç€ä½œä¸ºKeyçš„ç±»å‹ï¼Œå¦‚æœæ˜¯UObject*ï¼Œåˆ™å› ä¸ºNeedsKeyNodeä¸€ç›´è¿”å›falseï¼Œåˆ™æ— è®ºå¦‚ä½•éƒ½ä¼šè¿›å…¥MakePropertyEditorçš„åˆ†æ”¯ã€‚

å› æ­¤æ­¤é¡¹æµ‹è¯•çš„ç±»å‹å…¶å®æ˜¯Structï¼Œè¿™æ ·å°±å¿…é¡»ä¾èµ–bInlineRow å’ŒFoundPropertyCustomisation çš„é…åˆã€‚è¿™ä¸ªæ—¶å€™å°±å¿…é¡»æœ‰IPropertyTypeCustomizationæ‰ä¼šè¿›å…¥åˆ†æ”¯ï¼Œè€Œä¸”å¦‚æœIPropertyTypeCustomization::ShouldInlineKey()è¿”å›trueï¼Œåˆ™å°±ä¸ç®¡å±æ€§ä¸Šçš„ForceInlineRowå¦‚ä½•ï¼Œéƒ½ä¼šè¿›å…¥åˆ†æ”¯ã€‚å¦åˆ™å°±é å±æ€§ä¸Šçš„ForceInlineRowï¼Œè¿™ä¸ªæ—¶å€™æ‰æ˜¯è¿™ä¸ªMetaå‘æŒ¥ä½œç”¨çš„æ—¶å€™ã€‚

```cpp
FDetailPropertyRow::FDetailPropertyRow(TSharedPtr<FPropertyNode> InPropertyNode, TSharedRef<FDetailCategoryImpl> InParentCategory, TSharedPtr<FComplexPropertyNode> InExternalRootNode)
{
	if (PropertyNode->GetPropertyKeyNode().IsValid())
	{							
		TSharedPtr<IPropertyTypeCustomization> FoundPropertyCustomisation = GetPropertyCustomization(PropertyNode->GetPropertyKeyNode().ToSharedRef(), ParentCategory.Pin().ToSharedRef());
	
		bool bInlineRow = FoundPropertyCustomisation != nullptr ? FoundPropertyCustomisation->ShouldInlineKey() : false;
	
		static FName InlineKeyMeta("ForceInlineRow");
		bInlineRow |= InPropertyNode->GetParentNode()->GetProperty()->HasMetaData(InlineKeyMeta);
	
		// Only create the property editor if it's not a struct or if it requires to be inlined (and has customization)
		if (!NeedsKeyNode(PropertyNodeRef, InParentCategory) || (bInlineRow && FoundPropertyCustomisation != nullptr))
		{
			CachedKeyCustomTypeInterface = FoundPropertyCustomisation;
			
			MakePropertyEditor(PropertyNode->GetPropertyKeyNode().ToSharedRef(), Utilities, PropertyKeyEditor);
		}
	}
}

bool FDetailPropertyRow::NeedsKeyNode(TSharedRef<FPropertyNode> InPropertyNode, TSharedRef<FDetailCategoryImpl> InParentCategory)
{
	FStructProperty* KeyStructProp = CastField<FStructProperty>(InPropertyNode->GetPropertyKeyNode()->GetProperty());
	return KeyStructProp != nullptr;
}
```

æºç é‡Œä½¿ç”¨çš„ä¾‹å­ï¼š

åœ¨æºç é‡Œæœç´¢å‘ç°åˆ°è¯¥ä¾‹å­ï¼Œä½†å®é™…ä¸Šå…¶å®è¿™é‡ŒHLODSetupsä¸Šçš„ForceInlineRowå¹¶ä¸èƒ½èµ·ä½œç”¨ã€‚

```cpp
USTRUCT()
struct FRuntimePartitionDesc
{
	GENERATED_USTRUCT_BODY()

#if WITH_EDITORONLY_DATA
	/** Partition class */
	UPROPERTY(EditAnywhere, Category = RuntimeSettings)
	TSubclassOf<URuntimePartition> Class;

	/** Name for this partition, used to map actors to it through the Actor.RuntimeGrid property  */
	UPROPERTY(EditAnywhere, Category = RuntimeSettings, Meta = (EditCondition = "Class != nullptr", HideEditConditionToggle))
	FName Name;

	/** Main partition object */
	UPROPERTY(VisibleAnywhere, Category = RuntimeSettings, Instanced, Meta = (EditCondition = "Class != nullptr", HideEditConditionToggle, NoResetToDefault, TitleProperty = "Name"))
	TObjectPtr<URuntimePartition> MainLayer;

	/** HLOD setups used by this partition, one for each layers in the hierarchy */
	UPROPERTY(EditAnywhere, Category = RuntimeSettings, Meta = (EditCondition = "Class != nullptr", HideEditConditionToggle, ForceInlineRow))
	TArray<FRuntimePartitionHLODSetup> HLODSetups;
#endif

#if WITH_EDITOR
	void UpdateHLODPartitionLayers();
#endif
};
```


ï»¿# HideBehind

- **åŠŸèƒ½æè¿°ï¼š** åªåœ¨æŒ‡å®šçš„å±æ€§ä¸ºtrueæˆ–ä¸ä¸ºç©ºçš„æ—¶å€™æœ¬å±æ€§æ‰æ˜¾ç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** Foliageæ¨¡å—ä¸­
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Placement, meta=(UIMin = 0, ClampMin = 0, UIMax = 359, ClampMax = 359, HideBehind="AlignToNormal"))
	float AlignMaxAngle;
```

åªåœ¨Foliageé‡Œç”¨åˆ°ï¼Œå…¶å®ç”¨EditConditionå°±å¯ä»¥è¾¾åˆ°åŒæ ·çš„æ•ˆæœäº†ã€‚


ï»¿# HideCategories

- **åŠŸèƒ½æè¿°ï¼š** éšè—çš„ç±»åˆ«
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
Related To UCLASS: ShowCategories (../../Specifier/UCLASS/ShowCategories.md)
- **å…³è”é¡¹ï¼š** ShowCategories (ShowCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# HideEditConditionToggle

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ä½¿ç”¨EditConditionçš„å±æ€§ä¸Šï¼Œè¡¨ç¤ºè¯¥å±æ€§ä¸æƒ³è¦å…¶EditConditionç”¨åˆ°çš„å±æ€§è¢«éšè—èµ·æ¥ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [EditCondition](../EditCondition/EditCondition.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ç”¨åœ¨ä½¿ç”¨EditConditionçš„å±æ€§ä¸Šï¼Œè¡¨ç¤ºè¯¥å±æ€§ä¸æƒ³è¦å…¶EditConditionç”¨åˆ°çš„å±æ€§è¢«éšè—èµ·æ¥ã€‚å’ŒInlineEditConditionToggleæ˜¯æœ‰ç›¸åçš„ä½œç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (InlineEditConditionToggle))
	bool MyBool_Inline;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (EditCondition = "MyBool_Inline"))
	int32 MyInt_EditCondition_UseInline = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (HideEditConditionToggle,EditCondition = "MyBool_Inline"))
	int32 MyInt_EditCondition_UseInline_Hide = 123;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\HideEditConditionToggle\HideEditConditionToggle.gif](HideEditConditionToggle.gif)

## åŸç†ï¼š

åˆ¤æ–­å¦‚æœæœ‰HideEditConditionToggleï¼Œå°±æ”¯æŒä¸æ”¯æŒå½“å‰è¡Œæœ‰å•é€‰æ¡†çš„æŒ‰é’®ã€‚

```cpp

bool FPropertyNode::SupportsEditConditionToggle() const
{
	if (!Property.IsValid())
	{
		return false;
	}

	FProperty* MyProperty = Property.Get();

	static const FName Name_HideEditConditionToggle("HideEditConditionToggle");
	if (EditConditionExpression.IsValid() && !Property->HasMetaData(Name_HideEditConditionToggle))
	{
		const FBoolProperty* ConditionalProperty = EditConditionContext->GetSingleBoolProperty(EditConditionExpression);
		if (ConditionalProperty != nullptr)
		{
			// There are 2 valid states for inline edit conditions:
			// 1. The property is marked as editable and has InlineEditConditionToggle set. 
			// 2. The property is not marked as editable and does not have InlineEditConditionToggle set.
			// In both cases, the original property will be hidden and only show up as a toggle.

			static const FName Name_InlineEditConditionToggle("InlineEditConditionToggle");
			const bool bIsInlineEditCondition = ConditionalProperty->HasMetaData(Name_InlineEditConditionToggle);
			const bool bIsEditable = ConditionalProperty->HasAllPropertyFlags(CPF_Edit);

			if (bIsInlineEditCondition == bIsEditable)
			{
				return true;
			}

			if (bIsInlineEditCondition && !bIsEditable)
			{
				UE_LOG(LogPropertyNode, Warning, TEXT("Property being used as inline edit condition is not editable, but has redundant InlineEditConditionToggle flag. Field \"%s\" in class \"%s\"."), *ConditionalProperty->GetNameCPP(), *Property->GetOwnerStruct()->GetName());
				return true;
			}

			// The property is already shown, and not marked as inline edit condition.
			if (!bIsInlineEditCondition && bIsEditable)
			{
				return false;
			}
		}
	}

	return false;
}
```


ï»¿# HideInDetailPanel

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Actorçš„äº‹ä»¶é¢æ¿é‡Œéšè—è¯¥åŠ¨æ€å¤šæ’­å§”æ‰˜å±æ€§ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Actoré‡Œçš„åŠ¨æ€å¤šæ’­å§”æ‰˜
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨Actorçš„äº‹ä»¶é¢æ¿é‡Œéšè—è¯¥åŠ¨æ€å¤šæ’­å§”æ‰˜å±æ€§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType,Blueprintable)
class INSIDER_API AMyProperty_HideInDetailPanel :public AActor
{
	GENERATED_BODY()
public:
	DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnMyHideTestEvent);

	UPROPERTY(BlueprintAssignable, Category = "Event")
	FOnMyHideTestEvent MyEvent;

	UPROPERTY(BlueprintAssignable, Category = "Event", meta = (HideInDetailPanel))
	FOnMyHideTestEvent MyEvent_HideInDetailPanel;
};

```

## æµ‹è¯•æ•ˆæœï¼š

æµ‹è¯•æ­¥éª¤æ˜¯åœ¨è“å›¾é‡Œåˆ›å»ºAMyProperty_HideInDetailPanel çš„å­ç±»ï¼Œç„¶åè§‚å¯ŸEventçš„æ˜¾ç¤ºæƒ…å†µã€‚

å¯è§MyEventä¼šæ˜¾ç¤ºåœ¨Class Defautlsé‡Œçš„Eventsï¼Œè€ŒMyEvent_HideInDetailPanelåˆ™æ²¡æœ‰æ˜¾ç¤ºã€‚

ä¸è¿‡MyEvent_HideInDetailPanelä¾ç„¶æ˜¯å¯ä»¥åœ¨è“å›¾é‡Œè¿›è¡Œç»‘å®šï¼Œåªä¸è¿‡é»˜è®¤æ²¡æ˜¾ç¤ºåœ¨UIä¸Šè€Œå·²ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\HideInDetailPanel\Untitled.png)

## åŸç†ï¼š

å…ˆåˆ¤æ–­æ²¡æœ‰è¿™ä¸ªæ ‡è®°ï¼Œç„¶ååˆ›å»ºç›¸åº”çš„UIæ§ä»¶ã€‚

```cpp
void FActorDetails::AddEventsCategory(IDetailLayoutBuilder& DetailBuilder)
{
		IDetailCategoryBuilder& EventsCategory = DetailBuilder.EditCategory("Events", FText::GetEmpty(), ECategoryPriority::Uncommon);
		static const FName HideInDetailPanelName("HideInDetailPanel");
	
		// Find all the Multicast delegate properties and give a binding button for them
		for (TFieldIterator<FMulticastDelegateProperty> PropertyIt(Actor->GetClass(), EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
		{
			FMulticastDelegateProperty* Property = *PropertyIt;
			
			// Only show BP assiangable, non-hidden delegates		
			if (!Property->HasAnyPropertyFlags(CPF_Parm) && Property->HasAllPropertyFlags(CPF_BlueprintAssignable) && !Property->HasMetaData(HideInDetailPanelName))
			{}
		}
}

void FBlueprintDetails::AddEventsCategory(IDetailLayoutBuilder& DetailBuilder, FName PropertyName, UClass* PropertyClass)
{
	static const FName HideInDetailPanelName("HideInDetailPanel");
// Check for multicast delegates that we can safely assign
if ( !Property->HasAnyPropertyFlags(CPF_Parm) && Property->HasAllPropertyFlags(CPF_BlueprintAssignable) &&
				!Property->HasMetaData(HideInDetailPanelName) )
}
```


ï»¿# IgnoreCategoryKeywordsInSubclasses

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºè®©ä¸€ä¸ªç±»çš„é¦–ä¸ªå­ç±»å¿½ç•¥æ‰€æœ‰ç»§æ‰¿çš„ ShowCategories å’Œ HideCategories è¯´æ˜ç¬¦ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
Related To UCLASS: ComponentWrapperClass (../../Specifier/UCLASS/ComponentWrapperClass.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å’ŒComponentWrapperClassç›¸äº’å…³è”


ï»¿# InlineEditConditionToggle

- **åŠŸèƒ½æè¿°ï¼š** ä½¿è¿™ä¸ªboolå±æ€§åœ¨è¢«ç”¨ä½œEditConditionçš„æ—¶å€™å†…è”åˆ°å¯¹æ–¹çš„å±æ€§è¡Œé‡Œæˆä¸ºä¸€ä¸ªå•é€‰æ¡†ï¼Œè€Œä¸æ˜¯è‡ªå·±æˆä¸ºä¸€ä¸ªç¼–è¾‘è¡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [EditCondition](../EditCondition/EditCondition.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä½¿è¿™ä¸ªboolå±æ€§åœ¨è¢«ç”¨ä½œEditConditionçš„æ—¶å€™å†…è”åˆ°å¯¹æ–¹çš„å±æ€§è¡Œé‡Œæˆä¸ºä¸€ä¸ªå•é€‰æ¡†ï¼Œè€Œä¸æ˜¯è‡ªå·±æˆä¸ºä¸€ä¸ªç¼–è¾‘è¡Œã€‚

è™½ç„¶EditConditionæ”¯æŒåˆ«çš„ç±»å‹å±æ€§æˆ–è€…æ˜¯è¡¨è¾¾å¼ï¼Œä½†æ˜¯è¿™ä¸ªInlineEditConditionToggleåªæ”¯æŒboolå±æ€§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (InlineEditConditionToggle))
	bool MyBool_Inline;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (EditCondition = "MyBool_Inline"))
	int32 MyInt_EditCondition_UseInline = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle)
	int32 MyThirdInt_Inline = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = InlineEditConditionToggle, meta = (EditCondition = "MyThirdInt_Inline>200"))
	int32 MyInt_EditConditionExpression_UseInline = 123;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyBool_Inlineå˜æˆäº†å•é€‰æ¡†ã€‚è€ŒMyThirdInt_Inlineå°±æ²¡æœ‰è¢«éšè—æ‰ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\InlineEditConditionToggle\InlineEditConditionToggle.gif](InlineEditConditionToggle.gif)

## åŸç†ï¼š

å¯ä»¥çœ‹åˆ°ç”¨è¿™ä¸ªåˆ¤æ–­æ˜¯å¦æ”¯æŒå‡ºç°å•é€‰æ¡†ã€‚

```cpp

bool FPropertyNode::SupportsEditConditionToggle() const
{
	if (!Property.IsValid())
	{
		return false;
	}

	FProperty* MyProperty = Property.Get();

	static const FName Name_HideEditConditionToggle("HideEditConditionToggle");
	if (EditConditionExpression.IsValid() && !Property->HasMetaData(Name_HideEditConditionToggle))
	{
		const FBoolProperty* ConditionalProperty = EditConditionContext->GetSingleBoolProperty(EditConditionExpression);
		if (ConditionalProperty != nullptr)
		{
			// There are 2 valid states for inline edit conditions:
			// 1. The property is marked as editable and has InlineEditConditionToggle set. 
			// 2. The property is not marked as editable and does not have InlineEditConditionToggle set.
			// In both cases, the original property will be hidden and only show up as a toggle.

			static const FName Name_InlineEditConditionToggle("InlineEditConditionToggle");
			const bool bIsInlineEditCondition = ConditionalProperty->HasMetaData(Name_InlineEditConditionToggle);
			const bool bIsEditable = ConditionalProperty->HasAllPropertyFlags(CPF_Edit);

			if (bIsInlineEditCondition == bIsEditable)
			{
				return true;
			}

			if (bIsInlineEditCondition && !bIsEditable)
			{
				UE_LOG(LogPropertyNode, Warning, TEXT("Property being used as inline edit condition is not editable, but has redundant InlineEditConditionToggle flag. Field \"%s\" in class \"%s\"."), *ConditionalProperty->GetNameCPP(), *Property->GetOwnerStruct()->GetName());
				return true;
			}

			// The property is already shown, and not marked as inline edit condition.
			if (!bIsInlineEditCondition && bIsEditable)
			{
				return false;
			}
		}
	}

	return false;
}
```


ï»¿# MaxPropertyDepth

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå¯¹è±¡æˆ–ç»“æ„åœ¨ç»†èŠ‚é¢æ¿é‡Œå±•å¼€çš„å±‚æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** int32
- **é™åˆ¶ç±»å‹ï¼š** å¯¹è±¡æˆ–ç»“æ„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šå¯¹è±¡æˆ–ç»“æ„åœ¨ç»†èŠ‚é¢æ¿é‡Œå±•å¼€çš„å±‚æ•°ã€‚

- é»˜è®¤æ˜¯æ²¡æœ‰é™åˆ¶çš„ï¼Œå¯ä»¥ä¸€ç›´é€’å½’å±•å¼€åˆ°æœ€æ·±å±‚æ¬¡å­—æ®µã€‚
- å¦‚æœå¯¹è±¡çš„å­å¯¹è±¡å†æœ‰å­å¯¹è±¡ï¼Œè¿™æ ·é€’å½’å¾ˆå¤šå±‚çº§ï¼Œå¯èƒ½æˆ‘ä»¬ä¼šæƒ³è¦é™åˆ¶ä¸æƒ³å±•å¼€å¤ªæ·±ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŒ‡å®šä¸€ä¸ªå±‚çº§é™åˆ¶ã€‚
- å–å€¼-1è¡¨ç¤ºæ²¡æœ‰é™åˆ¶ï¼Œ0è¡¨ç¤ºå®Œå…¨ä¸å±•å¼€ï¼Œ>0è¡¨ç¤ºé™åˆ¶çš„å±‚æ•°ã€‚
- æºç é‡Œæ²¡æœ‰æ‰¾åˆ°ä¾‹å­ï¼Œä½†å´æ˜¯å¯ä»¥å·¥ä½œçš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyStructDepth1
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt1 = 123;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString1;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStructDepth2
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FMyStructDepth1 MyStruct1;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStructDepth3
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FMyStructDepth2 MyStruct2;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStructDepth4
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FMyStructDepth3 MyStruct3;
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_MaxPropertyDepth :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FMyStructDepth4 MyStruct;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(MaxPropertyDepth=2))
	FMyStructDepth4 MyStruct_Depth;
};

```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\MaxPropertyDepth\Untitled.png)

## åŸç†ï¼š

åœ¨æ¯ä¸ªFPropertyNodeæ„å»ºå­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ£€æŸ¥ä¸€ä¸‹å½“å‰çš„MaxChildDepthAllowed ï¼Œè¶…è¿‡äº†å°±ä¸ç»§ç»­å¾€ä¸‹æ„å»ºã€‚

```cpp
/** Safety Value representing Depth in the property tree used to stop diabolical topology cases
 * -1 = No limit on children
 *  0 = No more children are allowed.  Do not process child nodes
 *  >0 = A limit has been set by the property and will tick down for successive children
 */
int32 MaxChildDepthAllowed;

void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
	
		//Get the property max child depth
		static const FName Name_MaxPropertyDepth("MaxPropertyDepth");
		if (Property->HasMetaData(Name_MaxPropertyDepth))
		{
			int32 NewMaxChildDepthAllowed = Property->GetIntMetaData(Name_MaxPropertyDepth);
			//Ensure new depth is valid.  Otherwise just let the parent specified value stand
			if (NewMaxChildDepthAllowed > 0)
			{
				//if there is already a limit on the depth allowed, take the minimum of the allowable depths
				if (MaxChildDepthAllowed >= 0)
				{
					MaxChildDepthAllowed = FMath::Min(MaxChildDepthAllowed, NewMaxChildDepthAllowed);
				}
				else
				{
					//no current limit, go ahead and take the new limit
					MaxChildDepthAllowed = NewMaxChildDepthAllowed;
				}
			}
		}
}

void FPropertyNode::RebuildChildren()
{
	if (MaxChildDepthAllowed != 0)
{
	//the case where we don't want init child nodes is when an Item has children that we don't want to display
	//the other option would be to make each node "Read only" under that item.
	//The example is a material assigned to a static mesh.
	if (HasNodeFlags(EPropertyNodeFlags::CanBeExpanded) && (ChildNodes.Num() == 0))
	{
		InitChildNodes();
		if (ExpandedPropertyItemSet.Size() > 0)
		{
			FPropertyNodeUtils::SetExpandedItems(ThisAsSharedRef, ExpandedPropertyItemSet);
		}
	}
}
}
```


ï»¿# NoEditInline

- **åŠŸèƒ½æè¿°ï¼š** Object properties pointing to an UObject instance whos class is marked editinline will not show their properties inline in property windows. Useful for getting actor components to appear in the component tree but not inline in the root actor details panel.
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** EditInline (EditInline.md)

å¯¹è±¡å¼•ç”¨é»˜è®¤å°±ä¸èƒ½EditInlineï¼Œå› æ­¤ä¹Ÿä¸éœ€è¦é¢å¤–å†åŠ ä¸Šè¿™ä¸ªã€‚é™¤éInstancedä¹‹åï¼Ÿ

ç»“æ„å±æ€§é»˜è®¤å°±å¯ä»¥EditInlineï¼ŒåŠ ä¸Šè¿™ä¸ªåä¹Ÿæ²¡æœ‰ä½œç”¨ï¼Œå› æ­¤ä¹Ÿä¸éœ€è¦åŠ ä¸Šè¿™ä¸ªã€‚

åœ¨æºç ä¸­åªæ‰¾åˆ°ï¼š

```cpp
	UPROPERTY(VisibleAnywhere, Category = "Connection Point", meta = (NoEditInline))
	FLinearColor Color = FLinearColor::Black;
```


ï»¿# NoResetToDefault

- **åŠŸèƒ½æè¿°ï¼š** ç¦ç”¨å’Œéšè—å±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸Šçš„â€œé‡ç½®â€åŠŸèƒ½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç¦ç”¨å’Œéšè—å±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸Šçš„â€œé‡ç½®â€åŠŸèƒ½ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=ResetToDefaultTest)
	int32 MyInt_Default = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=ResetToDefaultTest, meta = (NoResetToDefault))
	int32 MyInt_NoResetToDefault = 123;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°é»˜è®¤çš„å±æ€§åœ¨æ”¹å˜å€¼åï¼Œå³ä¾§ä¼šå‡ºç°ä¸€ä¸ªé‡ç½®æŒ‰é’®ï¼Œä»¥ä¾¿è®©å±æ€§é‡ç½®å›é»˜è®¤å€¼ã€‚NoResetToDefaultçš„ä½œç”¨å°±æ˜¯å»é™¤è¿™ä¸ªåŠŸèƒ½ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\DetailsPanel\NoResetToDefault\ResetToDefaultTest.gif](ResetToDefaultTest.gif)

## åŸç†ï¼š

ç¼–è¾‘å™¨é‡Œä¼šåˆ¤æ–­è¿™ä¸ªmetaï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºSResetToDefaultPropertyEditorã€‚

```cpp
bool SSingleProperty::GeneratePropertyCustomization()
{
		if (!PropertyEditor->GetPropertyHandle()->HasMetaData(TEXT("NoResetToDefault")) && !bShouldHideResetToDefault)
		{
			HorizontalBox->AddSlot()
			.Padding( 2.0f )
			.AutoWidth()
			.VAlign( VAlign_Center )
			[
				SNew( SResetToDefaultPropertyEditor,  PropertyEditor->GetPropertyHandle() )
			];
		}
}
```


ï»¿# PrioritizeCategories

- **åŠŸèƒ½æè¿°ï¼š** æŠŠæŒ‡å®šçš„å±æ€§ç›®å½•ä¼˜å…ˆæ˜¾ç¤ºåœ¨å‰é¢

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[PrioritizeCategories](../../Specifier/UCLASS/Category/PrioritizeCategories/PrioritizeCategories.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# ReapplyCondition

- **åŠŸèƒ½æè¿°ï¼š** // Properties that have a ReapplyCondition should be disabled behind the specified property when in reapply mode
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

## ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Placement, meta=(UIMin = 0, ClampMin = 0, UIMax = 359, ClampMax = 359, ReapplyCondition="ReapplyRandomPitchAngle"))
	float RandomPitchAngle;
```

ä¹Ÿåªåœ¨Foliageä¸­ç”¨åˆ°ã€‚


ï»¿# ShowCategories

- **åŠŸèƒ½æè¿°ï¼š** æ˜¾ç¤ºç±»åˆ«
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [HideCategories](HideCategories.md)

åœ¨ç±»ä¸Šé¢æ ‡è®°çš„ShowCategoriesï¼Œå¹¶ä¸ä¼šä¿å­˜åˆ°metaä¸­å»ï¼Œåªæ˜¯ç”¨æ¥æŠ¹é™¤åŸºç±»HideCategoriesçš„è®¾ç½®ã€‚å› æ­¤metaé‡Œçš„ShowCategoriesæ˜¯æ²¡æœ‰ç”¨åˆ°çš„ã€‚

```cpp
//(BlueprintType = true, IncludePath = Class/Display/MyClass_HideCategories.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_HideCategories.h)
UCLASS(Blueprintable, ShowCategories = MyGroup1)
class INSIDER_API UMyClass_ShowCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup1)
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2 | MyGroup22")
		int Property_Group222;
};
```


ï»¿# UsesHierarchy

- **åŠŸèƒ½æè¿°ï¼š** è¯´æ˜ç±»ä½¿ç”¨å±‚çº§æ•°æ®ã€‚ç”¨äºå®ä¾‹åŒ–â€œç»†èŠ‚â€é¢æ¿ä¸­çš„å±‚çº§ç¼–è¾‘åŠŸèƒ½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0


ï»¿# Comment

- **åŠŸèƒ½æè¿°ï¼š** ç”¨æ¥è®°å½•æ³¨é‡Šçš„å†…å®¹
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

Commentè·ŸToolTipä¸åŒï¼Œåè€…æ˜¯ç”¨æˆ·é¼ æ ‡æ‚¬åœä¸Šçš„æç¤ºï¼Œå‰è€…åªæ˜¯ç®€å•çš„ä»£ç ä¸­çš„æ³¨é‡Šçš„è®°å½•ã€‚ä½†æ˜¯ä¸€èˆ¬æˆ‘ä»¬åœ¨ä»£ç é‡Œå†™ä¸Šçš„æ³¨é‡Šï¼Œä¼šè‡ªåŠ¨ä¹ŸåŠ åˆ°ToolTip ä¸Šï¼Œå› æ­¤æˆ‘ä»¬å¾€å¾€ä¹Ÿä¼šçœ‹åˆ°UIç•Œé¢ä¸Šçš„æç¤ºã€‚

ä½†å¦‚æœä¸æƒ³è¦ToolTipï¼Œæƒ³åªæœ‰Commentï¼Œåˆ™ä¹Ÿå¯ä»¥è‡ªå·±æ‰‹åŠ¨åœ¨metaé‡Œæ·»åŠ ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//(BlueprintType = true, Comment = //This is a comment on class, IncludePath = Property/Development/MyProperty_Development.h, ModuleRelativePath = Property/Development/MyProperty_Development.h, ToolTip = This is a comment on class)

//This is a comment on class
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Development :public UObject
{
	GENERATED_BODY()
public:
	//(Comment = //This is a comment on function, ModuleRelativePath = Property/Development/MyProperty_Development.h, ToolTip = This is a comment on function)
	
	//This is a comment on function
	UFUNCTION(BlueprintCallable)
	int32 MyFunc(FString str){return 0;}

	//	(Category = MyProperty_Development, Comment = //This is a comment on property, ModuleRelativePath = Property/Development/MyProperty_Development.h, ToolTip = This is a comment on property)
	 
	//This is a comment on property
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty = 123;

	//(Category = MyProperty_Development, Comment = This is my other property., ModuleRelativePath = Property/Development/MyProperty_Development.h)

	UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(Comment="This is my other property."))
	int32 MyProperty_WithComment = 123;
};

```

## æµ‹è¯•ç»“æœï¼š

MyProperty_WithCommentæ˜¯å•ç‹¬åªåŠ çš„Commentï¼Œå°±æ²¡æœ‰äº†é¼ æ ‡æ‚¬åœæ•ˆæœã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Development\Comment\Comment.gif](Comment.gif)


ï»¿# Deprecated

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å…ƒç´ è¦åºŸå¼ƒçš„å¼•æ“ç‰ˆæœ¬å·ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šè¯¥å…ƒç´ è¦åºŸå¼ƒçš„å¼•æ“ç‰ˆæœ¬å·ã€‚

è¿™ä¸ªå€¼åªæ˜¯å•çº¯çš„åœ¨C++ä»£ç ä¸­è®°å½•ä¸€ä¸‹ä¿¡æ¯ï¼Œå¹¶ä¸ä¼šçœŸæ­£çš„ä½¿å¾—ä¸€ä¸ªå…ƒç´ å˜æˆåºŸå¼ƒã€‚è¿™ä¸ªå€¼ä¹Ÿæ²¡æœ‰åœ¨åˆ«çš„åœ°æ–¹UIä½¿ç”¨å’Œæ˜¾ç¤ºå‡ºæ¥ã€‚

è¦åºŸå¼ƒä¸€ä¸ªå…ƒç´ ï¼Œè¿˜æ˜¯è¦ç”¨åˆ«çš„æ ‡è®°ï¼Œå¦‚**DeprecatedPropertyï¼ŒDeprecatedFunctionç­‰ã€‚**


ï»¿# DeprecatedFunction

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜ä¸€ä¸ªå‡½æ•°å·²ç»è¢«å¼ƒç”¨
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

*Any Blueprint references to this function will cause compilation warnings telling the user that the function is deprecated. You can add to the deprecation warning message (for example, to provide instructions on replacing the deprecated function) using the DeprecationMessage metadata specifier.*


ï»¿# DeprecatedProperty

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°å¼ƒç”¨ï¼Œå¼•ç”¨åˆ°è¯¥å±æ€§çš„è“å›¾ä¼šè§¦å‘ä¸€ä¸ªè­¦å‘Š

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** Development

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[Deprecated](../../../Specifier/UCLASS/Development/Deprecated/Deprecated.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ‡è®°å¼ƒç”¨ï¼Œå¼•ç”¨åˆ°è¯¥å±æ€§çš„è“å›¾ä¼šè§¦å‘ä¸€ä¸ªè­¦å‘Š

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
// Simple
UPROPERTY(BlueprintReadWrite, meta=(DeprecatedProperty, DeprecationMessage="This is deprecated"))
FString PlantName;

// Better
UPROPERTY(BlueprintReadWrite, meta=(DisplayName="PlantName", DeprecatedProperty, DeprecationMessage="PlantName is deprecated, instead use PlantDisplayName."))
FString DEPRECATED_PlantName;
```

![Untitled](/Untitled.png)

![Untitled](/Untitled%201.png)


ï»¿# DeprecationMessage

- **åŠŸèƒ½æè¿°ï¼š** å®šä¹‰å¼ƒç”¨çš„æ¶ˆæ¯

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UFUNCTION, UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** Development

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[Deprecated](../../Specifier/UCLASS/Development/Deprecated/Deprecated.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

## ä¾‹å­ï¼š

```cpp
UFUNCTION(meta=(DeprecatedFunction,DeprecationMessage="This function is deprecated, please use OtherFunctionName instead."))
ReturnType FunctionName([Parameter, Parameter, ...])

UPROPERTY(BlueprintReadWrite, meta=(DeprecatedProperty, DeprecationMessage="This is deprecated"))
FString PlantName;
```


ï»¿# DevelopmentOnly

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—ä¸€ä¸ªå‡½æ•°å˜ä¸ºDevelopmentOnlyï¼Œæ„å‘³ç€åªä¼šåœ¨Developmentæ¨¡å¼ä¸­è¿è¡Œã€‚é€‚ç”¨äºè°ƒè¯•è¾“å‡ºä¹‹ç±»çš„åŠŸèƒ½ï¼Œä½†åœ¨æœ€ç»ˆå‘å¸ƒç‰ˆä¸­ä¼šè·³è¿‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ä½¿å¾—ä¸€ä¸ªå‡½æ•°å˜ä¸ºDevelopmentOnlyï¼Œæ„å‘³ç€åªä¼šåœ¨Developmentæ¨¡å¼ä¸­è¿è¡Œã€‚é€‚ç”¨äºè°ƒè¯•è¾“å‡ºä¹‹ç±»çš„åŠŸèƒ½ï¼Œä½†åœ¨æœ€ç»ˆå‘å¸ƒç‰ˆä¸­ä¼šè·³è¿‡ã€‚

æºç ä¸­æœ€å…¸å‹çš„ä¾‹å­å°±æ˜¯PrintStringã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable,meta=(DevelopmentOnly))
	static void MyFunc_DevelopmentOnly(){}

	UFUNCTION(BlueprintCallable,meta=())
	static void MyFunc_NotDevelopmentOnly(){}
```

## è“å›¾æ•ˆæœï¼š

![Untitled](/Untitled.png)

## åŸç†ï¼š

å…¶ä¼šæ”¹å˜è¿™ä¸ªå‡½æ•°è“å›¾èŠ‚ç‚¹çš„çŠ¶æ€ä¸ºDevelopmentOnlyï¼Œä»è€Œæœ€ç»ˆå¯¼è‡´è¯¥nodeåœ¨shippingæ¨¡å¼ä¸‹è¢«pass throughã€‚

```cpp
void UK2Node_CallFunction::Serialize(FArchive& Ar)
{
		if (const UFunction* Function = GetTargetFunction())
		{
					// Enable as development-only if specified in metadata. This way existing functions that have the metadata added to them will get their enabled state fixed up on load.
					if (GetDesiredEnabledState() == ENodeEnabledState::Enabled && Function->HasMetaData(FBlueprintMetadata::MD_DevelopmentOnly))
					{
						SetEnabledState(ENodeEnabledState::DevelopmentOnly, /*bUserAction=*/ false);
					}
					// Ensure that if the metadata is removed, we also fix up the enabled state to avoid leaving it set as development-only in that case.
					else if (GetDesiredEnabledState() == ENodeEnabledState::DevelopmentOnly && !Function->HasMetaData(FBlueprintMetadata::MD_DevelopmentOnly))
					{
						SetEnabledState(ENodeEnabledState::Enabled, /*bUserAction=*/ false);
					}
		}
}
```


ï»¿# DevelopmentStatus

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜å¼€å‘çŠ¶æ€

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** Development

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[Experimental](../../Specifier/UCLASS/Development/Experimental/Experimental.md), [EarlyAccessPreview](../../Specifier/UCLASS/Development/EarlyAccessPreview/EarlyAccessPreview.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

DevelopmentStatus=Experimental
DevelopmentStatus=EarlyAccess


ï»¿# FriendlyName

- **åŠŸèƒ½æè¿°ï¼š** å’ŒDisplayNameä¸€æ ·ï¼Ÿ
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"


ï»¿# ShortTooltip

- **åŠŸèƒ½æè¿°ï¼š** æä¾›ä¸€ä¸ªæ›´ç®€æ´ç‰ˆæœ¬çš„æç¤ºæ–‡æœ¬ï¼Œä¾‹å¦‚åœ¨ç±»å‹é€‰æ‹©å™¨çš„æ—¶å€™æ˜¾ç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ToolTip](ToolTip/ToolTip.md)


ï»¿# ToolTip

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Metaé‡Œæä¾›ä¸€ä¸ªæç¤ºæ–‡æœ¬ï¼Œè¦†ç›–ä»£ç æ³¨é‡Šé‡Œçš„æ–‡æœ¬
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ShortTooltip](../ShortTooltip.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
// This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.
UCLASS(BlueprintType, Blueprintable, meta = (ToolTip = "This is a ToolTip within Class. There're so so so so so so so many words I want to say, but here's too narrow."))
class INSIDER_API UMyClass_ToolTip :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (ToolTip = "This is a ToolTip within Property.There're so so so so so so so many words I want to say, but here's too narrow."))
	float MyFloat_WithToolTip;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;

	UFUNCTION(BlueprintCallable, meta = (ToolTip = "This is a ToolTip within Function.There're so so so so so so so many words I want to say, but here's too narrow."))
	void MyFunc_WithToolTip() {}

	UFUNCTION(BlueprintCallable)
	void MyFunc() {}
};

// This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.
UCLASS(BlueprintType, Blueprintable, meta = (ToolTip = "This is a ToolTip within Class. There're so so so so so so so many words I want to say, but here's too narrow.", ShortToolTip = "This is a ShortToolTip within Class."))
class INSIDER_API UMyClass_WithAllToolTip :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (ToolTip = "This is a ToolTip within Property."))
	float MyFloat_WithToolTip;

UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (ToolTip = "This is a ToolTip within Property. There're so so so so so so so many words I want to say, but here's too narrow.\nThis is a new line.",ShortToolTip = "This is a ShortToolTip within Property."))
	float MyFloat_WithAllToolTip;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;

	UFUNCTION(BlueprintCallable, meta = (ToolTip = "This is a ToolTip within Function. There're so so so so so so so many words I want to say, but here's too narrow.",ShortToolTip = "This is a ShortToolTip within Function."))
	void MyFunc_WithAllToolTip() {}

	UFUNCTION(BlueprintCallable, meta = (ToolTip = "This is a ToolTip within Function."))
	void MyFunc_WithToolTip() {}
};

// This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.
UCLASS(BlueprintType, Blueprintable)
class INSIDER_API UMyClass_ToolTip_TypeA :public UObject
{
	GENERATED_BODY()
};

/**
*	This is a ToolTip out of Class.
*	There're so so so so so so so many words I want to say, but here's too narrow.
*	Please read this tooltip before you use this class. 
*/
UCLASS(BlueprintType, Blueprintable)
class INSIDER_API UMyClass_ToolTip_TypeB :public UObject
{
	GENERATED_BODY()
};
```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨é€‰å–çˆ¶ç±»æ—¶å€™çš„æç¤ºï¼š

å¯ä»¥å‘ç°ï¼Œå¦‚æœæä¾›äº†ToolTipï¼Œå°±ä¼šè¦†ç›–æ‰ä»£ç æ³¨é‡Šé‡Œçš„æ³¨é‡Šã€‚åŒæ—¶ä¹Ÿå¯ä»¥å‘ç°åœ¨ä¸‹å›¾ä¸­ï¼Œæç¤ºçš„æ–‡æœ¬è¿‡é•¿è¶…è¿‡äº†é€‰é¡¹æ¡†ã€‚è¿™æ—¶å¦‚æœæä¾›äº†ShortToolTipï¼Œåˆ™ä¼šåœ¨çˆ¶ç±»é€‰å–å™¨ä¸­æ˜¾ç¤ºShortToolTipä¸­çš„æ–‡æœ¬ï¼Œä»è€Œç®€æ´ä¸€ç‚¹æ˜¾ç¤ºã€‚åœ¨å¾ˆå¤šåˆ«çš„åœ°æ–¹ä¹ŸåŒæ ·åº”ç”¨è¿™ä¸ªè§„åˆ™ï¼Œæ¯”å¦‚ï¼ˆè¯¥ç±»å‹ï¼‰å˜é‡ä¸Šçš„æç¤ºï¼Œæˆ–è€…åœ¨é€‰æ‹©å˜é‡ç±»å‹çš„æ—¶å€™ã€‚

![1234.png](/1234.png)

## åŸç†ä»£ç ï¼š

åœ¨æºç é‡Œæœ‰FFieldå’ŒUFieldï¼Œæ™®é€šçš„å±æ€§æ˜¯FFieldï¼Œè€ŒåƒUClassæ˜¯ç»§æ‰¿äºUFieldï¼Œå› æ­¤è¦æ³¨æ„FField::GetToolTipTextçš„bShortTooltipä¸€ç›´æ˜¯falseï¼Œè€ŒUField::GetToolTipTextåˆ™ä¼šä¼ trueã€‚

```cpp
FText FField::GetToolTipText(bool bShortTooltip) const
{
	bool bFoundShortTooltip = false;
	static const FName NAME_Tooltip(TEXT("Tooltip"));
	static const FName NAME_ShortTooltip(TEXT("ShortTooltip"));
	FText LocalizedToolTip;
	FString NativeToolTip;

	if (bShortTooltip)
	{
		NativeToolTip = GetMetaData(NAME_ShortTooltip);
		if (NativeToolTip.IsEmpty())
		{
			NativeToolTip = GetMetaData(NAME_Tooltip);
		}
		else
		{
			bFoundShortTooltip = true;
		}
	}
	else
	{
		NativeToolTip = GetMetaData(NAME_Tooltip);
	}

	const FString Namespace = bFoundShortTooltip ? TEXT("UObjectShortTooltips") : TEXT("UObjectToolTips");
	const FString Key = GetFullGroupName(false);
	if (!FText::FindText(Namespace, Key, /*OUT*/LocalizedToolTip, &NativeToolTip))
	{
		if (!NativeToolTip.IsEmpty())
		{
			static const FString DoxygenSee(TEXT("@see"));
			static const FString TooltipSee(TEXT("See:"));
			if (NativeToolTip.ReplaceInline(*DoxygenSee, *TooltipSee) > 0)
			{
				NativeToolTip.TrimEndInline();
			}
		}
		LocalizedToolTip = FText::FromString(NativeToolTip);
	}

	return LocalizedToolTip;
}

FText UField::GetToolTipText(bool bShortTooltip) const
{
	bool bFoundShortTooltip = false;
	static const FName NAME_Tooltip(TEXT("Tooltip"));
	static const FName NAME_ShortTooltip(TEXT("ShortTooltip"));
	FText LocalizedToolTip;
	FString NativeToolTip;
	
	if (bShortTooltip)
	{
		NativeToolTip = GetMetaData(NAME_ShortTooltip);
		if (NativeToolTip.IsEmpty())
		{
			NativeToolTip = GetMetaData(NAME_Tooltip);
		}
		else
		{
			bFoundShortTooltip = true;
		}
	}
	else
	{
		NativeToolTip = GetMetaData(NAME_Tooltip);
	}

	const FString Namespace = bFoundShortTooltip ? TEXT("UObjectShortTooltips") : TEXT("UObjectToolTips");
	const FString Key = GetFullGroupName(false);
	if ( !FText::FindText( Namespace, Key, /*OUT*/LocalizedToolTip, &NativeToolTip ) )
	{
		if (NativeToolTip.IsEmpty())
		{
			NativeToolTip = FName::NameToDisplayString(FDisplayNameHelper::Get(*this), false);
		}
		else if (!bShortTooltip && IsNative())
		{
			FormatNativeToolTip(NativeToolTip, true);
		}
		LocalizedToolTip = FText::FromString(NativeToolTip);
	}

	return LocalizedToolTip;
}

//åœ¨ç±»å‹é€‰æ‹©å™¨ä¸­ä¼˜å…ˆé€‰æ‹©ShortTooltip
FText FClassPickerDefaults::GetDescription() const
{
	FText Result = LOCTEXT("NullClass", "(null class)");

	if (UClass* ItemClass = LoadClass<UObject>(NULL, *ClassName, NULL, LOAD_None, NULL))
	{
		Result = ItemClass->GetToolTipText(/*bShortTooltip=*/ true);
	}

	return Result;
}
```

ä½†å¯¹äºPropertyå’ŒFunctionï¼Œåœ¨æ˜¾ç¤ºçš„æ—¶å€™ï¼Œéƒ½åªä¼šæ˜¾ç¤ºToolTipï¼Œå¹¶ä¸ä¼šåº”ç”¨ShortToolTip

å˜é‡å’Œå‡½æ•°ï¼š

![55.png](/55.png)

![D:\github\UnrealSpecifiers\Doc\Meta\Development\ToolTip\77.png](77.png)

å…¶ä»–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä»£ç é‡Œæ³¨é‡Šçš„æ–‡æœ¬ä¹Ÿä¼šå½“ä½œToolTipã€‚æ”¯æŒ//å’Œ/**/è¿™ä¸¤ç§æ ¼å¼ã€‚å¦‚æœåœ¨ToolTipä¸­æƒ³æ¢è¡Œï¼Œå¯ä»¥ç›´æ¥åŠ /nå°±å¯ä»¥ã€‚

```cpp
/*
(BlueprintType = true, Comment = // This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.
, IncludePath = Any/ToolTip_Test.h, IsBlueprintBase = true, ModuleRelativePath = Any/ToolTip_Test.h, ToolTip = This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.)
*/

// This is a ToolTip out of Class.There're so so so so so so so many words I want to say, but here's too narrow.
UCLASS(BlueprintType, Blueprintable)
class INSIDER_API UMyClass_ToolTip_TypeA :public UObject
{
	GENERATED_BODY()
};

//[MyClass_ToolTip_TypeB	Class->Struct->Field->Object	/Script/Insider.MyClass_ToolTip_TypeB]
//(BlueprintType = true, Comment = /**
//*	This is a ToolTip out of Class.
//*	There're so so so so so so so many words I want to say, but here's too narrow.
//*	Please read this tooltip before you use this class. 
//*/, IncludePath = Any/ToolTip_Test.h, IsBlueprintBase = true, ModuleRelativePath = Any/ToolTip_Test.h, ToolTip = This is a ToolTip out of Class.
//There're so so so so so so so many words I want to say, but here's too narrow.
//Please read this tooltip before you use this class.)

/**
*	This is a ToolTip out of Class.
*	There're so so so so so so so many words I want to say, but here's too narrow.
*	Please read this tooltip before you use this class. 
*/
UCLASS(BlueprintType, Blueprintable)
class INSIDER_API UMyClass_ToolTip_TypeB :public UObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType, Blueprintable, meta = (ToolTip = "This is a ToolTip within Class. There're so so so so so so so many words I want to say, but here's too narrow.\nThis is a new line.", ShortToolTip = "This is a ShortToolTip within Class."))
```


ï»¿# Bitflags

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šä¸€ä¸ªæšä¸¾æ”¯æŒé‡‡ç”¨ä½æ ‡è®°èµ‹å€¼ï¼Œä»è€Œåœ¨è“å›¾ä¸­å¯ä»¥è¯†åˆ«å‡ºæ¥æ˜¯BitMask
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [UseEnumValuesAsMaskValuesInEditor](../UseEnumValuesAsMaskValuesInEditor/UseEnumValuesAsMaskValuesInEditor.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¸¸å¸¸å’ŒUPROPERTYä¸Šçš„bitmaskä¸€èµ·é…åˆä½¿ç”¨ã€‚

æ³¨æ„è¿™ä¸ªå’ŒUENUM(flags)çš„åŒºåˆ«ï¼Œåè€…æ˜¯å½±å“C++é‡Œå­—ç¬¦ä¸²è¾“å‡ºå‡½æ•°ã€‚

è¿™ä¸ªæ˜¯æŒ‡å®šè¯¥æšä¸¾æ”¯æŒä½æ ‡è®°ï¼Œä»è€Œåœ¨è“å›¾ä¸­å¯ä»¥è¢«é€‰æ‹©å‡ºæ¥ã€‚

```cpp
UENUM(BlueprintType,Flags)
enum class EMyEnum_Flags:uint8
{
	First,
	Second,
	Third,
};
UENUM(BlueprintType,Meta = (Bitflags))
enum class EMyEnum_BitFlags:uint8
{
	First,
	Second,
	Third,
};

//æºç ä¸­çš„ä¾‹å­ï¼š
UENUM(Meta = (Bitflags))
enum class EColorBits
{
ECB_Red,
ECB_Green,
ECB_Blue
};
UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = "EColorBits"))
int32 ColorFlags;
```

å¦‚ä¸‹å›¾æ‰€ç¤ºï¼šEMyEnum_Flagså°±ä¸ä¼šè¢«åˆ—åœ¨é€‰é¡¹é‡Œã€‚è€ŒEMyEnum_BitFlagså°±å¯ä»¥è¢«åˆ—è¿›æ¥ã€‚

![Untitled](/Untitled.png)

å¦‚æœæ²¡æœ‰UPROPERTY(bitmask)çš„é…åˆä½¿ç”¨ï¼Œåˆ™è“å›¾é‡Œè¿˜æ˜¯åªèƒ½å•é¡¹é€‰æ‹©

![Untitled](/Untitled%201.png)


ï»¿# Bitmask

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šä¸€ä¸ªå±æ€§é‡‡ç”¨Bitmaskèµ‹å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** ç”¨æ¥è¡¨ç¤ºæšä¸¾å€¼çš„int32
- **å…³è”é¡¹ï¼š** [BitmaskEnum](../BitmaskEnum/BitmaskEnum.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

è¿™ä¸ªæ ‡è®°å’Œenumèº«ä¸Šçš„å®šä¹‰å¹¶æ²¡æœ‰ä¸€å®šçš„å…³ç³»ï¼Œå› æ­¤å¯ä»¥å•ç‹¬å®šä¹‰ã€‚

```cpp
UENUM(BlueprintType)
enum class EMyEnum_Normal:uint8
{
	First,
	Second,
	Third,
};

UENUM(BlueprintType,Flags)
enum class EMyEnum_Flags:uint8
{
	First,
	Second,
	Third,
};

UENUM(BlueprintType,Meta = (Bitflags))
enum class EMyEnum_BitFlags:uint8
{
	First,
	Second,
	Third,
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_EnumBitFlags_Test:public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = "EMyEnum_Normal"))
	int32 MyNormal;

	UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = "EMyEnum_Flags"))
	int32 MyFlags;

	UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = "EMyEnum_BitFlags"))
	int32 MyBitFlags;
};
```

éƒ½æ˜¯å¯ä»¥åœ¨è“å›¾ä¸­ç”¨æ ‡è®°æ¥å®šä¹‰

![Untitled](/Untitled.png)

å¯ä»¥ç”¨BitmaskEnumè¿›ä¸€æ­¥æä¾›æšä¸¾å€¼


ï»¿# BitmaskEnum

- **åŠŸèƒ½æè¿°ï¼š** ä½¿ç”¨ä½æ ‡è®°åé‡‡ç”¨çš„æšä¸¾åå­—
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** ç”¨æ¥è¡¨ç¤ºæšä¸¾å€¼çš„int32
- **å…³è”é¡¹ï¼š** [Bitmask](../Bitmask/Bitmask.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¦‚æœæ²¡æœ‰æ ‡ä¸ŠBitmaskEnumï¼Œåˆ™æ— æ³•æä¾›æ ‡è®°çš„çš„åç§°å€¼

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_EnumBitFlags_Test:public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, Meta = (Bitmask))
	int32 MyNormalWithoutEnum;
};
```

å¦‚æœæ²¡æœ‰æ ‡ä¸ŠBitmaskEnumï¼Œåˆ™æ— æ³•æä¾›æ ‡è®°çš„çš„åç§°å€¼

![Untitled](/Untitled.png)


ï»¿# Enum

- **åŠŸèƒ½æè¿°ï¼š** ç»™ä¸€ä¸ªStringæŒ‡å®šä»¥æšä¸¾é‡Œå€¼çš„åç§°ä½œä¸ºé€‰é¡¹
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FString
- **å…³è”é¡¹ï¼š** [ValidEnumValues](ValidEnumValues/ValidEnumValues.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# EnumDisplayNameFn

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Runtimeä¸‹ä¸ºæšä¸¾å­—æ®µæä¾›è‡ªå®šä¹‰åç§°çš„å‡½æ•°å›è°ƒ
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åªåœ¨Runtimeä¸‹ç”Ÿæ•ˆï¼Œåœ¨Editorä¸‹ä¾ç„¶ä¸èµ·ä½œç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//[EMyEnum_CustomDisplay	Enum->Field->Object	/Script/Insider.EMyEnum_CustomDisplay]
//(BlueprintType = true, EnumDisplayNameFn = GetMyEnumCustomDisplayName, First.Name = EMyEnum_CustomDisplay::First, IsBlueprintBase = true, ModuleRelativePath = Enum/MyEnum_Test.h, Second.Name = EMyEnum_CustomDisplay::Second, Third.Name = EMyEnum_CustomDisplay::Third)
//	ObjectFlags:	RF_Public | RF_Transient 
//	Outer:	Package /Script/Insider
//	EnumFlags:	EEnumFlags::None
//	EnumDisplayNameFn:	6adb4804
//	CppType:	EMyEnum_CustomDisplay
//	CppForm:	EnumClass
//{
//	First = 0,
//	Second = 1,
//	Third = 2,
//	EMyEnum_MAX = 3
//};

UENUM(Blueprintable, meta = (EnumDisplayNameFn = "GetMyEnumCustomDisplayName"))
enum class EMyEnum_CustomDisplay :uint8
{
	First,
	Second,
	Third,
};

extern FText GetMyEnumCustomDisplayName(int32 val);

FText GetMyEnumCustomDisplayName(int32 val)
{
	EMyEnum_CustomDisplay enumValue = (EMyEnum_CustomDisplay)val;
	switch (enumValue)
	{
	case EMyEnum_CustomDisplay::First:
		return FText::FromString(TEXT("My_First"));
	case EMyEnum_CustomDisplay::Second:
		return FText::FromString(TEXT("My_Second"));
	case EMyEnum_CustomDisplay::Third:
		return FText::FromString(TEXT("My_Third"));
	default:
		return FText::FromString(TEXT("Invalid MyEnum"));
	}
}
```

## æµ‹è¯•è“å›¾ï¼š

![Untitled](/Untitled.png)

EnumDisplayNameFn çš„å‡½æ•°è®¾ç½®æ˜¯åœ¨gen.cppä¸­å®Œæˆçš„ï¼Œå› æ­¤å¹¶ä¸éœ€è¦æˆä¸ºUFUNCTIONã€‚

```cpp
const UECodeGen_Private::FEnumParams Z_Construct_UEnum_Insider_EMyEnum_CustomDisplay_Statics::EnumParams = {
	(UObject*(*)())Z_Construct_UPackage__Script_Insider,
	GetMyEnumCustomDisplayName,             //è¿™é‡Œï¼ï¼ï¼
	"EMyEnum_CustomDisplay",
	"EMyEnum_CustomDisplay",
	Z_Construct_UEnum_Insider_EMyEnum_CustomDisplay_Statics::Enumerators,
	RF_Public|RF_Transient|RF_MarkAsNative,
	UE_ARRAY_COUNT(Z_Construct_UEnum_Insider_EMyEnum_CustomDisplay_Statics::Enumerators),
	EEnumFlags::None,
	(uint8)UEnum::ECppForm::EnumClass,
	METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UEnum_Insider_EMyEnum_CustomDisplay_Statics::Enum_MetaDataParams), Z_Construct_UEnum_Insider_EMyEnum_CustomDisplay_Statics::Enum_MetaDataParams)
};
```

## åŸç†ä»£ç ï¼š

```cpp

/FText UEnum::GetDisplayNameTextByIndex(int32 NameIndex) const
{
	FString RawName = GetNameStringByIndex(NameIndex);

	if (RawName.IsEmpty())
	{
		return FText::GetEmpty();
	}

#if WITH_EDITOR
	FText LocalizedDisplayName;
	// In the editor, use metadata and localization to look up names
	static const FString Namespace = TEXT("UObjectDisplayNames");
	const FString Key = GetFullGroupName(false) + TEXT(".") + RawName;

	FString NativeDisplayName;
	if (HasMetaData(TEXT("DisplayName"), NameIndex))
	{
		NativeDisplayName = GetMetaData(TEXT("DisplayName"), NameIndex);
	}
	else
	{
		NativeDisplayName = FName::NameToDisplayString(RawName, false);
	}

	if (!(FText::FindText(Namespace, Key, /*OUT*/LocalizedDisplayName, &NativeDisplayName)))
	{
		LocalizedDisplayName = FText::FromString(NativeDisplayName);
	}

	if (!LocalizedDisplayName.IsEmpty())
	{
		return LocalizedDisplayName;
	}
#endif
	//Runtimeä¸‹åˆ°è¿™é‡Œ
	if (EnumDisplayNameFn)
	{
		return (*EnumDisplayNameFn)(NameIndex);
	}

	return FText::FromString(GetNameStringByIndex(NameIndex));
}
```


ï»¿# EnumValueDisplayNameOverrides

- **åŠŸèƒ½æè¿°ï¼š** æ”¹å˜æšä¸¾å±æ€§å€¼ä¸Šçš„æ˜¾ç¤ºåå­—
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ValidEnumValues](../ValidEnumValues/ValidEnumValues.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç»™æšä¸¾å±æ€§ä¸Šçš„æšä¸¾å€¼è¿›è¡Œä¸€äº›æ”¹åï¼Œå¯ä»¥æ”¹å˜å¤šä¸ªï¼ŒæŒ‰ç…§â€œA=B;C=Dâ€çš„æ ¼å¼åˆ—å‡ºå³å¯ã€‚æ”¶é›†åˆ°çš„ä¿¡æ¯æ˜¯TMap<FName, FText>æ˜ å°„ï¼Œå› æ­¤è¦åŒæ—¶æä¾›åŸæšä¸¾å€¼åç§°å’Œæ–°çš„æ˜¾ç¤ºåç§°é…å¯¹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UENUM(BlueprintType)
enum class EMyPropertyTestEnum : uint8
{
	First,
	Second,
	Third,
	Forth,
	Fifth,
};

UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EnumValueDisplayNameOverrides = "First=Cat;Second=Dog"))
EMyPropertyTestEnum MyEnumWithDisplayNameOverrides;
```

## è“å›¾æ•ˆæœï¼š

å¯è§å®é™…ä¸Šæ”¹å˜äº†Firstã€Secondçš„æ˜¾ç¤ºåå­—ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\EnumValueDisplayNameOverrides\Untitled.png)

åŸç†ä»£ç è§ValidEnumValuesä¸Šçš„ä»£ç 


ï»¿# GetRestrictedEnumValues

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šæšä¸¾å±æ€§å€¼çš„å“ªäº›æšä¸¾é€‰é¡¹æ˜¯ç¦ç”¨çš„
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TArray<FString> FuncName() const;
- **å…³è”é¡¹ï¼š** [ValidEnumValues](ValidEnumValues/ValidEnumValues.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

Restrictedå’ŒInvalidçš„åŒºåˆ«æ˜¯ï¼š

Invalidä¼šéšè—æ‰è¯¥é€‰é¡¹å€¼

Restrictedä¾ç„¶ä¼šæ˜¾ç¤ºè¯¥é€‰é¡¹å€¼ï¼Œåªæ˜¯ä¼šç°è°ƒä¸å¯é€‰ã€‚

æŒ‡å®šçš„å‡½æ•°åå­—å¿…é¡»æ˜¯ä¸€ä¸ªUFUNCTIONå‡½æ•°ï¼Œè¿™æ ·æ‰èƒ½é€šè¿‡åå­—æ‰¾åˆ°è¯¥å‡½æ•°ã€‚


ï»¿# InvalidEnumValues

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæšä¸¾å±æ€§å€¼ä¸Šä¸å¯é€‰çš„æšä¸¾å€¼é€‰é¡¹ï¼Œç”¨ä»¥æ’é™¤ä¸€äº›é€‰é¡¹
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** æšä¸¾å±æ€§å€¼
- **å…³è”é¡¹ï¼š** [ValidEnumValues](ValidEnumValues/ValidEnumValues.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å¦‚æœåŒæ—¶æŒ‡å®šäº†InvalidEnumValueså’ŒValidEnumValuesï¼Œä¸”é‡Œé¢çš„å€¼æœ‰é‡å ï¼Œåˆ™è¿˜æ˜¯ä»¥InvalidEnumValuesçš„ä¸ºå‡†ï¼šè¿™é¡¹æšä¸¾å€¼å°±æ˜¯éæ³•çš„ã€‚


ï»¿# DisplayName

- **åŠŸèƒ½æè¿°ï¼š** æ”¹å˜æšä¸¾å€¼çš„æ˜¾ç¤ºåç§°
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æ”¹å˜æšä¸¾å€¼çš„æ˜¾ç¤ºåç§°

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
[enum 602d0d4e680 EMyEnum_HasDisplayName	Enum->Field->Object	/Script/Insider.EMyEnum_HasDisplayName]
(BlueprintType = true, First.DisplayName = Dog, First.Name = EMyEnum_HasDisplayName::First, IsBlueprintBase = true, ModuleRelativePath = Enum/MyEnum_Test.h, Second.DisplayName = Cat, Second.Name = EMyEnum_HasDisplayName::Second, Third.DisplayName = Pig, Third.Name = EMyEnum_HasDisplayName::Third)
	ObjectFlags:	RF_Public | RF_Transient 
	Outer:	Package /Script/Insider
	EnumFlags:	None
	EnumDisplayNameFn:	0
	CppType:	EMyEnum_HasDisplayName
	CppForm:	EnumClass
{
	First = 0,
	Second = 1,
	Third = 2,
	EMyEnum_MAX = 3
};
*/
UENUM(Blueprintable)
enum class EMyEnum_HasDisplayName :uint8
{
	First UMETA(DisplayName="Dog"),
	Second UMETA(DisplayName="Cat"),
	Third UMETA(DisplayName="Pig"),
};

UCLASS(BlueprintType)
class INSIDER_API UMyEnum_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere,BlueprintReadWrite)
	EMyEnum_HasDisplayName MyEnum_HasDisplayName;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯è§æ”¹å˜äº†åç§°ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Enum\UMETA\DisplayName\image.png](image.png)


ï»¿# DisplayValue

- **åŠŸèƒ½æè¿°ï¼š** Enum /Script/Engine.AnimPhysCollisionType
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

## æºç ä¾‹å­ï¼š

```cpp
UENUM()
enum class AnimPhysCollisionType : uint8
{
	CoM UMETA(DisplayName="CoM", DisplayValue="CoM", ToolTip="Only limit the center of mass from crossing planes."),
	CustomSphere UMETA(ToolTip="Use the specified sphere radius to collide with planes."),
	InnerSphere UMETA(ToolTip="Use the largest sphere that fits entirely within the body extents to collide with planes."),
	OuterSphere UMETA(ToolTip="Use the smallest sphere that wholely contains the body extents to collide with planes.")
};
```


ï»¿# Grouping

- **åŠŸèƒ½æè¿°ï¼š** Enum /Script/Engine.EAlphaBlendOption
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æ„Ÿè§‰æ˜¯ç”¨åœ¨Sequenceré‡Œé¢çš„ï¼Œåªç”¨åœ¨SEasingFunctionGridWidgeté‡Œé¢ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UENUM()
enum class EAlphaBlendOption : uint8
{
	Linear = 0 UMETA(Grouping = Linear, DisplayName = "Linear", ToolTip = "Linear interpolation"),
	Cubic UMETA(Grouping = Cubic, DisplayName = "Cubic In", ToolTip = "Cubic-in interpolation"),
	HermiteCubic UMETA(Grouping = Cubic, DisplayName = "Hermite-Cubic InOut", ToolTip = "Hermite-Cubic"),
	Sinusoidal UMETA(Grouping = Sinusoidal, DisplayName = "Sinusoidal", ToolTip = "Sinusoidal interpolation"),
	QuadraticInOut UMETA(Grouping = Quadratic, DisplayName = "Quadratic InOut", ToolTip = "Quadratic in-out interpolation"),
	CubicInOut UMETA(Grouping = Cubic, DisplayName = "Cubic InOut", ToolTip = "Cubic in-out interpolation"),
	QuarticInOut UMETA(Grouping = Quartic, DisplayName = "Quartic InOut", ToolTip = "Quartic in-out interpolation"),
	QuinticInOut UMETA(Grouping = Quintic, DisplayName = "Quintic InOut", ToolTip = "Quintic in-out interpolation"),
	CircularIn UMETA(Grouping = Circular, DisplayName = "Circular In", ToolTip = "Circular-in interpolation"),
	CircularOut UMETA(Grouping = Circular, DisplayName = "Circular Out", ToolTip = "Circular-out interpolation"),
	CircularInOut UMETA(Grouping = Circular, DisplayName = "Circular InOut", ToolTip = "Circular in-out interpolation"),
	ExpIn UMETA(Grouping = Exponential, DisplayName = "Exponential In", ToolTip = "Exponential-in interpolation"),
	ExpOut UMETA(Grouping = Exponential, DisplayName = "Exponential Out", ToolTip = "Exponential-Out interpolation"),
	ExpInOut UMETA(Grouping = Exponential, DisplayName = "Exponential InOut", ToolTip = "Exponential in-out interpolation"),
	Custom UMETA(Grouping = Custom, DisplayName = "Custom", ToolTip = "Custom interpolation, will use custom curve inside an FAlphaBlend or linear if none has been set"),
};

UENUM()
enum class EMovieSceneBuiltInEasing : uint8
{
	// Linear easing
	Linear UMETA(Grouping=Linear,DisplayName="Linear"),
	// Sinusoidal easing
	SinIn UMETA(Grouping=Sinusoidal,DisplayName="Sinusoidal In"), SinOut UMETA(Grouping=Sinusoidal,DisplayName="Sinusoidal Out"), SinInOut UMETA(Grouping=Sinusoidal,DisplayName="Sinusoidal InOut"),
	// Quadratic easing
	QuadIn UMETA(Grouping=Quadratic,DisplayName="Quadratic In"), QuadOut UMETA(Grouping=Quadratic,DisplayName="Quadratic Out"), QuadInOut UMETA(Grouping=Quadratic,DisplayName="Quadratic InOut"),
	// Cubic easing
	Cubic UMETA(Grouping = Cubic, DisplayName = "Cubic"), CubicIn UMETA(Grouping=Cubic,DisplayName="Cubic In"), CubicOut UMETA(Grouping=Cubic,DisplayName="Cubic Out"), CubicInOut UMETA(Grouping=Cubic,DisplayName="Cubic InOut"), HermiteCubicInOut UMETA(Grouping = Cubic, DisplayName = "Hermite-Cubic InOut"),
	// Quartic easing
	QuartIn UMETA(Grouping=Quartic,DisplayName="Quartic In"), QuartOut UMETA(Grouping=Quartic,DisplayName="Quartic Out"), QuartInOut UMETA(Grouping=Quartic,DisplayName="Quartic InOut"),
	// Quintic easing
	QuintIn UMETA(Grouping=Quintic,DisplayName="Quintic In"), QuintOut UMETA(Grouping=Quintic,DisplayName="Quintic Out"), QuintInOut UMETA(Grouping=Quintic,DisplayName="Quintic InOut"),
	// Exponential easing
	ExpoIn UMETA(Grouping=Exponential,DisplayName="Exponential In"), ExpoOut UMETA(Grouping=Exponential,DisplayName="Exponential Out"), ExpoInOut UMETA(Grouping=Exponential,DisplayName="Exponential InOut"),
	// Circular easing
	CircIn UMETA(Grouping=Circular,DisplayName="Circular In"), CircOut UMETA(Grouping=Circular,DisplayName="Circular Out"), CircInOut UMETA(Grouping=Circular,DisplayName="Circular InOut"),
	// Custom
	Custom UMETA(Grouping = Custom, DisplayName = "Custom"),
};

```

## åŸç†ï¼š

```cpp
TArray<SEasingFunctionGridWidget::FGroup> SEasingFunctionGridWidget::ConstructGroups(const TSet<EMovieSceneBuiltInEasing>& FilterExclude)
{
	const UEnum* EasingEnum = StaticEnum<EMovieSceneBuiltInEasing>();
	check(EasingEnum)

	TArray<FGroup> Groups;

	for (int32 NameIndex = 0; NameIndex < EasingEnum->NumEnums() - 1; ++NameIndex)
	{
		const FString& Grouping = EasingEnum->GetMetaData(TEXT("Grouping"), NameIndex);
		EMovieSceneBuiltInEasing Value = (EMovieSceneBuiltInEasing)EasingEnum->GetValueByIndex(NameIndex);

		if (FilterExclude.IsEmpty() || FilterExclude.Find(Value) == nullptr)
		{
			FindOrAddGroup(Groups, Grouping).Values.Add(Value);
		}
	}

	return Groups;
}
```


ï»¿# Hidden

- **åŠŸèƒ½æè¿°ï¼š** éšè—UENUMçš„æŸä¸ªå€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UENUMçš„å€¼
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

éšè—UENUMçš„æŸä¸ªå€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UENUM(Blueprintable,BlueprintType)
enum class EMyEnum_Spacer_Hidden :uint8
{
	MyNormal,
	MySpacer UMETA(Spacer),
	MyHidden UMETA(Hidden),
};

UCLASS(BlueprintType)
class INSIDER_API UMyEnum_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere,BlueprintReadWrite)
	EMyEnum_Spacer_Hidden MyEnum_Spacer_Hidden;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\UMETA\Hidden\5b4de771-be09-4342-8955-dc0f824ef97d.png)

ä½†æ˜¯è“å›¾é‡Œè®¿é—®ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\UMETA\Hidden\Untitled.png)

## åŸç†ï¼š

åœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œç”Ÿæˆæšä¸¾å¯èƒ½çš„å€¼çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­Hiddenå’ŒSpaceré€‰é¡¹æ¥éšè—ã€‚

ä½†æ˜¯åœ¨SEnumComboBoxå’ŒSGraphPinEnumè¿™ç§åœ¨è“å›¾é‡Œæ˜¾ç¤ºçš„æ—¶å€™ï¼Œåªä¼šåˆ¤æ–­Hiddenï¼Œè€Œæ²¡æœ‰ï¼ˆå¿˜äº†ï¼Ÿï¼‰åˆ¤æ–­Spacerï¼Œå› æ­¤MySpaceræ˜¯ä¾ç„¶ä¼šè¢«æ˜¾ç¤ºå‡ºæ¥ã€‚

```cpp
bool FPropertyHandleBase::GeneratePossibleValues(TArray<FString>& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems, TArray<FText>* OutDisplayNames)
{
		// Ignore hidden enums
	bool bShouldBeHidden = Enum->HasMetaData(TEXT("Hidden"), EnumIndex ) || Enum->HasMetaData(TEXT("Spacer"), EnumIndex );
	if (!bShouldBeHidden)
	{
		if(ValidEnumValues.Num() > 0)
		{
			bShouldBeHidden = !ValidEnumValues.Contains(Enum->GetNameByIndex(EnumIndex));
		}
		// If both are specified, InvalidEnumValues takes precedence
		else if(InvalidEnumValues.Num() > 0)
		{
			bShouldBeHidden = InvalidEnumValues.Contains(Enum->GetNameByIndex(EnumIndex));
		}
	}
}

void SEnumComboBox::Construct(const FArguments& InArgs, const UEnum* InEnum)
{
		if (Enum->HasMetaData(TEXT("Hidden"), Index) == false)
		{
			VisibleEnums.Emplace(Index, Enum->GetValueByIndex(Index), Enum->GetDisplayNameTextByIndex(Index), Enum->GetToolTipTextByIndex(Index));
		}
}

void SGraphPinEnum::GenerateComboBoxIndexes( TArray< TSharedPtr<int32> >& OutComboBoxIndexes )
{
	// Ignore hidden enum values
	if( !EnumPtr->HasMetaData(TEXT("Hidden"), EnumIndex ) )
	{
		TSharedPtr<int32> EnumIdxPtr(new int32(EnumIndex));
		OutComboBoxIndexes.Add(EnumIdxPtr);
	}
}
```


ï»¿# Spacer

- **åŠŸèƒ½æè¿°ï¼š** éšè—UENUMçš„æŸä¸ªå€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UENUM
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

Spacerå’ŒHiddençš„åŠŸèƒ½å¤§ä½“æ˜¯ä¸€è‡´çš„ã€‚å”¯ä¸€åŒºåˆ«æ˜¯Spaceråœ¨è“å›¾é‡Œ==çš„æ—¶å€™è¿˜æ˜¯ä¼šæ˜¾ç¤ºå‡ºæ¥ã€‚

å› æ­¤è¿˜æ˜¯å»ºè®®å¦‚æœè¦éšè—æšä¸¾å€¼ï¼Œè¿˜æ˜¯è¦å°½é‡éƒ½ç”¨Hiddenã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\UMETA\Hidden\Untitled.png)

å…¶ä»–ç¤ºä¾‹ä»£ç è§Hidden


ï»¿# TraceQuery

- **åŠŸèƒ½æè¿°ï¼š** Enum /Script/Engine.ECollisionChannel
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM::UMETA
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

åªåœ¨ECollisionChannel ä¸Šä½¿ç”¨ï¼ŒæŒ‡å®šå“ªäº›é€šé“æ˜¯ç”¨æ¥Traceçš„ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UENUM(BlueprintType)
enum ECollisionChannel : int
{

	ECC_WorldStatic UMETA(DisplayName="WorldStatic"),
	ECC_WorldDynamic UMETA(DisplayName="WorldDynamic"),
	ECC_Pawn UMETA(DisplayName="Pawn"),
	ECC_Visibility UMETA(DisplayName="Visibility" , TraceQuery="1"),
	ECC_Camera UMETA(DisplayName="Camera" , TraceQuery="1"),
	ECC_PhysicsBody UMETA(DisplayName="PhysicsBody"),
	ECC_Vehicle UMETA(DisplayName="Vehicle"),
	ECC_Destructible UMETA(DisplayName="Destructible"),

	/** Reserved for gizmo collision */
	ECC_EngineTraceChannel1 UMETA(Hidden),

	ECC_EngineTraceChannel2 UMETA(Hidden),
	ECC_EngineTraceChannel3 UMETA(Hidden),
	ECC_EngineTraceChannel4 UMETA(Hidden), 
	ECC_EngineTraceChannel5 UMETA(Hidden),
	ECC_EngineTraceChannel6 UMETA(Hidden),

	ECC_GameTraceChannel1 UMETA(Hidden),
	ECC_GameTraceChannel2 UMETA(Hidden),
	ECC_GameTraceChannel3 UMETA(Hidden),
	ECC_GameTraceChannel4 UMETA(Hidden),
	ECC_GameTraceChannel5 UMETA(Hidden),
	ECC_GameTraceChannel6 UMETA(Hidden),
	ECC_GameTraceChannel7 UMETA(Hidden),
	ECC_GameTraceChannel8 UMETA(Hidden),
	ECC_GameTraceChannel9 UMETA(Hidden),
	ECC_GameTraceChannel10 UMETA(Hidden),
	ECC_GameTraceChannel11 UMETA(Hidden),
	ECC_GameTraceChannel12 UMETA(Hidden),
	ECC_GameTraceChannel13 UMETA(Hidden),
	ECC_GameTraceChannel14 UMETA(Hidden),
	ECC_GameTraceChannel15 UMETA(Hidden),
	ECC_GameTraceChannel16 UMETA(Hidden),
	ECC_GameTraceChannel17 UMETA(Hidden),
	ECC_GameTraceChannel18 UMETA(Hidden),
	
	/** Add new serializeable channels above here (i.e. entries that exist in FCollisionResponseContainer) */
	/** Add only nonserialized/transient flags below */

	// NOTE!!!! THESE ARE BEING DEPRECATED BUT STILL THERE FOR BLUEPRINT. PLEASE DO NOT USE THEM IN CODE

	ECC_OverlapAll_Deprecated UMETA(Hidden),
	ECC_MAX,
};
```

## åŸç†ï¼š

```cpp
void UCollisionProfile::LoadProfileConfig(bool bForceInit)
{
		static const FString TraceType = TEXT("TraceQuery");
}
```


ï»¿# UseEnumValuesAsMaskValuesInEditor

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæšä¸¾å€¼å·²ç»æ˜¯ä½ç§»åçš„å€¼ï¼Œè€Œä¸æ˜¯ä½æ ‡è®°çš„ç´¢å¼•ä¸‹æ ‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [Bitflags](../Bitflags/Bitflags.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šåœ¨ç¼–è¾‘å™¨é‡Œçš„æšä¸¾å€¼ç›´æ¥å°±æ˜¯ä½æ ‡è®°çš„æœ€ç»ˆå€¼ï¼Œè€Œä¸æ˜¯æ ‡è®°ä½ã€‚ä½†æ˜¯æ³¨æ„åœ¨C++é‡Œçš„å®šä¹‰æ˜¯ä¸€æ ·çš„å½¢å¼ï¼š

```cpp
UENUM(BlueprintType, meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum class EMotionExtractor_MotionType : uint8
{
	None				= 0 UMETA(Hidden),
	Translation			= 1 << 0,
	Rotation			= 1 << 1,
	Scale				= 1 << 2,
	TranslationSpeed	= 1 << 3,
	RotationSpeed		= 1 << 4,
};

UENUM(meta = (Bitflags))
enum class EPCGChangeType : uint8
{
	None = 0,
	Cosmetic = 1 << 0,
	Settings = 1 << 1,
	Input = 1 << 2,
	Edge = 1 << 3,
	Node = 1 << 4,
	Structural = 1 << 5
};
```

## æµ‹è¯•çš„ä»£ç ï¼š

```cpp
UENUM(BlueprintType,Meta = (Bitflags))
enum class EMyEnum_BitFlags:uint8
{
	First,//0
	Second,//1
	Third,//2
};

UENUM(BlueprintType, meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = "true"))
enum class EMyEnum_BitFlagsInEditor:uint8
{
	First,//0
	Second,//1
	Third,//2
};
```

## æµ‹è¯•çš„è“å›¾1ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\UseEnumValuesAsMaskValuesInEditor\Untitled.png)

## æµ‹è¯•çš„è“å›¾2ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\UseEnumValuesAsMaskValuesInEditor\Untitled%201.png)

å› æ­¤å¯ä»¥çœ‹å‡ºå‰è€…æ˜¯1<<2+1<<2ï¼Œè€Œåè€…æ˜¯1|2ï¼Œå› æ­¤åè€…æ˜¯ç›´æ¥æŠŠæšä¸¾å€¼ä½œä¸ºå·²ç»ä½ç§»åçš„å€¼


ï»¿# ValidEnumValues

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæšä¸¾å±æ€§å€¼ä¸Šå¯é€‰çš„æšä¸¾å€¼é€‰é¡¹
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Enum Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** æšä¸¾å±æ€§å€¼
- **å…³è”é¡¹ï¼š** [InvalidEnumValues](../InvalidEnumValues.md), [GetRestrictedEnumValues](../GetRestrictedEnumValues.md), [EnumValueDisplayNameOverrides](../EnumValueDisplayNameOverrides/EnumValueDisplayNameOverrides.md), [Enum](../Enum.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šæšä¸¾å±æ€§å€¼ä¸Šå¯é€‰çš„æšä¸¾å€¼é€‰é¡¹ï¼Œé»˜è®¤æƒ…å†µä¸‹ã€‚æšä¸¾å±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸Šå¯é€‰é¡¹ä¸ºå…¨éƒ¨çš„æšä¸¾å€¼ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡ValidEnumValuesæ¥é™åˆ¶åªå±•ç¤ºè¿™äº›å€¼ã€‚

æšä¸¾å±æ€§çš„å†™æ³•æœ‰3ç§ï¼Œåˆ†åˆ«æ˜¯enum classï¼ŒTEnumAsByteå’ŒFStringå åŠ enum metaçš„å†™æ³•ï¼Œè¿™3ç§å†™æ³•éƒ½ä¼šè¢«è§†ä¸ºä¸€ä¸ªæšä¸¾å±æ€§ç„¶åå°è¯•äº§ç”Ÿcombo listæ¥è®©ç”¨æˆ·é€‰æ‹©å±æ€§å€¼ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UENUM(BlueprintType)
enum class EMyPropertyTestEnum : uint8
{
	First,
	Second,
	Third,
	Forth,
	Fifth,
};

UENUM(BlueprintType)
namespace EMyPropertyTestEnum2
{
	enum Type : int
	{
		First,
		Second,
		Third,
		Forth,
		Fifth,
	};
}

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Enum :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	EMyPropertyTestEnum MyEnum;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ValidEnumValues = "First,Second,Third"))
	EMyPropertyTestEnum MyEnumWithValid;	// Type 1

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ValidEnumValues = "First,Second,Third"))
	TEnumAsByte<EMyPropertyTestEnum2::Type> MyAnotherEnumWithValid;	//Type 2

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (enum = "EMyPropertyTestEnum"))
	FString MyStringWithEnum;	//Type 3
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (InvalidEnumValues = "First,Second,Third"))
	EMyPropertyTestEnum MyEnumWithInvalid = EMyPropertyTestEnum::Forth;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (GetRestrictedEnumValues = "MyGetRestrictedEnumValues"))
	EMyPropertyTestEnum MyEnumWithRestricted;

public:
	UFUNCTION(BlueprintInternalUseOnly)
	TArray<FString> MyGetRestrictedEnumValues() const{	return TArray<FString>{"Second","Third"};}
};
```

## è“å›¾æ•ˆæœï¼š

å¯è§é»˜è®¤æƒ…å†µä¸‹æšä¸¾å±æ€§ä¼šæ˜¾ç¤ºå…¨éƒ¨5ä¸ªæšä¸¾å€¼ï¼Œä½†å…¶ä»–3ä¸ªæšä¸¾å±æ€§å€¼çš„å¯é€‰åˆ—è¡¨è¢«é™åˆ¶åˆ°äº†3ä¸ªã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Enum\ValidEnumValues\Untitled.png)

## åŸç†ï¼š

ä¸‹è¿°çš„ä»£ç ï¼Œ

```cpp
bool FPropertyHandleBase::GeneratePossibleValues(TArray< TSharedPtr<FString> >& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems)
{
	TArray<UObject*> OuterObjects;
	GetOuterObjects(OuterObjects);		
	
	const TArray<FName> ValidEnumValues = PropertyEditorHelpers::GetValidEnumsFromPropertyOverride(Property, Enum);
	const TArray<FName> InvalidEnumValues = PropertyEditorHelpers::GetInvalidEnumsFromPropertyOverride(Property, Enum);
	const TArray<FName> RestrictedEnumValues = PropertyEditorHelpers::GetRestrictedEnumsFromPropertyOverride(OuterObjects, Property, Enum);
	
	const TMap<FName, FText> EnumValueDisplayNameOverrides = PropertyEditorHelpers::GetEnumValueDisplayNamesFromPropertyOverride(Property, Enum);
	
	//NumEnums() - 1, because the last item in an enum is the _MAX item
	for( int32 EnumIndex = 0; EnumIndex < Enum->NumEnums() - 1; ++EnumIndex )
	{
		// Ignore hidden enums
		bool bShouldBeHidden = Enum->HasMetaData(TEXT("Hidden"), EnumIndex ) || Enum->HasMetaData(TEXT("Spacer"), EnumIndex );
		if (!bShouldBeHidden)
		{
			if(ValidEnumValues.Num() > 0)
			{
				bShouldBeHidden = !ValidEnumValues.Contains(Enum->GetNameByIndex(EnumIndex));
			}
			// If both are specified, InvalidEnumValues takes precedence
			else if(InvalidEnumValues.Num() > 0)
			{
				bShouldBeHidden = InvalidEnumValues.Contains(Enum->GetNameByIndex(EnumIndex));
			}
		}
	
		if (!bShouldBeHidden)
		{
			bShouldBeHidden = IsHidden(Enum->GetNameStringByIndex(EnumIndex));
		}
	
		if( !bShouldBeHidden )
		{
			// See if we specified an alternate name for this value using metadata
			FString EnumName = Enum->GetNameStringByIndex(EnumIndex);
			FString EnumDisplayName = EnumValueDisplayNameOverrides.FindRef(Enum->GetNameByIndex(EnumIndex)).ToString();
			if (EnumDisplayName.IsEmpty())
			{
				EnumDisplayName = Enum->GetDisplayNameTextByIndex(EnumIndex).ToString();
			}
	
			FText RestrictionTooltip;
			const bool bIsRestricted = GenerateRestrictionToolTip(EnumName, RestrictionTooltip) || RestrictedEnumValues.Contains(Enum->GetNameByIndex(EnumIndex));
			OutRestrictedItems.Add(bIsRestricted);
	
			if (EnumDisplayName.Len() == 0)
			{
				EnumDisplayName = MoveTemp(EnumName);
			}
			else
			{
				bUsesAlternateDisplayValues = true;
			}
	
			TSharedPtr< FString > EnumStr(new FString(EnumDisplayName));
			OutOptionStrings.Add(EnumStr);
	
			FText EnumValueToolTip = bIsRestricted ? RestrictionTooltip : Enum->GetToolTipTextByIndex(EnumIndex);
			OutToolTips.Add(MoveTemp(EnumValueToolTip));
		}
		else
		{
			OutToolTips.Add(FText());
		}
	}
}
```


ï»¿# HideFromModifiers

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šAttributeSetä¸‹çš„æŸå±æ€§ä¸å‡ºç°åœ¨GameplayEffectä¸‹çš„Modifiersçš„Attributeé€‰æ‹©é‡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** GAS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAttributeSetä¸‹çš„å±æ€§
- **å…³è”é¡¹ï¼š** [HideInDetailsView](../HideInDetailsView/HideInDetailsView.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šAttributeSetä¸‹çš„æŸå±æ€§ä¸å‡ºç°åœ¨GameplayEffectä¸‹çš„Modifiersçš„Attributeé€‰æ‹©é‡Œã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS()
class UMyAttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core")
	float HP = 100.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core", meta = (HideInDetailsView))
	float HP_HideInDetailsView = 100.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core", meta = (HideFromModifiers))
	float HP_HideFromModifiers = 100.f;
};
UCLASS()
class UMyAttributeSetTest : public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "GAS")
	FGameplayAttribute MyAttribute;
};
```

## æµ‹è¯•ç»“æœï¼š

åœ¨è“å›¾ä¸­åˆ›å»ºä¸€ä¸ªGameplayEffectï¼Œç„¶åè§‚å¯Ÿå…¶Modifiersä¸‹çš„Attributeé€‰æ‹©ã€‚

å‘ç°HP_HideFromModifiers å¯ä»¥å‡ºç°åœ¨æ­£å¸¸çš„FGameplayAttribute é€‰é¡¹å¡ä¸­ï¼Œä½†ä¸èƒ½å‡ºç°åœ¨Modifiersä¸‹çš„Attributeé€‰é¡¹å¡é‡Œã€‚è¿™å°±æ˜¯è¿™é‡Œçš„ä½œç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\GAS\HideFromModifiers\Untitled.png)

## åŸç†ï¼š

åœ¨FGameplayModifierInfoçš„Attributeå±æ€§ä¸Šæœ‰FilterMetaTagçš„å…ƒæ•°æ®ï¼Œç„¶åå–å‡ºå…¶é‡Œé¢çš„å€¼ï¼Œæœ€ç»ˆè¿˜æ˜¯ä¼ åˆ°GetAllAttributePropertiesä½œä¸ºFilterMetaStræ¥è¿‡æ»¤ã€‚å› æ­¤å±æ€§ä¸Šå‡ºç°HideFromModifierså°±ä¸èƒ½å‡ºç°ã€‚

```cpp
USTRUCT(BlueprintType)
struct GAMEPLAYABILITIES_API FGameplayModifierInfo
{
	GENERATED_USTRUCT_BODY()
	
	/** The Attribute we modify or the GE we modify modifies. */
	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier, meta=(FilterMetaTag="HideFromModifiers"))
	FGameplayAttribute Attribute;
};

void FAttributePropertyDetails::CustomizeHeader( TSharedRef<IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils )
{
		const FString& FilterMetaStr = StructPropertyHandle->GetProperty()->GetMetaData(TEXT("FilterMetaTag"));
	SNew(SGameplayAttributeWidget)
	.OnAttributeChanged(this, &FAttributePropertyDetails::OnAttributeChanged)
	.DefaultProperty(PropertyValue)
	.FilterMetaData(FilterMetaStr)
}
void FGameplayAttribute::GetAllAttributeProperties(TArray<FProperty*>& OutProperties, FString FilterMetaStr, bool UseEditorOnlyData)
{}
```


ï»¿# HideInDetailsView

- **åŠŸèƒ½æè¿°ï¼š** æŠŠè¯¥UAttributeSetå­ç±»é‡Œçš„å±æ€§éšè—åœ¨FGameplayAttributeçš„é€‰é¡¹åˆ—è¡¨é‡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** GAS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAttributeSet
- **å…³è”é¡¹ï¼š** [HideFromModifiers](../HideFromModifiers/HideFromModifiers.md), [SystemGameplayAttribute](../SystemGameplayAttribute/SystemGameplayAttribute.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠè¯¥UAttributeSetå­ç±»é‡Œçš„å±æ€§éšè—åœ¨FGameplayAttributeçš„é€‰é¡¹åˆ—è¡¨é‡Œã€‚

å¯ç”¨åœ¨UCLASSä¸Šéšè—æ‰æ•´ä¸ªç±»é‡Œçš„æ‰€æœ‰å±æ€§ï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨æŸä¸ªç‰¹å®šå±æ€§ä¸Šåªéšè—è¯¥å±æ€§ã€‚

åœ¨æºç é‡Œç”¨åˆ°çš„ä¾‹å­æ˜¯UAbilitySystemTestAttributeSetï¼Œå› ä¸ºå…¶å°±æ˜¯ä¸€ä¸ªä¸“é—¨ç”¨æ¥æµ‹è¯•çš„ASï¼Œå› æ­¤å¸Œæœ›ä¸å½±å“æ­£å¸¸çš„é€‰é¡¹åˆ—è¡¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS()
class UMyAttributeSet : public UAttributeSet
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core")
	float HP = 100.f;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core", meta = (HideInDetailsView))
	float HP_HideInDetailsView = 100.f;
};

UCLASS(meta = (HideInDetailsView))
class UMyAttributeSet_Hide : public UAttributeSet
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Core")
	float HP = 100.f;
};

UCLASS()
class UMyAttributeSetTest : public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "GAS")
	FGameplayAttribute MyAttribute;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åªèƒ½é€‰åˆ°UMyAttributeSet.HPå±æ€§ï¼Œæ— æ³•é€‰æ‹©åˆ°UMyAttributeSet_Hideé‡Œçš„é€‰é¡¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\GAS\HideInDetailsView\Untitled.png)

## åŸç†ï¼š

```cpp
PropertyModule.RegisterCustomPropertyTypeLayout( "GameplayAttribute", FOnGetPropertyTypeCustomizationInstance::CreateStatic( &FAttributePropertyDetails::MakeInstance ) );

void FGameplayAttribute::GetAllAttributeProperties(TArray<FProperty*>& OutProperties, FString FilterMetaStr, bool UseEditorOnlyData)
{
	for (TObjectIterator<UClass> ClassIt; ClassIt; ++ClassIt)
	{
		if (UseEditorOnlyData)
		{
			#if WITH_EDITOR
			// Allow entire classes to be filtered globally
			if (Class->HasMetaData(TEXT("HideInDetailsView")))
			{
				continue;
			}
			#endif
		}
		
		
			for (TFieldIterator<FProperty> PropertyIt(Class, EFieldIteratorFlags::ExcludeSuper); PropertyIt; ++PropertyIt)
			{
				FProperty* Property = *PropertyIt;

				if (UseEditorOnlyData)
				{
					// Allow properties to be filtered globally (never show up)
					if (Property->HasMetaData(TEXT("HideInDetailsView")))
					{
						continue;
					}
					#endif
				}
				
				OutProperties.Add(Property);
			}
	}
}
```


ï»¿# SystemGameplayAttribute

- **åŠŸèƒ½æè¿°ï¼š** æŠŠUAbilitySystemComponentå­ç±»é‡Œé¢çš„å±æ€§æš´éœ²åˆ°FGameplayAttribute é€‰é¡¹æ¡†é‡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** GAS
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UAbilitySystemComponentå­ç±»é‡Œé¢çš„å±æ€§
- **å…³è”é¡¹ï¼š** [HideInDetailsView](../HideInDetailsView/HideInDetailsView.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠUAbilitySystemComponentå­ç±»é‡Œé¢çš„å±æ€§æš´éœ²åˆ°FGameplayAttribute é€‰é¡¹æ¡†é‡Œã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(ClassGroup=AbilitySystem, hidecategories=(Object,LOD,Lighting,Transform,Sockets,TextureStreaming), editinlinenew, meta=(BlueprintSpawnableComponent))
class GAMEPLAYABILITIES_API UAbilitySystemComponent : public UGameplayTasksComponent, public IGameplayTagAssetInterface, public IAbilitySystemReplicationProxyInterface
{
	/** Internal Attribute that modifies the duration of gameplay effects created by this component */
	UPROPERTY(meta=(SystemGameplayAttribute="true"))
	float OutgoingDuration;

	/** Internal Attribute that modifies the duration of gameplay effects applied to this component */
	UPROPERTY(meta = (SystemGameplayAttribute = "true"))
	float IncomingDuration;
}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class UMyAbilitySystemComponent : public UAbilitySystemComponent
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "GAS")
	float MyFloat;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "GAS", meta = (SystemGameplayAttribute))
	float MyFloat_System;
};

UCLASS()
class UMyAttributeSetTest : public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = "GAS")
	FGameplayAttribute MyAttribute;
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyFloat_Systemå¯ä»¥æš´éœ²åˆ°é€‰é¡¹åˆ—è¡¨é‡Œå»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\GAS\SystemGameplayAttribute\Untitled.png)

## åŸç†ï¼š

ä¹Ÿæ˜¯åœ¨GetAllAttributePropertiesåˆ¤æ–­å±æ€§ä¸Šçš„SystemGameplayAttributeæ ‡è®°ã€‚

```cpp
void FGameplayAttribute::GetAllAttributeProperties(TArray<FProperty*>& OutProperties, FString FilterMetaStr, bool UseEditorOnlyData)
{
	// UAbilitySystemComponent can add 'system' attributes
	if (Class->IsChildOf(UAbilitySystemComponent::StaticClass()) && !Class->ClassGeneratedBy)
	{
		for (TFieldIterator<FProperty> PropertyIt(Class, EFieldIteratorFlags::ExcludeSuper); PropertyIt; ++PropertyIt)
		{
			FProperty* Property = *PropertyIt;
	
	
			// SystemAttributes have to be explicitly tagged
			if (Property->HasMetaData(TEXT("SystemGameplayAttribute")) == false)
			{
				continue;
			}
			OutProperties.Add(Property);
		}
	}
}
```


ï»¿# MaterialControlFlow

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¯¥UMaterialExpressionä¸ºä¸€ä¸ªæ§åˆ¶æµèŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpressionå­ç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ‡è¯†è¯¥UMaterialExpressionä¸ºä¸€ä¸ªæ§åˆ¶æµèŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚

ä¸€èˆ¬æ˜¯åœ¨IfThenElseï¼ŒForLoopè¿™ç§èŠ‚ç‚¹ä¸Šï¼Œå½“å‰å¼•æ“å®ç°è¿˜æœªå®Œå–„ï¼Œå› æ­¤è¯¥åŠŸèƒ½ç¦ç”¨ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(collapsecategories, hidecategories=Object, MinimalAPI)
class UMaterialExpressionIf : public UMaterialExpression
{}

UCLASS(collapsecategories, hidecategories = Object, MinimalAPI, meta=(MaterialControlFlow))
class UMaterialExpressionIfThenElse : public UMaterialExpression
{}
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥æ‰¾åˆ°IfèŠ‚ç‚¹ï¼Œä½†æ˜¯æ— æ³•è°ƒç”¨IfThenElseèŠ‚ç‚¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Material\MaterialControlFlow\Untitled.png)

## åŸç†ï¼š

åœ¨éå†æ‰€æœ‰å¯ç”¨FMaterialExpressionçš„æ—¶å€™ï¼Œå¦‚æœæœ‰MaterialControlFlowåˆ™ç•¥è¿‡ã€‚å½“å‰å¼•æ“ä¸‹AllowMaterialControlFlowä¸€ç›´æœªfalseï¼Œæœªå®ç°ã€‚

```cpp

// r.MaterialEnableControlFlow is removed and the feature is forced disabled as how control flow should be
// implemented in the material editor is still under discussion.
inline bool AllowMaterialControlFlow()
{
	return false;
}

void MaterialExpressionClasses::InitMaterialExpressionClasses()
{
		static const auto CVarMaterialEnableNewHLSLGenerator = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.MaterialEnableNewHLSLGenerator"));
		const bool bEnableControlFlow = AllowMaterialControlFlow();
		const bool bEnableNewHLSLGenerator = CVarMaterialEnableNewHLSLGenerator->GetValueOnAnyThread() != 0;
	
		for( TObjectIterator<UClass> It ; It ; ++It )
		{
			if( Class->IsChildOf(UMaterialExpression::StaticClass()) )
			{
					// Hide node types related to control flow, unless it's enabled
					if (!bEnableControlFlow && Class->HasMetaData("MaterialControlFlow"))
					{
									continue;
					}
					
					if (!bEnableNewHLSLGenerator && Class->HasMetaData("MaterialNewHLSLGenerator"))
					{
									continue;
					}
					
					// Hide node types that are tagged private
					if(Class->HasMetaData(TEXT("Private")))
					{
									continue;
					}
				AllExpressionClasses.Add(MaterialExpression);
			}
		}
}
```


ï»¿# MaterialNewHLSLGenerator

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¯¥UMaterialExpressionä¸ºé‡‡ç”¨æ–°HLSLç”Ÿæˆå™¨çš„èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpressionå­ç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ‡è¯†è¯¥UMaterialExpressionä¸ºé‡‡ç”¨æ–°HLSLç”Ÿæˆå™¨çš„èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚

## æºç ä¾‹å­ï¼š

```cpp

UCLASS(MinimalAPI, meta = (MaterialNewHLSLGenerator))
class UMaterialExpressionLess : public UMaterialExpressionBinaryOp
{
	GENERATED_UCLASS_BODY()
#if WITH_EDITOR
	virtual UE::HLSLTree::EOperation GetBinaryOp() const override { return UE::HLSLTree::EOperation::Less; }
#endif // WITH_EDITOR
};
```

## æµ‹è¯•æ•ˆæœï¼š

æè´¨è“å›¾é‡Œæ— æ³•è°ƒç”¨Lessã€‚

![Untitled](/Untitled.png)

## åŸç†ï¼š

åœ¨éå†æ‰€æœ‰å¯ç”¨FMaterialExpressionçš„æ—¶å€™ï¼Œå¦‚æœæœ‰MaterialNewHLSLGeneratoråˆ™ç•¥è¿‡ã€‚å½“å‰å¼•æ“ä¸‹r.MaterialEnableNewHLSLGeneratoræ˜¯åªè¯»çš„ï¼Œä¸”å®ç°æœªå®Œå…¨ã€‚

```cpp
static TAutoConsoleVariable<int32> CVarMaterialEnableNewHLSLGenerator(
	TEXT("r.MaterialEnableNewHLSLGenerator"),
	0,
	TEXT("Enables the new (WIP) material HLSL generator.\n")
	TEXT("0 - Don't allow\n")
	TEXT("1 - Allow if enabled by material\n")
	TEXT("2 - Force all materials to use new generator\n"),
	ECVF_RenderThreadSafe | ECVF_ReadOnly);

void MaterialExpressionClasses::InitMaterialExpressionClasses()
{
		static const auto CVarMaterialEnableNewHLSLGenerator = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.MaterialEnableNewHLSLGenerator"));
		const bool bEnableControlFlow = AllowMaterialControlFlow();
		const bool bEnableNewHLSLGenerator = CVarMaterialEnableNewHLSLGenerator->GetValueOnAnyThread() != 0;
	
		for( TObjectIterator<UClass> It ; It ; ++It )
		{
			if( Class->IsChildOf(UMaterialExpression::StaticClass()) )
			{
					// Hide node types related to control flow, unless it's enabled
					if (!bEnableControlFlow && Class->HasMetaData("MaterialControlFlow"))
					{
									continue;
					}
					
					if (!bEnableNewHLSLGenerator && Class->HasMetaData("MaterialNewHLSLGenerator"))
					{
									continue;
					}
					
					// Hide node types that are tagged private
					if(Class->HasMetaData(TEXT("Private")))
					{
									continue;
					}
				AllExpressionClasses.Add(MaterialExpression);
			}
		}
}
```


ï»¿# MaterialParameterCollectionFunction

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°æ˜¯ç”¨äºæ“ä½œUMaterialParameterCollectionï¼Œä»è€Œæ”¯æŒParameterNameçš„æå–å’ŒéªŒè¯
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** å¸¦æœ‰UMaterialParameterCollectionå‚æ•°çš„å‡½æ•°
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥å‡½æ•°æ˜¯ç”¨äºæ“ä½œUMaterialParameterCollectionï¼Œä»è€Œæ”¯æŒParameterNameçš„æå–å’ŒéªŒè¯ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Material :public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject", MaterialParameterCollectionFunction))
	static void MySetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue);

	UFUNCTION(BlueprintCallable, meta=(WorldContext="WorldContextObject"))
	static void MySetScalarParameterValue_NoError(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue);
};
```

## è“å›¾ä¸­æ•ˆæœï¼š

å¼•æ“è‡ªå¸¦çš„UKismetMaterialLibrary::SetScalarParameterValueå’Œæˆ‘ä»¬è‡ªå·±æ‰‹åŠ¨ç¼–å†™çš„MySetScalarParameterValueï¼Œä¼šè§¦å‘æè´¨å‚æ•°é›†åˆçš„è“å›¾èŠ‚ç‚¹éªŒè¯æ£€æµ‹ã€‚å¦‚æœæ²¡æœ‰æŒ‡å®šParameterNameï¼Œåˆ™ä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚è€Œæ²¡æœ‰MaterialParameterCollectionFunctionæ ‡è®°çš„MySetScalarParameterValue_NoErrorå‡½æ•°ç‰ˆæœ¬åˆ™åªæ˜¯å½“ä½œä¸€ä¸ªæ™®é€šçš„å‡½æ•°ä¸€æ ·ï¼Œä¸€æ˜¯ä¸ä¼šè‡ªåŠ¨æå–MPCä¸­çš„Parametersé›†åˆæ¥é€‰æ‹©ï¼ŒäºŒæ˜¯æ²¡æœ‰ParameterNameä¸ºç©ºçš„é”™è¯¯éªŒè¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Material\MaterialParameterCollectionFunction\Untitled.png)

## åŸç†ï¼š

```cpp
UBlueprintFunctionNodeSpawner* UBlueprintFunctionNodeSpawner::Create(UFunction const* const Function, UObject* Outer/* = nullptr*/)
{
	bool const bIsMaterialParamCollectionFunc = Function->HasMetaData(FBlueprintMetadata::MD_MaterialParameterCollectionFunction);
	if (bIsMaterialParamCollectionFunc)
	{
		NodeClass = UK2Node_CallMaterialParameterCollectionFunction::StaticClass();
	}
	else
	{
		NodeClass = UK2Node_CallFunction::StaticClass();
	}
}

TSharedPtr<SGraphNode> FNodeFactory::CreateNodeWidget(UEdGraphNode* InNode)
{
		if (UK2Node_CallMaterialParameterCollectionFunction* CallFunctionNode = Cast<UK2Node_CallMaterialParameterCollectionFunction>(InNode))
		{
			return SNew(SGraphNodeCallParameterCollectionFunction, CallFunctionNode);
		}
}
TSharedPtr<SGraphPin> SGraphNodeCallParameterCollectionFunction::CreatePinWidget(UEdGraphPin* Pin) const
{
	//æå–MPCä¸­å‚æ•°åˆ—è¡¨ç­‰æ“ä½œ
		if (Collection)
		{
			// Populate the ParameterName pin combobox with valid options from the Collection
			const bool bVectorParameters = CallFunctionNode->FunctionReference.GetMemberName().ToString().Contains(TEXT("Vector"));
			Collection->GetParameterNames(NameList, bVectorParameters);
		}
}
```

MaterialParameterCollectionFunctionè¿™ä¸ªæ ‡è®°çš„ï¼Œä¼šé‡‡ç”¨UK2Node_CallMaterialParameterCollectionFunctionæ¥éªŒè¯æè´¨å‡½æ•°çš„æ­£ç¡®ä¹¦å†™ä¸å¦ã€‚åŒæ—¶UK2Node_CallMaterialParameterCollectionFunctionè¿™ä¸ªè“å›¾èŠ‚ç‚¹ä¹Ÿåœ¨å¼•æ“å†…éƒ¨ç»§ç»­è¢«è¯†åˆ«ä»¥è¿›ä¸€æ­¥å®šåˆ¶åŒ–ParameterNameçš„PinèŠ‚ç‚¹ã€‚

å¼•æ“æºç å†…é‡‡ç”¨MaterialParameterCollectionFunctionæ ‡è®°çš„å‡½æ•°åªæœ‰UKismetMaterialLibraryé‡Œçš„å‡½æ•°ã€‚


ï»¿# OverridingInputProperty

- **åŠŸèƒ½æè¿°ï¼š** åœ¨UMaterialExpressionä¸­æŒ‡å®šæœ¬floatè¦è¦†ç›–çš„å…¶ä»–FExpressionInput å±æ€§ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpression::float
- **å…³è”é¡¹ï¼š** [RequiredInput](../RequiredInput.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨UMaterialExpressionä¸­æŒ‡å®šæœ¬floatè¦è¦†ç›–çš„å…¶ä»–FExpressionInput å±æ€§ã€‚

- åœ¨æè´¨è¡¨è¾¾å¼é‡Œæœ‰äº›å±æ€§ï¼Œå½“ç”¨æˆ·æ²¡è¿æ¥çš„æ—¶å€™ï¼Œæˆ‘ä»¬æƒ³æä¾›ä¸€ä¸ªé»˜è®¤å€¼ã€‚è¿™ä¸ªæ—¶å€™è¿™ä¸ªFloatå±æ€§çš„æŒ‡å°±å¯ä»¥å½“ä½œé»˜è®¤å€¼ã€‚
- è€Œå½“ç”¨æˆ·è¿æ¥çš„æ—¶å€™ï¼Œè¿™ä¸ªå¼•è„šåˆè¦å˜æˆä¸€ä¸ªæ­£å¸¸çš„è¾“å…¥ï¼Œå› æ­¤å¾—æœ‰å¦ä¸€ä¸ªFExpressionInput å±æ€§ï¼Œæ‰€ä»¥æ‰éœ€è¦ç”¨OverridingInputProperty æŒ‡å®šå¦ä¸€ä¸ªå±æ€§ã€‚
- è¢«OverridingInputProperty æŒ‡å®šçš„FExpressionInput å±æ€§ä¸€èˆ¬æ˜¯RequiredInput = "false"ï¼Œå› ä¸ºæ­£å¸¸çš„é€»è¾‘æ˜¯ä½ éƒ½æä¾›é»˜è®¤å€¼äº†ï¼Œé‚£å½“ç„¶ç”¨æˆ·å°±ä¸ä¸€å®šéå¾—è¾“å…¥è¿™ä¸ªå€¼äº†ã€‚å½“ç„¶ä¹Ÿå¯ä»¥RequiredInput = "true"ï¼Œæé†’ç”¨æˆ·è¿™ä¸ªå¼•è„šæœ€å¥½è¦æœ‰ä¸ªè¾“å…¥ï¼Œä½†å¦‚æœçœŸæ²¡æœ‰ï¼Œä¹Ÿå¯ä»¥ç”¨é»˜è®¤å€¼ã€‚
- è¾“å‡ºèŠ‚ç‚¹ä¸Šçš„å¾ˆå¤šBaseColorä¹‹ç±»çš„å¼•è„šå°±æ˜¯åˆRequiredInputåˆæä¾›é»˜è®¤å€¼çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

åœ¨Compileå‡½æ•°ä¸­æ¨¡ä»¿æºç ç»™å¤§å®¶ç¤ºèŒƒå¦‚ä½•æ­£ç¡®å¤„ç†è¿™ç§å±æ€§æ¥è·å¾—å€¼ã€‚å¤§å®¶ä¹Ÿå¯ä»¥å‚ç…§æºç ä¸­åˆ«çš„ä¾‹å­æ¥å‚è€ƒã€‚

```cpp
UCLASS()
class UMyProperty_MyMaterialExpression : public UMaterialExpression
{
	GENERATED_UCLASS_BODY()
public:
	UPROPERTY()
	FExpressionInput MyInput_Default;

	UPROPERTY(meta = (RequiredInput = "true"))
	FExpressionInput MyInput_Required;

	UPROPERTY(meta = (RequiredInput = "false"))
	FExpressionInput MyInput_NotRequired;
public:
	UPROPERTY(EditAnywhere, Category = OverridingInputProperty, meta = (RequiredInput = "false"))
	FExpressionInput MyAlpha;

	/** only used if MyAlpha is not hooked up */
	UPROPERTY(EditAnywhere, Category = OverridingInputProperty, meta = (OverridingInputProperty = "MyAlpha"))
	float ConstAlpha = 1.f;

	UPROPERTY(EditAnywhere, Category = OverridingInputProperty, meta = (RequiredInput = "true"))
	FExpressionInput MyAlpha2;

	/** only used if MyAlpha is not hooked up */
	UPROPERTY(EditAnywhere, Category = OverridingInputProperty, meta = (OverridingInputProperty = "MyAlpha2"))
	float ConstAlpha2 = 1.f;
public:

	//~ Begin UMaterialExpression Interface
#if WITH_EDITOR
	virtual int32 Compile(class FMaterialCompiler* Compiler, int32 OutputIndex) override
	{
		int32 IndexAlpha = MyAlpha.GetTracedInput().Expression ? MyAlpha.Compile(Compiler) : Compiler->Constant(ConstAlpha);
		return 0;
	}
	virtual void GetCaption(TArray<FString>& OutCaptions) const override;

	virtual bool GenerateHLSLExpression(FMaterialHLSLGenerator& Generator, UE::HLSLTree::FScope& Scope, int32 OutputIndex, UE::HLSLTree::FExpression const*& OutExpression) const override;
#endif
	//~ End UMaterialExpression Interface
};

```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyAlphaå’ŒMyAlpha2çš„å³è¾¹éƒ½æœ‰ä¸ªé»˜è®¤å€¼ï¼ŒäºŒè€…åˆå› ä¸ºRequiredInputçš„ä¸åŒè€Œä¸€ä¸ªç°è‰²ä¸€ä¸ªç™½è‰²ã€‚

å…¶ä»–3ä¸ªMyInputç”¨æ¥ç»™å¤§å®¶å¯¹æ¯”ã€‚

å³ä¾§çš„æè´¨æœ€ç»ˆè¾“å‡ºè¡¨è¾¾å¼ä¸Šçš„å„ä¸ªå¼•è„šæ›´æ˜¯æœ‰å„ç§æƒ…å†µæ¥è®©å¤§å®¶å‚è€ƒã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Material\OverridingInputProperty\Untitled.png)

## åŸç†ï¼š

å…¶å®ä¹Ÿæ˜¯æ ¹æ®Metaçš„æ ‡è®°ï¼Œæ¥æ”¹å˜å¼•è„šçš„å¯ç¼–è¾‘çŠ¶æ€ä»¥åŠè¾“å…¥æ¡†ã€‚

```cpp

bool UMaterialExpression::CanEditChange(const FProperty* InProperty) const
{
	bool bIsEditable = Super::CanEditChange(InProperty);
	if (bIsEditable && InProperty != nullptr)
	{
		// Automatically set property as non-editable if it has OverridingInputProperty metadata
		// pointing to an FExpressionInput property which is hooked up as an input.
		//
		// e.g. in the below snippet, meta=(OverridingInputProperty = "A") indicates that ConstA will
		// be overridden by an FExpressionInput property named 'A' if one is connected, and will thereby
		// be set as non-editable.
		//
		//	UPROPERTY(meta = (RequiredInput = "false", ToolTip = "Defaults to 'ConstA' if not specified"))
		//	FExpressionInput A;
		//
		//	UPROPERTY(EditAnywhere, Category = MaterialExpressionAdd, meta = (OverridingInputProperty = "A"))
		//	float ConstA;
		//

		static FName OverridingInputPropertyMetaData(TEXT("OverridingInputProperty"));

		if (InProperty->HasMetaData(OverridingInputPropertyMetaData))
		{
			const FString& OverridingPropertyName = InProperty->GetMetaData(OverridingInputPropertyMetaData);

			FStructProperty* StructProp = FindFProperty<FStructProperty>(GetClass(), *OverridingPropertyName);
			if (ensure(StructProp != nullptr))
			{
				static FName RequiredInputMetaData(TEXT("RequiredInput"));

				// Must be a single FExpressionInput member, not an array, and must be tagged with metadata RequiredInput="false"
				if (ensure(	StructProp->Struct->GetFName() == NAME_ExpressionInput &&
							StructProp->ArrayDim == 1 &&
							StructProp->HasMetaData(RequiredInputMetaData) &&
							!StructProp->GetBoolMetaData(RequiredInputMetaData)))
				{
					const FExpressionInput* Input = StructProp->ContainerPtrToValuePtr<FExpressionInput>(this);

					if (Input->Expression != nullptr && Input->GetTracedInput().Expression != nullptr)
					{
						bIsEditable = false;
					}
				}
			}
		}

		if (bIsEditable)
		{
			// If the property has EditCondition metadata, then whether it's editable depends on the other EditCondition property
			const FString EditConditionPropertyName = InProperty->GetMetaData(TEXT("EditCondition"));
			if (!EditConditionPropertyName.IsEmpty())
			{
				FBoolProperty* EditConditionProperty = FindFProperty<FBoolProperty>(GetClass(), *EditConditionPropertyName);
				{
					bIsEditable = *EditConditionProperty->ContainerPtrToValuePtr<bool>(this);
				}
			}
		}
	}

	return bIsEditable;
}

```


ï»¿# Private

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¯¥UMaterialExpressionä¸ºç§æœ‰èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpressionå­ç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ‡è¯†è¯¥UMaterialExpressionä¸ºç§æœ‰èŠ‚ç‚¹ï¼Œå½“å‰åœ¨æè´¨è“å›¾å³é”®èœå•ä¸­éšè—ã€‚

åœ¨MaterialXæ¨¡å—ä¸­ä½¿ç”¨ï¼Œç›®å‰æ˜¯æŠŠé‡Œé¢çš„Expressionæš‚æ—¶å…ˆéƒ½éšè—èµ·æ¥ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS()
class UMyMaterialExpression_NotPrivate : public UMaterialExpression
{}ï¼›

UCLASS(meta=(Private))
class UMyMaterialExpression_Private : public UMaterialExpression
{}ï¼›
```

## æµ‹è¯•æ•ˆæœï¼š

æè´¨è“å›¾é‡Œåªèƒ½è°ƒç”¨UMyMaterialExpression_NotPrivate ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Material\Private\Untitled.png)

## åŸç†ï¼š

åœ¨éå†æ‰€æœ‰å¯ç”¨FMaterialExpressionçš„æ—¶å€™ï¼Œå¦‚æœæœ‰Privateåˆ™ç•¥è¿‡ã€‚

```cpp
static TAutoConsoleVariable<int32> CVarMaterialEnableNewHLSLGenerator(
	TEXT("r.MaterialEnableNewHLSLGenerator"),
	0,
	TEXT("Enables the new (WIP) material HLSL generator.\n")
	TEXT("0 - Don't allow\n")
	TEXT("1 - Allow if enabled by material\n")
	TEXT("2 - Force all materials to use new generator\n"),
	ECVF_RenderThreadSafe | ECVF_ReadOnly);

void MaterialExpressionClasses::InitMaterialExpressionClasses()
{
		static const auto CVarMaterialEnableNewHLSLGenerator = IConsoleManager::Get().FindTConsoleVariableDataInt(TEXT("r.MaterialEnableNewHLSLGenerator"));
		const bool bEnableControlFlow = AllowMaterialControlFlow();
		const bool bEnableNewHLSLGenerator = CVarMaterialEnableNewHLSLGenerator->GetValueOnAnyThread() != 0;
	
		for( TObjectIterator<UClass> It ; It ; ++It )
		{
			if( Class->IsChildOf(UMaterialExpression::StaticClass()) )
			{
					// Hide node types related to control flow, unless it's enabled
					if (!bEnableControlFlow && Class->HasMetaData("MaterialControlFlow"))
					{
									continue;
					}
					
					if (!bEnableNewHLSLGenerator && Class->HasMetaData("MaterialNewHLSLGenerator"))
					{
									continue;
					}
					
					// Hide node types that are tagged private
					if(Class->HasMetaData(TEXT("Private")))
					{
									continue;
					}
				AllExpressionClasses.Add(MaterialExpression);
			}
		}
}
```


ï»¿# RequiredInput

- **åŠŸèƒ½æè¿°ï¼š** åœ¨UMaterialExpressionä¸­æŒ‡å®šFExpressionInputå±æ€§æ˜¯å¦è¦æ±‚è¾“å…¥ï¼Œå¼•è„šæ˜¾ç¤ºç™½è‰²æˆ–ç°è‰²ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpression::FExpressionInput
- **å…³è”é¡¹ï¼š** [OverridingInputProperty](OverridingInputProperty/OverridingInputProperty.md)

åœ¨UMaterialExpressionä¸­æŒ‡å®šFExpressionInputå±æ€§æ˜¯å¦è¦æ±‚è¾“å…¥ï¼Œå¼•è„šæ˜¾ç¤ºç™½è‰²æˆ–ç°è‰²ã€‚

ä¸€èˆ¬éƒ½é…åˆOverridingInputPropertyä½¿ç”¨ã€‚

ä»£ç å’Œæ•ˆæœå‚è§OverridingInputProperty

## åŸç†ï¼š

```cpp

bool UMaterialExpression::CanEditChange(const FProperty* InProperty) const
{
	bool bIsEditable = Super::CanEditChange(InProperty);
	if (bIsEditable && InProperty != nullptr)
	{
		// Automatically set property as non-editable if it has OverridingInputProperty metadata
		// pointing to an FExpressionInput property which is hooked up as an input.
		//
		// e.g. in the below snippet, meta=(OverridingInputProperty = "A") indicates that ConstA will
		// be overridden by an FExpressionInput property named 'A' if one is connected, and will thereby
		// be set as non-editable.
		//
		//	UPROPERTY(meta = (RequiredInput = "false", ToolTip = "Defaults to 'ConstA' if not specified"))
		//	FExpressionInput A;
		//
		//	UPROPERTY(EditAnywhere, Category = MaterialExpressionAdd, meta = (OverridingInputProperty = "A"))
		//	float ConstA;
		//

		static FName OverridingInputPropertyMetaData(TEXT("OverridingInputProperty"));

		if (InProperty->HasMetaData(OverridingInputPropertyMetaData))
		{
			const FString& OverridingPropertyName = InProperty->GetMetaData(OverridingInputPropertyMetaData);

			FStructProperty* StructProp = FindFProperty<FStructProperty>(GetClass(), *OverridingPropertyName);
			if (ensure(StructProp != nullptr))
			{
				static FName RequiredInputMetaData(TEXT("RequiredInput"));

				// Must be a single FExpressionInput member, not an array, and must be tagged with metadata RequiredInput="false"
				if (ensure(	StructProp->Struct->GetFName() == NAME_ExpressionInput &&
							StructProp->ArrayDim == 1 &&
							StructProp->HasMetaData(RequiredInputMetaData) &&
							!StructProp->GetBoolMetaData(RequiredInputMetaData)))
				{
					const FExpressionInput* Input = StructProp->ContainerPtrToValuePtr<FExpressionInput>(this);

					if (Input->Expression != nullptr && Input->GetTracedInput().Expression != nullptr)
					{
						bIsEditable = false;
					}
				}
			}
		}

		if (bIsEditable)
		{
			// If the property has EditCondition metadata, then whether it's editable depends on the other EditCondition property
			const FString EditConditionPropertyName = InProperty->GetMetaData(TEXT("EditCondition"));
			if (!EditConditionPropertyName.IsEmpty())
			{
				FBoolProperty* EditConditionProperty = FindFProperty<FBoolProperty>(GetClass(), *EditConditionPropertyName);
				{
					bIsEditable = *EditConditionProperty->ContainerPtrToValuePtr<bool>(this);
				}
			}
		}
	}

	return bIsEditable;
}

```


ï»¿# ShowAsInputPin

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—UMaterialExpressioné‡Œçš„ä¸€äº›åŸºç¡€ç±»å‹å±æ€§å˜æˆæè´¨èŠ‚ç‚¹ä¸Šçš„å¼•è„šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Material
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UMaterialExpressioné‡Œçš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿å¾—UMaterialExpressioné‡Œçš„ä¸€äº›åŸºç¡€ç±»å‹å±æ€§å˜æˆæè´¨èŠ‚ç‚¹ä¸Šçš„å¼•è„šã€‚

- æ‰€è°“åŸºç¡€ç±»å‹ï¼ŒæŒ‡çš„æ˜¯floatï¼ŒFVectorè¿™ç§å¸¸ç”¨çš„ç±»å‹ã€‚
- é»˜è®¤è¿™äº›åŸºç¡€ç±»å‹å±æ€§æ˜¯ä¸æ˜¾ç¤ºä¸ºå¼•è„šçš„ã€‚
- ShowAsInputPin å€¼æœ‰ä¸¤ä¸ªé€‰é¡¹ï¼ŒPrimaryå¯ä»¥ç›´æ¥æ˜¾ç¤ºå‡ºæ¥ï¼ŒAdvancedéœ€è¦å±•å¼€ç®­å¤´åæ˜¾ç¤ºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinTest)
	float MyFloat;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinTest, meta = (ShowAsInputPin = "Primary"))
	float MyFloat_Primary;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = PinTest, meta = (ShowAsInputPin = "Advanced"))
	float MyFloat_Advanced;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyFloatæ²¡æœ‰æ˜¾ç¤ºåœ¨èŠ‚ç‚¹ä¸Šã€‚

MyFloat_Primaryæ˜¾ç¤ºåœ¨èŠ‚ç‚¹ä¸Šã€‚

MyFloat_Advancedéœ€è¦å±•å¼€ç®­å¤´åæ‰æ˜¾ç¤ºå‡ºæ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Material\ShowAsInputPin\Untitled.png)

## åŸç†ï¼š

éå†UMaterialExpressioné‡Œçš„å±æ€§ï¼Œæ ¹æ®å«æœ‰ShowAsInputPin çš„ç±»å‹æ¥ç”Ÿæˆå¼•è„šã€‚

```cpp
TArray<FProperty*> UMaterialExpression::GetPropertyInputs() const
{
	TArray<FProperty*> PropertyInputs;

	static FName OverridingInputPropertyMetaData(TEXT("OverridingInputProperty"));
	static FName ShowAsInputPinMetaData(TEXT("ShowAsInputPin"));
	for (TFieldIterator<FProperty> InputIt(GetClass(), EFieldIteratorFlags::IncludeSuper, EFieldIteratorFlags::ExcludeDeprecated); InputIt; ++InputIt)
	{
		bool bCreateInput = false;
		FProperty* Property = *InputIt;
		// Don't create an expression input if the property is already associated with one explicitly declared
		bool bOverridingInputProperty = Property->HasMetaData(OverridingInputPropertyMetaData);
		// It needs to have the 'EditAnywhere' specifier
		const bool bEditAnywhere = Property->HasAnyPropertyFlags(CPF_Edit);
		// It needs to be marked with a valid pin category meta data
		const FString ShowAsInputPin = Property->GetMetaData(ShowAsInputPinMetaData);
		const bool bShowAsInputPin = ShowAsInputPin == TEXT("Primary") || ShowAsInputPin == TEXT("Advanced");

		if (!bOverridingInputProperty && bEditAnywhere && bShowAsInputPin)
		{
			// Check if the property type fits within the allowed widget types
			FFieldClass* PropertyClass = Property->GetClass();
			if (PropertyClass == FFloatProperty::StaticClass()
				|| PropertyClass == FDoubleProperty::StaticClass()
				|| PropertyClass == FIntProperty::StaticClass()
				|| PropertyClass == FUInt32Property::StaticClass()
				|| PropertyClass == FByteProperty::StaticClass()
				|| PropertyClass == FBoolProperty::StaticClass()
				)
			{
				bCreateInput = true;
			}
			else if (PropertyClass == FStructProperty::StaticClass())
			{
				FStructProperty* StructProperty = CastField<FStructProperty>(Property);
				UScriptStruct* Struct = StructProperty->Struct;
				if (Struct == TBaseStructure<FLinearColor>::Get()
					|| Struct == TBaseStructure<FVector4>::Get()
					|| Struct == TVariantStructure<FVector4d>::Get()
					|| Struct == TBaseStructure<FVector>::Get()
					|| Struct == TVariantStructure<FVector3f>::Get()
					|| Struct == TBaseStructure<FVector2D>::Get()
					)
				{
					bCreateInput = true;
				}
			}
		}
		if (bCreateInput)
		{
			PropertyInputs.Add(Property);
		}
	}

	return PropertyInputs;
}
```


ï»¿# NiagaraClearEachFrame

- **åŠŸèƒ½æè¿°ï¼š** ScriptStruct /Script/Niagara.NiagaraSpawnInfo
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Niagara
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šæŸç»“æ„çš„æ•°æ®åœ¨Niagaraåç»­æ¯ä¸€å¸§ä¸åº”è¯¥è¯»å–ï¼Œåªä½œä¸ºåˆå§‹æ•°æ®ã€‚

å½“å‰åªç”¨åœ¨FNiagaraSpawnInfoä¸Šï¼Œä»…ä»…å†…éƒ¨ç”¨ã€‚

## æºç ä¾‹å­ï¼š

```cpp
/** Data controlling the spawning of particles */
USTRUCT(BlueprintType, meta = (DisplayName = "Spawn Info", NiagaraClearEachFrame = "true"))
struct FNiagaraSpawnInfo
{
}
```

## åŸç†ï¼š

```cpp
// If the NiagaraClearEachFrame value is set on the data set, we don't bother reading it in each frame as we know that it is is invalid. However,
// this is only used for the base data set. Other reads are potentially from events and are therefore perfectly valid.
if (DataSetIndex == 0 && Var.GetType().GetScriptStruct() != nullptr && Var.GetType().GetScriptStruct()->GetMetaData(TEXT("NiagaraClearEachFrame")).Equals(TEXT("true"), ESearchCase::IgnoreCase))
{
	Fmt = VariableName + TEXT("{0} = {4};\n");
}
```


ï»¿# NiagaraInternalType

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç»“æ„çš„ç±»å‹ä¸ºNiagaraçš„å†…éƒ¨ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Niagara
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥ç»“æ„çš„ç±»å‹ä¸ºNiagaraçš„å†…éƒ¨ç±»å‹ã€‚

ç”¨æ¥å’Œç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹åŒºåˆ†ã€‚ç”¨æˆ·ä¸éœ€è¦è‡ªå·±ä½¿ç”¨è¯¥å…ƒæ•°æ®ã€‚

## æºç ä¾‹å­ï¼š

```cpp
USTRUCT(meta = (DisplayName = "Half", NiagaraInternalType = "true"))
struct FNiagaraHalf
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 Value = 0;
};

USTRUCT(meta = (DisplayName = "Half Vector2", NiagaraInternalType = "true"))
struct FNiagaraHalfVector2
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 x = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 y = 0;
};

USTRUCT(meta = (DisplayName = "Half Vector3", NiagaraInternalType = "true"))
struct FNiagaraHalfVector3
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 x = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 y = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 z = 0;
};

USTRUCT(meta = (DisplayName = "Half Vector4", NiagaraInternalType = "true"))
struct FNiagaraHalfVector4
{
	GENERATED_USTRUCT_BODY()

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 x = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 y = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 z = 0;

	UPROPERTY(EditAnywhere, Category = Parameters)
	uint16 w = 0;
};

```

## åŸç†ï¼š

```cpp
#if WITH_EDITORONLY_DATA
bool FNiagaraTypeDefinition::IsInternalType() const
{
	if (const UScriptStruct* ScriptStruct = GetScriptStruct())
	{
		return ScriptStruct->GetBoolMetaData(TEXT("NiagaraInternalType"));
	}

	return false;
}
#endif
```


ï»¿# AllowPreserveRatio

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸ºFVectorå±æ€§æ·»åŠ ä¸€ä¸ªæ¯”ç‡é”ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FVector
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸ºFVectorå±æ€§æ·»åŠ ä¸€ä¸ªæ¯”ç‡é”ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, Category = VectorTest)
	FVector MyVector_Default;

	UPROPERTY(EditAnywhere, Category = VectorTest, meta = (AllowPreserveRatio))
	FVector MyVector_AllowPreserveRatio;

	UPROPERTY(EditAnywhere, Category = VectorTest, meta = (ShowNormalize))
	FVector MyVector_ShowNormalize;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyVector_AllowPreserveRatioçš„å€¼åœ¨é”ä¸Šä¹‹åå¯ä»¥å½¢æˆå›ºå®šçš„æ¯”ç‡ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\AllowPreserveRatio\AllowPreserveRatio.gif](AllowPreserveRatio.gif)

## åŸç†ï¼š

å…¶å®å°±æ˜¯UIå®šåˆ¶åŒ–çš„æ—¶å€™æ£€æµ‹å‡ºAllowPreserveRatioå°±åˆ›å»ºå•ç‹¬çš„UIã€‚

```cpp
void FMathStructCustomization::MakeHeaderRow(TSharedRef<class IPropertyHandle>& StructPropertyHandle, FDetailWidgetRow& Row)
{
		if (StructPropertyHandle->HasMetaData("AllowPreserveRatio"))
		{
			if (!GConfig->GetBool(TEXT("SelectionDetails"), *(StructPropertyHandle->GetProperty()->GetName() + TEXT("_PreserveScaleRatio")), bPreserveScaleRatio, GEditorPerProjectIni))
			{
				bPreserveScaleRatio = true;
			}
		
			HorizontalBox->AddSlot()
			.AutoWidth()
			.MaxWidth(18.0f)
			.VAlign(VAlign_Center)
			[
				// Add a checkbox to toggle between preserving the ratio of x,y,z components of scale when a value is entered
				SNew(SCheckBox)
				.IsChecked(this, &FMathStructCustomization::IsPreserveScaleRatioChecked)
				.OnCheckStateChanged(this, &FMathStructCustomization::OnPreserveScaleRatioToggled, StructWeakHandlePtr)
				.Style(FAppStyle::Get(), "TransparentCheckBox")
				.ToolTipText(LOCTEXT("PreserveScaleToolTip", "When locked, scales uniformly based on the current xyz scale values so the object maintains its shape in each direction when scaled"))
				[
					SNew(SImage)
					.Image(this, &FMathStructCustomization::GetPreserveScaleRatioImage)
					.ColorAndOpacity(FSlateColor::UseForeground())
				]
			];
		}

}
```


ï»¿# ArrayClamp

- **åŠŸèƒ½æè¿°ï¼š** é™å®šæ•´æ•°å±æ€§çš„å€¼å¿…é¡»åœ¨æŒ‡å®šæ•°ç»„çš„åˆæ³•ä¸‹æ ‡èŒƒå›´å†…ï¼Œ[0,ArrayClamp.Size()-1]
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** int32
- **é™åˆ¶ç±»å‹ï¼š** int32
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

é™å®šæ•´æ•°å±æ€§çš„å€¼å¿…é¡»åœ¨æŒ‡å®šæ•°ç»„çš„åˆæ³•ä¸‹æ ‡èŒƒå›´å†…ï¼Œ[0,ArrayClamp.Size()-1]

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ArrayClampTest)
	int32 MyInt_NoArrayClamp = 0;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ArrayClampTest, meta = (ArrayClamp = "MyIntArray"))
	int32 MyInt_HasArrayClamp = 0;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ArrayClampTest)
	TArray<int32> MyIntArray;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§æ‹¥æœ‰ArrayClampçš„æ•´æ•°å€¼è¢«é™åˆ¶åœ¨æ•°ç»„çš„ä¸‹æ ‡ä¸­ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\ArrayClamp\ArrayClamp.gif](ArrayClamp.gif)

## åŸç†ï¼š

æ ¹æ®æŒ‡å®šçš„æ•°ç»„åç§°åœ¨æœ¬ç±»é‡Œå¯»æ‰¾åˆ°Arrayå±æ€§ï¼Œç„¶åæŠŠæœ¬æ•´æ•°å±æ€§çš„å€¼Clampåœ¨è¯¥æ•°ç»„çš„ä¸‹æ ‡èŒƒå›´å†…ã€‚

```cpp
template <typename Type>
static Type ClampIntegerValueFromMetaData(Type InValue, FPropertyHandleBase& InPropertyHandle, FPropertyNode& InPropertyNode)
{
	Type RetVal = ClampValueFromMetaData<Type>(InValue, InPropertyHandle);

	//enforce array bounds
	const FString& ArrayClampString = InPropertyHandle.GetMetaData(TEXT("ArrayClamp"));
	if (ArrayClampString.Len())
	{
		FObjectPropertyNode* ObjectPropertyNode = InPropertyNode.FindObjectItemParent();
		if (ObjectPropertyNode && ObjectPropertyNode->GetNumObjects() == 1)
		{
			Type LastValidIndex = static_cast<Type>(GetArrayPropertyLastValidIndex(ObjectPropertyNode, ArrayClampString));
			RetVal = FMath::Clamp<Type>(RetVal, 0, LastValidIndex);
		}
		else
		{
			UE_LOG(LogPropertyNode, Warning, TEXT("Array Clamping isn't supported in multi-select (Param Name: %s)"), *InPropertyHandle.GetProperty()->GetName());
		}
	}

	return RetVal;
}
```


ï»¿# ClampMax

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†å®é™…æ¥å—çš„æœ€å¤§å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [UIMin](UIMin/UIMin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# ClampMin

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†å®é™…æ¥å—çš„æœ€å°å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [UIMin](UIMin/UIMin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# ColorGradingMode

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—ä¸€ä¸ªFVector4å±æ€§æˆä¸ºé¢œè‰²æ˜¾ç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FVector4
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿å¾—ä¸€ä¸ªFVector4å±æ€§æˆä¸ºé¢œè‰²æ˜¾ç¤ºã€‚å› ä¸ºFVector4å’ŒRGBAæ­£å¥½å¯¹åº”ã€‚

å¿…é¡»é…åˆUIMinï¼ŒUIMaxæ‰èƒ½ä½¿ç”¨ï¼Œå¦åˆ™ä¼šå´©æºƒï¼Œå› ä¸ºFColorGradingVectorCustomizationé‡Œç›´æ¥å¯¹UIMinValueç›´æ¥å–å€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = ())
	FVector4 MyVector4_NotColor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = (UIMin = "0", UIMax = "1",ColorGradingMode = "saturation"))
	FVector4 MyVector4_Saturation;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = (UIMin = "0", UIMax = "1",ColorGradingMode = "contrast"))
	FVector4 MyVector4_Contrast;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = (UIMin = "0", UIMax = "1",ColorGradingMode = "gamma"))
	FVector4 MyVector4_Gamma;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = (UIMin = "0", UIMax = "1",ColorGradingMode = "gain"))
	FVector4 MyVector4_Gain;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = ColorGradingModeTest, meta = (UIMin = "0", UIMax = "1",ColorGradingMode = "offset"))
	FVector4 MyVector4_Offset;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°æ²¡æœ‰ColorGradingMode çš„ä¾ç„¶æ˜¯æ™®é€šçš„FVector4ï¼Œå¦åˆ™å°±ä¼šç”¨é¢œè‰²è½¬ç›˜æ¥æ˜¾ç¤ºç¼–è¾‘ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Numeric\ColorGradingMode\Untitled.png)

## åŸç†ï¼š

å¦‚æœæ˜¯FVector4å±æ€§ï¼Œå†åˆ¤æ–­å¦‚æœæœ‰ColorGradingModeï¼Œåˆ™åˆ›å»ºFColorGradingVectorCustomizationæ¥æŠŠFVectorå®šåˆ¶åŒ–ä¼šé¢œè‰²æ˜¾ç¤ºã€‚å†æ ¹æ®å­—ç¬¦ä¸²åˆ¤æ–­EColorGradingModesï¼Œæœ€ååˆ›å»ºç›¸åº”çš„å…·ä½“UIæ§ä»¶ã€‚

```cpp
void FVector4StructCustomization::CustomizeChildren(TSharedRef<IPropertyHandle> StructPropertyHandle, IDetailChildrenBuilder& StructBuilder, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	FProperty* Property = StructPropertyHandle->GetProperty();
	if (Property)
	{
		const FString& ColorGradingModeString = Property->GetMetaData(TEXT("ColorGradingMode"));
		if (!ColorGradingModeString.IsEmpty())
		{
			//Create our color grading customization shared pointer
			TSharedPtr<FColorGradingVectorCustomization> ColorGradingCustomization = GetOrCreateColorGradingVectorCustomization(StructPropertyHandle);

			//Customize the childrens
			ColorGradingVectorCustomization->CustomizeChildren(StructBuilder, StructCustomizationUtils);
			
			// We handle the customize Children so just return here
			return;
		}
	}

	//Use the base class customize children
	FMathStructCustomization::CustomizeChildren(StructPropertyHandle, StructBuilder, StructCustomizationUtils);
}

EColorGradingModes FColorGradingVectorCustomizationBase::GetColorGradingMode() const
{
	EColorGradingModes ColorGradingMode = EColorGradingModes::Invalid;

	if (ColorGradingPropertyHandle.IsValid())
	{
		//Query all meta data we need
		FProperty* Property = ColorGradingPropertyHandle.Pin()->GetProperty();
		const FString& ColorGradingModeString = Property->GetMetaData(TEXT("ColorGradingMode"));

		if (ColorGradingModeString.Len() > 0)
		{
			if (ColorGradingModeString.Compare(TEXT("saturation")) == 0)
			{
				ColorGradingMode = EColorGradingModes::Saturation;
			}
			else if (ColorGradingModeString.Compare(TEXT("contrast")) == 0)
			{
				ColorGradingMode = EColorGradingModes::Contrast;
			}
			else if (ColorGradingModeString.Compare(TEXT("gamma")) == 0)
			{
				ColorGradingMode = EColorGradingModes::Gamma;
			}
			else if (ColorGradingModeString.Compare(TEXT("gain")) == 0)
			{
				ColorGradingMode = EColorGradingModes::Gain;
			}
			else if (ColorGradingModeString.Compare(TEXT("offset")) == 0)
			{
				ColorGradingMode = EColorGradingModes::Offset;
			}
		}
	}

	return ColorGradingMode;
}
```


ï»¿# CtrlMultiplier

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†åœ¨CtrlæŒ‰ä¸‹æ—¶é¼ æ ‡è½®æ»šåŠ¨å’Œé¼ æ ‡æ‹–åŠ¨æ”¹å˜å€¼çš„å€ç‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** æ•°æ®ç»“æ„ï¼šFVectorï¼ŒFRotatorï¼ŒFColor
- **å…³è”é¡¹ï¼š** [ShiftMultiplier](../ShiftMultiplier.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šæ•°å­—è¾“å…¥æ¡†åœ¨CtrlæŒ‰ä¸‹æ—¶é¼ æ ‡è½®æ»šåŠ¨å’Œé¼ æ ‡æ‹–åŠ¨æ”¹å˜å€¼çš„å€ç‡ã€‚

- CtrlMultiplierçš„é»˜è®¤å€¼æ˜¯0.1fï¼Œä¸€èˆ¬ä½œä¸ºä¸€ç§ç²¾è°ƒæ¨¡å¼ã€‚
- ç›´æ¥è®¾ç½®åˆ°floatå±æ€§ä¸Šå¹¶æ— æ•ˆæœã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå±æ€§ä¸Šçš„CtrlMultiplierå¹¶ä¸ä¼šè®¾ç½®åˆ°SNumericEntryBoxå’ŒSSpinBoxä¸Šï¼Œå› ä¸ºè¿™äºŒè€…å¹¶ä¸ä¼šç›´æ¥ä»propertyä¸Šæå–metaæ¥è®¾ç½®åˆ°å…¶æœ¬èº«çš„Multiplierå€¼ä¸Šã€‚
- åœ¨æºç é‡Œå‘ç°FMathStructCustomizationé‡Œä¼šæå–CtrlMultiplierå’ŒShiftMultiplierçš„å€¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ä¸€äº›æ•°å­¦ç»“æ„ä¸Šè®¾ç½®ï¼Œå¦‚FVectorï¼ŒFRotatorï¼ŒFColor
- å¦‚æœè‡ªå·±å®šä¹‰Customizationå’Œåˆ›å»ºSSpinBoxï¼Œåˆ™å¯ä»¥è‡ªå·±æå–Multiplierçš„å€¼è‡ªå·±è®¾ç½®åˆ°æ§ä»¶é‡Œå»ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultiplierTest, meta = (CtrlMultiplier = "5"))
	float MyFloat_HasCtrlMultiplier = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultiplierTest, meta = (ShiftMultiplier = "100"))
	float MyFloat_HasShiftMultiplier = 100;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultiplierTest)
	FVector MyVector_NoMultiplier;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultiplierTest, meta = (CtrlMultiplier = "5"))
	FVector MyVector_HasCtrlMultiplier;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultiplierTest, meta = (ShiftMultiplier = "100"))
	FVector MyVector_HasShiftMultiplier;
```

## æµ‹è¯•æ•ˆæœï¼š

- å‘ç°æ™®é€šfloatå±æ€§æµ‹è¯•å¹¶æ— æ•ˆæœï¼ŒæŒ‰ä¸‹Ctrlå’ŒShiftä¾ç„¶æ˜¯é»˜è®¤çš„æ”¹å˜å€¼0.1å’Œ10.f
- æ™®é€šçš„é»˜è®¤FVectorï¼ŒæŒ‰ä¸‹Ctrlå’ŒShiftä¹Ÿæ˜¯é»˜è®¤çš„æ”¹å˜å€¼0.1å’Œ10.f
- MyVector_HasCtrlMultiplierï¼Œå‘ç°æŒ‰ä¸‹Ctrlï¼Œä¸€ä¸‹å­æ”¹å˜å¹…åº¦æ˜¯5
- MyVector_HasShiftMultiplierï¼Œå‘ç°æŒ‰ä¸‹Shiftï¼Œä¸€ä¸‹å­æ”¹å˜å¹…åº¦æ˜¯100
- å½“ç„¶ç”¨é¼ æ ‡æ‹–åŠ¨ä¹Ÿæ˜¯ä¸€æ ·çš„æ•ˆæœï¼Œåªæ˜¯é‚£æ ·æ”¹å˜å¤ªè¿‡å‰§çƒˆï¼Œæ¼”ç¤ºæ•ˆæœä¸æ˜æ˜¾

![Multipiler.gif](/Multipiler.gif)

## åŸç†ï¼š

```cpp
SNumericEntryBoxçš„æ„é€ å‡½æ•°é‡Œï¼š
		, _ShiftMultiplier(10.f)
		, _CtrlMultiplier(0.1f)

void FMathStructCustomization::MakeHeaderRow(TSharedRef<class IPropertyHandle>& StructPropertyHandle, FDetailWidgetRow& Row)
{
	for (int32 ChildIndex = 0; ChildIndex < SortedChildHandles.Num(); ++ChildIndex)
	{
		TSharedRef<IPropertyHandle> ChildHandle = SortedChildHandles[ChildIndex];
	
		// Propagate metadata to child properties so that it's reflected in the nested, individual spin boxes
		ChildHandle->SetInstanceMetaData(TEXT("UIMin"), StructPropertyHandle->GetMetaData(TEXT("UIMin")));
		ChildHandle->SetInstanceMetaData(TEXT("UIMax"), StructPropertyHandle->GetMetaData(TEXT("UIMax")));
		ChildHandle->SetInstanceMetaData(TEXT("SliderExponent"), StructPropertyHandle->GetMetaData(TEXT("SliderExponent")));
		ChildHandle->SetInstanceMetaData(TEXT("Delta"), StructPropertyHandle->GetMetaData(TEXT("Delta")));
		ChildHandle->SetInstanceMetaData(TEXT("LinearDeltaSensitivity"), StructPropertyHandle->GetMetaData(TEXT("LinearDeltaSensitivity")));
		ChildHandle->SetInstanceMetaData(TEXT("ShiftMultiplier"), StructPropertyHandle->GetMetaData(TEXT("ShiftMultiplier")));
		ChildHandle->SetInstanceMetaData(TEXT("CtrlMultiplier"), StructPropertyHandle->GetMetaData(TEXT("CtrlMultiplier")));
		ChildHandle->SetInstanceMetaData(TEXT("SupportDynamicSliderMaxValue"), StructPropertyHandle->GetMetaData(TEXT("SupportDynamicSliderMaxValue")));
		ChildHandle->SetInstanceMetaData(TEXT("SupportDynamicSliderMinValue"), StructPropertyHandle->GetMetaData(TEXT("SupportDynamicSliderMinValue")));
		ChildHandle->SetInstanceMetaData(TEXT("ClampMin"), StructPropertyHandle->GetMetaData(TEXT("ClampMin")));
		ChildHandle->SetInstanceMetaData(TEXT("ClampMax"), StructPropertyHandle->GetMetaData(TEXT("ClampMax")));
		}
}
```


ï»¿# Delta

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šæ•°å­—è¾“å…¥æ¡†å€¼æ”¹å˜çš„å¹…åº¦ä¸ºDeltaçš„å€æ•°
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [LinearDeltaSensitivity](../LinearDeltaSensitivity.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è®¾å®šæ•°å­—è¾“å…¥æ¡†å€¼æ”¹å˜çš„å¹…åº¦ä¸ºDeltaçš„å€æ•°ã€‚

## æ³¨æ„çš„äº‹é¡¹æ˜¯ï¼š

1. åœ¨å…¨å±€ä½¿å¾—å˜åŒ–å€¼æˆä¸ºDeltaçš„å€æ•°
2. Deltaé»˜è®¤å€¼æ˜¯0ï¼Œè¿™ä¸ªæ—¶å€™ä»£è¡¨æ²¡æœ‰è®¾ç½®ï¼Œæ•°å­—ä¼šæŒ‡æ•°æ”¹å˜ã€‚
3. æ³¨æ„å’ŒWheelStepçš„åŒºåˆ«æ˜¯ï¼ŒDeltaåœ¨é¼ æ ‡å·¦å³æ‹–åŠ¨å’ŒæŒ‰ä¸‹é”®ç›˜æ–¹å‘é”®çš„æ—¶å€™ç”Ÿæ•ˆï¼ŒWheelStepæ˜¯åªåœ¨é¼ æ ‡æ»šè½®å˜åŒ–çš„æ—¶å€™ç”Ÿæ•ˆã€‚äºŒè€…è™½ç„¶éƒ½æ˜¯ç”¨æ¥æ§åˆ¶å˜åŒ–å¹…åº¦ï¼Œä½†ä½œç”¨èŒƒå›´ä¸åŒã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest)
	float MyFloat_DefaultDelta = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (Delta = 10))
	float MyFloat_Delta10 = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (UIMin = "0", UIMax = "1000", Delta = 10))
	float MyFloat_Delta10_UIMinMax = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (Delta = 10, LinearDeltaSensitivity = 50))
	float MyFloat_Delta10_LinearDeltaSensitivity50 = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (UIMin = "0", UIMax = "1000", Delta = 10, LinearDeltaSensitivity = 50))
	float MyFloat_Delta10_LinearDeltaSensitivity50_UIMinMax = 100;
```

## æµ‹è¯•æ•ˆæœï¼š

- MyFloat_DefaultDelta ï¼Œé»˜è®¤æƒ…å†µä¸‹é¼ æ ‡å¾€å³æ‹–åŠ¨å˜åŒ–å¾ˆå‰§çƒˆï¼Œå˜åŒ–å‘ˆæŒ‡æ•°ä¸Šå‡ã€‚
- MyFloat_Delta10ï¼Œé¼ æ ‡å¾€å³æ‹–åŠ¨å˜åŒ–ä¹Ÿå¾ˆå‰§çƒˆï¼ˆæœ€ç»ˆåˆ°è¾¾çš„å€¼ä¹Ÿå¾ˆå·¨å¤§ï¼‰ï¼Œä½†æ˜¯å˜åŒ–å§‹ç»ˆä»¥Deltaä¸ºæ­¥å¹…ã€‚
- MyFloat_Delta10_UIMinMax ï¼Œé™å®šäº†UIMinMaxï¼Œå¯¼è‡´æœ€å¤§å€¼å—é™ï¼Œä½†æ˜¯å˜åŒ–å…¶å®æ˜¯æŒ‰ç…§æ¯”ä¾‹å€¼çº¿æ€§ï¼ˆSliderExponenté»˜è®¤æ˜¯1æ²¡æœ‰æ”¹å˜ï¼‰ã€‚
- MyFloat_Delta10_LinearDeltaSensitivity50 ï¼Œåœ¨æ²¡æœ‰UIMinMaxçš„æƒ…å†µä¸‹ï¼Œä¸”åŒæ—¶è®¾ç½®äº†LinearDeltaSensitivityï¼Œä¼šå¯¼è‡´é¼ æ ‡å¾€å³æ‹–åŠ¨çš„æ•´ä¸ªè¿‡ç¨‹ä¸­å˜åŒ–å€¼å§‹ç»ˆæ˜¯çº¿æ€§ã€‚LinearDeltaSensitivityè¶Šå¤§è¶Šä¸æ•æ„Ÿã€‚å› æ­¤ä¸€æ¬¡ä¸€æ¬¡ç¼“æ…¢çš„æ”¹å˜10
- MyFloat_Delta10_LinearDeltaSensitivity50_UIMinMax ï¼Œå¦‚æœä¸Šé¢ä¸€ä¸ªå†åŠ ä¸ŠUIMinMaxï¼Œåˆ™å‘ç°åˆå¤±å»äº†LinearDeltaSensitivityçš„æ•ˆæœã€‚å› ä¸ºLinearDeltaSensitivityä¸èƒ½åœ¨æœ‰æ»šåŠ¨æ¡çš„æƒ…å†µä¸‹ç”Ÿæ•ˆã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\Delta\Delta.gif](Delta.gif)

## åŸç†ï¼š

- åœ¨æ–¹å‘é”®ä¸Šä¸‹å·¦å³æŒ‰é”®çš„æ—¶å€™æ¯æ¬¡å˜åŒ–æ­£è´ŸDeltaï¼Œä½†æ˜¯OnKeyDownæ²¡æœ‰ç›´æ¥ç»‘å®šï¼Œæ‰€ä»¥é»˜è®¤æƒ…å†µä¸‹æŒ‰é”®åªä¼šè§¦å‘ç„¦ç‚¹çš„è½¬ç§»ã€‚
- åŸºç¡€stepæ˜¯0.1æˆ–1ï¼Œå¦‚æœæ²¡å—åˆ°CtrlMultiplierå’ŒShiftMultiplierçš„å½±å“ã€‚
- é»˜è®¤æƒ…å†µä¸‹ï¼Œé¼ æ ‡å·¦å³ç§»åŠ¨æ”¹å˜çš„å·®é‡ä¸­çš„æŒ‡æ•°éƒ¨åˆ†æ˜¯FMath::Pow((double)CurrentValue, (double)SliderExponent.Get())ï¼ŒSliderExponenté»˜è®¤æ˜¯1ï¼Œä¹Ÿå°±æ˜¯è¶Šå¾€å·¦å³ä¸¤ç«¯æ”¹å˜çš„å¹…åº¦è¶Šå¤§ã€‚
- åœ¨åŒæ—¶è®¾ç½®LinearDeltaSensitivityå’ŒDeltaçš„æƒ…å†µä¸‹ï¼Œé¼ æ ‡å·¦å³ç§»åŠ¨æ”¹å˜çš„å·®é‡ä¸­çš„æŒ‡æ•°éƒ¨åˆ†æ˜¯FMath::Pow((double)Delta.Get(), (double)SliderExponent.Get())ï¼Œå³æ”¹å˜çš„å·®é‡åœ¨å·¦å³æ•´ä¸ªæ•°è½´ä¸Šæ˜¯çº¿æ€§ä¸€è‡´çš„ã€‚
- åœ¨æœ€åæäº¤å€¼çš„æ—¶å€™ï¼Œæ”¹å˜çš„å·®é‡å€¼ä¼šè¢«è§„èŒƒåˆ°Deltaçš„å€æ•°ä¸Šæ¥ã€‚

```cpp
, _Delta(0)
virtual FReply SSpinBox<NumericType>::OnMouseMove(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent) override
{
		if (bUnlimitedSpinRange)
		{
				// If this control has a specified delta and sensitivity then we use that instead of the current value for determining how much to change.
				const double Sign = (MouseEvent.GetCursorDelta().X > 0) ? 1.0 : -1.0;
				
				if (LinearDeltaSensitivity.IsSet() && LinearDeltaSensitivity.Get() != 0 && Delta.IsSet() && Delta.Get() > 0)
				{
								const double MouseDelta = FMath::Abs(MouseEvent.GetCursorDelta().X / (float)LinearDeltaSensitivity.Get());
								NewValue = InternalValue + (Sign * MouseDelta * FMath::Pow((double)Delta.Get(), (double)SliderExponent.Get())) * Step;
				}
				else
				{
								const double MouseDelta = FMath::Abs(MouseEvent.GetCursorDelta().X / SliderWidthInSlateUnits);
								const double CurrentValue = FMath::Clamp<double>(FMath::Abs(InternalValue), 1.0, (double)std::numeric_limits<NumericType>::max());
								NewValue = InternalValue + (Sign * MouseDelta * FMath::Pow((double)CurrentValue, (double)SliderExponent.Get())) * Step;
				}
		}
}

virtual FReply SSpinBox<NumericType>::OnKeyDown(const FGeometry& MyGeometry, const FKeyEvent& InKeyEvent) override
{
		else if (Key == EKeys::Up || Key == EKeys::Right)
		{
			const NumericType LocalValueAttribute = ValueAttribute.Get();
			const NumericType LocalDelta = Delta.Get();
			InternalValue = (double)LocalValueAttribute;
			CommitValue(LocalValueAttribute + LocalDelta, InternalValue + (double)LocalDelta, CommittedViaArrowKey, ETextCommit::OnEnter);
			ExitTextMode();
			return FReply::Handled();
		}
		else if (Key == EKeys::Down || Key == EKeys::Left)
		{
			const NumericType LocalValueAttribute = ValueAttribute.Get();
			const NumericType LocalDelta = Delta.Get();
			InternalValue = (double)LocalValueAttribute;
			CommitValue(LocalValueAttribute - LocalDelta, InternalValue + (double)LocalDelta, CommittedViaArrowKey, ETextCommit::OnEnter);
			ExitTextMode();
			return FReply::Handled();
		}
}

void SSpinBox<NumericType>::CommitValue(NumericType NewValue, double NewSpinValue, ECommitMethod CommitMethod, ETextCommit::Type OriginalCommitInfo)
{
	// If needed, round this value to the delta. Internally the value is not held to the Delta but externally it appears to be.
	if (CommitMethod == CommittedViaSpin || CommitMethod == CommittedViaArrowKey || bAlwaysUsesDeltaSnap)
	{
		NumericType CurrentDelta = Delta.Get();
		if (CurrentDelta != NumericType())
		{
			NewValue = FMath::GridSnap<NumericType>(NewValue, CurrentDelta); // snap numeric point value to nearest Delta
		}
	}

}

```


ï»¿# ForceUnits

- **åŠŸèƒ½æè¿°ï¼š** å›ºå®šè®¾å®šå±æ€§å€¼çš„å•ä½ä¿æŒä¸å˜ï¼Œä¸æ ¹æ®æ•°å€¼åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºå•ä½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [Units](Units/Units.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# HideAlphaChannel

- **åŠŸèƒ½æè¿°ï¼š** ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™éšè—Alphaé€šé“ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FColor , FLinearColor 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™éšè—Alphaé€šé“ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, Category = AlphaTest)
	FColor MyColor;

	UPROPERTY(EditAnywhere, Category = AlphaTest, meta = (HideAlphaChannel))
	FColor MyColor_HideAlphaChannel;

	UPROPERTY(EditAnywhere, Category = AlphaTest)
	FLinearColor MyLinearColor;

	UPROPERTY(EditAnywhere, Category = AlphaTest, meta = (HideAlphaChannel))
	FLinearColor MyLinearColor_HideAlphaChannel;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§å¸¦æœ‰HideAlphaChannelçš„å±æ€§å°±æ²¡æœ‰äº†Alphaé€šé“ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Numeric\HideAlphaChannel\Untitled.png)

## åŸç†ï¼š

```cpp
void FColorStructCustomization::CustomizeHeader(TSharedRef<class IPropertyHandle> InStructPropertyHandle, class FDetailWidgetRow& InHeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	bIgnoreAlpha = TypeSupportsAlpha() == false || StructPropertyHandle->GetProperty()->HasMetaData(TEXT("HideAlphaChannel"));
}

.AlphaDisplayMode(bIgnoreAlpha ? EColorBlockAlphaDisplayMode::Ignore : EColorBlockAlphaDisplayMode::Separate)

```


ï»¿# InlineColorPicker

- **åŠŸèƒ½æè¿°ï¼š** ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™ç›´æ¥å†…è”ä¸€ä¸ªé¢œè‰²é€‰æ‹©å™¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FColor , FLinearColor 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™ç›´æ¥å†…è”ä¸€ä¸ªé¢œè‰²é€‰æ‹©å™¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, Category = ColorPicker, meta = (InlineColorPicker))
	FColor MyColor_InlineColorPicker;
	UPROPERTY(EditAnywhere, Category = ColorPicker, meta = (InlineColorPicker))
	FLinearColor MyLinearColor_InlineColorPicker;
```

## æµ‹è¯•ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Numeric\InlineColorPicker\Untitled.png)

## åŸç†ï¼š

æ ¹æ®ä¸åŒçš„æ ‡è®°åˆ›å»ºä¸åŒçš„çš„ColorWidget ã€‚

```cpp

void FColorStructCustomization::MakeHeaderRow(TSharedRef<class IPropertyHandle>& InStructPropertyHandle, FDetailWidgetRow& Row)
{
	if (InStructPropertyHandle->HasMetaData("InlineColorPicker"))
	{
		ColorWidget = CreateInlineColorPicker(StructWeakHandlePtr);
		ContentWidth = 384.0f;
	}
	else
	{
		ColorWidget = CreateColorWidget(StructWeakHandlePtr);
	}
}
```


ï»¿# LinearDeltaSensitivity

- **åŠŸèƒ½æè¿°ï¼š** åœ¨è®¾å®šDeltaåï¼Œè¿›ä¸€æ­¥è®¾å®šæ•°å­—è¾“å…¥æ¡†å˜æˆçº¿æ€§æ”¹å˜ä»¥åŠæ”¹å˜çš„æ•æ„Ÿåº¦ï¼ˆå€¼è¶Šå¤§è¶Šä¸æ•æ„Ÿï¼‰
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [Delta](Delta/Delta.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç”Ÿæ•ˆçš„æ¡ä»¶ï¼š

1. å…ˆè®¾ç½®Delta>0
2. ä¸è®¾ç½®UIMin, UIMax
3. è®¾å®šLinearDeltaSensitivity >0

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (UIMin = "0", UIMax = "1000", Delta = 10))
	float MyFloat_Delta10_UIMinMax = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (Delta = 10, LinearDeltaSensitivity = 50))
	float MyFloat_Delta10_LinearDeltaSensitivity50 = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DeltaTest, meta = (UIMin = "0", UIMax = "1000", Delta = 10, LinearDeltaSensitivity = 50))
	float MyFloat_Delta10_LinearDeltaSensitivity50_UIMinMax = 100;
```

## æµ‹è¯•æ•ˆæœï¼š

æ•ˆæœè§£æè¯·å‚è§ï¼šDeltaçš„è§£æ

![Delta.gif](D:\github\UnrealSpecifiers\Doc\Meta\Numeric\Delta\Delta.gif)

## åŸç†ï¼š

å¯è§åªæœ‰æ²¡æœ‰UIMinMaxä¸”å·²ç»è®¾ç½®Deltaåæ‰èƒ½èµ°è¿›çº¿æ€§æ”¹å˜çš„ä»£ç åˆ†æ”¯ã€‚

```cpp
, _Delta(0)
virtual FReply SSpinBox<NumericType>::OnMouseMove(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent) override
{
		if (bUnlimitedSpinRange)
		{
				// If this control has a specified delta and sensitivity then we use that instead of the current value for determining how much to change.
				const double Sign = (MouseEvent.GetCursorDelta().X > 0) ? 1.0 : -1.0;
				
				if (LinearDeltaSensitivity.IsSet() && LinearDeltaSensitivity.Get() != 0 && Delta.IsSet() && Delta.Get() > 0)
				{
								const double MouseDelta = FMath::Abs(MouseEvent.GetCursorDelta().X / (float)LinearDeltaSensitivity.Get());
								NewValue = InternalValue + (Sign * MouseDelta * FMath::Pow((double)Delta.Get(), (double)SliderExponent.Get())) * Step;
				}
				else
				{
								const double MouseDelta = FMath::Abs(MouseEvent.GetCursorDelta().X / SliderWidthInSlateUnits);
								const double CurrentValue = FMath::Clamp<double>(FMath::Abs(InternalValue), 1.0, (double)std::numeric_limits<NumericType>::max());
								NewValue = InternalValue + (Sign * MouseDelta * FMath::Pow((double)CurrentValue, (double)SliderExponent.Get())) * Step;
				}
		}
}

```


ï»¿# Multiple

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—çš„å€¼å¿…é¡»æ˜¯Mutlipleæä¾›çš„å€¼çš„æ•´æ•°å€ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** int32
- **é™åˆ¶ç±»å‹ï¼š** int32
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šæ•°å­—çš„å€¼å¿…é¡»æ˜¯Mutlipleæä¾›çš„å€¼çš„æ•´æ•°å€ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultipleTest)
	int32 MyInt_NoMultiple = 100;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MultipleTest, meta = (Multiple = 5))
	int32 MyInt_HasMultiple = 100;
```

## è“å›¾æ•ˆæœï¼š

å¯ä»¥çœ‹åˆ°ï¼Œæ‹¥æœ‰Multiple çš„åªèƒ½æŒ‰ç…§5çš„å€æ•°æ¥å¢é•¿ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\Multiple\Multiple.gif](Multiple.gif)

## åŸç†ï¼š

```cpp
template <typename Type>
static Type ClampIntegerValueFromMetaData(Type InValue, FPropertyHandleBase& InPropertyHandle, FPropertyNode& InPropertyNode)
{
	Type RetVal = ClampValueFromMetaData<Type>(InValue, InPropertyHandle);

	//if there is "Multiple" meta data, the selected number is a multiple
	const FString& MultipleString = InPropertyHandle.GetMetaData(TEXT("Multiple"));
	if (MultipleString.Len())
	{
		check(MultipleString.IsNumeric());
		Type MultipleValue;
		TTypeFromString<Type>::FromString(MultipleValue, *MultipleString);
		if (MultipleValue != 0)
		{
			RetVal -= Type(RetVal) % MultipleValue;
		}
	}

	return RetVal;
}
```


ï»¿# NoSpinbox

- **åŠŸèƒ½æè¿°ï¼š** ä½¿æ•°å€¼å±æ€§ç¦æ­¢é»˜è®¤çš„æ‹–æ”¾å’Œæ»šè½®çš„UIç¼–è¾‘åŠŸèƒ½ï¼Œæ•°å€¼å±æ€§åŒ…æ‹¬intç³»åˆ—ä»¥åŠfloatç³»åˆ—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** Numeric Type, int / float
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿æ•°å€¼å±æ€§ç¦æ­¢é»˜è®¤çš„æ‹–æ”¾å’Œæ»šè½®çš„UIç¼–è¾‘åŠŸèƒ½ï¼Œæ•°å€¼å±æ€§åŒ…æ‹¬intç³»åˆ—ä»¥åŠfloatç³»åˆ—ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=SpinBoxTest)
	int32 MyInt = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=SpinBoxTest, meta = (NoSpinbox = true))
	int32 MyInt_NoSpinbox = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=SpinBoxTest)
	float MyFloat = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=SpinBoxTest, meta = (NoSpinbox = true))
	float MyFloat_NoSpinbox = 123;
```

## æµ‹è¯•æ•ˆæœï¼š

å‘ç°å¸¦æœ‰NoSpinbox çš„å±æ€§ä¸èƒ½ç”¨é¼ æ ‡å·¦å³æ‹–åŠ¨æ”¹å˜æ•°å€¼ï¼Œä¹Ÿä¸èƒ½ç”¨é¼ æ ‡æ»šè½®æ”¹å˜æ•°å€¼ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\NoSpinbox\SpinBoxTest.gif](SpinBoxTest.gif)

## åŸç†ï¼š

å¯ä»¥çœ‹åˆ°é’ˆå¯¹æ•°å€¼çš„UIï¼ŒbAllowSpinçš„åŠŸèƒ½ç›´æ¥å†³å®šäº†Widgetçš„AllowWheelå’ŒAllowSpinåŠŸèƒ½ã€‚

```cpp
virtual TSharedRef<SWidget>	GetDefaultValueWidget() override
{
	const typename TNumericPropertyParams<NumericType>::FMetaDataGetter MetaDataGetter = TNumericPropertyParams<NumericType>::FMetaDataGetter::CreateLambda([&](const FName& Key)
		{
			return (PinProperty) ? PinProperty->GetMetaData(Key) : FString();
		});

	TNumericPropertyParams<NumericType> NumericPropertyParams(PinProperty, PinProperty ? MetaDataGetter : nullptr);
	
	const bool bAllowSpin = !(PinProperty && PinProperty->GetBoolMetaData("NoSpinbox"));

	// Save last committed value to compare when value changes
	LastSliderCommittedValue = GetNumericValue().GetValue();
	
	return SNew(SBox)
		.MinDesiredWidth(MinDesiredBoxWidth)
		.MaxDesiredWidth(400)
		[
			SNew(SNumericEntryBox<NumericType>)
			.EditableTextBoxStyle(FAppStyle::Get(), "Graph.EditableTextBox")
			.BorderForegroundColor(FSlateColor::UseForeground())
			.Visibility(this, &SGraphPinNumSlider::GetDefaultValueVisibility)
			.IsEnabled(this, &SGraphPinNumSlider::GetDefaultValueIsEditable)
			.Value(this, &SGraphPinNumSlider::GetNumericValue)
			.MinValue(NumericPropertyParams.MinValue)
			.MaxValue(NumericPropertyParams.MaxValue)
			.MinSliderValue(NumericPropertyParams.MinSliderValue)
			.MaxSliderValue(NumericPropertyParams.MaxSliderValue)
			.SliderExponent(NumericPropertyParams.SliderExponent)
			.Delta(NumericPropertyParams.Delta)
			.LinearDeltaSensitivity(NumericPropertyParams.GetLinearDeltaSensitivityAttribute())
			.AllowWheel(bAllowSpin)
			.WheelStep(NumericPropertyParams.WheelStep)
			.AllowSpin(bAllowSpin)
			.OnValueCommitted(this, &SGraphPinNumSlider::OnValueCommitted)
			.OnValueChanged(this, &SGraphPinNumSlider::OnValueChanged)
			.OnBeginSliderMovement(this, &SGraphPinNumSlider::OnBeginSliderMovement)
			.OnEndSliderMovement(this, &SGraphPinNumSlider::OnEndSliderMovement)
		];
}
```


ï»¿# ShiftMultiplier

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†åœ¨ShiftæŒ‰ä¸‹æ—¶é¼ æ ‡è½®æ»šåŠ¨å’Œé¼ æ ‡æ‹–åŠ¨æ”¹å˜å€¼çš„å€ç‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** æ•°æ®ç»“æ„ï¼šFVectorï¼ŒFRotatorï¼ŒFColor
- **å…³è”é¡¹ï¼š** [CtrlMultiplier](CtrlMultiplier/CtrlMultiplier.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

é»˜è®¤å€¼æ˜¯10.f

Shiftçš„æ¨¡å¼å¯ä»¥è®¤ä¸ºæ˜¯ä¸€ç§å¿«è°ƒæ¨¡å¼ï¼Œå¯ä»¥å¿«é€Ÿçš„æ”¹å˜å€¼ã€‚


ï»¿# ShowNormalize

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—FVectorå˜é‡åœ¨ç»†èŠ‚é¢æ¿å‡ºç°ä¸€ä¸ªæ­£è§„åŒ–çš„æŒ‰é’®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FVector
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿å¾—FVectorå˜é‡åœ¨ç»†èŠ‚é¢æ¿å‡ºç°ä¸€ä¸ªæ­£è§„åŒ–çš„æŒ‰é’®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, Category = VectorTest)
	FVector MyVector_Default;

	UPROPERTY(EditAnywhere, Category = VectorTest, meta = (AllowPreserveRatio))
	FVector MyVector_AllowPreserveRatio;

	UPROPERTY(EditAnywhere, Category = VectorTest, meta = (ShowNormalize))
	FVector MyVector_ShowNormalize;
```

## æµ‹è¯•ç»“æœï¼š

MyVector_ShowNormalizeå³ä¾§çš„æŒ‰é’®å¯ä»¥æŠŠå€¼æ­£è§„åŒ–ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\ShowNormalize\AllowPreserveRatio.gif](AllowPreserveRatio.gif)

## åŸç†ï¼š

å…¶å®å°±æ˜¯UIå®šåˆ¶åŒ–çš„æ—¶å€™æ£€æµ‹å‡ºShowNormalizeå°±åˆ›å»ºå•ç‹¬çš„UIã€‚

```cpp
if (StructPropertyHandle->HasMetaData("ShowNormalize") && MathStructCustomization::IsFloatVector(StructPropertyHandle))
{
	HorizontalBox->AddSlot()
		.AutoWidth()
		.MaxWidth(18.0f)
		.VAlign(VAlign_Center)
		[
			// Add a button to scale the vector uniformly to achieve a unit vector
			SNew(SButton)
				.OnClicked(this, &FMathStructCustomization::OnNormalizeClicked, StructWeakHandlePtr)
				.ButtonStyle(FAppStyle::Get(), "NoBorder")
				.ToolTipText(LOCTEXT("NormalizeToolTip", "When clicked, if the vector is large enough, it scales the vector uniformly to achieve a unit vector (vector with a length of 1)"))
				[
					SNew(SImage)
						.ColorAndOpacity(FSlateColor::UseForeground())
						.Image(FAppStyle::GetBrush(TEXT("Icons.Normalize")))	
				]
		];
}
```


ï»¿# SliderExponent

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„å˜åŒ–æŒ‡æ•°åˆ†å¸ƒ
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„å˜åŒ–æŒ‡æ•°åˆ†å¸ƒã€‚é»˜è®¤å€¼æ˜¯1ã€‚

è¯¥å€¼å¿…é¡»é…åˆMinï¼ŒMaxä½¿ç”¨

æ‰€è°“æŒ‡æ•°åˆ†å¸ƒæŒ‡çš„æ˜¯åœ¨UIMinå’ŒMaxçš„èŒƒå›´å†…ï¼Œå½“æ»šåŠ¨çš„æ–‡æœ¬å€¼å˜åŒ–çš„æ—¶å€™ï¼Œæ»šåŠ¨æ¡çš„ç™¾åˆ†æ¯”å€¼å¦‚ä½•å˜åŒ–ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸­é—´ç‚¹çš„å€¼å°±æ˜¯åœ¨50%ã€‚ä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥æŒ‡å®šä¸€ä¸ªæŒ‡æ•°ï¼Œå½¢æˆä¸€æ¡æŒ‡æ•°åˆ†å¸ƒæ›²çº¿ï¼Œåœ¨æ•°è½´å·¦ä¾§ä¸€å¼€å§‹çš„æ—¶å€™æ¯”è¾ƒå¹³ç¼“å˜åŠ¨æ¯”è¾ƒç¼“æ…¢æ‹¥æœ‰æ›´é«˜çš„è°ƒæ•´ç²¾åº¦ï¼Œåœ¨æ•°è½´çš„å³ä¾§ç»“æŸçš„éƒ¨åˆ†æ›²çº¿å˜å¾—é™¡å³­å˜åŠ¨å‰§çƒˆå°±å¤±å»äº†ç²¾åº¦ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SliderTest, meta = (UIMin = "0", UIMax = "1000"))
	float MyFloat_DefaultSliderExponent = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = SliderTest, meta = (UIMin = "0", UIMax = "1000", SliderExponent = 5))
	float MyFloat_HasSliderExponent = 100;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§SliderExponent=5çš„æ•ˆæœå¯¼è‡´100çš„æ–‡æœ¬å€¼è½åœ¨UI 1000çš„èŒƒå›´å†…ä¸€å¼€å§‹å°±å¤„äºå¿«0.3çš„ä½ç½®ï¼Œä¸”å˜åŠ¨çš„èŒƒå›´åœ¨500å‰æ¯”è¾ƒç²¾ç»†ï¼Œ500åæ¯”è¾ƒè¿…é€Ÿã€‚è·Ÿå‰è€…å½¢æˆå¯¹æ¯”ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\SliderExponent\SliderExponent.gif](SliderExponent.gif)

## åŸç†ï¼š

é»˜è®¤çš„å€¼æ˜¯1ï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™é‡‡ç”¨SpinBoxComputeExponentSliderFractionæ¥è®¡ç®—æ–°çš„ç™¾åˆ†æ¯”ï¼Œè¯»è€…å¯è‡ªè¡Œè§‚å¯ŸSpinBoxComputeExponentSliderFractionå‡½æ•°æ¥äº†è§£æŒ‡æ•°åˆ†å¸ƒçš„æƒ…å†µã€‚

```cpp
const float CachedSliderExponent = SliderExponent.Get();
if (!FMath::IsNearlyEqual(CachedSliderExponent, 1.f))
{
	if (SliderExponentNeutralValue.IsSet() && SliderExponentNeutralValue.Get() > GetMinSliderValue() && SliderExponentNeutralValue.Get() < GetMaxSliderValue())
	{
		//Compute a log curve on both side of the neutral value
		float StartFractionFilled = Fraction((double)SliderExponentNeutralValue.Get(), (double)GetMinSliderValue(), (double)GetMaxSliderValue());
		FractionFilled = SpinBoxComputeExponentSliderFraction(FractionFilled, StartFractionFilled, CachedSliderExponent);
	}
	else
	{
		FractionFilled = 1.0f - FMath::Pow(1.0f - FractionFilled, CachedSliderExponent);
	}
}
```


ï»¿# sRGB

- **åŠŸèƒ½æè¿°ï¼š** ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™é‡‡ç”¨sRGBæ–¹å¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FColor , FLinearColor 

ä½¿FColoræˆ–FLinearColorå±æ€§åœ¨ç¼–è¾‘çš„æ—¶å€™é‡‡ç”¨sRGBæ–¹å¼ã€‚

ä½†æ˜¯åœ¨æµ‹è¯•çš„æ—¶å€™å¹¶æ— æ³•å·¥ä½œã€‚

## åŸç†ï¼š

```cpp
void FColorStructCustomization::CustomizeHeader(TSharedRef<class IPropertyHandle> InStructPropertyHandle, class FDetailWidgetRow& InHeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{

	if (StructPropertyHandle->GetProperty()->HasMetaData(TEXT("sRGB")))
	{
		sRGBOverride = StructPropertyHandle->GetProperty()->GetBoolMetaData(TEXT("sRGB"));
	}

}

```


ï»¿# SupportDynamicSliderMaxValue

- **åŠŸèƒ½æè¿°ï¼š** æ”¯æŒæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡çš„æœ€å¤§èŒƒå›´å€¼åœ¨AltæŒ‰ä¸‹æ—¶è¢«åŠ¨æ€æ”¹å˜
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FVector4
- **å…³è”é¡¹ï¼š** [SupportDynamicSliderMinValue](SupportDynamicSliderMinValue/SupportDynamicSliderMinValue.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…


ï»¿# SupportDynamicSliderMinValue

- **åŠŸèƒ½æè¿°ï¼š** æ”¯æŒæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡çš„æœ€å°èŒƒå›´å€¼åœ¨AltæŒ‰ä¸‹æ—¶è¢«åŠ¨æ€æ”¹å˜
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FVector4
- **å…³è”é¡¹ï¼š** [SupportDynamicSliderMaxValue](../SupportDynamicSliderMaxValue.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ”¯æŒæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡çš„æœ€å°èŒƒå›´å€¼åœ¨AltæŒ‰ä¸‹æ—¶è¢«åŠ¨æ€æ”¹å˜ã€‚

- å¿…é¡»é…åˆUIMinï¼ŒUIMaxä½¿ç”¨ï¼Œå› ä¸ºè¿™æ ·æ‰æœ‰æ»šåŠ¨æ¡UI
- ä¸€èˆ¬æƒ…å†µä¸‹æ»šåŠ¨æ¡èŒƒå›´æ˜¯åˆå§‹è®¾ç½®å¥½çš„ï¼Œä½†è¯¥è®¾ç½®æ”¯æŒåŠ¨æ€æ”¹å˜ã€‚æ–¹æ³•æ˜¯æŒ‰ä¸‹Altæ‹–åŠ¨é¼ æ ‡ã€‚
- æ™®é€šçš„floatå±æ€§ç­‰æ˜¯ä¸æ”¯æŒè¯¥metaçš„ï¼Œå› ä¸ºæ™®é€šè‡ªåŠ¨ç”Ÿæˆçš„çš„SPropertyEditorNumericï¼Œæ²¡æœ‰ä»property metaä¸­æå–SupportDynamicSliderMinValueï¼Œå› æ­¤å³ä½¿è®¾ç½®äº†ä¹Ÿä¸ä¼šç”Ÿæ•ˆã€‚
- ç›®å‰æºç ä¸­åªæœ‰ç»§æ‰¿äº†FMathStructCustomizationçš„FColorGradingVectorCustomizationBaseï¼ˆå¯¹åº”FVector4ï¼‰æ‰æå–SupportDynamicSliderMinValueï¼Œç„¶åè‡ªå·±åˆ›å»ºSNumericEntryBoxï¼Œä»è€Œæ­£ç¡®çš„è®¾ç½®SupportDynamicSliderMinValueçš„å€¼ã€‚
- å› æ­¤å¦‚æœä½ ä¹Ÿæƒ³ä½¿å¾—è‡ªå·±çš„ç»“æ„é‡Œçš„æ•°å­—å±æ€§æ”¯æŒè¯¥åŠŸèƒ½ï¼Œä¹Ÿéœ€è¦æ‰‹åŠ¨åˆ›å»ºCustomizationï¼Œç„¶ååœ¨é‡Œé¢æ‰‹åŠ¨åˆ›å»ºSNumericEntryBoxï¼Œä»è€Œè‡ªå·±è®¾ç½®SupportDynamicSliderMinValueçš„å€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DynamicSliderTest, meta = (UIMin = "0", UIMax = "1"))
	FVector4 MyVector4_NoDynamicSlider;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DynamicSliderTest, meta = (UIMin = "0", UIMax = "1", SupportDynamicSliderMinValue = "true", SupportDynamicSliderMaxValue = "true"))
	FVector4 MyVector4_SupportDynamicSlider;
```

## æµ‹è¯•ç»“æœï¼š

å¯ä»¥çœ‹è§MyVector4_NoDynamicSliderå¹¶æ— æ³•æ›´æ”¹0-1çš„æ»šåŠ¨æ¡èŒƒå›´ã€‚è€ŒMyVector4_SupportDynamicSlideråœ¨æŒ‰ä¸‹AltåŒæ—¶æ‹–åŠ¨é¼ æ ‡åå¯ä»¥æ”¹å˜æœ€å°å’Œæœ€å¤§çš„UIèŒƒå›´ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\SupportDynamicSliderMinValue\DynamicSlider.gif](DynamicSlider.gif)

## åŸç†ï¼š

åœ¨SPropertyEditorNumericé‡Œå¹¶ä¸ä¼šå»æå–SupportDynamicSliderMinValueè¯¥å±æ€§ï¼Œå› æ­¤é»˜è®¤æƒ…å†µä¸‹è¯¥å€¼æ˜¯ä¸ç”Ÿæ•ˆçš„ã€‚

```cpp
void SPropertyEditorNumeric<NumericType>::Construct( const FArguments& InArgs, const TSharedRef<FPropertyEditor>& InPropertyEditor )
{
	TNumericPropertyParams<NumericType> NumericPropertyParams(Property, MetaDataGetter);
	ChildSlot
	[
		SAssignNew(PrimaryWidget, SNumericEntryBox<NumericType>)
		// Only allow spinning if we have a single value
		.AllowSpin(bAllowSpin)
		.Value(this, &SPropertyEditorNumeric<NumericType>::OnGetValue)
		.Font(InArgs._Font)
		.MinValue(NumericPropertyParams.MinValue)
		.MaxValue(NumericPropertyParams.MaxValue)
		.MinSliderValue(NumericPropertyParams.MinSliderValue)
		.MaxSliderValue(NumericPropertyParams.MaxSliderValue)
		.SliderExponent(NumericPropertyParams.SliderExponent)
		.Delta(NumericPropertyParams.Delta)
		// LinearDeltaSensitivity needs to be left unset if not provided, rather than being set to some default
		.LinearDeltaSensitivity(NumericPropertyParams.GetLinearDeltaSensitivityAttribute())
		.AllowWheel(bAllowSpin)
		.WheelStep(NumericPropertyParams.WheelStep)
		.UndeterminedString(PropertyEditorConstants::DefaultUndeterminedText)
		.OnValueChanged(this, &SPropertyEditorNumeric<NumericType>::OnValueChanged)
		.OnValueCommitted(this, &SPropertyEditorNumeric<NumericType>::OnValueCommitted)
		.OnUndeterminedValueCommitted(this, &SPropertyEditorNumeric<NumericType>::OnUndeterminedValueCommitted)
		.OnBeginSliderMovement(this, &SPropertyEditorNumeric<NumericType>::OnBeginSliderMovement)
		.OnEndSliderMovement(this, &SPropertyEditorNumeric<NumericType>::OnEndSliderMovement)
		.TypeInterface(TypeInterface)
	];
	}
	
	virtual FReply OnMouseMove(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent) override
	{
			if (MouseEvent.IsAltDown())
			{
							float DeltaToAdd = (float)MouseEvent.GetCursorDelta().X / SliderWidthInSlateUnits;
			
							if (SupportDynamicSliderMaxValue.Get() && (NumericType)InternalValue == GetMaxSliderValue())
							{
								ApplySliderMaxValueChanged(DeltaToAdd, false);
							}
							else if (SupportDynamicSliderMinValue.Get() && (NumericType)InternalValue == GetMinSliderValue())
							{
								ApplySliderMinValueChanged(DeltaToAdd, false);
							}
			}
	}
```


ï»¿# UIMax

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„æœ€å¤§èŒƒå›´å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [UIMin](UIMin/UIMin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# UIMin

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šæ»šåŠ¨æ¡æ‹–åŠ¨çš„æœ€å°èŒƒå›´å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [UIMax](../UIMax.md), [ClampMin](../ClampMin.md), [ClampMax](../ClampMax.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

UIMin-UIMaxå’ŒClampMin-ClampMaxçš„åŒºåˆ«æ˜¯ï¼ŒUIç³»åˆ—é˜»æ­¢ç”¨æˆ·åœ¨æ‹–åŠ¨é¼ æ ‡çš„æ—¶å€™æŠŠå€¼è¶…è¿‡æŸä¸ªèŒƒå›´ï¼Œä½†æ˜¯ç”¨æˆ·ä¾ç„¶å¯ä»¥æ‰‹åŠ¨è¾“å…¥è¶…è¿‡è¿™ä¸ªèŒƒå›´çš„å€¼ã€‚è€ŒClampç³»åˆ—æ˜¯å®é™…çš„å€¼çš„èŒƒå›´é™åˆ¶ï¼Œç”¨æˆ·æ‹–åŠ¨æˆ–è€…æ‰‹åŠ¨è¾“å…¥å€¼éƒ½ä¸å…è®¸è¶…è¿‡è¿™ä¸ªèŒƒå›´ã€‚

è¿™ä¸¤ä¸ªé™åˆ¶éƒ½æ— æ³•é™åˆ¶è“å›¾ä¸‹ç›´æ¥ä¿®æ”¹å€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MinMaxTest)
	float MyFloat_NoMinMax = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MinMaxTest, meta = (UIMin = "0", UIMax = "100"))
	float MyFloat_HasMinMax_UI = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MinMaxTest, meta = (ClampMin = "0", ClampMax = "100"))
	float MyFloat_HasMinMax_Clamp = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MinMaxTest, meta = (ClampMin = "0", ClampMax = "100",UIMin = "20", UIMax = "50"))
	float MyFloat_HasMinMax_ClampAndUI = 100;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MinMaxTest, meta = (ClampMin = "20", ClampMax = "50",UIMin = "0", UIMax = "100"))
	float MyFloat_HasMinMax_ClampAndUI2= 100;
```

## æµ‹è¯•æ•ˆæœï¼š

- ä»MyFloat_HasMinMax_UIå‘ç°ï¼ŒUIMin, UIMaxé™åˆ¶æ•°å­—è¾“å…¥æ¡†æ»šåŠ¨æ¡çš„èŒƒå›´ï¼Œä½†ä¾ç„¶å¯ä»¥æ‰‹åŠ¨è¾“å…¥è¶…è¿‡çš„å€¼999
- ä»MyFloat_HasMinMax_Clamp å‘ç°ï¼ŒClampMinï¼ŒClampMax ä¼šåŒæ—¶é™åˆ¶UIå’Œæ‰‹åŠ¨è¾“å…¥çš„èŒƒå›´ã€‚
- ä»MyFloat_HasMinMax_ClampAndUIå’ŒMyFloat_HasMinMax_ClampAndUI2å‘ç°ï¼ŒUIçš„æ»šåŠ¨æ¡ä¼šå–UIçš„é™åˆ¶å’ŒClampé™åˆ¶çš„æ›´çª„èŒƒå›´ï¼Œè€Œå®é™…è¾“å…¥å€¼ä¹Ÿæ˜¯ä¼šè¢«é™åˆ¶åœ¨æ›´çª„çš„èŒƒå›´å†…ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\UIMin\MinMax2.gif](MinMax2.gif)

## åŸç†ï¼š

TNumericPropertyParamsåœ¨æ„é€ çš„æ—¶å€™å°±ä¼šå–å¾—ä¸€äº›metaæ¥åˆå§‹åŒ–è¿™äº›å˜é‡ã€‚å¦åˆ™å°±ä¼šæˆä¸ºé»˜è®¤å€¼ã€‚

æ•°å€¼ç±»å‹æœ‰å®é™…çš„æœ€å°æœ€å¤§å€¼ï¼ˆMinValue-MaxValueï¼‰ï¼Œæ˜¯ç”±ClampMinå’ŒClampMaxæä¾›çš„ã€‚ä¹Ÿæœ‰UIä¸Šçš„æœ€å°æœ€å¤§å€¼ï¼ˆMinSliderValue-MaxSliderValueï¼‰ï¼Œæ˜¯ç”±Max(UImin,ClampMin)å’ŒMin(UIMax,ClampMax)æä¾›çš„ï¼Œå³å–æœ€å°çš„èŒƒå›´æ¥ä¿éšœåˆæ³•è¾“å…¥ã€‚

```cpp
template<typename NumericType>
struct TNumericPropertyParams
{
	if (MetaDataGetter.IsBound())
	{
		UIMinString = MetaDataGetter.Execute("UIMin");
		UIMaxString = MetaDataGetter.Execute("UIMax");
		SliderExponentString = MetaDataGetter.Execute("SliderExponent");
		LinearDeltaSensitivityString = MetaDataGetter.Execute("LinearDeltaSensitivity");
		DeltaString = MetaDataGetter.Execute("Delta");
		ClampMinString = MetaDataGetter.Execute("ClampMin");
		ClampMaxString = MetaDataGetter.Execute("ClampMax");
		ForcedUnits = MetaDataGetter.Execute("ForceUnits");
		WheelStepString = MetaDataGetter.Execute("WheelStep");
	}
	
	TOptional<NumericType> MinValue;
	TOptional<NumericType> MaxValue;
	TOptional<NumericType> MinSliderValue;
	TOptional<NumericType> MaxSliderValue;
	NumericType SliderExponent;
	NumericType Delta;
	int32 LinearDeltaSensitivity;
	TOptional<NumericType> WheelStep;
}
//æœ€ç»ˆè¿™äº›å€¼ä¼šä¼ è¾“ç»™
SAssignNew(SpinBox, SSpinBox<NumericType>)
	.Style(InArgs._SpinBoxStyle)
	.Font(InArgs._Font.IsSet() ? InArgs._Font : InArgs._EditableTextBoxStyle->TextStyle.Font)
	.Value(this, &SNumericEntryBox<NumericType>::OnGetValueForSpinBox)
	.Delta(InArgs._Delta)
	.ShiftMultiplier(InArgs._ShiftMultiplier)
	.CtrlMultiplier(InArgs._CtrlMultiplier)
	.LinearDeltaSensitivity(InArgs._LinearDeltaSensitivity)
	.SupportDynamicSliderMaxValue(InArgs._SupportDynamicSliderMaxValue)
	.SupportDynamicSliderMinValue(InArgs._SupportDynamicSliderMinValue)
	.OnDynamicSliderMaxValueChanged(InArgs._OnDynamicSliderMaxValueChanged)
	.OnDynamicSliderMinValueChanged(InArgs._OnDynamicSliderMinValueChanged)
	.OnValueChanged(OnValueChanged)
	.OnValueCommitted(OnValueCommitted)
	.MinFractionalDigits(MinFractionalDigits)
	.MaxFractionalDigits(MaxFractionalDigits)
	.MinSliderValue(InArgs._MinSliderValue)
	.MaxSliderValue(InArgs._MaxSliderValue)
	.MaxValue(InArgs._MaxValue)
	.MinValue(InArgs._MinValue)
	.SliderExponent(InArgs._SliderExponent)
	.SliderExponentNeutralValue(InArgs._SliderExponentNeutralValue)
	.EnableWheel(InArgs._AllowWheel)
	.BroadcastValueChangesPerKey(InArgs._BroadcastValueChangesPerKey)
	.WheelStep(InArgs._WheelStep)
	.OnBeginSliderMovement(InArgs._OnBeginSliderMovement)
	.OnEndSliderMovement(InArgs._OnEndSliderMovement)
	.MinDesiredWidth(InArgs._MinDesiredValueWidth)
	.TypeInterface(Interface)
	.ToolTipText(this, &SNumericEntryBox<NumericType>::GetValueAsText);
	
	
//æœ€å
void SSpinBox<NumericType>::CommitValue(NumericType NewValue, double NewSpinValue, ECommitMethod CommitMethod, ETextCommit::Type OriginalCommitInfo)
{
	if (CommitMethod == CommittedViaSpin || CommitMethod == CommittedViaArrowKey)
	{
		const NumericType LocalMinSliderValue = GetMinSliderValue();
		const NumericType LocalMaxSliderValue = GetMaxSliderValue();
		NewValue = FMath::Clamp<NumericType>(NewValue, LocalMinSliderValue, LocalMaxSliderValue);
		NewSpinValue = FMath::Clamp<double>(NewSpinValue, (double)LocalMinSliderValue, (double)LocalMaxSliderValue);
	}
	
	{
		const NumericType LocalMinValue = GetMinValue();
		const NumericType LocalMaxValue = GetMaxValue();
		NewValue = FMath::Clamp<NumericType>(NewValue, LocalMinValue, LocalMaxValue);
		NewSpinValue = FMath::Clamp<double>(NewSpinValue, (double)LocalMinValue, (double)LocalMaxValue);
	}
	
	// Update the internal value, this needs to be done before rounding.
	InternalValue = NewSpinValue;
	
	const bool bAlwaysUsesDeltaSnap = GetAlwaysUsesDeltaSnap();
	// If needed, round this value to the delta. Internally the value is not held to the Delta but externally it appears to be.
	if (CommitMethod == CommittedViaSpin || CommitMethod == CommittedViaArrowKey || bAlwaysUsesDeltaSnap)
	{
		NumericType CurrentDelta = Delta.Get();
		if (CurrentDelta != NumericType())
		{
			NewValue = FMath::GridSnap<NumericType>(NewValue, CurrentDelta); // snap numeric point value to nearest Delta
		}
	}
	
	// Update the max slider value based on the current value if we're in dynamic mode
	if (SupportDynamicSliderMaxValue.Get() && ValueAttribute.Get() > GetMaxSliderValue())
	{
		ApplySliderMaxValueChanged(float(ValueAttribute.Get() - GetMaxSliderValue()), true);
	}
	else if (SupportDynamicSliderMinValue.Get() && ValueAttribute.Get() < GetMinSliderValue())
	{
		ApplySliderMinValueChanged(float(ValueAttribute.Get() - GetMinSliderValue()), true);
	}
}

```


ï»¿# Units

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šå±æ€§å€¼çš„å•ä½ï¼Œæ”¯æŒå®æ—¶æ ¹æ®æ•°å€¼ä¸åŒåŠ¨æ€æ”¹å˜æ˜¾ç¤ºçš„å•ä½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** float,int32
- **å…³è”é¡¹ï¼š** [ForceUnits](../ForceUnits.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è®¾å®šå±æ€§å€¼çš„å•ä½ã€‚ä¸€ä¸ªå•ä½æœ‰å¤šä¸ªåˆ«åï¼Œå¦‚Kilogramså’Œkgï¼ŒCentimeterså’Œcmï¼Œéƒ½æ˜¯å¯ä»¥çš„ã€‚

Unitsçš„ä½œç”¨ä¸å…‰æ˜¯è®¾å®šå•ä½ï¼Œè€Œä¸”éšå«ç€è¿™ä¸ªæ˜¾ç¤ºçš„å•ä½å­—ç¬¦ä¸²å¯ä»¥æ ¹æ®ç”¨æˆ·è¾“å…¥çš„æ•°å€¼è‡ªåŠ¨çš„è¿›è¡Œè°ƒæ•´é€‚åº”ã€‚æ¯”å¦‚100cmå…¶å®å°±æ˜¯1mï¼Œ0.5kmå°±æ˜¯500mã€‚

å¦å¤–è®¾å®šäº†å•ä½ä¹‹åï¼Œè¿˜å¯ä»¥æ¥å—ç”¨æˆ·ç›´æ¥åœ¨æ•°å­—æ¡†ä¸­è¾“å…¥æ•°å­—å’Œå•ä½çš„ç»„åˆï¼Œæ¯”å¦‚ç›´æ¥æ•²å…¥1kmå°±å¯ä»¥è®¾ç½®å€¼ä¸º1ï¼Œå•ä½ä¸ºkmã€‚æˆ–è€…1ftä¸º1è‹±å°º=30.84cmã€‚

è¦å®ç°è‡ªåŠ¨çš„è°ƒæ•´æ˜¾ç¤ºå•ä½çš„åŠŸèƒ½ï¼Œé¦–å…ˆéœ€è¦åœ¨é¡¹ç›®è®¾ç½®é‡Œè®¾ç½®å•ä½ç³»åˆ—ã€‚æ¯”å¦‚ä¸‹å›¾å°±åœ¨è·ç¦»ä¸Šè®¾ç½®äº†å˜ç±³ï¼Œç±³ï¼Œåƒç±³ï¼Œæ¯«ç±³çš„å•ä½ï¼ˆé¡ºåºä¸é‡è¦ï¼‰ã€‚ç„¶åä¹‹åæ•°å­—æ¡†æ˜¾ç¤ºè·ç¦»çš„å•ä½æ—¶å°±å¯ä»¥åœ¨è¿™4è€…ä¹‹é—´è½¬æ¢ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Numeric\Units\Untitled.png)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UPROPERTY(EditAnywhere, Category = UnitsTest)
float MyFloat_NoUnits = 0.0;

UPROPERTY(EditAnywhere, Category = UnitsTest, Meta = (Units = "cm"))
float MyFloat_HasUnits_Distance = 100.f;

UPROPERTY(EditAnywhere, Category = UnitsTest, Meta = (ForceUnits = "cm"))
float MyFloat_HasForceUnits_Distance = 100.f;
```

## æµ‹è¯•æ•ˆæœï¼š

- åœ¨é¡¹ç›®è®¾ç½®é‡Œå¡«å…¥4ä¸ªå•ä½ï¼šcmï¼Œmï¼Œkmï¼Œmmåå¼€å§‹æµ‹è¯•ã€‚
- å‘ç°é‡‡ç”¨Unitsçš„å±æ€§ï¼Œä¼šè‡ªåŠ¨çš„æ ¹æ®å€¼çš„ä¸åŒè°ƒæ•´å•ä½ã€‚è€Œä¸”ä¹Ÿæ¥å—æ•°å­—+å•ä½çš„è¾“å…¥ã€‚
- å‘ç°é‡‡ç”¨ForceUnitsçš„å±æ€§ï¼Œä¹Ÿå¯ä»¥æ¥å—æ•°å­—+å•ä½çš„è¾“å…¥ï¼Œä½†æ˜¯åœ¨æ˜¾ç¤ºä¸Šå´å§‹ç»ˆæ˜¾ç¤ºä¸ºcmï¼Œä¸ä¼šè°ƒæ•´åˆ°åˆ«çš„å•ä½ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\Units\Unit.gif](Unit.gif)

## åŸç†ï¼š

- å¦‚æœForcedUnitsæœ‰è®¾ç½®ï¼Œåˆ™ä¼šåŒæ—¶è®¾ç½®UnderlyingUnitsï¼ˆåŸºç¡€å•ä½ï¼‰ï¼ŒUserDisplayUnits å’ŒFixedDisplayUnits ã€‚
- å¦åˆ™å¦‚æœè®¾ç½®Unitsï¼Œåˆ™ä¼šåªè®¾ç½®åˆ°UnderlyingUnitså’ŒFixedDisplayUnits
- æœ€ååœ¨æ˜¾ç¤ºå•ä½çš„æ—¶å€™ï¼Œå¦‚æœæœ‰UserDisplayUnitsï¼Œåˆ™ä¼˜å…ˆé‡‡ç”¨ã€‚ä¹‹åæ‰æ˜¯FixedDisplayUnits ã€‚
- ToStringçš„æ—¶å€™ï¼Œæ˜¯æŠŠUnderlyingUnitsè½¬åˆ°UserDisplayUnitsæˆ–FixedDisplayUnitsã€‚
- åœ¨æ•°å­—è¾“å…¥æ¡†æ”¹å˜çš„æ—¶å€™ï¼Œä¼šè§¦å‘SetupFixedDisplayï¼Œä»è€Œåœ¨å†…éƒ¨æ¯æ¬¡é‡æ–°è®¡ç®—åˆé€‚çš„å•ä½èµ‹å€¼åˆ°FixedDisplayUnitsã€‚å› æ­¤å¦‚ä¸Šé¢è¯´çš„ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®UserDisplayUnitsï¼ˆæ²¡æœ‰ForceUnitsï¼‰ï¼Œåˆ™æ¯æ¬¡éƒ½ä¼šè°ƒæ•´åˆ°æ–°çš„åˆé€‚æ˜¾ç¤ºå•ä½ã€‚å¦åˆ™å°±ä¼šå› ä¸ºUserDisplayUnitsä¼˜å…ˆçº§æœ€é«˜ä¸”ä¸€ç›´æœ‰å€¼ï¼Œå¯¼è‡´æ€»æ˜¯ä»¥UserDisplayUnitsæ˜¾ç¤ºä¿æŒä¸å˜ã€‚

```cpp
void SPropertyEditorNumeric<NumericType>::Construct( const FArguments& InArgs, const TSharedRef<FPropertyEditor>& InPropertyEditor )
{
		// First off, check for ForceUnits= meta data. This meta tag tells us to interpret, and always display the value in these units. FUnitConversion::Settings().ShouldDisplayUnits does not apply to such properties
		const FString& ForcedUnits = MetaDataGetter.Execute("ForceUnits");
		TOptional<EUnit> PropertyUnits = FUnitConversion::UnitFromString(*ForcedUnits);
		if (PropertyUnits.IsSet())
		{
			// Create the type interface and set up the default input units if they are compatible
			TypeInterface = MakeShareable(new TNumericUnitTypeInterface<NumericType>(PropertyUnits.GetValue()));
			TypeInterface->UserDisplayUnits = TypeInterface->FixedDisplayUnits = PropertyUnits.GetValue();
		}
		// If that's not set, we fall back to Units=xxx which calculates the most appropriate unit to display in
		else
		{
			if (FUnitConversion::Settings().ShouldDisplayUnits())
			{
				const FString& DynamicUnits = PropertyHandle->GetMetaData(TEXT("Units"));
				if (!DynamicUnits.IsEmpty())
				{
					PropertyUnits = FUnitConversion::UnitFromString(*DynamicUnits);
				}
				else
				{
					PropertyUnits = FUnitConversion::UnitFromString(*MetaDataGetter.Execute("Units"));
				}
			}
		
			if (!PropertyUnits.IsSet())
			{
				PropertyUnits = EUnit::Unspecified;
			}
		}
}

void SPropertyEditorNumeric<NumericType>::OnValueCommitted( NumericType NewValue, ETextCommit::Type CommitInfo )
{

			if (TypeInterface.IsValid())
			{
				TypeInterface->SetupFixedDisplay(NewValue);
			}
}

template<typename NumericType>
void TNumericUnitTypeInterface<NumericType>::SetupFixedDisplay(const NumericType& InValue)
{
	// We calculate this regardless of whether FixedDisplayUnits is used, so that the moment it is used, it's correct
	EUnit DisplayUnit = FUnitConversion::CalculateDisplayUnit(InValue, UnderlyingUnits);
	if (DisplayUnit != EUnit::Unspecified)
	{
		FixedDisplayUnits = DisplayUnit;
	}
}

//åœ¨è½¬æ¢çš„æ—¶å€™
FString TNumericUnitTypeInterface<NumericType>::ToString(const NumericType& Value) const
{
		if (UserDisplayUnits.IsSet())
		{
			auto Converted = FinalValue.ConvertTo(UserDisplayUnits.GetValue());
			if (Converted.IsSet())
			{
				return ToUnitString(Converted.GetValue());
			}
		}
		
		if (FixedDisplayUnits.IsSet())
		{
			auto Converted = FinalValue.ConvertTo(FixedDisplayUnits.GetValue());
			if (Converted.IsSet())
			{
				return ToUnitString(Converted.GetValue());
			}
		}
}
	

```


ï»¿# WheelStep

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šé¼ æ ‡è½®ä¸Šä¸‹æ»šåŠ¨äº§ç”Ÿçš„å˜åŒ–å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Numeric Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** float/int
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šæ•°å­—è¾“å…¥æ¡†ä¸Šé¼ æ ‡è½®ä¸Šä¸‹æ»šåŠ¨äº§ç”Ÿçš„å˜åŒ–å€¼ã€‚

## é»˜è®¤å€¼çš„è§„åˆ™ï¼š

å¦‚æœå±æ€§æ˜¯æµ®ç‚¹æ•°ä¸”UIæ»šåŠ¨æ¡èŒƒå›´å°äº10ï¼Œåˆ™WheelStep=0.1ï¼Œå¦åˆ™ä¸º1

å¦‚æœå±æ€§æ˜¯æ•´æ•°ï¼Œåˆ™WheelStep=1

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = WheelStepTest)
	float MyFloat_DefaultWheelStep = 50;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = WheelStepTest, meta = (UIMin = "0", UIMax = "10"))
	float MyFloat_SmallWheelStep = 1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = WheelStepTest, meta = (WheelStep = 10))
	float MyFloat_HasWheelStep = 50;
```

## æ•ˆæœå›¾ï¼š

é»˜è®¤å€¼ä¸æŒ‡å®šUIMinï¼ŒUIMaxä¹Ÿå¯ä»¥é¼ æ ‡è½®æ»šåŠ¨å˜åŒ–å€¼ã€‚é»˜è®¤ä¸º1

MyFloat_SmallWheelStepçš„UIèŒƒå›´åªæœ‰10ï¼Œåˆ™é»˜è®¤æ”¹å˜å¹…åº¦0.1

æŒ‡å®šWheelStep =10ï¼Œåˆ™ä¸€ä¸‹å­å˜åŒ–10

![D:\github\UnrealSpecifiers\Doc\Meta\Numeric\WheelStep\WheelStep2.gif](WheelStep2.gif)

## åŸç†ï¼š

é€šè¿‡ä»£ç å¯çŸ¥ï¼Œå¦‚æœè®¾ç½®äº†WheelStepåˆ™ç”¨è¯¥å€¼ã€‚

å¦åˆ™å¦‚æœæ˜¯æµ®ç‚¹æ•°ä¸”UIæ»šåŠ¨æ¡èŒƒå›´å°äº10ï¼Œåˆ™WheelStep=0.1ï¼Œå¦åˆ™ä¸º1

å¦åˆ™å¦‚æœæ˜¯æ•´æ•°ï¼Œåˆ™WheelStep=1

```cpp
	virtual FReply SSpinBox<NumericType>::OnMouseWheel(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent) override
	{
		if (bEnableWheel && PointerDraggingSliderIndex == INDEX_NONE && HasKeyboardFocus())
		{
			// If there is no WheelStep defined, we use 1.0 (Or 0.1 if slider range is <= 10)
			constexpr bool bIsIntegral = TIsIntegral<NumericType>::Value;
			const bool bIsSmallStep = !bIsIntegral && (GetMaxSliderValue() - GetMinSliderValue()) <= 10.0;
			double Step = WheelStep.IsSet() && WheelStep.Get().IsSet() ? WheelStep.Get().GetValue() : (bIsSmallStep ? 0.1 : 1.0);

			if (MouseEvent.IsControlDown())
			{
				// If no value is set for WheelSmallStep, we use the DefaultStep multiplied by the CtrlMultiplier
				Step *= CtrlMultiplier.Get();
			}
			else if (MouseEvent.IsShiftDown())
			{
				// If no value is set for WheelBigStep, we use the DefaultStep multiplied by the ShiftMultiplier
				Step *= ShiftMultiplier.Get();
			}

			const double Sign = (MouseEvent.GetWheelDelta() > 0) ? 1.0 : -1.0;
			const double NewValue = InternalValue + (Sign * Step);
			const NumericType RoundedNewValue = RoundIfIntegerValue(NewValue);

			return FReply::Handled();
		}

		return FReply::Unhandled();
	}
```


ï»¿# AssetBundles

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜è¯¥å±æ€§å…¶å¼•ç”¨çš„èµ„äº§å±äºå“ªä¸€äº›AssetBundlesã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** UPrimaryDataAssetå†…éƒ¨çš„FSoftObjectPtrï¼ŒFSoftObjectPath 
- **å…³è”é¡¹ï¼š** [IncludeAssetBundles](../IncludeAssetBundles/IncludeAssetBundles.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç”¨äºUPrimaryDataAssetå†…éƒ¨çš„ SoftObjectPtr æˆ– SoftObjectPath å±æ€§ï¼Œæ ‡æ˜å…¶å¼•ç”¨çš„èµ„äº§å±äºå“ªä¸€äº›AssetBundlesã€‚

è¦ç†è§£è¿™ä¸ªçš„ä½œç”¨ï¼Œéœ€è¦å…ˆç†è§£ä¸€äº›åŸºæœ¬æ¦‚å¿µï¼š

- PrimaryAssetæŒ‡çš„æ˜¯åœ¨æ¸¸æˆä¸­å¯ä»¥è¿›è¡Œæ‰‹åŠ¨è½½å…¥/é‡Šæ”¾çš„ä¸œè¥¿ã€‚åŒ…æ‹¬å…³å¡æ–‡ä»¶ï¼ˆ.umapï¼‰ä»¥åŠä¸€äº›æ¸¸æˆç›¸å…³çš„ç‰©ä»¶ï¼Œä¾‹å¦‚è§’è‰²æˆ–è€…èƒŒåŒ…é‡Œçš„ç‰©å“ã€‚é¡¾åæ€ä¹‰ï¼Œä¸»è¦èµ„äº§æŒ‡çš„æ˜¯æ¸¸æˆé‡Œçš„ä¸»è¦æ ¹éƒ¨èµ„äº§ï¼Œå…¶å¼•ç”¨æ ‘ä¸‹æœ‰ä¸€å¤§å †å…¶ä»–èµ„äº§ã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬å¾€å¾€ä¼šä¸»åŠ¨åŠ è½½æˆ–é‡Šæ”¾è¿™äº›ä¸»è¦èµ„äº§ï¼Œæ¯”å¦‚åŠ è½½å…³å¡ï¼ŒåŠ è½½æ€ªç‰©è§’è‰²ï¼ŒåŠ è½½æ‰è½é“å…·ã€‚ä½†æˆ‘ä»¬ä¸€èˆ¬ä¸å¤ªä¼šç›´æ¥å»åŠ è½½æè´¨è´´å›¾å£°éŸ³è¿™ç§èµ„äº§ï¼Œå› ä¸ºå®ƒä»¬ç»å¤§å¤šæ•°æ˜¯è¢«ä¸»è¦èµ„äº§å¼•ç”¨ç€ã€‚æˆ‘ä»¬åœ¨åŠ è½½ä¸»è¦èµ„äº§çš„æ—¶å€™ï¼Œå°±ä¼šè‡ªå¸¦çš„åŠ è½½è¿™äº›æ¬¡è¦èµ„äº§äº†ã€‚
- SecondaryAssetæŒ‡çš„æ˜¯å…¶ä»–çš„é‚£äº›Assetsäº†ï¼Œä¾‹å¦‚è´´å›¾å’Œå£°éŸ³ç­‰ã€‚è¿™ä¸€ç±»å‹çš„assetsæ˜¯æ ¹æ®PrimaryAssetæ¥è‡ªåŠ¨è¿›è¡Œè½½å…¥çš„ã€‚æˆ‘ä»¬ä¸€èˆ¬æ¥è¯´ä¸å¤ªéœ€è¦å¯¹æ¬¡è¦èµ„äº§è¿›è¡Œç®¡ç†ï¼Œå…¶ä¼šè¢«ä¸»è¦èµ„äº§æ ¹æ®å¼•ç”¨å…³ç³»æ¥è‡ªåŠ¨çš„åŠ è½½ã€‚
- AssetBundleå¯ä»¥å«åšèµ„äº§åŒ…ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªAssetçš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯¹æ¯ä¸ªèµ„äº§åŒ…èµ·ä¸ªåå­—æ¥åŒºåˆ†ï¼Œæ¯”å¦‚UIï¼ŒGameï¼Œè¿™æ ·å…¶å®ä¹Ÿæ˜¯å¯¹ä¸€äº›èµ„äº§è¿›è¡Œæ ‡ç­¾åˆ†ç±»ã€‚è¿™é‡Œçš„Assetæˆ‘ä»¬ä¸åŒºåˆ†æ˜¯PrimaryAssetè¿˜æ˜¯SecondaryAssetï¼Œå› ä¸ºè¿™æ˜¯ä»ç”¨é€”ä¸Šè¿›è¡ŒåŒºåˆ†çš„ï¼Œè€Œä¸æ˜¯åŠ è½½æ–¹å¼ã€‚AssetBundleçš„ä½œç”¨æ˜¯å½“æˆ‘ä»¬åŠ è½½PrimaryAssetçš„æ—¶å€™ï¼Œè¿™ä¸ªPrimaryAssetæœ¬èº«å¯èƒ½å¼•ç”¨ç€å¦å¤–ä¸€äº›SecondaryAssetèµ„äº§ï¼Œå„è‡ªæœ‰ä¸åŒçš„ç”¨é€”ã€‚æˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™äº›SecondaryAssetèµ„äº§åˆ’åˆ†åˆ°ä¸åŒçš„AssetBundleé‡Œï¼Œè¿™æ ·æˆ‘ä»¬åœ¨åŠ è½½PrimaryAssetçš„æ—¶å€™ï¼Œå¯ä»¥é€šè¿‡é¢å¤–æä¾›AssetBundleNameæ¥æ›´åŠ ç²¾ç»†åŒ–çš„æ§åˆ¶SecondaryAssetèµ„äº§çš„åŠ è½½ã€‚
- PrimaryAsseté‡Œçš„æŒ‡å®šAssetBundleçš„Assetå±æ€§å¿…é¡»æ˜¯è½¯å¼•ç”¨ï¼Œå¦åˆ™æ˜¯ç¡¬å¼•ç”¨çš„è¯æ— è®ºå¦‚ä½•ä¹Ÿä¼šè¢«åŠ è½½è¿›æ¥ã€‚è½¯å¼•ç”¨çš„Assetåœ¨é»˜è®¤æ—¶å€™éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨çš„è¿›è¡ŒåŠ è½½ï¼Œé€šè¿‡é™„åŠ AssetBundleï¼Œå°±å¯ä»¥åœ¨åŠ è½½PrimaryAssetçš„æ—¶å€™ï¼Œé™„å¸¦çš„åŠ è½½è¯¥è½¯å¼•ç”¨èµ„äº§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Asset_Item :public UPrimaryDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite,EditAnywhere)
		FString Name;
	UPROPERTY(BlueprintReadWrite, EditAnywhere,meta=(AssetBundles="UI,Game"))
		TSoftObjectPtr<UTexture2D> Icon;
	UPROPERTY(BlueprintReadWrite, EditAnywhere,meta=(AssetBundles="Game"))
		TSoftObjectPtr<UStaticMesh> Mesh;
public:
	virtual FPrimaryAssetId GetPrimaryAssetId() const override;
};
```

## æµ‹è¯•æ•ˆæœï¼š

- é¦–å…ˆæˆ‘ä»¬åœ¨BPé‡Œå®šä¹‰äº†UMyProperty_Asset_Item çš„èµ„äº§ï¼Œå¹¶ç›¸åº”çš„é…ç½®ä¸Šäº†å¼•ç”¨çš„å¯¹è±¡ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œæœ‰ä¸€ä¸ªå›¾æ ‡æ˜¯ç»™UIå’ŒGameç”¨çš„ï¼Œæœ‰ä¸€ä¸ªMeshæ˜¯ä¸“é—¨ç»™Gameç”¨çš„ã€‚å¤§æ¦‚è®¾æƒ³ä¸€ä¸‹åœ¨ä¸€äº›ç•Œé¢æˆ‘ä»¬åªéœ€è¦é“å…·çš„å›¾æ ‡å°±å¯ä»¥äº†ã€‚
- ç„¶ååœ¨LoadPrimaryAssetçš„æ—¶å€™å¯ä»¥æŒ‡å®šLoadBundlesçš„åå­—ï¼Œä»è€ŒåªåŠ è½½ç‰¹å®šçš„Bundleã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚
- å½“æŒ‡å®šBundleä¸ºUIçš„æ—¶å€™ï¼Œå¯ä»¥çœ‹è§Meshå¹¶æ²¡æœ‰åŠ è½½è¿›æ¥ã€‚
- å½“æŒ‡å®šBundleä¸ºGameçš„æ—¶å€™ï¼Œå¯ä»¥çœ‹è§Iconå’ŒMeshéƒ½åŠ è½½äº†è¿›æ¥ã€‚
- è¦æ³¨æ„åœ¨ç¼–è¾‘å™¨ä¸‹æµ‹è¯•æ—¶å€™ï¼Œå¦‚æœä¹‹å‰å·²ç»åŠ è½½äº†Meshï¼Œå› ä¸ºè¿˜å¸¸é©»åœ¨ç¼–è¾‘å™¨å†…å­˜é‡Œã€‚å› æ­¤å³ä½¿æ˜¯ä½¿ç”¨åå­—UIï¼Œä¹Ÿä»ç„¶ä¼šå‘ç°Meshå¯ä»¥è¢«å¼•ç”¨åˆ°ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Object\AssetBundles\AssetBundles.jpg](AssetBundles.jpg)

## åŸç†ï¼š

é¦–å…ˆUPrimaryDataAsseté‡Œæœ‰ä¸€ä¸ªAssetBundleDataä¿å­˜ç€å½“å‰å¼•ç”¨çš„AssetBundleçš„ä¿¡æ¯ï¼Œè¿™ä¸ªä¿¡æ¯æ˜¯åœ¨ç¼–è¾‘å™¨ç¯å¢ƒä¸‹PreSaveçš„æ—¶å€™ä¿å­˜çš„ï¼Œä¼šåœ¨UAssetManager::InitializeAssetBundlesFromMetadataé‡Œè¿›è¡Œmetaçš„åˆ†æå’Œæ˜ å°„ã€‚ä¹‹ååœ¨UAssetManagerçš„LoadPrimaryAssetæ—¶å†…éƒ¨è°ƒç”¨ ChangeBundleStateForPrimaryAssetsï¼Œç„¶åæ£€æŸ¥AssetBundleæŠŠå…¶ä»–é¢å¤–è¦ä¸€å¹¶åŠ è½½çš„Assetæ·»åŠ åˆ°PathsToLoadï¼Œä»è€Œæœ€ç»ˆå®Œæˆä¸€å¹¶åŠ è½½çš„è¿™ä¸ªé€»è¾‘ã€‚

```cpp
void UAssetManager::InitializeAssetBundlesFromMetadata_Recursive(const UStruct* Struct, const void* StructValue, FAssetBundleData& AssetBundle, FName DebugName, TSet<const void*>& AllVisitedStructValues) const
{
	static FName AssetBundlesName = TEXT("AssetBundles");
	static FName IncludeAssetBundlesName = TEXT("IncludeAssetBundles");
	
	//æ ¹æ®å½“å‰å¯¹è±¡çš„å€¼ï¼Œæœç´¢æ‹¥æœ‰AssetBundlesçš„å±æ€§çš„å€¼ï¼Œæœ€åAddBundleAssetï¼ŒBundleNameå°±æ˜¯è®¾ç½®çš„å€¼ï¼Œè€ŒFoundRefæ˜¯å¼•ç”¨çš„å¯¹è±¡çš„èµ„äº§è·¯å¾„
	TSet<FName> BundleSet;
	TArray<const FProperty*> PropertyChain;
	It.GetPropertyChain(PropertyChain);
	
	for (const FProperty* PropertyToSearch : PropertyChain)
	{
					if (PropertyToSearch->HasMetaData(AssetBundlesName))
					{
						TSet<FName> LocalBundleSet;
						TArray<FString> BundleList;
						const FString& BundleString = PropertyToSearch->GetMetaData(AssetBundlesName);
						BundleString.ParseIntoArrayWS(BundleList, TEXT(","));
	
						for (const FString& BundleNameString : BundleList)
						{
							LocalBundleSet.Add(FName(*BundleNameString));
						}
	
						// If Set is empty, initialize. Otherwise intersect
						if (BundleSet.Num() == 0)
						{
							BundleSet = LocalBundleSet;
						}
						else
						{
							BundleSet = BundleSet.Intersect(LocalBundleSet);
						}
		}
}

	for (const FName& BundleName : BundleSet)
	{
					AssetBundle.AddBundleAsset(BundleName, FoundRef.GetAssetPath());
	}
}

#if WITH_EDITORONLY_DATA
void UPrimaryDataAsset::UpdateAssetBundleData()
{
	// By default parse the metadata
	if (UAssetManager::IsInitialized())
	{
		AssetBundleData.Reset();
		UAssetManager::Get().InitializeAssetBundlesFromMetadata(this, AssetBundleData);
	}
}

void UPrimaryDataAsset::PreSave(FObjectPreSaveContext ObjectSaveContext)
{
	Super::PreSave(ObjectSaveContext);

	UpdateAssetBundleData();

	if (UAssetManager::IsInitialized())
	{
		// Bundles may have changed, refresh
		UAssetManager::Get().RefreshAssetData(this);
	}
}
#endif

void UPrimaryDataAsset::PostLoad()
{
	Super::PostLoad();

#if WITH_EDITORONLY_DATA
	FAssetBundleData OldData = AssetBundleData;
	
	UpdateAssetBundleData();

	if (UAssetManager::IsInitialized() && OldData != AssetBundleData)
	{
		// Bundles changed, refresh
		UAssetManager::Get().RefreshAssetData(this);
	}
#endif
}

//åŠ è½½assetçš„æ—¶å€™ï¼Œå¦‚æœæœ‰FAssetBundleEntryï¼Œåˆ™ä¸€èµ·åŠ åˆ°PathsToLoadé‡Œ
TSharedPtr<FStreamableHandle> UAssetManager::ChangeBundleStateForPrimaryAssets(const TArray<FPrimaryAssetId>& AssetsToChange, const TArray<FName>& AddBundles, const TArray<FName>& RemoveBundles, bool bRemoveAllBundles, FStreamableDelegate DelegateToCall, TAsyncLoadPriority Priority)
{
	if (!AssetPath.IsNull())
		{
			// Dynamic types can have no base asset path
			PathsToLoad.Add(AssetPath);
		}
		
		for (const FName& BundleName : NewBundleState)
		{
			FAssetBundleEntry Entry = GetAssetBundleEntry(PrimaryAssetId, BundleName);
		
			if (Entry.IsValid())
			{
				for (const FTopLevelAssetPath & Path : Entry.AssetPaths)
				{
					PathsToLoad.AddUnique(FSoftObjectPath(Path));
				}
			}
			else
			{
				UE_LOG(LogAssetManager, Verbose, TEXT("ChangeBundleStateForPrimaryAssets: No assets for bundle %s::%s"), *PrimaryAssetId.ToString(), *BundleName.ToString());
			}
		}
}
```

å‚è€ƒæ–‡æ¡£ï¼š[https://dev.epicgames.com/documentation/en-us/unreal-engine/asset-management-in-unreal-engine?application_version=5.4](https://dev.epicgames.com/documentation/en-us/unreal-engine/asset-management-in-unreal-engine?application_version=5.4)


ï»¿# CollapsableChildProperties

- **åŠŸèƒ½æè¿°ï¼š** åœ¨TextureGraphæ¨¡å—ä¸­æ–°å¢åŠ çš„metaã€‚ç”¨äºæŠ˜å ä¸€ä¸ªç»“æ„çš„å†…éƒ¨å±æ€§ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TextureGraphæ’ä»¶å†…ä½¿ç”¨
- **å…³è”é¡¹ï¼š** [ShowInnerProperties](ShowInnerProperties/ShowInnerProperties.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

åœ¨TextureGraphæ¨¡å—ä¸­æ–°å¢åŠ çš„metaã€‚ç”¨äºæŠ˜å ä¸€ä¸ªç»“æ„çš„å†…éƒ¨å±æ€§ã€‚

## æºç ï¼š

```cpp
bool STG_GraphPinOutputSettings::CollapsibleChildProperties() const
{
	FProperty* Property = GetPinProperty();
	bool Collapsible = false;
	// check if there is a display name defined for the property, we use that as the Pin Name
	if (Property && Property->HasMetaData("CollapsableChildProperties"))
	{
		Collapsible = true;
	}
	return Collapsible;
}

	UPROPERTY(EditAnywhere, Category = NoCategory, meta = (TGType = "TG_Input", CollapsableChildProperties,ShowOnlyInnerProperties, FullyExpand, NoResetToDefault, PinDisplayName = "Settings") )
	FTG_OutputSettings OutputSettings;
```


ï»¿# DisplayThumbnail

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ˜¯å¦åœ¨è¯¥å±æ€§å·¦ä¾§æ˜¾ç¤ºä¸€ä¸ªç¼©ç•¥å›¾ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [ThumbnailSize](../ThumbnailSize.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šæ˜¯å¦åœ¨è¯¥å±æ€§å·¦ä¾§æ˜¾ç¤ºä¸€ä¸ªç¼©ç•¥å›¾ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_Thumbnail_Test :public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (DisplayThumbnail = "false"))
	UObject* MyObject;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (DisplayThumbnail = "true"))
	UObject* MyObject_DisplayThumbnail;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	AActor* MyActor;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (DisplayThumbnail = "true"))
	AActor* MyActor_DisplayThumbnail;
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyObject_DisplayThumbnailçš„å·¦ä¾§æ˜¾ç¤ºå‡ºäº†æ‰€é€‰æ‹©èµ„äº§çš„ç¼©ç•¥å›¾ï¼Œè€ŒMyObjectå› ä¸ºè®¾ç½®äº†falseå› æ­¤æ˜¯æ²¡æœ‰çš„ã€‚å¦‚æœä¸è®¾ç½®DisplayThumbnail =falseï¼Œåˆ™é»˜è®¤ä¹Ÿæ˜¯ä¼šæ˜¾ç¤ºç¼©ç•¥å›¾çš„ã€‚

MyActor_DisplayThumbnailå‡ºç°äº†ç¼©ç•¥å›¾çš„å›¾æ ‡ï¼Œä½†æ˜¯å‘ç°å¹¶æ²¡æœ‰æ˜¾ç¤ºå‡ºæ­£ç¡®çš„è¯´äº†å›¾ã€‚AActoråœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸æ˜¾ç¤ºç¼©ç•¥å›¾çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\DisplayThumbnail\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­æ˜¯å¦è¦æ˜¾ç¤ºç¼©ç•¥å›¾å°±åœ¨è¿™ä¸ªå‡½æ•°ã€‚

é»˜è®¤æƒ…å†µä¸‹éActorç±»å‹æ‰ä¼šæ˜¾ç¤ºã€‚å¦å¤–SPropertyEditorAssetæ˜¯ç”¨åœ¨èµ„äº§ç±»å‹å±æ€§ä¸Šçš„ï¼Œå…¶å®å°±æ˜¯Objectå±æ€§ã€‚

```cpp
bool SPropertyEditorAsset::ShouldDisplayThumbnail(const FArguments& InArgs, const UClass* InObjectClass) const
{
	if (!InArgs._DisplayThumbnail || !InArgs._ThumbnailPool.IsValid())
	{
		return false;
	}

	bool bShowThumbnail = InObjectClass == nullptr || !InObjectClass->IsChildOf(AActor::StaticClass());

	// also check metadata for thumbnail & text display
	const FProperty* PropertyToCheck = nullptr;
	if (PropertyEditor.IsValid())
	{
		PropertyToCheck = PropertyEditor->GetProperty();
	}
	else if (PropertyHandle.IsValid())
	{
		PropertyToCheck = PropertyHandle->GetProperty();
	}

	if (PropertyToCheck != nullptr)
	{
		PropertyToCheck = GetActualMetadataProperty(PropertyToCheck);

		return GetTagOrBoolMetadata(PropertyToCheck, TEXT("DisplayThumbnail"), bShowThumbnail);
	}

	return bShowThumbnail;
}
```


ï»¿# ExposeFunctionCategories

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥Objectå±æ€§æ‰€å±äºçš„ç±»é‡Œçš„æŸäº›ç›®å½•ä¸‹çš„å‡½æ•°å¯ä»¥ç›´æ¥åœ¨æœ¬ç±»ä¸Šæš´éœ²å‡ºæ¥ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥Objectå±æ€§æ‰€å±äºçš„ç±»é‡Œçš„æŸäº›ç›®å½•ä¸‹çš„å‡½æ•°å¯ä»¥ç›´æ¥åœ¨æœ¬ç±»ä¸Šæš´éœ²å‡ºæ¥ã€‚

ä¸€å¼€å§‹ç›´æ¥è¿˜æŒºéš¾ç†è§£çš„å…¶å«ä¹‰å’Œä½œç”¨çš„ï¼Œä½†è¿™å…¶å®æ˜¯ä¸€ä¸ªä¾¿åˆ©æ€§çš„åŠŸèƒ½è€Œå·²ã€‚æ¯”å¦‚æœ‰ç±»Aé‡Œé¢å®šä¹‰ä¸€äº›å‡½æ•°ï¼Œç„¶åç±»Bé‡Œæœ‰ä¸ªAçš„å¯¹è±¡ã€‚è¿™ä¸ªæ—¶å€™å¦‚æœæƒ³åœ¨Bå¯¹è±¡èº«ä¸Šå»è°ƒç”¨Açš„å‡½æ•°ï¼Œå°±å¾—æ‰‹åŠ¨å…ˆæ‹–æ‹‰å‡ºB.ObjAç„¶åå†æ‹–æ‹‰å‡ºå…¶å†…éƒ¨çš„å‡½æ•°ã€‚æˆ‘ä»¬å¸Œæœ›æŠŠå½“å‰Bçš„åº”ç”¨ä¸Šä¸‹æ–‡åœºæ™¯ä¸‹ï¼Œå¯ä»¥æŠŠAé‡Œçš„æŸäº›å‡½æ•°ç›´æ¥æ¯”è¾ƒæ–¹ä¾¿çš„æš´éœ²åˆ°Bé‡Œæ¥è°ƒç”¨ã€‚

å…¶å®å°±æ˜¯å¼•æ“å¸®æˆ‘ä»¬è‡ªåŠ¨çš„æ‹–æ‹‰å‡ºB.ObjAè¿™ä¸€æ­¥æ“ä½œè€Œå·²ã€‚ä½ å¦‚æœæƒ³è¦è°ƒç”¨Aé‡Œçš„æ›´å¤šçš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥è‡ªå·±æ‰‹åŠ¨åœ¨B.ObjAèº«ä¸Šæ‹–æ‹‰å³é”®å‡ºæ›´å¤šçš„å‡½æ•°ã€‚

æºç é‡Œè¿™ç§åº”ç”¨ä¹Ÿæ¯”è¾ƒå¤šï¼Œæ¯”è¾ƒæ–¹ä¾¿çš„ä¾‹å­æ˜¯ä»¥ä¸‹æºç ä¾‹å­ï¼Œè¿™æ ·å½“å‰åœ¨ASkeletalMeshActor èº«ä¸Šå°±å¯ä»¥ç›´æ¥æ‹–æ‹‰å‡ºUSkeletalMeshComponenté‡ŒExposeFunctionCategories æ‰€å®šä¹‰çš„ç›®å½•çš„å‡½æ•°ã€‚

```cpp
UCLASS(ClassGroup=ISkeletalMeshes, Blueprintable, ComponentWrapperClass, ConversionRoot, meta=(ChildCanTick), MinimalAPI)
class ASkeletalMeshActor : public AActor
{
private:
	UPROPERTY(Category = SkeletalMeshActor, VisibleAnywhere, BlueprintReadOnly, meta = (ExposeFunctionCategories = "Mesh,Components|SkeletalMesh,Animation,Physics", AllowPrivateAccess = "true"))
	TObjectPtr<class USkeletalMeshComponent> SkeletalMeshComponent;
}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_ExposeFunctionCategories :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Category = "FirstFunc")
	void MyExposeFunc1() {}
	UFUNCTION(BlueprintCallable, Category = "SecondFunc")
	void MyExposeFunc2() {}
	UFUNCTION(BlueprintCallable, Category = "ThirdFunc")
	void MyExposeFunc3() {}
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_ExposeFunctionCategories_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadOnly, meta = (ExposeFunctionCategories = "FirstFunc,ThirdFunc"))
	UMyProperty_ExposeFunctionCategories* MyObject_Expose;
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥è§åˆ°åœ¨UMyProperty_ExposeFunctionCategories_Test ç±»å‹çš„Objectèº«ä¸Šï¼Œæˆ‘ç›´æ¥è¾“å…¥MyExposeFuncå°±å¯ä»¥å¼¹å‡ºâ€œFirstFuncï¼ŒThirdFuncâ€è¿™ä¸¤ä¸ªç›®å½•é‡Œçš„è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œè€Œä¸ä¼šç›´æ¥å¼¹å‡ºMyExposeFunc2ï¼Œå› ä¸ºå…¶æ²¡æœ‰ç›´æ¥è¢«æš´éœ²å‡ºæ¥ã€‚

è€Œå¦‚æœåœ¨MyObject_Exposeè¿™ç§å†…éƒ¨å¯¹è±¡ä¸Šç›´æ¥æ‹–æ‹‰å³é”®ï¼Œåˆ™å¯ä»¥è§åˆ°æ‰€æœ‰å†…éƒ¨å®šä¹‰çš„å‡½æ•°ã€‚æ³¨æ„è¿™é‡Œè™½ç„¶æœ‰ä¸¤ä¸ªæ¡ç›®çš„MyExposeFunc1ï¼Œä½†å…¶å®è°ƒç”¨å‡ºæ¥çš„æ˜¯åŒä¸€ä¸ªå‡½æ•°ï¼Œå®é™…å¹¶æ²¡æœ‰å½±å“ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\ExposeFunctionCategories\Untitled.png)

## åŸç†ï¼š

åœ¨è“å›¾å³é”®èœå•çš„æ„å»ºè¿‡ç¨‹ä¸­ï¼Œä¼šåˆ¤æ–­æŸä¸ªæ“ä½œæ˜¯å¦è¦è¿‡æ»¤æ‰ã€‚è¿™é‡Œçš„IsUnexposedMemberActionå°±æ˜¯åˆ¤æ–­è¿™ä¸ªå‡½æ•°æ˜¯å¦åº”è¯¥è¢«è¿‡æ»¤æ‰ã€‚å¤§è‡´çš„é€»è¾‘æ˜¯å–å¾—å…¶å‡½æ•°å¯¹åº”çš„å±æ€§ï¼Œæ¯”å¦‚åœ¨UMyProperty_ExposeFunctionCategories_Test è¿™ä¸ªObjectèº«ä¸Šï¼Œé€’å½’åˆ°å­å¯¹è±¡ï¼Œå…¶å®æœ‰3ä¸ªå‡½æ•°ä¼šè¿›æ¥å‚åŠ æµ‹è¯•ã€‚è¿™3ä¸ªå‡½æ•°ï¼ˆMyExposeFunc 1 2 3ï¼‰å„è‡ªæœ‰è‡ªå·±çš„Categoryï¼Œä½†éƒ½å¯¹åº”MyObject_Exposeè¿™ä¸ªPropertyï¼Œå› æ­¤å…¶AllExposedCategoriesçš„å€¼æ˜¯æˆ‘ä»¬å®šä¹‰çš„â€œFirstFunc,ThirdFuncâ€æ•°ç»„ï¼Œæœ€ç»ˆåªæœ‰ä¸¤ä¸ªå‡½æ•°é€šè¿‡æµ‹è¯•ï¼Œå› æ­¤æœ€åæ˜¾ç¤º1ï¼Œ3ä¸¤ä¸ªå‡½æ•°ã€‚

```cpp
static bool BlueprintActionMenuUtilsImpl::IsUnexposedMemberAction(FBlueprintActionFilter const& Filter, FBlueprintActionInfo& BlueprintAction)
{
	bool bIsFilteredOut = false;

	if (UFunction const* Function = BlueprintAction.GetAssociatedFunction())
	{
		TArray<FString> AllExposedCategories;
		for (FBindingObject Binding : BlueprintAction.GetBindings())
		{
			if (FProperty* Property = Binding.Get<FProperty>())
			{
				const FString& ExposedCategoryMetadata = Property->GetMetaData(FBlueprintMetadata::MD_ExposeFunctionCategories);
				if (ExposedCategoryMetadata.IsEmpty())
				{
					continue;
				}

				TArray<FString> PropertyExposedCategories;
				ExposedCategoryMetadata.ParseIntoArray(PropertyExposedCategories, TEXT(","), true);
				AllExposedCategories.Append(PropertyExposedCategories);
			}
		}

		const FString& FunctionCategory = Function->GetMetaData(FBlueprintMetadata::MD_FunctionCategory);
		bIsFilteredOut = !AllExposedCategories.Contains(FunctionCategory);
	}
	return bIsFilteredOut;
}
```


ï»¿# FullyExpand

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [ShowInnerProperties](ShowInnerProperties/ShowInnerProperties.md)

ä½†æ˜¯æ²¡æœ‰å‘ç°è¯¥Metaè¢«ä½¿ç”¨çš„åŸç†ä»£ç ã€‚

åœ¨æºç ä¸­æœç´¢å‘ç°æœ‰å¤šå¤„åº”ç”¨ï¼Œä½†å®é™…ä¸Šæ²¡æœ‰åŸç†ä»£ç ã€‚

```cpp
	/** The options that are available on the node. */
	UPROPERTY(EditAnywhere, Instanced, Category = "Options", meta=(ShowInnerProperties, FullyExpand="true"))
	TObjectPtr<UMovieGraphValueContainer> SelectOptions;

	/** The currently selected option. */
	UPROPERTY(EditAnywhere, Instanced, Category = "Options", meta=(ShowInnerProperties, FullyExpand="true"))
	TObjectPtr<UMovieGraphValueContainer> SelectedOption;
```


ï»¿# HideAssetPicker

- **åŠŸèƒ½æè¿°ï¼š** éšè—Objectç±»å‹å¼•è„šä¸Šçš„AssetPickerçš„é€‰æ‹©åˆ—è¡¨
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

éšè—Objectç±»å‹å¼•è„šä¸Šçš„AssetPickerçš„é€‰æ‹©åˆ—è¡¨ã€‚è¿™åœ¨æœ‰æ—¶æˆ‘ä»¬åªæ˜¯æƒ³è¦è‡ªå·±ä¼ é€’Objectå¼•ç”¨ï¼Œä¸å¸Œæœ›ç”¨æˆ·é€‰æ‹©åˆ°å¼•æ“é‡Œåˆ«çš„èµ„äº§çš„æ—¶å€™ä¼šæ¯”è¾ƒæœ‰ç”¨ã€‚å› ä¸ºAssetç±»å‹å…¶å®ä¹Ÿæ˜¯Objectï¼Œå› æ­¤å¯¹äºObjectå¼•ç”¨ç±»å‹çš„å‚æ•°å«åšHideAssetPickerã€‚

åœ¨æºç é‡Œå¹¶æ²¡æœ‰æ‰¾åˆ°æœ‰ä½¿ç”¨çš„åœ°æ–¹ï¼Œä½†æ˜¯è¿™ä¸ªåŠŸèƒ½æ˜¯å¯ç”¨çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable)
	static void MyFunc_NoHideAssetPicker(UObject* ObjectClass) {}

	UFUNCTION(BlueprintCallable, meta = (HideAssetPicker = "ObjectClass"))
	static void MyFunc_HideAssetPicker(UObject* ObjectClass) {}
```

## è“å›¾æ•ˆæœï¼š

é»˜è®¤çš„æƒ…å†µMyFunc_NoHideAssetPickeræ˜¯å¯ä»¥å¼¹å‡ºé€‰æ‹©åˆ—è¡¨çš„ã€‚è€ŒMyFunc_HideAssetPickeråˆ™å°±éšè—äº†èµ·æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\HideAssetPicker\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­ä¸€ä¸ªå‡½æ•°å¼•è„šæ˜¯å¦å…è®¸æ‰“å¼€AssetPickerçš„é€»è¾‘æ˜¯ï¼š

- å¿…é¡»æ˜¯ä¸ªobject ç±»å‹
- å¦‚æœæ˜¯UActorComponentåˆ™ä¸æ˜¾ç¤º
- å¦‚æœæ˜¯Actorç±»å‹ï¼Œé‚£ä¹ˆå¾—åœ¨å…³å¡è“å›¾ä¸­ï¼Œä¸”è¯¥Actoræ˜¯placeableçš„æ‰æ˜¾ç¤ºã€‚
- å¦‚æœç”¨HideAssetPickeræ˜¾å¼æŒ‡å®šäº†è¯¥å‚æ•°ï¼Œåˆ™è¯¥å‚æ•°ä¹Ÿä¸æ˜¾ç¤ºã€‚

```cpp
bool UEdGraphSchema_K2::ShouldShowAssetPickerForPin(UEdGraphPin* Pin) const
{
	bool bShow = true;
	if (Pin->PinType.PinCategory == PC_Object)
	{
		UClass* ObjectClass = Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get());
		if (ObjectClass)
		{
			// Don't show literal buttons for component type objects
			bShow = !ObjectClass->IsChildOf(UActorComponent::StaticClass());

			if (bShow && ObjectClass->IsChildOf(AActor::StaticClass()))
			{
				// Only show the picker for Actor classes if the class is placeable and we are in the level script
				bShow = !ObjectClass->HasAllClassFlags(CLASS_NotPlaceable)
							&& FBlueprintEditorUtils::IsLevelScriptBlueprint(FBlueprintEditorUtils::FindBlueprintForNode(Pin->GetOwningNode()));
			}

			if (bShow)
			{
				if (UK2Node_CallFunction* CallFunctionNode = Cast<UK2Node_CallFunction>(Pin->GetOwningNode()))
				{
					if (UFunction* FunctionRef = CallFunctionNode->GetTargetFunction())
					{
						const UEdGraphPin* WorldContextPin = CallFunctionNode->FindPin(FunctionRef->GetMetaData(FBlueprintMetadata::MD_WorldContext));
						bShow = ( WorldContextPin != Pin );

						// Check if we have explictly marked this pin as hiding the asset picker
						const FString& HideAssetPickerMetaData = FunctionRef->GetMetaData(FBlueprintMetadata::MD_HideAssetPicker);
						if(!HideAssetPickerMetaData.IsEmpty())
						{
							TArray<FString> PinNames;
							HideAssetPickerMetaData.ParseIntoArray(PinNames, TEXT(","), true);
							const FString PinName = Pin->GetName();
							for(FString& ParamNameToHide : PinNames)
							{
								ParamNameToHide.TrimStartAndEndInline();
								if(ParamNameToHide == PinName)
								{
									bShow = false;
									break;
								}
							}
						}
					}
				}
				else if (Cast<UK2Node_CreateDelegate>( Pin->GetOwningNode())) 
				{
					bShow = false;
				}
			}
		}
	}
	return bShow;
}

```


ï»¿# IncludeAssetBundles

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºUPrimaryDataAssetçš„å­å¯¹è±¡å±æ€§ï¼ŒæŒ‡å®šåº”è¯¥ç»§ç»­é€’å½’åˆ°è¯¥å­å¯¹è±¡é‡Œå»æ¢æµ‹AssetBundleæ•°æ®ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UPrimaryDataAssetå†…éƒ¨çš„ObjectPtrå±æ€§
- **å…³è”é¡¹ï¼š** [AssetBundles](../AssetBundles/AssetBundles.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨äºUPrimaryDataAssetçš„å­å¯¹è±¡å±æ€§ï¼ŒæŒ‡å®šåº”è¯¥ç»§ç»­é€’å½’åˆ°è¯¥å­å¯¹è±¡é‡Œå»æ¢æµ‹AssetBundleæ•°æ®ã€‚

è¿™æ ·è¿™äº›æŒ‡å¯¹è±¡å†…éƒ¨çš„ FSoftObjectPtr æˆ– FSoftObjectPath å±æ€§ï¼Œå…¶ä¸Šé¢æ ‡æ˜çš„AssetBundleçš„æ•°æ®æ‰ä¼šè¢«è§£ææ·»åŠ åˆ°UPrimaryDataAssetçš„AssetBundleDataé‡Œã€‚

- é»˜è®¤æƒ…å†µä¸‹ï¼ŒInitializeAssetBundlesFromMetadata_Recursiveåªä¼šåˆ†æåˆ°UPrimaryDataAssetçš„æœ¬èº«è¿™ä¸€å±‚çº§çš„å±æ€§ï¼Œæ¯”å¦‚ä¸‹é¢çš„Iconå’ŒMeshå±æ€§ã€‚
- è€Œå¦‚æœå†åµŒå¥—äº†ä¸€å±‚ï¼Œå°±æ˜¯UPrimaryDataAssetä¸‹é¢æ‹¥æœ‰åªå¯¹è±¡ï¼ŒUMyProperty_Asset_ChildObjectï¼Œè€ŒUMyProperty_Asset_ChildObject é‡Œé¢åˆåŒ…å«FSoftObjectPath ï¼Œå¸Œæœ›å®ƒè¢«å±äºAssetBundles çš„ä¸€éƒ¨åˆ†ï¼Œåœ¨åŠ è½½UPrimaryDataAssetçš„æ—¶å€™åŒæ—¶ä¸€å¹¶åŠ è½½ã€‚è¿™ä¸ªæ—¶å€™å°±éœ€è¦å‘Šè¯‰å¼•æ“éœ€è¦ç»§ç»­åˆ†æè¿™ä¸ªå­å¯¹è±¡ã€‚
- æ³¨æ„åˆ°UMyProperty_Asset_ChildObjectæˆ‘éƒ½æ˜¯ç”¨TObjectPtrï¼Œæ˜¯ä¸ªç¡¬å¼•ç”¨ï¼Œè¯¥å¯¹è±¡åœ¨UMyProperty_Asset_Item è¢«åŠ è½½çš„æ—¶å€™ä¹Ÿä¼šè‡ªç„¶è¢«åŠ è½½è¿›æ¥ã€‚å› æ­¤æ— è®ºå¦‚ä½•ï¼ŒUMyProperty_Asset_ChildObject éƒ½ä¼šè¢«åŠ è½½è¿›æ¥ã€‚ä½†æ˜¯UMyProperty_Asset_ChildObject å†…éƒ¨çš„ChildIconæ˜¯ç”¨TSoftObjectPtrï¼Œæ˜¯è½¯å¼•ç”¨ï¼Œå› æ­¤å¿…é¡»ä¾èµ–AssetBundleçš„æœºåˆ¶æ‰ä¼šè¢«åŠ è½½ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Asset_ChildObject :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (AssetBundles = "Client"))
	TSoftObjectPtr<UTexture2D> ChildIcon;
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Asset_Item :public UPrimaryDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString Name;
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (AssetBundles = "UI,Game"))
	TSoftObjectPtr<UTexture2D> Icon;
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (AssetBundles = "Game"))
	TSoftObjectPtr<UStaticMesh> Mesh;

public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TObjectPtr<UMyProperty_Asset_ChildObject> MyChildObject_NotIncludeAssetBundles;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (IncludeAssetBundles))
	TObjectPtr<UMyProperty_Asset_ChildObject> MyChildObject_IncludeAssetBundles;
public:
	virtual FPrimaryAssetId GetPrimaryAssetId() const override;
};
```

## æµ‹è¯•æ•ˆæœï¼š

é…ç½®çš„æ•°æ®å›¾çš„ä¸‹éƒ¨åˆ†ï¼Œåˆ†åˆ«é…ç½®äº†ä¸¤å¼ å›¾ç‰‡ã€‚ä½†åœ¨LoadPrimaryAssetåï¼Œåªæœ‰MyChildObject_IncludeAssetBundleså†…éƒ¨çš„ChildIconæ‰è¢«åŠ è½½è¿›æ¥ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Object\IncludeAssetBundles\IncludeAssetBundles.jpg](IncludeAssetBundles.jpg)

å¦‚æœåˆ†æUMyProperty_Asset_Item çš„AssetBunbleDataæ•°æ®ï¼Œä¼šå‘ç°å…¶ClientåªåŒ…å«ç¬¬äºŒå¼ Stoneå›¾ç‰‡çš„è·¯å¾„ã€‚è¿™æ˜¯å› ä¸ºåªæœ‰ç¬¬äºŒå¼ å›¾ç‰‡æ‰è¢«åˆ†æåˆ°å¹¶åŒ…å«è¿›æ¥ã€‚

```cpp
{
				BundleName = "Client";
				BundleAssets =
				{
					{
						AssetPath =
						{
							PackageName = "/Game/Asset/Image/T_Shop_Stone";
							AssetName = "T_Shop_Stone";
						};
						SubPathString = "";
					};
				},
				AssetPaths =
				{
					{
						PackageName = "/Game/Asset/Image/T_Shop_Stone";
						AssetName = "T_Shop_Stone";
					};
				},
			};
```

## åŸç†ï¼š

UPrimaryDataAssetä¸‹çš„å±æ€§å¦‚æœæ˜¯ä¸ªObjectå±æ€§ï¼Œåªå½“æœ‰IncludeAssetBundlesçš„æ—¶å€™ï¼Œæ‰ä¼šè¿›ä¸€æ­¥é€’å½’å‘ä¸‹æ¢æµ‹ã€‚

```cpp
void UAssetManager::InitializeAssetBundlesFromMetadata_Recursive(const UStruct* Struct, const void* StructValue, FAssetBundleData& AssetBundle, FName DebugName, TSet<const void*>& AllVisitedStructValues) const
{
	static FName AssetBundlesName = TEXT("AssetBundles");
	static FName IncludeAssetBundlesName = TEXT("IncludeAssetBundles");
	
	//æ ¹æ®å½“å‰å¯¹è±¡çš„å€¼ï¼Œæœç´¢æ‹¥æœ‰AssetBundlesçš„å±æ€§çš„å€¼ï¼Œæœ€åAddBundleAssetï¼ŒBundleNameå°±æ˜¯è®¾ç½®çš„å€¼ï¼Œè€ŒFoundRefæ˜¯å¼•ç”¨çš„å¯¹è±¡çš„èµ„äº§è·¯å¾„
	else if (const FObjectProperty* ObjectProperty = CastField<FObjectProperty>(Property))
	{
		if (ObjectProperty->PropertyFlags & CPF_InstancedReference || ObjectProperty->GetOwnerProperty()->HasMetaData(IncludeAssetBundlesName))
		{
			const UObject* Object = ObjectProperty->GetObjectPropertyValue(PropertyValue);
			if (Object != nullptr)
			{
				InitializeAssetBundlesFromMetadata_Recursive(Object->GetClass(), Object, AssetBundle, Object->GetFName(), AllVisitedStructValues);
			}
		}
	}
}
```


ï»¿# LoadBehavior

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨UCLASSä¸Šæ ‡è®°è¿™ä¸ªç±»çš„åŠ è½½è¡Œä¸ºï¼Œä½¿å¾—ç›¸åº”çš„TObjectPtrå±æ€§æ”¯æŒå»¶è¿ŸåŠ è½½ã€‚å¯é€‰çš„åŠ è½½è¡Œä¸ºé»˜è®¤ä¸ºEagerï¼Œå¯æ”¹ä¸ºLazyOnDemandã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TObjectPtr 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ç”¨åœ¨UCLASSä¸Šæ ‡è®°è¿™ä¸ªç±»çš„åŠ è½½è¡Œä¸ºï¼Œä½¿å¾—ç›¸åº”çš„TObjectPtrå±æ€§æ”¯æŒå»¶è¿ŸåŠ è½½ã€‚å¯é€‰çš„åŠ è½½è¡Œä¸ºé»˜è®¤ä¸ºEagerï¼Œå¯æ”¹ä¸ºLazyOnDemandã€‚

- é»˜è®¤Eagerçš„é€»è¾‘å’Œæˆ‘ä»¬å¸¸è§çš„èµ„æºç¡¬å¼•ç”¨çš„é€»è¾‘ç›¸åŒï¼Œå°±æ˜¯å¦‚æœAç¡¬å¼•ç”¨äº†Bï¼Œåœ¨åŠ è½½Açš„æ—¶å€™å°±ä¼šé€’å½’æŠŠBä¹ŸåŠ è½½è¿›æ¥ã€‚
- æ”¹ä¸ºLazyOnDemandçš„é€»è¾‘æ˜¯åªæœ‰åœ¨è¿™ä¸ªèµ„æºçœŸæ­£è¢«éœ€è¦ï¼ˆè§¦å‘Getï¼‰çš„æ—¶å€™æ‰ä¼šå»åŠ è½½è¯¥èµ„æºã€‚è¿™ä¹Ÿæ˜¯ç§ç¡¬å¼•ç”¨ï¼Œä½†æ˜¯æ˜¯å»¶è¿ŸåŠ è½½çš„ã€‚åŒæ ·Aç¡¬å¼•ç”¨äº†Bï¼Œåœ¨åŠ è½½Açš„æ—¶å€™ï¼Œä¸ä¼šç›´æ¥ç«‹é©¬å°±åŠ è½½Bï¼Œè€Œæ˜¯å…ˆè®°å½•ä¸‹æ¥è¿™ä¸ªå¼•ç”¨å…³ç³»ä¿¡æ¯ï¼ˆBçš„ObjectPathï¼‰ã€‚åœ¨Aé‡ŒçœŸæ­£éœ€è¦è®¿é—®Bçš„æ—¶å€™ï¼Œè¿™ä¸ªæ—¶å€™å› ä¸ºå·²ç»äº‹å…ˆè®°å½•çŸ¥é“äº†Båœ¨å“ªé‡Œï¼Œå› æ­¤å°±å¯ä»¥åœ¨è¿™ä¸ªæ—¶å€™å†å»æŠŠBåŠ è½½è¿›æ¥ã€‚å¦‚æœåŠ è½½çš„å¤Ÿå¿«ï¼Œå¯¹ç”¨æˆ·æ˜¯æ— æ„Ÿçš„ã€‚LazyOnDemandåªåœ¨ç¼–è¾‘å™¨ä¸‹ç”Ÿæ•ˆï¼Œè¿™ä¹ˆåšçš„å¥½å¤„æ˜¯å¯ä»¥å°½å¿«çš„æ‰“å¼€ç¼–è¾‘å™¨ï¼Œè€Œä¸æ˜¯ç­‰å¾…æ‰€æœ‰èµ„æºéƒ½åŠ è½½è¿›æ¥ã€‚å› ä¸ºå…¶å®å¹¶ä¸æ˜¯æ‰€æœ‰èµ„æºéƒ½è¦ç¬¬ä¸€æ—¶é—´åŠ è½½è§£æè¿›æ¥è®¿é—®ã€‚
- åŒFSoftObjectPtrçš„åŒºåˆ«æ˜¯åè€…æ˜¯è½¯å¼•ç”¨ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨çš„è‡ªå·±åˆ¤æ–­æ—¶æœºåŠ è½½ã€‚è€ŒLazyOnDemandæ˜¯è‡ªåŠ¨çš„å»¶è¿ŸåŠ è½½ï¼Œç”¨æˆ·æ˜¯æ— æ„Ÿçš„ï¼Œä¸éœ€è¦åšé¢å¤–çš„æ“ä½œã€‚
- LoadBehavioråªä½œç”¨äºTObjectPtrå±æ€§ï¼ŒUObject*å±æ€§æ€»æ˜¯ç›´æ¥éƒ½åŠ è½½çš„ã€‚å› ä¸ºåªæœ‰TObjectPtré‡Œå®ç°äº†UObject*çš„å¼•ç”¨è·¯å¾„ä¿¡æ¯ç¼–ç ï¼Œæ‰å¯ä»¥æ”¯æŒå»¶è¿ŸåŠ è½½ã€‚
- LoadBehaviorä¹Ÿåªæ”¯æŒåœ¨ç¼–è¾‘å™¨ç¯å¢ƒã€‚å› ä¸ºåœ¨Runtimeï¼ŒTObjectPträ¼šé€€åŒ–æˆUObject*ï¼Œä¹Ÿå°±å…¨éƒ¨éƒ½æ˜¯ç›´æ¥åŠ è½½äº†ã€‚
- LoadBehaviorä¸€èˆ¬æ ‡è®°åœ¨èµ„äº§ç±»å‹çš„ç±»ä¸Šã€‚æºç é‡Œæ ‡è®°çš„ç±»æœ‰ï¼šDataAsset,DataTable,CurveTable,SoundCue,SoundWave,DialogueWave,AnimMontageã€‚å› æ­¤å‡å¦‚ä½ è‡ªå·±è‡ªå®šä¹‰äº†èµ„äº§ç±»ï¼Œä¹ŸåŒ…å«äº†è®¸å¤šæ•°æ®ï¼Œå°±å¯ä»¥ç”¨LazyOnDemandæ¥ä¼˜åŒ–åœ¨ç¼–è¾‘å™¨ä¸‹çš„åŠ è½½é€Ÿåº¦ã€‚
- è¦æµ‹è¯•LoadBehaviorï¼Œè¦æ‰“å¼€å¼•æ“çš„çš„LazyLoadImportsåŠŸèƒ½ï¼Œé»˜è®¤æƒ…å†µä¸‹æ˜¯å…³é—­çš„ã€‚æ‰“å¼€çš„æ–¹å¼å¯åœ¨DefaultEngine.iniä¸‹å¢åŠ Core.System.ExperimentalèŠ‚ä¸‹LazyLoadImports=Trueçš„è®¾ç½®ã€‚æºç å¯å‚è€ƒIsImportLazyLoadEnabledè¿™ä¸ªæ–¹æ³•ã€‚
- åœ¨æµ‹è¯•çš„æ—¶å€™ï¼Œè¦å°å¿ƒå¦‚æœæ˜¯åŒå‡»æ‰“å¼€DataAssetèµ„äº§ï¼Œå› ä¸ºåœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œè¦å±•ç¤ºå±æ€§çš„å€¼ï¼Œåœ¨å±æ€§ä¸Šä¼šè°ƒç”¨GetObjectPropertyValue_InContainerï¼Œå› æ­¤ä¼šè§¦å‘ObjectHandleResolveï¼Œå¯¼è‡´TObjectPtrçš„Resolveã€‚

## æµ‹è¯•ä»£ç ï¼š

å¦‚ä¸‹ä¸“é—¨å®šä¹‰äº†UMyDataAsset_Eager å’ŒUMyDataAsset_LazyOnDemand ä¸¤ç§DataAssetï¼Œå¹¶æ ‡æ³¨äº†ä¸åŒçš„LoadBehavior ä»¥åšå¯¹æ¯”ã€‚

```cpp
//(BlueprintType = true, IncludePath = Property/MyProperty_Asset.h, IsBlueprintBase = true, LoadBehavior = Eager, ModuleRelativePath = Property/MyProperty_Asset.h)
UCLASS(Blueprintable, Blueprintable, meta = (LoadBehavior = "Eager"))
class INSIDER_API UMyDataAsset_Eager :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float Score;
};

//(BlueprintType = true, IncludePath = Property/MyProperty_Asset.h, IsBlueprintBase = true, LoadBehavior = LazyOnDemand, ModuleRelativePath = Property/MyProperty_Asset.h)
UCLASS(Blueprintable, Blueprintable, meta = (LoadBehavior = "LazyOnDemand"))
class INSIDER_API UMyDataAsset_LazyOnDemand :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float Score;
};

UCLASS(BlueprintType)
class INSIDER_API UMyClass_LoadBehaviorTest :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TObjectPtr<UMyDataAsset_LazyOnDemand> MyLazyOnDemand_AssetPtr;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	TObjectPtr<UMyDataAsset_Eager> MyEager_AssetPtr;

public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere,meta = (LoadBehavior = "Eager"))
	TObjectPtr<UMyDataAsset_LazyOnDemand> MyLazyOnDemand_AssetPtr_EagerOnProperty;

	UPROPERTY(BlueprintReadWrite, EditAnywhere,meta = (LoadBehavior = "LazyOnDemand"))
	TObjectPtr<UMyDataAsset_Eager> MyEager_AssetPtr_LazyOnDemandOnProperty;

public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	UMyDataAsset_LazyOnDemand* MyLazyOnDemand_Asset;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	UMyDataAsset_Eager* MyEager_Asset;

public:
	UFUNCTION(BlueprintCallable)
	static void LoadBehaviorTest();
};

void UMyClass_LoadBehaviorTest::LoadBehaviorTest()
{
	UPackage* pk = LoadPackage(nullptr, TEXT("/Game/Class/Behavior/LoadBehavior/DA_LoadBehaviorTest"), 0);
	UMyClass_LoadBehaviorTest* obj = LoadObject<UMyClass_LoadBehaviorTest>(pk, TEXT("DA_LoadBehaviorTest"));
}

//å¼€å¯åŠŸèƒ½
DefaultEngine.ini
[Core.System.Experimental]
LazyLoadImports=True
```

## æµ‹è¯•ç»“æœï¼š

åœ¨ç¼–è¾‘å™¨è¿è¡Œèµ·æ¥ä¹‹åï¼Œæ‰‹åŠ¨è°ƒç”¨LoadBehaviorTestæ¥åŠ è½½è¿™ä¸ªUMyClass_LoadBehaviorTest çš„DataAssetã€‚æŸ¥çœ‹ä¸åŒç±»å‹å±æ€§çš„å¯¹è±¡å€¼ã€‚å¯ä»¥å‘ç°ï¼š

- å…¶ä¸­MyLazyOnDemand_AssetPtrå’ŒMyLazyOnDemand_AssetPtr_EagerOnPropertyçš„ObjectPtrçš„å€¼æ˜¯è¿˜æ²¡æœ‰Resolvedçš„ï¼Œå…¶ä»–çš„éƒ½å¯ä»¥æŸ¥çœ‹åˆ°ç›´æ¥å¯¹è±¡çš„å€¼ã€‚
- å¯ä»¥å¾—å‡ºçš„ç»“è®ºæœ‰ï¼Œåªæœ‰åœ¨UCLASSä¸Šæ ‡è®°LazyOnDemandæ‰å¯ä»¥ä½¿å¾—å»¶è¿ŸåŠ è½½ç”Ÿæ•ˆã€‚åœ¨å±æ€§ä¸Šæ ‡è®°LoadBehavior å¹¶ä¸ä¼šèµ·ä½œç”¨ã€‚ç›´æ¥UObject*çš„å±æ€§ç»Ÿç»Ÿéƒ½ä¼šç›´æ¥åŠ è½½ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\LoadBehavior\Untitled.png)

## åŸç†ï¼š

åœ¨LinkerLoadImportBehavior.cppé‡Œå¯çœ‹è§åˆ¤æ–­LoadBehaviorçš„FindLoadBehavioræ–¹æ³•ï¼Œå› æ­¤å‘ç°å…¶åªä½œç”¨åœ¨UCLASSä¸Šã€‚

å¦å¤–ä¹Ÿå¯åœ¨TObjectPtrçš„Getå‡½æ•°é‡Œå‘ç°ResolveObjectHandleçš„è°ƒç”¨ã€‚è¿™æ˜¯è§¦å‘Resolveçš„åœ°æ–¹ã€‚

ä¹Ÿæ³¨æ„åˆ°UE_WITH_OBJECT_HANDLE_LATE_RESOLVE çš„å®šä¹‰æ˜¯WITH_EDITORONLY_DATAï¼Œå› æ­¤æ˜¯åœ¨ç¼–è¾‘å™¨ç¯å¢ƒä¸‹ç”Ÿæ•ˆã€‚

```cpp
//D:\github\UnrealEngine\Engine\Source\Runtime\CoreUObject\Private\UObject\LinkerLoadImportBehavior.cpp
enum class EImportBehavior : uint8
{
	Eager = 0,
	// @TODO: OBJPTR: we want to permit lazy background loading in the future
	//LazyBackground,
	LazyOnDemand,
};

EImportBehavior FindLoadBehavior(const UClass& Class)
{
	//Package class can't have meta data because of UHT
	if (&Class == UPackage::StaticClass())
	{
		return EImportBehavior::LazyOnDemand;
	}

	static const FName Name_LoadBehavior(TEXT("LoadBehavior"));
	if (const FString* LoadBehaviorMeta = Class.FindMetaData(Name_LoadBehavior))
	{
		if (*LoadBehaviorMeta == TEXT("LazyOnDemand"))
		{
			return EImportBehavior::LazyOnDemand;
		}
		return EImportBehavior::Eager;
	}
	else
	{
		//look in super class to see if it has lazy load on
		const UClass* Super = Class.GetSuperClass();
		if (Super != nullptr)
		{
			return FindLoadBehavior(*Super);
		}
		return EImportBehavior::Eager;
	}
}

	#define UE_WITH_OBJECT_HANDLE_LATE_RESOLVE WITH_EDITORONLY_DATA

	inline UObject* ResolveObjectHandle(FObjectHandle& Handle)
	{
#if UE_WITH_OBJECT_HANDLE_LATE_RESOLVE || UE_WITH_OBJECT_HANDLE_TRACKING
		UObject* ResolvedObject = ResolveObjectHandleNoRead(Handle);
		UE::CoreUObject::Private::OnHandleRead(ResolvedObject);
		return ResolvedObject;
#else
		return ReadObjectHandlePointerNoCheck(Handle);
#endif
	}
```


ï»¿# MustBeLevelActor

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

æ„æ€æ˜¯è¿™ä¸ªå¿…é¡»æ˜¯åœºæ™¯é‡Œçš„Actorï¼Œè€Œä¸æ˜¯LevelScriptActorçš„æ„æ€ã€‚

è§¦å‘æ—¶æœºåœ¨ç”¨ç®­å¤´é€‰æ‹©çš„å½“å‰é€‰ä¸­actorçš„æ—¶å€™ã€‚

## æºç ä¸­é‡è§ï¼š

```cpp
if (FObjectPropertyBase* ObjectProperty = CastField<FObjectPropertyBase>(Property))
{
	ObjectClass = ObjectProperty->PropertyClass;
	bMustBeLevelActor = ObjectProperty->GetOwnerProperty()->GetBoolMetaData(TEXT("MustBeLevelActor"));
	RequiredInterface = ObjectProperty->GetOwnerProperty()->GetClassMetaData(TEXT("MustImplement"));
}
```


ï»¿# ShowInnerProperties

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºå¯¹è±¡å¼•ç”¨çš„å†…éƒ¨å±æ€§
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **å…³è”é¡¹ï¼š** [ShowOnlyInnerProperties](../ShowOnlyInnerProperties/ShowOnlyInnerProperties.md), [FullyExpand](../FullyExpand.md), [CollapsableChildProperties](../CollapsableChildProperties.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºå¯¹è±¡å¼•ç”¨çš„å†…éƒ¨å±æ€§ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¯¹è±¡å¼•ç”¨å±æ€§çš„å†…éƒ¨å±æ€§åœ¨ç»†èŠ‚é¢æ¿é‡Œæ˜¯ä¸ä¼šæ˜¾ç¤ºå‡ºæ¥çš„ï¼Œåªæ˜¯å­¤é›¶é›¶çš„æ˜¾ç¤ºä¸€ä¸ªå¯¹è±¡åå­—ã€‚ä½†ä½ å¦‚æœæƒ³ç›´æ¥æ˜¾ç¤ºå‡ºå…¶å†…éƒ¨å±æ€§ç„¶åå¯ä»¥ç¼–è¾‘çš„è¯ï¼Œå°±éœ€è¦ShowInnerPropertiesè¿™ä¸ªmetaçš„ä½œç”¨ã€‚

ä½†ShowInnerPropertiesä½œç”¨æœ‰ä¸¤ä¸ªé™å®šæ¡ä»¶ï¼Œä¸€æ˜¯è¿™ä¸ªå±æ€§å¾—æ˜¯UObject*ï¼ŒäºŒæ˜¯è¿™ä¸ªå±æ€§ä¸æ˜¯ä¸ªå®¹å™¨ã€‚

åŒæ—¶ä¹Ÿæ³¨æ„åˆ°ï¼ŒStructå±æ€§æ˜¯é»˜è®¤å°±ä¼šæ˜¾ç¤ºå†…éƒ¨å±æ€§çš„ï¼Œå› æ­¤ä¹Ÿä¸éœ€è¦å†è®¾ç½®ShowInnerPropertiesã€‚

**å’ŒEditInineNewçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

è¿™ç§æ•ˆæœï¼Œå’Œåœ¨UCLASSä¸Šè®¾ç½®EditInineNewé…åˆå…¶å¯¹è±¡å¼•ç”¨å±æ€§ä¸Šè®¾ç½®Instancedï¼Œè¾¾æˆçš„æ•ˆæœå¾ˆç›¸ä¼¼ã€‚åŒºåˆ«æ˜¯UCLASSä¸Šè®¾ç½®EditInineNewä¼šä½¿å¾—ä¸€ä¸ªç±»çš„å¯¹è±¡å±æ€§å¼•ç”¨å¯ä»¥åœ¨å±æ€§é¢æ¿é‡Œåˆ›å»ºå¯¹è±¡ï¼Œ è€ŒUPROPERTYä¸Šçš„Instancedï¼Œä¼šä½¿å¾—è¿™ä¸ªå±æ€§è‡ªåŠ¨çš„å¢åŠ EditInlineçš„metaï¼Œå› æ­¤ä¹Ÿä¼šäº§ç”Ÿæ˜¾ç¤ºå†…éƒ¨å±æ€§çš„åŒæ ·æ•ˆæœã€‚å› æ­¤ç»“è®ºä¸Šæ¥è¯´ï¼Œå’ŒShowInnerPropertiesåƒçš„æ˜¯æœ¬è´¨æ˜¯EditInlineè¿™ä¸ªmetaã€‚ä½†EditInlineçš„æ•ˆæœå¤šäº†ä¸€å±‚æ˜¯å®ƒæ”¯æŒå¯¹è±¡å®¹å™¨ï¼Œè€ŒShowInnerPropertiesåªæ”¯æŒå•ä¸ªå¯¹è±¡å¼•ç”¨å±æ€§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

USTRUCT(BlueprintType)
struct FMyPropertyInner
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 StructInnerInt = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FString StructInnerString;
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_InnerSub :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 ObjectInnerInt = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FString ObjectInnerString;
};

UCLASS(BlueprintType, EditInlineNew)
class INSIDER_API UMyProperty_InnerSub_EditInlineNew :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 ObjectInnerInt = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FString ObjectInnerString;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Inner :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FMyPropertyInner InnerStruct;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ShowInnerProperties))
	FMyPropertyInner InnerStruct_ShowInnerProperties;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UMyProperty_InnerSub* InnerObject;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ShowInnerProperties))
	UMyProperty_InnerSub* InnerObject_ShowInnerProperties;
	
	//(Category = MyProperty_Inner, EditInline = , ModuleRelativePath = Property/MyProperty_Inner.h)
	//CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline))
	UMyProperty_InnerSub* InnerObject_EditInline;
	
	//(Category = MyProperty_Inner, EditInline = true, ModuleRelativePath = Property/MyProperty_Inner.h)
	//CPF_Edit | CPF_BlueprintVisible | CPF_ExportObject | CPF_ZeroConstructor | CPF_InstancedReference | CPF_NoDestructor | CPF_PersistentInstance | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced)
	UMyProperty_InnerSub* InnerObject_Instanced;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UMyProperty_InnerSub_EditInlineNew* InnerObject_EditInlineNewClass;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditInline))
	UMyProperty_InnerSub_EditInlineNew* InnerObject_EditInlineNewClass_EditInline;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced)
	UMyProperty_InnerSub_EditInlineNew* InnerObject_EditInlineNewClass_Instanced;

public:
	UFUNCTION(CallInEditor)
	void ClearInnerObject();
	UFUNCTION(CallInEditor)
	void InitInnerObject();
};

void UMyProperty_Inner::ClearInnerObject()
{
	InnerObject = nullptr;
	InnerObject_ShowInnerProperties = nullptr;
	InnerObject_EditInline = nullptr;
	InnerObject_Instanced = nullptr;

	InnerObject_EditInlineNewClass = nullptr;
	InnerObject_EditInlineNewClass_EditInline = nullptr;
	InnerObject_EditInlineNewClass_Instanced = nullptr;

	Modify();

	FPropertyEditorModule& PropertyEditorModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>("PropertyEditor");
	PropertyEditorModule.NotifyCustomizationModuleChanged();
}

void UMyProperty_Inner::InitInnerObject()
{
	InnerObject = NewObject<UMyProperty_InnerSub>(this);
	InnerObject_ShowInnerProperties = NewObject<UMyProperty_InnerSub>(this);
	InnerObject_EditInline = NewObject<UMyProperty_InnerSub>(this);
	InnerObject_Instanced = NewObject<UMyProperty_InnerSub>(this);

	InnerObject_EditInlineNewClass = NewObject<UMyProperty_InnerSub_EditInlineNew>(this);
	InnerObject_EditInlineNewClass_EditInline = NewObject<UMyProperty_InnerSub_EditInlineNew>(this);
	//InnerObject_EditInlineNewClass_Instanced = NewObject<UMyProperty_InnerSub_EditInlineNew>(this);

	Modify();

	FPropertyEditorModule& PropertyEditorModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>("PropertyEditor");
	PropertyEditorModule.NotifyCustomizationModuleChanged();
}
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\ShowInnerProperties\Untitled.png)

å¯ä»¥è§‚å¯Ÿåˆ°ï¼š

- ç»“æ„çš„å±æ€§é»˜è®¤æ”¯æŒå±•å¼€å†…éƒ¨å±æ€§
- å¸¦æœ‰ShowInnerPropertiesçš„UMyProperty_InnerSub* InnerObject_ShowInnerProperties;æ”¯æŒå±•å¼€å±æ€§
- å¸¦æœ‰EditInlineå’ŒInstancedçš„UMyProperty_InnerSub* ä¹Ÿéƒ½æ”¯æŒå±•å¼€å†…éƒ¨å±æ€§ï¼Œä¹Ÿå¯ä»¥è§‚å¯Ÿåˆ°ä»–ä»¬çš„metaæ˜¯ä¸€è‡´çš„ï¼Œéƒ½å¸¦æœ‰EditInline=true
- åªæœ‰EditInlineNewçš„UCLASSçš„UMyProperty_InnerSub_EditInlineNew* InnerObject_EditInlineNewClass;å…¶å¯¹è±¡å¼•ç”¨ä¸æ”¯æŒå±•å¼€å±æ€§ï¼Œè¯´æ˜åœ¨ç±»ä¸Šè®¾ç½®EditInlineNewå¹¶æ²¡æœ‰ä½œç”¨ã€‚
- ä½†æ˜¯æˆ‘ä»¬ä¹Ÿè§‚å¯Ÿåˆ°InnerObject_EditInlineNewClass_Instancedçš„è®¾ç½®é‡Œæ”¯æŒç›´æ¥åˆ›å»ºå¯¹è±¡ï¼Œå› ä¸ºå…¶ç±»ä¸Šæœ‰EditInlineNewã€‚è€ŒInnerObject_Instancedä¸Šå¹¶ä¸æ”¯æŒç›´æ¥åˆ›å»ºå¯¹è±¡ï¼Œå› ä¸ºå…¶ç±»UMyProperty_InnerSubä¸Šå¹¶æ²¡æœ‰EditInlineNewï¼Œå› æ­¤ä¸ä¼šå‡ºç°åœ¨å¯é€‰æ¡†é‡Œã€‚

## æ‰©å±•ä¾‹å­ï¼š

åœ¨æºç ä¸­æœç´¢è§‚å¯Ÿåˆ°UChildActorComponent::ChildActorTemplateä¸Šä¹Ÿä¼šå¸¦æœ‰ShowInnerPropertiesï¼Œåˆ™å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„åº”ç”¨ï¼Œä»¥ä¾¿è®©æˆ‘ä»¬ç›´æ¥åœ¨ç†Ÿæ‚‰ç»†èŠ‚é¢æ¿é‡Œç›´æ¥ç¼–è¾‘ChildActorçš„å±æ€§æ•°æ®ã€‚

ä½†å‡å¦‚æˆ‘ä»¬å»æ‰è¿™ä¸ªShowInnerPropertiesï¼Œæˆ‘ä»¬å¯ä»¥æ¥å‰åå¯¹æ¯”ä¸€ä¸‹æ•ˆæœï¼š

```cpp
class UChildActorComponent : public USceneComponent
{
	UPROPERTY(VisibleDefaultsOnly, DuplicateTransient, Category=ChildActorComponent, meta=(ShowInnerProperties))
	TObjectPtr<AActor> ChildActorTemplate;
}

void UMyProperty_Inner::RemoveActorMeta()
{
	FProperty* prop = UChildActorComponent::StaticClass()->FindPropertyByName(TEXT("ChildActorTemplate"));
	prop->RemoveMetaData(TEXT("ShowInnerProperties"));
}

void UMyProperty_Inner::AddActorMeta()
{
	FProperty* prop = UChildActorComponent::StaticClass()->FindPropertyByName(TEXT("ChildActorTemplate"));
	prop->SetMetaData(TEXT("ShowInnerProperties"), TEXT(""));
}

```

## å¯¹æ¯”æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\ShowInnerProperties\Untitled%201.png)

å¯ä»¥å‘ç°ï¼Œå»é™¤ShowInnerPropertiesåï¼ŒChildActorTemplateå±æ€§é€€åŒ–æˆä¸€ä¸ªæ™®é€šçš„å¯¹è±¡å¼•ç”¨ï¼Œæˆ‘ä»¬æ— æ³•åœ¨ä¸Šé¢ç›´æ¥ç¼–è¾‘å¯¹è±¡çš„å†…éƒ¨å±æ€§ã€‚

## åŸç†ï¼š

æºç é‡Œæœ€å…¸å‹çš„ä¾‹å­æ˜¯ChildActorTemplateï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥æ˜¾ç¤ºå‡ºå†…éƒ¨çš„å±æ€§ã€‚

```cpp
class UChildActorComponent : public USceneComponent
{
	UPROPERTY(VisibleDefaultsOnly, DuplicateTransient, Category=ChildActorComponent, meta=(ShowInnerProperties))
	TObjectPtr<AActor> ChildActorTemplate;
}
```

ä½œç”¨çš„æºç ï¼š

```cpp
void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
		const bool bIsObjectOrInterface = CastField<FObjectPropertyBase>(MyProperty) || CastField<FInterfaceProperty>(MyProperty);
		// we are EditInlineNew if this property has the flag, or if inside a container that has the flag.
		bIsEditInlineNew = GotReadAddresses && bIsObjectOrInterface && !MyProperty->HasMetaData(Name_NoEditInline) && 
			(MyProperty->HasMetaData(Name_EditInline) || (bIsInsideContainer && OwnerProperty->HasMetaData(Name_EditInline)));
		bShowInnerObjectProperties = bIsObjectOrInterface && MyProperty->HasMetaData(Name_ShowInnerProperties);
		
		if (bIsEditInlineNew)
		{
			SetNodeFlags(EPropertyNodeFlags::EditInlineNew, true);
		}
		else if (bShowInnerObjectProperties)
		{
			SetNodeFlags(EPropertyNodeFlags::ShowInnerObjectProperties, true);
		}
}

void FItemPropertyNode::InitExpansionFlags(void)
{
	FProperty* MyProperty = GetProperty();

	if (TSharedPtr<FPropertyNode>& ValueNode = GetOrCreateOptionalValueNode())
	{
		// This is a set optional, so check its SetValue instead.
		MyProperty = ValueNode->GetProperty();
	}

	bool bExpandableType = CastField<FStructProperty>(MyProperty)
		|| (CastField<FArrayProperty>(MyProperty) || CastField<FSetProperty>(MyProperty) || CastField<FMapProperty>(MyProperty));

	if (bExpandableType
		|| HasNodeFlags(EPropertyNodeFlags::EditInlineNew)
		|| HasNodeFlags(EPropertyNodeFlags::ShowInnerObjectProperties)
		|| (MyProperty->ArrayDim > 1 && ArrayIndex == -1))
	{
		SetNodeFlags(EPropertyNodeFlags::CanBeExpanded, true);
	}
}
void FPropertyNode::RebuildChildren()
{
	if (HasNodeFlags(EPropertyNodeFlags::CanBeExpanded) && (ChildNodes.Num() == 0))
	{
		InitChildNodes();
		if (ExpandedPropertyItemSet.Size() > 0)
		{
			FPropertyNodeUtils::SetExpandedItems(ThisAsSharedRef, ExpandedPropertyItemSet);
		}
	}
}
```

ç‰¹åˆ«æ³¨æ„ï¼Œè¿™é‡Œçš„bShowInnerObjectPropertiesçš„åˆ¤æ–­æ¡ä»¶æ˜¯bIsObjectOrInterface ä¸”æœ‰metaï¼Œå› æ­¤è¯¥ç‰¹æ€§åªä½œç”¨äºå¯¹è±¡å¼•ç”¨ä¸Šã€‚ç„¶åå¦‚æœåˆ¤æ–­æœ‰EPropertyNodeFlags::ShowInnerObjectPropertiesï¼Œåˆ™ç»§ç»­è®¾ç½®EPropertyNodeFlags::CanBeExpandedï¼Œæœ€åå¯¼è‡´å±•å¼€å¯¹è±¡çš„å±æ€§ã€‚


ï»¿# ShowOnlyInnerProperties

- **åŠŸèƒ½æè¿°ï¼š** æŠŠç»“æ„å±æ€§çš„å†…éƒ¨å±æ€§ç›´æ¥ä¸Šæä¸€ä¸ªå±‚çº§ç›´æ¥å±•ç¤º
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FStructå±æ€§
- **å…³è”é¡¹ï¼š** [ShowInnerProperties](../ShowInnerProperties/ShowInnerProperties.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠç»“æ„å±æ€§çš„å†…éƒ¨å±æ€§ç›´æ¥ä¸Šæä¸€ä¸ªå±‚çº§ç›´æ¥å±•ç¤ºï¼Œè€Œä¸æ˜¯åƒé»˜è®¤ä¸€æ ·å½’å±äºä¸€ä¸ªå¯å±•å¼€çš„çˆ¶çº§ç»“æ„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite)
FMyPropertyInner InnerStruct;

UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (ShowOnlyInnerProperties))
FMyPropertyInner InnerStruct_ShowOnlyInnerProperties;
```

## æ•ˆæœå¯¹æ¯”ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\ShowOnlyInnerProperties\Untitled.png)

å¯ä»¥å‘ç°InnerStruct_ShowOnlyInnerPropertiesçš„å†…éƒ¨å±æ€§ç›´æ¥å°±æ˜¾ç¤ºåœ¨å¯¹è±¡çš„å½“å‰å±‚çº§ä¸Šï¼Œè€ŒInnerStructçš„å±æ€§æœ‰ä¸€ä¸ªç»“æ„åç§°ä½œä¸ºCategoryæ¥å±•å¼€ã€‚

## åŸç†ï¼š

åœ¨é‡è§FStructPropertyçš„æ—¶å€™ï¼Œä¼šå¼€å§‹åˆ¤æ–­ShowOnlyInnerPropertiesæ¥å†³å®šæ˜¯å¦è¦åˆ›å»ºä¸€ä¸ªå¯å±•å¼€çš„Categoryï¼Œæˆ–è€…è¿˜æ˜¯ç›´æ¥æŠŠå†…éƒ¨å±æ€§å±•ç¤ºå‡ºæ¥ã€‚æœ‰äº†ShowOnlyInnerPropertiesï¼Œå°±ä¼šç›´æ¥é€’å½’è¿­ä»£åˆ°å…¶å†…éƒ¨å±æ€§ã€‚

```cpp
void DetailLayoutHelpers::UpdateSinglePropertyMapRecursive(FPropertyNode& InNode, FName CurCategory, FComplexPropertyNode* CurObjectNode, FUpdatePropertyMapArgs& InUpdateArgs)
{
		static FName ShowOnlyInners("ShowOnlyInnerProperties");
		// Whether or not to push out struct properties to their own categories or show them inside an expandable struct
		// This recursively applies for any nested structs that have the ShowOnlyInners metadata 
		const bool bPushOutStructProps = bIsStruct && !bIsCustomizedStruct && Property->HasMetaData(ShowOnlyInners);
		
		if (bRecurseIntoChildren || LocalUpdateFavoriteSystemOnly)
		{
						// Built in struct properties or children of arras 
						UpdateSinglePropertyMapRecursive(ChildNode, CurCategory, CurObjectNode, ChildArgs);
		}

}

void FObjectPropertyNode::GetCategoryProperties(const TSet<UClass*>& ClassesToConsider, const FProperty* CurrentProperty, bool bShouldShowDisableEditOnInstance, bool bShouldShowHiddenProperties,
	const TSet<FName>& CategoriesFromBlueprints, TSet<FName>& CategoriesFromProperties, TArray<FName>& SortedCategories)
	{
			if (CurrentProperty->HasMetaData(Name_ShowOnlyInnerProperties))
			{
				const FStructProperty* StructProperty = CastField<const FStructProperty>(CurrentProperty);
				if (StructProperty)
				{
					for (TFieldIterator<FProperty> It(StructProperty->Struct); It; ++It)
					{
						GetCategoryProperties(ClassesToConsider, *It, bShouldShowDisableEditOnInstance, bShouldShowHiddenProperties, CategoriesFromBlueprints, CategoriesFromProperties, SortedCategories);
					}
				}
			}
			
}
```


ï»¿# ThumbnailSize

- **åŠŸèƒ½æè¿°ï¼š** æ”¹å˜ç¼©ç•¥å›¾çš„å¤§å°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [DisplayThumbnail](DisplayThumbnail/DisplayThumbnail.md)

æ”¹å˜ç¼©ç•¥å›¾çš„å¤§å°ã€‚ä½†å‘ç°å¹¶ä¸ä¼šèµ·ä½œç”¨ã€‚

## åŸç†ï¼š

```cpp
void SObjectPropertyEntryBox::Construct( const FArguments& InArgs )
{
	// check if the property metadata wants us to display a thumbnail
const FString& DisplayThumbnailString = PropertyHandle->GetProperty()->GetMetaData(TEXT("DisplayThumbnail"));
if(DisplayThumbnailString.Len() > 0)
{
	bDisplayThumbnail = DisplayThumbnailString == TEXT("true");
}

// check if the property metadata has an override to the thumbnail size
const FString& ThumbnailSizeString = PropertyHandle->GetProperty()->GetMetaData(TEXT("ThumbnailSize"));
if ( ThumbnailSizeString.Len() > 0 )
{
	FVector2D ParsedVector;
	if ( ParsedVector.InitFromString(ThumbnailSizeString) )
	{
		ThumbnailSize.X = (int32)ParsedVector.X;
		ThumbnailSize.Y = (int32)ParsedVector.Y;
	}
}
}
```


ï»¿# Untracked

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—TSoftObjectPtrå’ŒFSoftObjectPathçš„è½¯å¯¹è±¡å¼•ç”¨ç±»å‹çš„å±æ€§ï¼Œä¸è·Ÿè¸ªè®°å½•èµ„äº§çš„ ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Object Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSoftObjectPtrï¼ŒFSoftObjectPath 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ä½¿å¾—TSoftObjectPtrå’ŒFSoftObjectPathçš„è½¯å¯¹è±¡å¼•ç”¨ç±»å‹çš„å±æ€§ï¼Œä¸è·Ÿè¸ªè®°å½•èµ„äº§çš„ ã€‚

ä¸€èˆ¬é»˜è®¤æƒ…å†µï¼Œå±æ€§ä¸Šçš„è½¯å¯¹è±¡å¼•ç”¨ä¹Ÿæ˜¯ä¼šäº§ç”Ÿèµ„äº§çš„å¼•ç”¨ä¾èµ–ï¼Œè™½ç„¶åœ¨Loadæœ¬èº«çš„æ—¶å€™ï¼Œä¸ä¼šåƒç¡¬å¼•ç”¨ä¸€æ ·ä¹Ÿå»åŠ è½½å…¶ä»–è½¯å¼•ç”¨å¯¹è±¡ã€‚ä½†æ˜¯å› ä¸ºå¼•ç”¨å…³ç³»ä¾ç„¶å­˜åœ¨ï¼Œå› æ­¤åœ¨cookçš„æ—¶å€™ï¼Œæˆ–è€…èµ„äº§é‡å®šå‘çš„æ—¶å€™éƒ½ä¼šå»æ£€æŸ¥è¿™äº›è½¯å¼•ç”¨å¯¹è±¡ï¼Œç¡®ä¿å…¶ä¹Ÿä¼šè¢«cookè¿›å»ï¼Œæˆ–è€…æ­£å¸¸çš„å¤„ç†ã€‚

è€Œå½“ä½ æƒ³åœ¨å±æ€§ä¸Šè®°å½•â€œå¼•ç”¨â€ä¸€äº›èµ„äº§ï¼Œä»¥ä¾¿ä¹‹ååŠ è½½ä½¿ç”¨ï¼Œä½†æ˜¯åˆä¸æƒ³äº§ç”ŸçœŸæ­£çš„èµ„äº§å¼•ç”¨ä¾èµ–ï¼Œè¿™ä¸ªæ—¶å€™å°±å¯ä»¥ç”¨untrackedã€‚æºç ä¸­åº”ç”¨çš„ä¸å¤šï¼Œè¿™æ˜¯æ¯”è¾ƒç¨€å°‘çš„æƒ…å†µä¸‹ã€‚

å’Œtransientæ ‡è®°çš„åŒºåˆ«æ˜¯ï¼Œtransientå±æ€§åœ¨åºåˆ—åŒ–çš„æ—¶å€™ä¹Ÿä¸ä¼šåºåˆ—åŒ–ï¼Œå› ä¸ºå…¶ctrl+Sä¿å­˜åé‡å¯ç¼–è¾‘å™¨ä¼šä¸¢å¤±å€¼ã€‚transientå±æ€§æ—¢ä¸äº§ç”Ÿèµ„äº§å¼•ç”¨å…³ç³»ä¹Ÿåºåˆ—åŒ–ä¿å­˜å€¼ï¼ŒUntrackedå±æ€§ä¼šåºåˆ—åŒ–ä¿å­˜å€¼ä½†ä¸äº§ç”Ÿèµ„äº§å¼•ç”¨å…³ç³»ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Soft :public UDataAsset
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TSoftObjectPtr<UStaticMesh> MyStaticMesh;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Untracked))
	TSoftObjectPtr<UStaticMesh> MyStaticMeshUntracked;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FSoftObjectPath MySoftMesh;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Untracked))
	FSoftObjectPath MySoftMeshUntracked;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient)
	TSoftObjectPtr<UStaticMesh> MyStaticMeshTransient;
};
```

## è“å›¾æ•ˆæœï¼š

åœ¨è“å›¾ä¸­å»ºç«‹ä¸€ä¸ªUMyProperty_Soft DataAssetèµ„äº§ï¼Œç„¶åè®¾ç½®å…¶å±æ€§å€¼ã€‚ç„¶åæŸ¥çœ‹å…¶å¼•ç”¨çš„èµ„æºï¼Œä¼šå‘ç°Untrackedçš„å±æ€§ï¼Œå…¶è®¾ç½®çš„èµ„äº§å¹¶æ²¡æœ‰å‡ºç°åœ¨å¼•ç”¨å…³ç³»ä¸­ã€‚å½“ç„¶Transientçš„å±æ€§ä¹Ÿä¸åœ¨å¼•ç”¨å…³ç³»ä¸­ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Object\Untracked\Untitled.png)

## åŸç†ï¼š

Untrackedå…ƒæ•°æ®ï¼Œä¼šè®¾ç½®ä¸ºESoftObjectPathCollectType::NeverCollectçš„é€‰é¡¹ã€‚ç»§ç»­æœç´¢ä¼šå‘ç°å¸¦æœ‰NeverCollectçš„FSoftObjectPathï¼Œå…¶ä¸Šé¢çš„èµ„äº§package ä¸ä¼šè¢«ç®—åˆ°èµ„äº§å¼•ç”¨é‡Œï¼Œä»è€Œä¸ä¼šå¸¦åˆ°upackage Importè¡¨é‡Œã€‚æºç ä¸­æœ‰å¤šå¤„åœ°æ–¹å¸¦æœ‰è¿™ä¸ªNeverCollect çš„ç±»ä¼¼åˆ¤æ–­ã€‚

```cpp
bool FSoftObjectPathThreadContext::GetSerializationOptions(FName& OutPackageName, FName& OutPropertyName, ESoftObjectPathCollectType& OutCollectType, ESoftObjectPathSerializeType& OutSerializeType, FArchive* Archive) const
{
#if WITH_EDITOR
		bEditorOnly = Archive->IsEditorOnlyPropertyOnTheStack();

		static FName UntrackedName = TEXT("Untracked");
		if (CurrentProperty && CurrentProperty->GetOwnerProperty()->HasMetaData(UntrackedName))
		{
			// Property has the Untracked metadata, so set to never collect references if it's higher than NeverCollect
			CurrentCollectType = FMath::Min(ESoftObjectPathCollectType::NeverCollect, CurrentCollectType);
		}
#endif
}

FArchive& FImportExportCollector::operator<<(FSoftObjectPath& Value)
{
	FName CurrentPackage;
	FName PropertyName;
	ESoftObjectPathCollectType CollectType;
	ESoftObjectPathSerializeType SerializeType;
	FSoftObjectPathThreadContext& ThreadContext = FSoftObjectPathThreadContext::Get();
	ThreadContext.GetSerializationOptions(CurrentPackage, PropertyName, CollectType, SerializeType, this);

	if (CollectType != ESoftObjectPathCollectType::NeverCollect && CollectType != ESoftObjectPathCollectType::NonPackage)
	{
		FName PackageName = Value.GetLongPackageFName();
		if (PackageName != RootPackageName && !PackageName.IsNone())
		{
			AddImport(Value, CollectType);
		}
	}
	return *this;
}
```


ï»¿# ContentDir

- **åŠŸèƒ½æè¿°ï¼š** ä½¿ç”¨UEçš„é£æ ¼æ¥é€‰æ‹©Contentä»¥åŠå­ç›®å½•ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FDirectoryPath
- **å…³è”é¡¹ï¼š** [RelativePath](../RelativePath.md), [RelativeToGameContentDir](../RelativeToGameContentDir.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿ç”¨UEçš„é£æ ¼æ¥é€‰æ‹©Contentä»¥åŠå­ç›®å½•ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œé€‰æ‹©ä¸€ä¸ªç›®å½•ï¼Œä¼šå¼¹å‡ºwindowsé»˜è®¤çš„é€‰æ‹©ç›®å½•å¯¹è¯æ¡†ï¼Œå› ä¸ºFDirectoryPath ä½ ç¡®å®å¯ä»¥ç”¨æ¥é€‰æ‹©åˆ°windowsç³»ç»Ÿé‡Œä»»æ„çš„ç›®å½•ï¼ˆå¯èƒ½ä½ çš„é¡¹ç›®å°±æ˜¯è¿™ä¹ˆéœ€æ±‚çš„ï¼‰ã€‚ä½†å¦‚æœä½ ç¡®å®å°±æ˜¯æƒ³è¦é€‰æ‹©ä¸€ä¸ªUE Contentä¸‹ç›®å½•ï¼Œè¿™ä¸ªæ—¶å€™ä½ æŒ‡å®šContentDirï¼ŒUEå°±å¯ä»¥ä¸ºä½ å¼¹å‡ºä¸€ä¸ªä¸“é—¨çš„UEé€‰æ‹©ç›®å½•å¯¹è¯æ¡†ï¼Œæ›´åŠ çš„ä¾¿åˆ©ä¹Ÿé¿å…å‡ºé”™ã€‚

åœ¨ä½¿ç”¨FDirectoryPathçš„æ—¶å€™ï¼ŒContentDirå’ŒLongPackageNameæ˜¯ç­‰ä»·çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Path :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DirectoryPath)
	FDirectoryPath MyDirectory_Default;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DirectoryPath, meta = (ContentDir))
	FDirectoryPath MyDirectory_ContentDir;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DirectoryPath, meta = (LongPackageName))
	FDirectoryPath MyDirectory_LongPackageName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DirectoryPath, meta = (RelativeToGameContentDir))
	FDirectoryPath MyDirectory_RelativeToGameContentDir;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DirectoryPath, meta = (RelativePath))
	FDirectoryPath MyDirectory_RelativePath;
};

```

## æµ‹è¯•ç»“æœï¼š

- é»˜è®¤çš„MyDirectory_Defaultä¼šæ‰“å¼€ç³»ç»Ÿå¯¹è¯æ¡†ï¼Œå¯ä»¥é€‰æ‹©ä»»ä½•ç›®å½•ã€‚
- MyDirectory_ContentDirå’ŒMyDirectory_LongPackageNameï¼Œä¼šå¦‚å›¾æ‰€ç¤ºå¼¹å‡ºUEé£æ ¼çš„å¯¹è¯æ¡†æ¥é€‰æ‹©ç›®å½•ã€‚
- MyDirectory_RelativeToGameContentDirå’ŒMyDirectory_RelativePathéƒ½ä¼šå¼¹å‡ºç³»ç»Ÿå¯¹è¯æ¡†ï¼Œä¸åŒçš„æ˜¯MyDirectory_RelativeToGameContentDiræœ€ç»ˆçš„ç›®å½•ä¼šé™åˆ¶åœ¨Contentç›®å½•ä¸‹ï¼ˆå¦‚æœé€‰æ‹©åˆ«çš„ç›®å½•ï¼Œä¼šå¼¹å‡ºé”™è¯¯è­¦å‘Šï¼‰ï¼Œç»“æœæ˜¯ä¸ªç›¸å¯¹è·¯å¾„ã€‚MyDirectory_RelativePathçš„ç»“æœä¹Ÿæ˜¯ä¸ªç›¸å¯¹è·¯å¾„ï¼Œä½†æ˜¯å¯ä»¥é€‰æ‹©ä»»æ„ç›®å½•ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Path\ContentDir\Untitled.png)

## åŸç†ï¼š

FDirectoryPathçš„ç¼–è¾‘æœ‰FDirectoryPathStructCustomizationæ¥å®šåˆ¶åŒ–ã€‚æ ¹æ®å…¶ä»£ç å¯è§ï¼Œå¦‚æœæœ‰ContentDiræˆ–LongPackageNameï¼Œåˆ™åˆ™æ˜¯ä¸ªContentDirï¼Œåˆ™ä¼šé‡‡ç”¨OnPickContentæ¥é€‰æ‹©ç›®å½•ã€‚å†…éƒ¨å†ç”¨ContentBrowserModule.Get().CreatePathPicker(PathPickerConfig)æ¥åˆ›å»ºä¸“é—¨çš„ç›®å½•é€‰æ‹©èœå•ã€‚

å¦åˆ™èµ°åˆ°OnPickDirectoryåˆ†æ”¯ï¼Œä¼šé‡‡ç”¨DesktopPlatform->OpenDirectoryDialogæ¥æ‰“å¼€ç³»ç»Ÿçš„å¯¹è¯æ¡†ã€‚

ä»æºç ä¹Ÿå¯ä»¥çœ‹å‡ºï¼š

bRelativeToGameContentDirä¼šå¯¼è‡´Directory.RightChopInline(AbsoluteGameContentDir.Len(), EAllowShrinking::No);ï¼Œ æŠŠConentè·¯å¾„çš„å·¦è¾¹éƒ¨åˆ†åˆ‡æ‰ã€‚

bUseRelativePathä¼šè§¦å‘Directory = IFileManager::Get().ConvertToRelativePath(*Directory);ï¼ŒæŠŠè·¯å¾„è½¬æ¢æˆç›¸å¯¹è·¯å¾„ã€‚

```cpp
/** Structure for directory paths that are displayed in the editor with a picker UI. */
USTRUCT(BlueprintType)
struct FDirectoryPath
{
	GENERATED_BODY()

	/**
	* The path to the directory.
	*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Path)
	FString Path;
};

RegisterCustomPropertyTypeLayout("DirectoryPath", FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FDirectoryPathStructCustomization::MakeInstance));
RegisterCustomPropertyTypeLayout("FilePath", FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FFilePathStructCustomization::MakeInstance));
	
void FDirectoryPathStructCustomization::CustomizeHeader( TSharedRef<IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils )
{
	TSharedPtr<IPropertyHandle> PathProperty = StructPropertyHandle->GetChildHandle("Path");

	const bool bRelativeToGameContentDir = StructPropertyHandle->HasMetaData( TEXT("RelativeToGameContentDir") );
	const bool bUseRelativePath = StructPropertyHandle->HasMetaData( TEXT("RelativePath") );
	const bool bContentDir = StructPropertyHandle->HasMetaData( TEXT("ContentDir") ) || StructPropertyHandle->HasMetaData(TEXT("LongPackageName"));
	
	AbsoluteGameContentDir = FPaths::ConvertRelativePathToFull(FPaths::ProjectContentDir());
	
	if(bContentDir)
	{
		PickerWidget = SAssignNew(PickerButton, SButton)
		.ButtonStyle( FAppStyle::Get(), "HoverHintOnly" )
		.ToolTipText( LOCTEXT( "FolderComboToolTipText", "Choose a content directory") )
		.OnClicked( this, &FDirectoryPathStructCustomization::OnPickContent, PathProperty.ToSharedRef() )
		.ContentPadding(2.0f)
		.ForegroundColor( FSlateColor::UseForeground() )
		.IsFocusable(false)
		.IsEnabled(this, &FDirectoryPathStructCustomization::IsBrowseEnabled, StructPropertyHandle)
		[
			SNew(SImage)
			.Image(FAppStyle::GetBrush("PropertyWindow.Button_Ellipsis"))
			.ColorAndOpacity(FSlateColor::UseForeground())
		];
	
	}
	else
	{
		PickerWidget = SAssignNew(BrowseButton, SButton)
		.ButtonStyle( FAppStyle::Get(), "HoverHintOnly" )
		.ToolTipText( LOCTEXT( "FolderButtonToolTipText", "Choose a directory from this computer") )
		.OnClicked( this, &FDirectoryPathStructCustomization::OnPickDirectory, PathProperty.ToSharedRef(), bRelativeToGameContentDir, bUseRelativePath )
		.ContentPadding( 2.0f )
		.ForegroundColor( FSlateColor::UseForeground() )
		.IsFocusable( false )
		.IsEnabled( this, &FDirectoryPathStructCustomization::IsBrowseEnabled, StructPropertyHandle )
		[
			SNew( SImage )
			.Image( FAppStyle::GetBrush("PropertyWindow.Button_Ellipsis") )
			.ColorAndOpacity( FSlateColor::UseForeground() )
		];
	}
}

FReply FDirectoryPathStructCustomization::OnPickContent(TSharedRef<IPropertyHandle> PropertyHandle) 
{
	FContentBrowserModule& ContentBrowserModule = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser");
	FPathPickerConfig PathPickerConfig;
	PropertyHandle->GetValue(PathPickerConfig.DefaultPath);
	PathPickerConfig.bAllowContextMenu = false;
	PathPickerConfig.OnPathSelected = FOnPathSelected::CreateSP(this, &FDirectoryPathStructCustomization::OnPathPicked, PropertyHandle);

	FMenuBuilder MenuBuilder(true, NULL);
	MenuBuilder.AddWidget(SNew(SBox)
		.WidthOverride(300.0f)
		.HeightOverride(300.0f)
		[
			ContentBrowserModule.Get().CreatePathPicker(PathPickerConfig)
		], FText());

	PickerMenu = FSlateApplication::Get().PushMenu(PickerButton.ToSharedRef(),
		FWidgetPath(),
		MenuBuilder.MakeWidget(),
		FSlateApplication::Get().GetCursorPos(),
		FPopupTransitionEffect(FPopupTransitionEffect::ContextMenu)
		);

	return FReply::Handled();
}

FReply FDirectoryPathStructCustomization::OnPickDirectory(TSharedRef<IPropertyHandle> PropertyHandle, const bool bRelativeToGameContentDir, const bool bUseRelativePath) const
{
	FString Directory;
	IDesktopPlatform* DesktopPlatform = FDesktopPlatformModule::Get();
	if (DesktopPlatform)
	{

		TSharedPtr<SWindow> ParentWindow = FSlateApplication::Get().FindWidgetWindow(BrowseButton.ToSharedRef());
		void* ParentWindowHandle = (ParentWindow.IsValid() && ParentWindow->GetNativeWindow().IsValid()) ? ParentWindow->GetNativeWindow()->GetOSWindowHandle() : nullptr;

		FString StartDirectory = FEditorDirectories::Get().GetLastDirectory(ELastDirectory::GENERIC_IMPORT);
		if (bRelativeToGameContentDir && !IsValidPath(StartDirectory, bRelativeToGameContentDir))
		{
			StartDirectory = AbsoluteGameContentDir;
		}

		// Loop until; a) the user cancels (OpenDirectoryDialog returns false), or, b) the chosen path is valid (IsValidPath returns true)
		for (;;)
		{
			if (DesktopPlatform->OpenDirectoryDialog(ParentWindowHandle, LOCTEXT("FolderDialogTitle", "Choose a directory").ToString(), StartDirectory, Directory))
			{
				FText FailureReason;
				if (IsValidPath(Directory, bRelativeToGameContentDir, &FailureReason))
				{
					FEditorDirectories::Get().SetLastDirectory(ELastDirectory::GENERIC_IMPORT, Directory);

					if (bRelativeToGameContentDir)
					{
						Directory.RightChopInline(AbsoluteGameContentDir.Len(), EAllowShrinking::No);
					}
					else if (bUseRelativePath)
					{
						Directory = IFileManager::Get().ConvertToRelativePath(*Directory);
					}

					PropertyHandle->SetValue(Directory);
				}
				else
				{
					StartDirectory = Directory;
					FMessageDialog::Open(EAppMsgType::Ok, FailureReason);
					continue;
				}
			}
			break;
		}
	}

	return FReply::Handled();
}

```


ï»¿# FilePathFilter

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šæ–‡ä»¶é€‰æ‹©å™¨çš„æ‰©å±•åï¼Œè§„åˆ™ç¬¦åˆç³»ç»Ÿå¯¹è¯æ¡†çš„æ ¼å¼è§„èŒƒï¼Œå¯ä»¥å¡«å†™å¤šä¸ªæ‰©å±•åã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FFilePath
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸€èˆ¬å¸¸è§çš„ç”¨æ³•æ˜¯â€.umapâ€ï¼Œâ€œ.uassetâ€ä¹‹ç±»çš„ã€‚ä½†ä¹Ÿå¯ä»¥æ”¯æŒé‡‡ç”¨â€œæè¿° | *.åç¼€åâ€çš„æ ¼å¼è‡ªå·±ä¹¦å†™è¿‡æ»¤æ–¹å¼ï¼Œè§„åˆ™åŒwindowsç³»ç»Ÿé€‰å–è§„åˆ™ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥åŒæ—¶å†™å¤šä¸ªåç¼€åã€‚


ï»¿# LongPackageName

- **åŠŸèƒ½æè¿°ï¼š** ä½¿ç”¨UEçš„é£æ ¼æ¥é€‰æ‹©Contentä»¥åŠå­ç›®å½•ï¼Œæˆ–è€…æŠŠæ–‡ä»¶è·¯å¾„è½¬æ¢ä¸ºé•¿åŒ…åã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FDirectoryPathï¼ŒFFilePath
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

LongPackageNameå¯ä»¥åŒæ—¶ç”¨åœ¨FDirectoryPathå’ŒFFilePathï¼Œéƒ½é™åˆ¶é€‰å–èŒƒå›´åœ¨Contentç›®å½•å†…ã€‚

ç”¨åœ¨FDirectoryPathä¸Šçš„æ—¶å€™ï¼Œé™åˆ¶ç›®å½•ä¸ºContentæˆ–å…¶å­ç›®å½•ã€‚

ç”¨åœ¨FFilePathçš„æ—¶å€™ï¼Œé™åˆ¶é€‰æ‹©èŒƒå›´ä¸ºContenté‡Œçš„èµ„äº§ï¼Œæœ€ç»ˆæŠŠé€‰å–çš„æ–‡ä»¶è·¯å¾„è½¬æ¢ä¸ºâ€œ/Game/ObjectPathâ€è¿™ç§å¯¹è±¡çš„è·¯å¾„åã€‚


ï»¿# RelativePath

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—ç³»ç»Ÿç›®å½•é€‰æ‹©å¯¹è¯æ¡†çš„ç»“æœä¸ºå½“å‰è¿è¡Œexeçš„ç›¸å¯¹è·¯å¾„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FDirectoryPath 
- **å…³è”é¡¹ï¼š** [ContentDir](ContentDir/ContentDir.md)

å½“å‰ç›®å½•ä¸ºï¼šD:\github\GitWorkspace\Hello\Binaries\Win64ï¼Œå°±æ˜¯exeæ‰€åœ¨çš„å·¥ä½œç›®å½•ã€‚é€‰æ‹©çš„ç›®å½•ä¼šè¢«è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ã€‚

```cpp
Directory = IFileManager::Get().ConvertToRelativePath(*Directory);
```


ï»¿# RelativeToGameContentDir

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—ç³»ç»Ÿç›®å½•é€‰æ‹©å¯¹è¯æ¡†çš„ç»“æœä¸ºç›¸å¯¹Contentçš„ç›¸å¯¹è·¯å¾„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FDirectoryPath 
- **å…³è”é¡¹ï¼š** [ContentDir](ContentDir/ContentDir.md)

é™åˆ¶ç›®å½•é€‰æ‹©çš„ç»“æœå¿…é¡»æ˜¯Conentç›®å½•æˆ–å…¶å­ç›®å½•ï¼Œå¦åˆ™ä¼šå¼¹å‡ºæŠ¥é”™ä¿¡æ¯ã€‚è½¬æ¢çš„é€»è¾‘ä¸ºæŠŠå·¦ä¾§çš„Contentè·¯å¾„è£åˆ‡æ‰ã€‚

```cpp
Directory.RightChopInline(AbsoluteGameContentDir.Len(), EAllowShrinking::No);
```


ï»¿# RelativeToGameDir

- **åŠŸèƒ½æè¿°ï¼š** å¦‚æœç³»ç»Ÿç›®å½•é€‰æ‹©æ¡†çš„ç»“æœä¸ºProjectçš„å­ç›®å½•ï¼Œåˆ™è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ï¼Œå¦åˆ™è¿”å›ç»å¯¹è·¯å¾„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Path Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FFilePath 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å¦‚æœç³»ç»Ÿç›®å½•é€‰æ‹©æ¡†çš„ç»“æœä¸ºProjectçš„å­ç›®å½•ï¼Œåˆ™è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ï¼Œå¦åˆ™è¿”å›ç»å¯¹è·¯å¾„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath)
	FFilePath MyFilePath_Default;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath, meta = (LongPackageName))
	FFilePath MyFilePath_LongPackageName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath, meta = (RelativeToGameDir))
	FFilePath MyFilePath_RelativeToGameDir;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath, meta = (FilePathFilter = "umap"))
	FFilePath MyFilePath_FilePathFilter;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath, meta = (FilePathFilter = "My Config Files|*.ini"))
	FFilePath MyFilePath_FilePathFilter_INI;
```

## æµ‹è¯•ç»“æœï¼š

- FFilePathå¼¹å‡ºçš„éƒ½ä¸ºWindowsç³»ç»Ÿçš„é»˜è®¤æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ã€‚
- MyFilePath_Defaultï¼Œå¼¹å‡ºé»˜è®¤çš„ç³»ç»Ÿæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ï¼Œå¯ä»¥é€‰æ‹©ä»»ä½•è·¯å¾„çš„ä»»ä½•æ–‡ä»¶ã€‚
- MyFilePath_LongPackageNameï¼Œé™åˆ¶é€‰æ‹©èŒƒå›´ä¸ºContentä¸‹çš„èµ„äº§ï¼Œå¦åˆ™ä¼šå¼¹å‡ºæŠ¥é”™ã€‚ç»“æœè·¯å¾„ä¼šè¢«è½¬æ¢ä¸º/Game/ObjectPathè¿™ç§é•¿çš„åŒ…åã€‚
- MyFilePath_RelativeToGameDirï¼Œå¦‚æœé€‰æ‹©ç»“æœä¸ºProjectç›®å½•ï¼ˆuprojectæ‰€åœ¨çš„ç›®å½•ï¼‰ä¸‹çš„å­æ–‡ä»¶ï¼Œåˆ™è¿”å›ç»“æœä¼šç›¸å¯¹è·¯å¾„ã€‚å¦åˆ™ç›´æ¥è¿”å›ç»å¯¹è·¯å¾„ã€‚
- MyFilePath_FilePathFilterï¼Œå¯ä»¥é€‰æ‹©ä»»ä½•ç›®å½•ä¸‹çš„æŒ‡å®šåç¼€åçš„æ–‡ä»¶ã€‚ä»£ç é‡Œç¤ºä¾‹ä¸ºumapï¼Œåˆ™åªèƒ½é€‰æ‹©å…³å¡æ–‡ä»¶ã€‚
- MyFilePath_FilePathFilter_INIï¼Œæ¼”ç¤ºäº†åªèƒ½é€‰å–iniæ–‡ä»¶ã€‚FilePathFilter æ”¯æŒæˆ‘ä»¬é‡‡ç”¨â€œæè¿° | *.åç¼€åâ€çš„æ ¼å¼è‡ªå·±ä¹¦å†™è¿‡æ»¤æ–¹å¼ï¼Œè§„åˆ™åŒwindowsç³»ç»Ÿé€‰å–è§„åˆ™ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥åŒæ—¶å†™å¤šä¸ªåç¼€åã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Path\RelativeToGameDir\Untitled.png)

## åŸç†ï¼š

åœ¨ä¸‹é¢ä»£ç å°±å¯ä»¥çœ‹è§FilePathFilterï¼ŒbLongPackageName ï¼ŒbRelativeToGameDir çš„å¤„ç†é€»è¾‘ã€‚

- FileTypeFilter è®¾å®šæ‰©å±•ååˆ°SFilePathPickeré‡Œ
- bLongPackageName è§¦å‘TryConvertFilenameToLongPackageNameæ¥è½¬æ¢è·¯å¾„ã€‚
- bRelativeToGameDir è§¦å‘AbsolutePickedPath.RightChop(AbsoluteProjectDir.Len());æ¥å˜æˆç›¸å¯¹è·¯å¾„ã€‚

```cpp
USTRUCT(BlueprintType)
struct FFilePath
{
	GENERATED_BODY()

	/**
	* The path to the file.
	*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = FilePath)
	FString FilePath;
};

void FFilePathStructCustomization::CustomizeHeader( TSharedRef<IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils )
{
	const FString& MetaData = StructPropertyHandle->GetMetaData(TEXT("FilePathFilter"));
	bLongPackageName = StructPropertyHandle->HasMetaData(TEXT("LongPackageName"));
	bRelativeToGameDir = StructPropertyHandle->HasMetaData(TEXT("RelativeToGameDir"));
	
	if (MetaData.IsEmpty())
	{
		FileTypeFilter = TEXT("All files (*.*)|*.*");
	}
	else
	{
		if (MetaData.Contains(TEXT("|"))) // If MetaData follows the Description|ExtensionList format, use it as is
		{
			FileTypeFilter = MetaData;
		}
		else
		{
			FileTypeFilter = FString::Printf(TEXT("%s files (*.%s)|*.%s"), *MetaData, *MetaData, *MetaData);
		}
	}
}

void FFilePathStructCustomization::HandleFilePathPickerPathPicked( const FString& PickedPath )
{
	FString FinalPath = PickedPath;
	if (bLongPackageName)
	{
		FString LongPackageName;
		FString StringFailureReason;
		if (FPackageName::TryConvertFilenameToLongPackageName(PickedPath, LongPackageName, &StringFailureReason) == false)
		{
			FMessageDialog::Open(EAppMsgType::Ok, FText::FromString(StringFailureReason));
		}
		FinalPath = LongPackageName;
	}
	else if (bRelativeToGameDir && !PickedPath.IsEmpty())
	{
		//A filepath under the project directory will be made relative to the project directory
		//Otherwise, the absolute path will be returned unless it doesn't exist, the current path will
		//be kept. This can happen if it's already relative to project dir (tabbing when selected)

		const FString ProjectDir = FPaths::ProjectDir();
		const FString AbsoluteProjectDir = FPaths::ConvertRelativePathToFull(ProjectDir);
		const FString AbsolutePickedPath = FPaths::ConvertRelativePathToFull(PickedPath);

		//Verify if absolute path to file exists. If it was already relative to content directory
		//the absolute will be to binaries and will possibly be garbage
		if (FPaths::FileExists(AbsolutePickedPath))
		{
			//If file is part of the project dir, chop the project dir part
			//Otherwise, use the absolute path
			if (AbsolutePickedPath.StartsWith(AbsoluteProjectDir))
			{
				FinalPath = AbsolutePickedPath.RightChop(AbsoluteProjectDir.Len());
			}
			else
			{
				FinalPath = AbsolutePickedPath;
			}
		}
		else
		{
			//If absolute file doesn't exist, it might already be relative to project dir
			//If not, then it might be a manual entry, so keep it untouched either way
			FinalPath = PickedPath;
		}
	}

	PathStringProperty->SetValue(FinalPath);
	FEditorDirectories::Get().SetLastDirectory(ELastDirectory::GENERIC_OPEN, FPaths::GetPath(PickedPath));
}
```


ï»¿# DataTablePin

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºDataTableæˆ–CurveTableç±»å‹ï¼Œä»¥ä¾¿ä¸ºFNameçš„å…¶ä»–å‚æ•°æä¾›RowNameListçš„é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** DataTableï¼ŒCurveTable
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šä¸€ä¸ªå‡½æ•°å‚æ•°ä¸ºUDataTableç±»å‹ï¼Œè¿™æ ·å°±å¯ä»¥åŠ è½½æ ¹æ®DataTableé‡Œçš„æ•°æ®ï¼Œä¸ºRowNameæä¾›ä¸€ä¸ªListæ¥é€‰æ‹©ï¼Œè€Œä¸æ˜¯æ‰‹å¡«ã€‚æ”¯æŒçš„ç±»å‹æ˜¯DataTableå’ŒCurveTable

å¦‚æœæ˜¯DataTablePinï¼Œåˆ™ä¼šé‡‡ç”¨UK2Node_CallDataTableFunctionæ¥ç”Ÿæˆè“å›¾èŠ‚ç‚¹ï¼Œä»¥ä¾¿åœ¨DataTable Pinè¿æ¥å‚æ•°æ”¹å˜çš„æ—¶å€™ï¼Œè§¦å‘RowNameListçš„åˆ·æ–°ã€‚

UK2Node_GetDataTableRowä¹Ÿæ˜¯ä¸€ä¸ªå•ç‹¬çš„è“å›¾èŠ‚ç‚¹ã€‚

ä½†æ˜¯å‘ç°RowNameå¹¶æ²¡æœ‰ç”¨metaæŒ‡å®šï¼Ÿä½†æ˜¯æœ‰åˆ¤æ–­å‡½æ•°çš„å‚æ•°å¦‚æœç±»å‹æ˜¯FNameï¼Œå°±ä¼šæŠŠå®ƒå½“ä½œRowNameæ¥çœ‹å¾…ã€‚ï¼ˆè¿™ä¹ˆç®€å•ç²—ç³™çš„åˆ¤æ–­ï¼Œä¹Ÿæ˜¯å› ä¸ºå…¶å¹¶ä¸æ‰“ç®—æŠŠè¿™ä¸ªMetaç»™ç”¨æˆ·ä½¿ç”¨ï¼‰ã€‚å› æ­¤å®é™…ä¸Šå‡½æ•°é‡Œå¯ä»¥æœ‰å¤šä¸ªFNameçš„å‚æ•°ï¼Œéƒ½ä¼šè¢«è‡ªåŠ¨çš„èµ‹äºˆRowNameList

åœ¨æºç ä¸­ç”¨çš„åœ°æ–¹åªæœ‰UDataTableFunctionLibrary

```cpp
UFUNCTION(BlueprintCallable, Category = "DataTable", meta = (ExpandEnumAsExecs="OutResult", DataTablePin="CurveTable"))
static ENGINE_API void EvaluateCurveTableRow(UCurveTable* CurveTable, FName RowName, float InXY, TEnumAsByte<EEvaluateCurveTableResult::Type>& OutResult, float& OutXY,const FString& ContextString);
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION(BlueprintCallable, meta = (DataTablePin="CurveTable"))
	static void GetMyCurveTableRow(UCurveTable* CurveTable, FName MyRowName, float InXY, float& OutXY,const FString& ContextString){}
	
	UFUNCTION(BlueprintCallable, meta = (DataTablePin="TargetTable"))
	static bool HasMyDataTableRow(UDataTable* TargetTable, FName MyRowName,FName OtherRowName){return false;}
```

## è“å›¾æ•ˆæœï¼š

å·¦ä¾§ä¸ºè‡ªå·±å®šä¹‰çš„å‡½æ•°èŠ‚ç‚¹ï¼Œå¯ä»¥çœ‹è§å·¦ä¾§çš„è“å›¾èŠ‚ç‚¹ä¸Šçš„Nameéƒ½å˜æˆäº†CurveTableå’ŒDataTableé‡Œçš„RowNameListï¼Œå³ä½¿è¿™äº›FNameå‚æ•°å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹æ®ŠæŒ‡å®šï¼Œä½†æ˜¯è“å›¾ç³»ç»Ÿé‡Œè‡ªåŠ¨è¯†åˆ«åˆ°FNameç±»å‹å¹¶æ”¹å˜äº†å®é™…çš„Pin Widget.

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\DataTablePin\Untitled.png)

## åŸç†ï¼š

å¦‚æœå‘ç°FNameèŠ‚ç‚¹ï¼Œä¼šå»å°è¯•æ‰¾DataTablePinï¼Œç„¶åæ ¹æ®DataTablePinçš„ç±»å‹æ¥æ”¹å˜FNameç±»å‹çš„Pinç±»å‹ã€‚

```cpp
TSharedPtr<class SGraphPin> FBlueprintGraphPanelPinFactory::CreatePin(class UEdGraphPin* InPin) const
{
	if (InPin->PinType.PinCategory == UEdGraphSchema_K2::PC_Name)
	{
		UObject* Outer = InPin->GetOuter();

		// Create drop down combo boxes for DataTable and CurveTable RowName pins
		const UEdGraphPin* DataTablePin = nullptr;
		if (Outer->IsA(UK2Node_CallFunction::StaticClass()))
		{
			const UK2Node_CallFunction* CallFunctionNode = CastChecked<UK2Node_CallFunction>(Outer);
			if (CallFunctionNode)
			{
				const UFunction* FunctionToCall = CallFunctionNode->GetTargetFunction();
				if (FunctionToCall)
				{
					const FString& DataTablePinName = FunctionToCall->GetMetaData(FBlueprintMetadata::MD_DataTablePin);
					DataTablePin = CallFunctionNode->FindPin(DataTablePinName);
				}
			}
		}
		else if (Outer->IsA(UK2Node_GetDataTableRow::StaticClass()))
		{
			const UK2Node_GetDataTableRow* GetDataTableRowNode = CastChecked<UK2Node_GetDataTableRow>(Outer);
			DataTablePin = GetDataTableRowNode->GetDataTablePin();
		}

		if (DataTablePin)
		{
			if (DataTablePin->DefaultObject != nullptr && DataTablePin->LinkedTo.Num() == 0)
			{
				if (auto DataTable = Cast<UDataTable>(DataTablePin->DefaultObject))
				{
					return SNew(SGraphPinDataTableRowName, InPin, DataTable);
				}
				if (DataTablePin->DefaultObject->IsA(UCurveTable::StaticClass()))
				{
					UCurveTable* CurveTable = (UCurveTable*)DataTablePin->DefaultObject;
					if (CurveTable)
					{
						TArray<TSharedPtr<FName>> RowNames;
						/** Extract all the row names from the RowMap */
						for (TMap<FName, FRealCurve*>::TConstIterator Iterator(CurveTable->GetRowMap()); Iterator; ++Iterator)
						{
							/** Create a simple array of the row names */
							TSharedPtr<FName> RowNameItem = MakeShareable(new FName(Iterator.Key()));
							RowNames.Add(RowNameItem);
						}
						return SNew(SGraphPinNameList, InPin, RowNames);
					}
				}
			}
		}
	}

	return nullptr;
}

```


ï»¿# DisableSplitPin

- **åŠŸèƒ½æè¿°ï¼š** ç¦ç”¨Structçš„splitåŠŸèƒ½
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

å¯¹äºæŸäº›Structï¼Œç‰¹åˆ«æ˜¯åªæœ‰ä¸€ä¸ªæˆå‘˜å˜é‡çš„ç»“æ„ï¼Œæœ‰æ—¶å€™å¦‚æœæŒ‰ç…§é»˜è®¤çš„å±•å¼€åˆ™ä¼šæ˜¾å¾—å¾ˆæ€ªã€‚è¿™ä¸ªæ—¶å€™å°±å¸Œæœ›èƒ½å¤Ÿç¦ç”¨æ‰è¿™ä¸ªåŠŸèƒ½ã€‚ä½†æ˜¯æ³¨æ„ä¾ç„¶å¯ä»¥æ‰‹åŠ¨åœ¨è“å›¾é‡ŒBreakæ¥è®¿é—®æˆå‘˜å˜é‡ã€‚å¦‚æœåœ¨è“å›¾é‡Œä¹Ÿä¸æƒ³æš´éœ²æˆå‘˜å˜é‡è®¿é—®ï¼Œé‚£åº”è¯¥åœ¨UPROPERTYä¸Šä¸èƒ½åŠ BlueprintReadWrite/BlueprintReadOnly

åœ¨æºç é‡Œæœç´¢ï¼Œå¦‚FGameplayTagï¼ŒFPostProcessSettingsï¼ŒFSlatePostSettings

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType, meta = (DisableSplitPin))
struct INSIDER_API FMyStruct_DisableSplitPin
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_WithSplitPin
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};
```

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\DisableSplitPin\Untitled.png)

å…è®¸çš„å¯¹æ¯”

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\DisableSplitPin\Untitled%201.png)


ï»¿# HiddenByDefault

- **åŠŸèƒ½æè¿°ï¼š** Structçš„Make Structå’ŒBreak StructèŠ‚ç‚¹ä¸­çš„å¼•è„šé»˜è®¤ä¸ºéšè—çŠ¶æ€
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
//(BlueprintType = true, HiddenByDefault = , ModuleRelativePath = Struct/MyStruct_HiddenByDefault.h)
USTRUCT(BlueprintType, meta = (HiddenByDefault))
struct INSIDER_API FMyStruct_HiddenByDefault
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_NotHidden
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};
```

## è“å›¾ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\HiddenByDefault\Untitled.png)

æ‰€è°“éšè—ï¼ŒæŒ‡çš„æ˜¯åœ¨èŠ‚ç‚¹çš„ç»†èŠ‚é¢æ¿é‡Œéœ€è¦æ‰‹åŠ¨é€‰æ‹©æŸäº›å±æ€§ã€‚è€Œä¸æ˜¯åƒé»˜è®¤çš„ä¸€æ ·ä¸€å¼€å§‹å°±å…¨éƒ¨è‡ªåŠ¨æ‰“å¼€ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\HiddenByDefault\Untitled%201.png)


ï»¿# HidePin

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼ŒæŒ‡å®šè¦éšè—çš„å‚æ•°åç§°ï¼Œä¹Ÿå¯ä»¥éšè—è¿”å›å€¼ã€‚å¯ä»¥éšè—å¤šä¸ªå‚æ•°
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [InternalUseParam](../InternalUseParam/InternalUseParam.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æºç é‡Œå€’æ˜¯ç»å¸¸å‘ç°å’ŒDefaultToSelfæ¯”è¾ƒåˆåŒã€‚æ—¢éšè—çš„åŒæ—¶ï¼Œåˆæœ‰é»˜è®¤å€¼ã€‚ä¸€èµ·åˆå¹¶çš„æ•ˆæœæ˜¯æŠŠä¸€ä¸ªé™æ€å‡½æ•°è°ƒç”¨ï¼Œé™åˆ¶åœ¨ä¸€ä¸ªå‚æ•°ç›´æ¥ä¸ºå¤–éƒ¨è°ƒç”¨ç¯å¢ƒå¯¹è±¡ã€‚

HidePinçš„å€¼ä¹Ÿç»å¸¸æ˜¯WorldContextObjectï¼Œ

meta = (HidePin = "WorldContextObject", DefaultToSelf = "WorldContextObject")

## C++æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_HidePinfTest :public AActor
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	int MyFunc_Default(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (HidePin = "options"))
	int MyFunc_HidePin(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment"))
	int MyFunc_HidePin2(FName name, float value, FString options,FString comment) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options"))
	int MyFunc_InternalUseParam(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (HidePin = "ReturnValue"))
	int MyFunc_HideReturn(FName name, float value, FString options, FString& otherReturn) { return 0; }

public:
	UFUNCTION(BlueprintPure)
	int MyPure_Default(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (HidePin = "options"))
	int MyPure_HidePin(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (InternalUseParam = "options"))
	int MyPure_InternalUseParam(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (HidePin = "ReturnValue"))
	int MyPure_HideReturn(FName name, float value, FString options, FString& otherReturn) { return 0; }

public:
	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment"))
	int MyFunc_InternalUseParams2(FName name, float value, FString options,FString comment) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment,ReturnValue"))
	int MyFunc_InternalUseParams3(FName name, float value, FString options,FString comment) { return 0; }

};
```

## è“å›¾æµ‹è¯•ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\HidePin\Untitled.png)

å¯ä»¥çœ‹å‡ºBlueprintCallableå’ŒBlueprintPureå…¶å®éƒ½å¯ä»¥ã€‚å¦å¤–ReturnValueæ˜¯é»˜è®¤çš„è¿”å›å€¼çš„åå­—ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¿™ä¸ªæ¥éšè—æ‰ã€‚

## åŸç†ï¼š

åœ¨æºç é‡Œæœç´¢ï¼Œå”¯ä¸€ç”¨åˆ°çš„æ˜¯ï¼š

å¯ä»¥å‘ç°ä»¥ä¸‹è¿™äº›æƒ…å†µçš„Pinä¼šè‡ªåŠ¨è¢«éšè—ï¼š

- LatentInfo=â€ParametertNameâ€
- HidePin=â€ParametertNameâ€
- InternalUseParam=â€ParametertName1, ParametertName2â€ï¼Œå¯ä»¥å¤šä¸ª
- ExpandEnumAsExecsæˆ–ExpandBoolAsExecsé‡Œé¢æŒ‡å®šçš„PinNames
- WorldContext=â€ParametertNameâ€ï¼Œæˆå‘˜å‡½æ•°è¢«è°ƒç”¨ï¼Œä¸”C++åŸºç±»æœ‰å®ç°GetWorldï¼Œè¿™æ—¶WorldContextå¯ä»¥è‡ªåŠ¨è¢«èµ‹äºˆæ­£ç¡®çš„Worldå€¼ï¼Œå°±ä¸éœ€è¦æ˜¾ç¤ºå‡ºæ¥äº†ã€‚

è¿™ä¸ªå‡½æ•°æ˜¯è¢«CreatePinsForFunctionCallæ‰€è°ƒç”¨ï¼Œç”¨æ¥å¯¹Functionçš„å†…éƒ¨Propertyè¿›è¡Œç­›é€‰ï¼Œä¹Ÿå°±æ˜¯Params+ReturnValueï¼Œå› æ­¤æ˜¯HidePinæ˜¯ä¸èƒ½ç”¨æ¥éšè—Targetè¿™ç§Pinçš„ï¼Œè¿™ç§éœ€æ±‚åº”è¯¥æ˜¯HideSelfPinã€‚

```cpp
// Gets a list of pins that should hidden for a given function
void FBlueprintEditorUtils::GetHiddenPinsForFunction(UEdGraph const* Graph, UFunction const* Function, TSet<FName>& HiddenPins, TSet<FName>* OutInternalPins)
{
	check(Function != nullptr);
	TMap<FName, FString>* MetaData = UMetaData::GetMapForObject(Function);	
	if (MetaData != nullptr)
	{
		for (TMap<FName, FString>::TConstIterator It(*MetaData); It; ++It)
		{
			const FName& Key = It.Key();

			if (Key == FBlueprintMetadata::MD_LatentInfo)
			{
				HiddenPins.Add(*It.Value());
			}
			else if (Key == FBlueprintMetadata::MD_HidePin)
			{
				TArray<FString> HiddenPinNames;
				It.Value().ParseIntoArray(HiddenPinNames, TEXT(","));
				for (FString& HiddenPinName : HiddenPinNames)
				{
					HiddenPinName.TrimStartAndEndInline();
					HiddenPins.Add(*HiddenPinName);
				}
			}
			else if (Key == FBlueprintMetadata::MD_ExpandEnumAsExecs ||
					Key == FBlueprintMetadata::MD_ExpandBoolAsExecs)
			{
				TArray<FName> EnumPinNames;
				UK2Node_CallFunction::GetExpandEnumPinNames(Function, EnumPinNames);
				
				for (const FName& EnumName : EnumPinNames)
				{
					HiddenPins.Add(EnumName);
				}
			}
			else if (Key == FBlueprintMetadata::MD_InternalUseParam)
			{
				TArray<FString> HiddenPinNames;
				It.Value().ParseIntoArray(HiddenPinNames, TEXT(","));
				for (FString& HiddenPinName : HiddenPinNames)
				{
					HiddenPinName.TrimStartAndEndInline();

					FName HiddenPinFName(*HiddenPinName);
					HiddenPins.Add(HiddenPinFName);

					if (OutInternalPins)
					{
						OutInternalPins->Add(HiddenPinFName);
					}
				}
			}
			else if (Key == FBlueprintMetadata::MD_WorldContext)
			{
				const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
				if(!K2Schema->IsStaticFunctionGraph(Graph))
				{
					bool bHasIntrinsicWorldContext = false;

					UBlueprint const* CallingContext = FindBlueprintForGraph(Graph);
					if (CallingContext && CallingContext->ParentClass)
					{
						UClass* NativeOwner = CallingContext->ParentClass;
						while(NativeOwner && !NativeOwner->IsNative())
						{
							NativeOwner = NativeOwner->GetSuperClass();
						}

						if(NativeOwner)
						{
							bHasIntrinsicWorldContext = NativeOwner->GetDefaultObject()->ImplementsGetWorld();
						}
					}

					// if the blueprint has world context that we can lookup with "self", 
					// then we can hide this pin (and default it to self)
					if (bHasIntrinsicWorldContext)
					{
						HiddenPins.Add(*It.Value());
					}
				}
			}
		}
	}
}
```


ï»¿# HideSelfPin

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼Œéšè—é»˜è®¤çš„SelfPinï¼Œä¹Ÿå°±æ˜¯Targetï¼Œå¯¼è‡´è¯¥å‡½æ•°åªèƒ½åœ¨OwnerClasså†…è°ƒç”¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼Œéšè—é»˜è®¤çš„SelfPinï¼Œä¹Ÿå°±æ˜¯Targetï¼Œå¯¼è‡´è¯¥å‡½æ•°åªèƒ½åœ¨OwnerClasså†…è°ƒç”¨ã€‚

æ³¨é‡Šé‡Œè¯´é€šå¸¸ä¸ DefaultToSelf è¯´æ˜ç¬¦å…±ç”¨ã€‚ä½†æ˜¯å®é™…ä¸Šåœ¨æºç é‡Œæ²¡æ‰¾åˆ°ä¾‹å­ã€‚

å’ŒHidePinä»¥åŠInternalUseParamæ¯”è¾ƒç±»ä¼¼ï¼Œä¸è¿‡åè€…å¯ä»¥éšè—å…¶ä»–å‚æ•°ï¼ŒHideSelfPinåªèƒ½éšè—SelfPin

## é€»è¾‘ä»£ç ï¼š

å¯ä»¥çœ‹å‡ºSelfPinçš„bHidden ä¸å¦ï¼Œå—åˆ°ä¸€äº›æƒ…å†µçš„å½±å“ï¼š

1. å¦‚æœæ˜¯Static å‡½æ•°ï¼ˆè“å›¾å‡½æ•°åº“é‡Œçš„å‡½æ•°ï¼Œæˆ–è€…C++é‡Œçš„é™æ€å‡½æ•°ï¼‰ï¼Œå› ä¸ºé»˜è®¤ä¸éœ€è¦Targetæ¥è°ƒç”¨ï¼Œåˆ™é»˜è®¤å°±éšè—èµ·SelfPin.
2. å¦‚æœå‡½æ•°ä¸Šå¸¦æœ‰HideSelfPinæ ‡è®°ï¼Œåˆ™é»˜è®¤ä¹Ÿéšè—ä¸”ä¸å¯åœ¨å¤–éƒ¨è¿æ¥ï¼Œå¯¼è‡´è¯¥å‡½æ•°åªèƒ½åœ¨æœ¬ç±»å†…è°ƒç”¨ã€‚
3. å¦‚æœå‡½æ•°æ˜¯BlueprintPureå‡½æ•°ï¼Œä¸”å½“å‰æ˜¯åœ¨OwnerClasså†…è°ƒç”¨ï¼Œåˆ™ä¸éœ€è¦æ˜¾ç¤ºSelfPinã€‚
4. åœ¨æºç é‡Œåªæ‰¾åˆ°è¿™ä¸€ä¸ªåœ°æ–¹çš„åˆ¤æ–­å’Œåº”ç”¨ã€‚å› æ­¤å¯ä»¥è®¤ä¸ºHidleSelfPinåªéšè—Selfï¼Œæ„æ€æ˜¯åªéšè—ç±»æˆå‘˜å‡½æ•°è¢«è°ƒç”¨æ—¶å€™çš„ThisæŒ‡é’ˆï¼ˆå°±æ˜¯Selfï¼Œä¹Ÿå°±æ˜¯Target)ï¼Œä½†ä¸ä¼šéšè—Staticå‡½æ•°è¢«è°ƒç”¨æ—¶å€™çš„å‚æ•°ï¼Œå“ªæ€•è¿™ä¸ªå‚æ•°è¢«DefaultToSelfæ ‡è¯†ã€‚è¢«DefaultToSelfæ ‡å¿—åªæ„å‘³ç€è¿™ä¸ªå‚æ•°çš„é»˜è®¤å€¼ä¸ºå¤–éƒ¨è°ƒç”¨ç¯å¢ƒçš„Selfå€¼ï¼Œå¹¶ä¸æ˜¯æŒ‡è¿™ä¸ªå‡½æ•°èŠ‚ç‚¹ä¸Šçš„SelfPinï¼Œé™æ€å‡½æ•°çš„SelfPinæ€»æ˜¯éšè—çš„ã€‚è¢«DefaultToSelfæ ‡è¯†çš„é‚£ä¸ªå‚æ•°è™½ç„¶å€¼ç­‰äºSelfï¼Œä½†å¹¶ä¸æ˜¯SelfPin.

```cpp
bool UK2Node_CallFunction::CreatePinsForFunctionCall(const UFunction* Function)
{
//...
		if (bIsStaticFunc)
		{
			// For static methods, wire up the self to the CDO of the class if it's not us
			if (!bIsFunctionCompatibleWithSelf)
			{
				UClass* AuthoritativeClass = FunctionOwnerClass->GetAuthoritativeClass();
				SelfPin->DefaultObject = AuthoritativeClass->GetDefaultObject();
			}
		
			// Purity doesn't matter with a static function, we can always hide the self pin since we know how to call the method
			SelfPin->bHidden = true;
		}
		else
		{
			if (Function->GetBoolMetaData(FBlueprintMetadata::MD_HideSelfPin))
			{
				SelfPin->bHidden = true;
				SelfPin->bNotConnectable = true;
			}
			else
			{
				// Hide the self pin if the function is compatible with the blueprint class and pure (the !bIsConstFunc portion should be going away soon too hopefully)
				SelfPin->bHidden = (bIsFunctionCompatibleWithSelf && bIsPureFunc && !bIsConstFunc);
			}
		}
}
```

## C++æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS()
class INSIDER_API UMyFunctionLibrary_SelfPinTest :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

	UFUNCTION(BlueprintPure,meta=(DefaultToSelf="myOwner",hidePin="myOwner"))
	static FString PrintProperty_HasDefaultToSelf_ButHide(UObject* myOwner,FName propertyName);

	UFUNCTION(BlueprintPure,meta=(DefaultToSelf="myOwner",HideSelfPin="true"))
	static FString PrintProperty_HasDefaultToSelf_AndHideSelf(UObject* myOwner,FName propertyName);

	UFUNCTION(BlueprintPure,meta=(DefaultToSelf="myOwner",InternalUseParam="myOwner"))
	static FString PrintProperty_HasDefaultToSelf_ButInternal(UObject* myOwner,FName propertyName);
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_HideSelfTest :public AActor
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	void MyFunc_Default(int value){}

	UFUNCTION(BlueprintCallable,meta=(HideSelfPin="true"))
	void MyFunc_HideSelfPin(int value){}
};
```

## è“å›¾é‡Œæµ‹è¯•æ•ˆæœï¼š

ä»ç¬¬ä¸€ä¸ªå›¾å¯ä»¥çœ‹åˆ°ï¼ŒHideSelfPinç”¨åœ¨Staticå‡½æ•°å¹¶æ— æ•ˆæœã€‚è€ŒInternalUseParamå¯ä»¥éšè—å¼•è„šã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\HideSelfPin\Untitled.png)

è€Œå¯¹äºç±»æˆå‘˜å‡½æ•°çš„æµ‹è¯•ç»“æœå¯ä»¥çœ‹å‡ºï¼š

- åœ¨ç±»å†…éƒ¨è°ƒç”¨çš„æ—¶å€™ï¼Œselfå¯ä»¥è¢«éšè—èµ·æ¥ï¼Œä½†éƒ½å¯ä»¥è°ƒç”¨ã€‚äºŒè€…çš„åŒºåˆ«æ˜¯ï¼ŒMyFunc_Defaultè¿™ä¸ªé»˜è®¤çš„ç‰ˆæœ¬ï¼Œä¹Ÿå¯ä»¥æ¥å—åŒç±»å‹çš„AMyFunction_HideSelfTest ä¸åŒå¯¹è±¡å®ä¾‹æ¥è°ƒç”¨ã€‚è€ŒMyFunc_HideSelfPinåªèƒ½è¢«å½“å‰çš„å¯¹è±¡æ¥è°ƒç”¨ã€‚
- è€Œåœ¨å·¦ä¾§å…³å¡è“å›¾ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªAMyFunction_HideSelfTest å¯¹è±¡å°è¯•è°ƒç”¨è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œå¯ä»¥å‘ç°MyFunc_Defaultå¯ä»¥è°ƒç”¨ï¼Œè€ŒMyFunc_HideSelfPinè¿™ä¸ªå‡½æ•°èŠ‚ç‚¹å°±æ— æ³•è¢«åˆ›å»ºå‡ºæ¥ã€‚å°±ç®—ç”¨å¤åˆ¶ç²˜è´´çš„æ–¹æ³•ç¡¬åˆ›é€ å‡ºæ¥ï¼Œä¹Ÿå› ä¸ºå¤±å»äº†Selfè¿™ä¸ªTarget Pinè€Œæ— æ³•è¿æ¥ï¼Œä»è€Œæ— æ³•è°ƒç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\HideSelfPin\Untitled%201.png)


ï»¿# InternalUseParam

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨å‡½æ•°è°ƒç”¨ä¸Šï¼ŒæŒ‡å®šè¦éšè—çš„å‚æ•°åç§°ï¼Œä¹Ÿå¯ä»¥éšè—è¿”å›å€¼ã€‚å¯ä»¥éšè—å¤šä¸ªå‚æ•°
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **å…³è”é¡¹ï¼š** [HidePin](../HidePin/HidePin.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

è¯¥å…ƒæ•°æ®å’ŒHidePinæ˜¯ç­‰ä»·çš„ã€‚

## C++æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_HidePinfTest :public AActor
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	int MyFunc_Default(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (HidePin = "options"))
	int MyFunc_HidePin(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment"))
	int MyFunc_HidePin2(FName name, float value, FString options,FString comment) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options"))
	int MyFunc_InternalUseParam(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (HidePin = "ReturnValue"))
	int MyFunc_HideReturn(FName name, float value, FString options, FString& otherReturn) { return 0; }

public:
	UFUNCTION(BlueprintPure)
	int MyPure_Default(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (HidePin = "options"))
	int MyPure_HidePin(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (InternalUseParam = "options"))
	int MyPure_InternalUseParam(FName name, float value, FString options) { return 0; }

	UFUNCTION(BlueprintPure, meta = (HidePin = "ReturnValue"))
	int MyPure_HideReturn(FName name, float value, FString options, FString& otherReturn) { return 0; }

public:
	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment"))
	int MyFunc_InternalUseParams2(FName name, float value, FString options,FString comment) { return 0; }

	UFUNCTION(BlueprintCallable, meta = (InternalUseParam = "options,comment,ReturnValue"))
	int MyFunc_InternalUseParams3(FName name, float value, FString options,FString comment) { return 0; }

};
```

## è“å›¾æµ‹è¯•ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\InternalUseParam\Untitled.png)

å¯ä»¥çœ‹å‡ºBlueprintCallableå’ŒBlueprintPureå…¶å®éƒ½å¯ä»¥ã€‚å¦å¤–ReturnValueæ˜¯é»˜è®¤çš„è¿”å›å€¼çš„åå­—ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¿™ä¸ªæ¥éšè—æ‰ã€‚

## åŸç†ï¼š

å¯è§MD_InternalUseParamçš„ä½¿ç”¨ä¹Ÿæ˜¯åœ¨éšè—å¼•è„šã€‚

```cpp
// Gets a list of pins that should hidden for a given function
void FBlueprintEditorUtils::GetHiddenPinsForFunction(UEdGraph const* Graph, UFunction const* Function, TSet<FName>& HiddenPins, TSet<FName>* OutInternalPins)
{
	check(Function != nullptr);
	TMap<FName, FString>* MetaData = UMetaData::GetMapForObject(Function);	
	if (MetaData != nullptr)
	{
		for (TMap<FName, FString>::TConstIterator It(*MetaData); It; ++It)
		{
			const FName& Key = It.Key();

			if (Key == FBlueprintMetadata::MD_LatentInfo)
			{
				HiddenPins.Add(*It.Value());
			}
			else if (Key == FBlueprintMetadata::MD_HidePin)
			{
				TArray<FString> HiddenPinNames;
				It.Value().ParseIntoArray(HiddenPinNames, TEXT(","));
				for (FString& HiddenPinName : HiddenPinNames)
				{
					HiddenPinName.TrimStartAndEndInline();
					HiddenPins.Add(*HiddenPinName);
				}
			}
			else if (Key == FBlueprintMetadata::MD_ExpandEnumAsExecs ||
					Key == FBlueprintMetadata::MD_ExpandBoolAsExecs)
			{
				TArray<FName> EnumPinNames;
				UK2Node_CallFunction::GetExpandEnumPinNames(Function, EnumPinNames);
				
				for (const FName& EnumName : EnumPinNames)
				{
					HiddenPins.Add(EnumName);
				}
			}
			else if (Key == FBlueprintMetadata::MD_InternalUseParam)
			{
				TArray<FString> HiddenPinNames;
				It.Value().ParseIntoArray(HiddenPinNames, TEXT(","));
				for (FString& HiddenPinName : HiddenPinNames)
				{
					HiddenPinName.TrimStartAndEndInline();

					FName HiddenPinFName(*HiddenPinName);
					HiddenPins.Add(HiddenPinFName);

					if (OutInternalPins)
					{
						OutInternalPins->Add(HiddenPinFName);
					}
				}
			}
			else if (Key == FBlueprintMetadata::MD_WorldContext)
			{
				const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
				if(!K2Schema->IsStaticFunctionGraph(Graph))
				{
					bool bHasIntrinsicWorldContext = false;

					UBlueprint const* CallingContext = FindBlueprintForGraph(Graph);
					if (CallingContext && CallingContext->ParentClass)
					{
						UClass* NativeOwner = CallingContext->ParentClass;
						while(NativeOwner && !NativeOwner->IsNative())
						{
							NativeOwner = NativeOwner->GetSuperClass();
						}

						if(NativeOwner)
						{
							bHasIntrinsicWorldContext = NativeOwner->GetDefaultObject()->ImplementsGetWorld();
						}
					}

					// if the blueprint has world context that we can lookup with "self", 
					// then we can hide this pin (and default it to self)
					if (bHasIntrinsicWorldContext)
					{
						HiddenPins.Add(*It.Value());
					}
				}
			}
		}
	}
}
```


ï»¿# PinHiddenByDefault

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—è¿™ä¸ªç»“æ„é‡Œçš„å±æ€§åœ¨è“å›¾é‡Œä½œä¸ºå¼•è„šæ—¶é»˜è®¤æ˜¯éšè—çš„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Pin
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** struct member property
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿å¾—è¿™ä¸ªç»“æ„é‡Œçš„å±æ€§åœ¨è“å›¾é‡Œä½œä¸ºå¼•è„šæ—¶é»˜è®¤æ˜¯éšè—çš„ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯è¿™ä¸ªmetaåªä½œç”¨äºç»“æ„çš„æˆå‘˜å±æ€§ï¼Œä¸”åªä½œç”¨åœ¨è“å›¾é‡Œçš„èŠ‚ç‚¹ã€‚åœ¨æœ‰äº›æ—¶å€™ä¸€ä¸ªç»“æ„é‡Œæ‹¥æœ‰å¤šä¸ªå±æ€§ï¼Œä½†ä¸æ˜¯å¸Œæœ›ä¸€ä¸‹å­æš´éœ²æ‰€æœ‰å±æ€§æ¥è®©ç”¨æˆ·ç¼–è¾‘ï¼Œæœ‰äº›å±æ€§å¯èƒ½æ˜¯é«˜çº§å±æ€§éœ€è¦ä¸€å¼€å§‹éšè—èµ·æ¥ã€‚

è¯¥æ ‡è®°ä¹Ÿå¯ä»¥åœ¨åŠ¨ç”»è“å›¾ä¸­ï¼Œè®©åŠ¨ç”»èŠ‚ç‚¹çš„æŸäº›å±æ€§ä¸æš´éœ²æˆå¼•è„šã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMyPinHiddenTestStruct
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=PinHiddenByDefaultTest)
	int32 MyInt_NotHidden = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=PinHiddenByDefaultTest, meta = (PinHiddenByDefault))
	int32 MyInt_PinHiddenByDefault = 123;
};

	UFUNCTION(BlueprintCallable)
	static FMyPinHiddenTestStruct MyHiddenPinTestFunc(FMyPinHiddenTestStruct Input);
```

## æµ‹è¯•ç»“æœï¼š

å¯ä»¥å‘ç°MakeStructå’ŒBreakStructçš„èŠ‚ç‚¹ï¼Œé»˜è®¤åªæœ‰MyInt_NotHiddenã€‚å½“é€‰æ‹©è¯¥è“å›¾èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥åœ¨å³ä¾§ç»†èŠ‚é¢æ¿çœ‹åˆ°MyInt_PinHiddenByDefault çš„æ˜¾ç¤ºé»˜è®¤æ²¡æœ‰é€‰ä¸­ï¼Œè¿™å°±æ˜¯åŒºåˆ«ã€‚

åŒæ ·çš„ï¼Œå½“è¯¥ç»“æ„å½“ä½œå‡½æ•°è¾“å…¥å’Œè¾“å‡ºå‚æ•°çš„æ—¶å€™ï¼Œå½“ç”¨SplitStuctPinå±•å¼€ç»“æ„èŠ‚ç‚¹ï¼Œä¼šå‘ç°MyInt_PinHiddenByDefault ä¹Ÿè¢«éšè—äº†èµ·æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Pin\PinHiddenByDefault\Untitled.png)

## åŸç†ï¼š

é€šè¿‡æºç å¯ä»¥å‘ç°ï¼ŒFStructOperationOptionalPinManager é‡Œä½¿ç”¨äº†è¯¥metaï¼Œç„¶åFMakeStructPinManager å’ŒFBreakStructPinManager ç»§æ‰¿äº†ï¼Œä»è€Œä½¿å¾—PinHiddenByDefaultçš„Pinä¸€å¼€å§‹ä¸æ˜¾ç¤ºã€‚

```cpp
struct FStructOperationOptionalPinManager : public FOptionalPinManager
{
	//~ Begin FOptionalPinsUpdater Interface
	virtual void GetRecordDefaults(FProperty* TestProperty, FOptionalPinFromProperty& Record) const override
	{
		Record.bCanToggleVisibility = true;
		Record.bShowPin = true;
		if (TestProperty)
		{
			Record.bShowPin = !TestProperty->HasMetaData(TEXT("PinHiddenByDefault"));
			if (Record.bShowPin)
			{
				if (UStruct* OwnerStruct = TestProperty->GetOwnerStruct())
				{
					Record.bShowPin = !OwnerStruct->HasMetaData(TEXT("HiddenByDefault"));
				}
			}
		}
	}

	virtual void CustomizePinData(UEdGraphPin* Pin, FName SourcePropertyName, int32 ArrayIndex, FProperty* Property) const override;
	// End of FOptionalPinsUpdater interfac
};

struct FMakeStructPinManager : public FStructOperationOptionalPinManager
{}
struct FBreakStructPinManager : public FStructOperationOptionalPinManager
{}

```


ï»¿# Abstract

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¯¥FRigUnitä¸ºæŠ½è±¡ç±»ï¼Œä¸ç”¨å®ç°Executeã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitç±»å‹ä¸Š
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æ ‡è¯†è¯¥FRigUnitä¸ºæŠ½è±¡ç±»ï¼Œä¸ç”¨å®ç°Executeï¼Œå¸¸å¸¸ç”¨ä½œåˆ«çš„FRigUnitç±»çš„åŸºç±»ä½¿ç”¨ã€‚

ä½†å¦‚æœè¿˜æ˜¯å®ç°äº†Executeï¼Œå…¶å®ä¹Ÿè¿˜æ˜¯å¯ä»¥åœ¨è“å›¾ä¸­è°ƒç”¨çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigAbstract",Abstract))
struct INSIDER_API FRigUnit_MyRigAbstract: public FRigUnit
{
	GENERATED_BODY()
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Abstract\Untitled.png)

## åŸç†ï¼š

åœ¨ä¸€äº›å†…éƒ¨å¤„ç†çš„æ—¶å€™ï¼Œå½“ç„¶ä¼šç•¥è¿‡è¿™ç§æŠ½è±¡åŸºç±»ã€‚

```cpp
void FRigVMBlueprintUtils::ForAllRigVMStructs(TFunction<void(UScriptStruct*)> InFunction)
{
	// Run over all unit types
	for(TObjectIterator<UStruct> StructIt; StructIt; ++StructIt)
	{
		if (*StructIt)
		{
			if(StructIt->IsChildOf(FRigVMStruct::StaticStruct()) && !StructIt->HasMetaData(FRigVMStruct::AbstractMetaName))
			{
				if (UScriptStruct* ScriptStruct = Cast<UScriptStruct>(*StructIt))
				{
					InFunction(ScriptStruct);
				}
			}
		}
	}
}
```


ï»¿# Aggregate

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnité‡Œçš„å±æ€§å¼•è„šä¸ºå¯æ‰©å±•è¿ç»­äºŒå…ƒè¿ç®—ç¬¦çš„è¿ç®—æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸‹çš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šFRigUnité‡Œçš„å±æ€§å¼•è„šä¸ºå¯æ‰©å±•è¿ç»­äºŒå…ƒè¿ç®—ç¬¦çš„è¿ç®—æ•°ã€‚

è®°å¾—åœ¨Inputå’ŒOutputä¸Šéƒ½åŠ ä¸ŠAggregateã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigAggregate"))
struct INSIDER_API FRigUnit_MyRigAggregate : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input,Aggregate))
	float A = 0.f;

	UPROPERTY(meta = (Input,Aggregate))
	float B= 0.f;

	UPROPERTY(meta = (Output,Aggregate))
	float Result = 0.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åŠ äº†Aggregateä¹‹åï¼Œåœ¨è“å›¾èŠ‚ç‚¹ä¸Šå°±å¯ä»¥ç»§ç»­åŠ¨æ€AddPinã€‚åœ¨å·¦ä¾§çš„Graphä¸Šä¹Ÿä¼šåˆ›å»ºä¸­é—´MyRigAggregateèŠ‚ç‚¹ã€‚ç‚¹å¼€åï¼Œå¯ä»¥çœ‹è§ï¼Œå…¶å®å°±æ˜¯ç»§ç»­ç»„è£…åŸå§‹çš„äºŒå…ƒè¿ç®—æ¥è¾¾æˆç»§ç»­AddPinçš„æ•ˆæœã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Aggregate\Untitled.png)

## åŸç†ï¼š

è¯†åˆ«è¯¥Metaç„¶åç„¶åæŠŠå¼•è„šåŠ åˆ°AggregateInputså’ŒAggregateOutputsé‡Œã€‚

```cpp
TArray<URigVMPin*> URigVMUnitNode::GetAggregateInputs() const
{
	TArray<URigVMPin*> AggregateInputs;
#if UE_RIGVM_AGGREGATE_NODES_ENABLED
	if (const UScriptStruct* Struct = GetScriptStruct())
	{
		for (URigVMPin* Pin : GetPins())
		{
			if (Pin->GetDirection() == ERigVMPinDirection::Input)
			{
				if (const FProperty* Property = Struct->FindPropertyByName(Pin->GetFName()))
				{
					if (Property->HasMetaData(FRigVMStruct::AggregateMetaName))
					{
						AggregateInputs.Add(Pin);
					}
				}			
			}
		}
	}
	else
	{
		return Super::GetAggregateInputs();
	}
#endif
	return AggregateInputs;
}
```


ï»¿# Constant

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†ä¸€ä¸ªå±æ€§æˆä¸ºä¸€ä¸ªå¸¸é‡çš„å¼•è„šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY, USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [Input](Input/Input.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æ”¾åœ¨UPROPERTYä¸Šçš„æ—¶å€™ï¼Œå’ŒVisibleä¸€æ ·ï¼Œæ ‡è¯†ä¸€ä¸ªå±æ€§æˆä¸ºä¸€ä¸ªå¸¸é‡çš„å¼•è„šã€‚

æ”¾åœ¨USTRUCTä¸Šçš„æ—¶å€™ï¼Œå‘ç°ç”¨åœ¨IsDefinedAsConstantè¿™ç§å‡½æ•°ä¸Šï¼Œä½†æ˜¯F5æ²¡æœ‰å‘ç°è°ƒç”¨çš„åœ°æ–¹ã€‚

```cpp
USTRUCT(meta = (DisplayName = "Rotation Order", Category = "Math|Quaternion", Constant))
struct RIGVM_API FRigVMFunction_MathQuaternionRotationOrder : public FRigVMFunction_MathBase
{
}
```


ï»¿# CustomWidget

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥FRigUnité‡Œçš„å±æ€§è¦ç”¨è‡ªå®šä¹‰çš„æ§ä»¶æ¥ç¼–è¾‘ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸­çš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šè¯¥FRigUnité‡Œçš„å±æ€§è¦ç”¨è‡ªå®šä¹‰çš„æ§ä»¶æ¥ç¼–è¾‘ã€‚

CustomWidgetçš„å€¼æ˜¯åœ¨ä¸€äº›é€‰é¡¹ä¸­é€‰æ‹©çš„ï¼Œè¿™äº›è‡ªå®šä¹‰æ§ä»¶æ˜¯å·²ç»åœ¨å¼•æ“ä¸­å®ç°çš„ã€‚

å¯ç”¨çš„åˆ—è¡¨ä¸ºï¼šBoneNameï¼ŒControlNameï¼ŒSpaceName/NullNameï¼ŒCurveNameï¼ŒElementNameï¼ŒConnectorNameï¼ŒDrawingNameï¼ŒShapeNameï¼ŒAnimationChannelNameï¼ŒMetadataNameï¼ŒMetadataTagNameã€‚

æµ‹è¯•ä»£ç é‡Œå°±åªç”¨BoneNameä½œä¸ºæµ‹è¯•å±•ç¤ºï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigCustomWidget"))
struct INSIDER_API FRigUnit_MyRigCustomWidget : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	FString MyString;

	UPROPERTY(meta = (Input, CustomWidget = "BoneName"))
	FString MyString_Custom;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyString_Customçš„Pinç±»å‹å˜æˆå¯é€‰BoneNameçš„åˆ—è¡¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\CustomWidget\Untitled.png)

## åŸç†ï¼š

```cpp
TSharedPtr<SGraphPin> FControlRigGraphPanelPinFactory::CreatePin_Internal(UEdGraphPin* InPin) const
{
		if (CustomWidgetName == TEXT("BoneName"))
		{
			return SNew(SRigVMGraphPinNameList, InPin)
				.ModelPin(ModelPin)
				.OnGetNameFromSelection_UObject(RigGraph, &UControlRigGraph::GetSelectedElementsNameList)
				.OnGetNameListContent_UObject(RigGraph, &UControlRigGraph::GetBoneNameList)
				.OnGetSelectedClicked_UObject(RigGraph, &UControlRigGraph::HandleGetSelectedClicked)
				.OnBrowseClicked_UObject(RigGraph, &UControlRigGraph::HandleBrowseClicked);
		}
//ç­‰ç­‰å…¶ä»–
}
```


ï»¿# Deprecated

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¯¥FRigUnitä¸ºå¼ƒç”¨çŠ¶æ€ï¼Œä¸åœ¨è“å›¾å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitç±»å‹ä¸Š
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æ ‡è¯†è¯¥FRigUnitä¸ºå¼ƒç”¨çŠ¶æ€ï¼Œä¸åœ¨è“å›¾å³é”®èœå•ä¸­æ˜¾ç¤ºã€‚

ä½†å¦‚æœä¹‹å‰å·²ç»åœ¨è“å›¾ä¸­ä½¿ç”¨äº†ï¼Œåˆ™è¿˜æ˜¯å¯ä»¥ç»§ç»­ä½¿ç”¨ã€‚

æ³¨æ„è¿™ä¸ªæ—¶å€™è¦ç›¸åº”çš„å®ç°GetUpgradeInfo()ï¼Œå¦åˆ™ä¼šæŠ¥é”™ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigDeprecated",Deprecated))
struct INSIDER_API FRigUnit_MyRigDeprecated : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
	virtual void Execute() override;

	RIGVM_METHOD()
	virtual FRigVMStructUpgradeInfo GetUpgradeInfo() const override;
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Untitled.png)

## åŸç†ï¼š

åœ¨æ„å»ºèœå•é¡¹çš„æ—¶å€™ç•¥è¿‡Deprecatedçš„èŠ‚ç‚¹ã€‚

```cpp
void FRigVMEditorModule::GetTypeActions(URigVMBlueprint* RigVMBlueprint, FBlueprintActionDatabaseRegistrar& ActionRegistrar)
{
		// Add all rig units
	for(const FRigVMFunction& Function : Registry.GetFunctions())
	{
			// skip deprecated units
		if(Function.Struct->HasMetaData(FRigVMStruct::DeprecatedMetaName))
		{
			continue;
		}
	}
}
```


ï»¿# DetailsOnly

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§åªåœ¨ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸‹çš„å±æ€§
- **å…³è”é¡¹ï¼š** [Input](../Input/Input.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§åªåœ¨ç»†èŠ‚é¢æ¿ä¸­æ˜¾ç¤ºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(meta = (Input, DetailsOnly))
	float MyFloat_DetailsOnly = 456.f;
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\DetailsOnly\Untitled.png)

## åŸç†ï¼š

æ ¹æ®DetailsOnlyåˆ¤æ–­è¿”å›æ˜¯å¦ShowInDetailsPanelOnlyã€‚

```cpp
bool URigVMPin::ShowInDetailsPanelOnly() const
{
#if WITH_EDITOR
	if (GetParentPin() == nullptr)
	{
		if (URigVMUnitNode* UnitNode = Cast<URigVMUnitNode>(GetNode()))
		{
			if (UScriptStruct* ScriptStruct = UnitNode->GetScriptStruct())
			{
				if (FProperty* Property = ScriptStruct->FindPropertyByName(GetFName()))
				{
					if (Property->HasMetaData(FRigVMStruct::DetailsOnlyMetaName))
					{
						return true;
					}
				}
			}
		}
		else if(const URigVMTemplateNode* TemplateNode = Cast<URigVMTemplateNode>(GetNode()))
		{
			if(const FRigVMTemplate* Template = TemplateNode->GetTemplate())
			{
				return !Template->GetArgumentMetaData(GetFName(), FRigVMStruct::DetailsOnlyMetaName).IsEmpty();
			}
		}
	}
#endif
	return false;
}
```


ï»¿# ExpandByDefault

- **åŠŸèƒ½æè¿°ï¼š** æŠŠFRigUnité‡Œçš„å±æ€§å¼•è„šé»˜è®¤å±•å¼€ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠFRigUnité‡Œçš„å±æ€§å¼•è„šé»˜è®¤å±•å¼€ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRig"))
struct INSIDER_API FRigUnit_MyRig : public FRigUnit
{
	UPROPERTY(meta = (Input))
	FMyCommonStruct MyStruct_Normal;

	UPROPERTY(meta = (Input, ExpandByDefault))
	FMyCommonStruct MyStruct_ExpandByDefault;
	
		UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
ï½
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§MyStruct_ExpandByDefaulté»˜è®¤çŠ¶æ€ä¸‹å°±æŠŠè¯¥ç»“æ„å±•å¼€ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\ExpandByDefault\Untitled.png)

## åŸç†ï¼š

è¯†åˆ«è¯¥Metaç„¶åè®¾å®šè¯¥å¼•è„šçš„bIsExpandedçŠ¶æ€ã€‚

```cpp
FRigVMPinInfo::FRigVMPinInfo(FProperty* InProperty, ERigVMPinDirection InDirection, int32 InParentIndex, const uint8* InDefaultValueMemory)
{
	if (InProperty->HasMetaData(FRigVMStruct::ExpandPinByDefaultMetaName))
	{
		bIsExpanded = true;
	}
}
```


ï»¿# Hidden

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§éšè—
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸­å±æ€§
- **å…³è”é¡¹ï¼š** [Input](Input/Input.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# Icon

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„å›¾æ ‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FRigUnit
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„å›¾æ ‡ã€‚

æ ¹æ®æºç ä¸­çš„æ³¨é‡Šå¾—çŸ¥ï¼ŒIconçš„æ ¼å¼æ˜¯â€œStyleSetName|StyleName|SmallStyleName|StatusOverlayStyleNameâ€ï¼Œæœ€åä¸¤é¡¹æ˜¯å¯é€‰çš„ï¼Œå¯å‚è€ƒFSlateIconçš„æ›´å¤šä»‹ç»ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigIcon",Icon="EditorStyle|GraphEditor.Macro.ForEach_16x"))
struct INSIDER_API FRigUnit_MyRigIcon: public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åŠ äº†Iconä¹‹åï¼Œå·¦ä¸Šè§’å›¾æ ‡å˜æˆäº†å…¶ä»–ï¼Œä¸æ˜¯é»˜è®¤çš„få‡½æ•°ç›®æ ‡ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Icon\Untitled.png)

## åŸç†ï¼š

```cpp
FSlateIcon URigVMEdGraphNode::GetIconAndTint(FLinearColor& OutColor) const
{

		if(MetadataScriptStruct && MetadataScriptStruct->HasMetaDataHierarchical(FRigVMStruct::IconMetaName))
		{
			FString IconPath;
			const int32 NumOfIconPathNames = 4;
			
			FName IconPathNames[NumOfIconPathNames] = {
				NAME_None, // StyleSetName
				NAME_None, // StyleName
				NAME_None, // SmallStyleName
				NAME_None  // StatusOverlayStyleName
			};
		
			// icon path format: StyleSetName|StyleName|SmallStyleName|StatusOverlayStyleName
			// the last two names are optional, see FSlateIcon() for reference
			MetadataScriptStruct->GetStringMetaDataHierarchical(FRigVMStruct::IconMetaName, &IconPath);
			return FSlateIcon(IconPathNames[0], IconPathNames[1], IconPathNames[2], IconPathNames[3]);
		}	
}
```


ï»¿# Input

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å…¥å¼•è„šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸­å±æ€§
- **å…³è”é¡¹ï¼š** [Output](../Output.md), [Visible](../Visible/Visible.md), [Hidden](../Hidden.md), [DetailsOnly](../DetailsOnly/DetailsOnly.md), [Constant](../Constant.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å…¥å¼•è„šã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ªå¼•è„šå¦‚æœåŒæ—¶åŠ ä¸ŠInputå’ŒOutputï¼Œé‚£å®ƒå°±å˜æˆIOå¼•è„šï¼ŒåŒæ—¶å¯ä½œä¸ºè¾“å…¥å’Œè¾“å‡ºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName="MyRig"))
struct INSIDER_API FRigUnit_MyRig : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
	virtual void Execute() override;

public:
	UPROPERTY()
	float MyFloat_Normal;

	UPROPERTY(meta = (Input))
	float MyFloat_Input;

	UPROPERTY(meta = (Output))
	float MyFloat_Output;

	UPROPERTY(meta = (Input, Output))
	float MyFloat_IO;

	UPROPERTY(meta = (Visible))
	float MyFloat_Visible;

	UPROPERTY(meta = (Hidden))
	float MyFloat_Hidden;
};
```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨ControlRigè“å›¾é‡Œå°±å¯ä»¥è°ƒç”¨MyRigèŠ‚ç‚¹ï¼Œæ³¨æ„è§‚å¯Ÿå±æ€§åœ¨è“å›¾èŠ‚ç‚¹ä¸Šçš„å¼•è„šè¡¨ç°ä»¥åŠåœ¨å³ä¾§ç»†èŠ‚é¢æ¿çš„æ˜¾ç¤ºã€‚

- MyFloat_Normalä¸æ ‡metaï¼Œåœ¨ä¸¤ä¸ªåœ°æ–¹éƒ½æ²¡æœ‰æ˜¾ç¤ºã€‚
- MyFloat_Inputï¼Œä½œä¸ºè¾“å…¥å¼•è„šï¼Œä¸”åœ¨å³ä¾§ç»†èŠ‚é¢æ¿ä¹Ÿæ˜¾ç¤ºã€‚
- MyFloat_Outputï¼Œä½œä¸ºè¾“å‡ºå¼•è„šï¼Œå³ä¾§ç»†èŠ‚é¢æ¿ä¸æ˜¾ç¤ºã€‚
- MyFloat_IOï¼Œå¯ä»¥åŒæ—¶ä½œä¸ºè¾“å…¥å’Œè¾“å‡ºå¼•è„šï¼Œå³ä¾§ç»†èŠ‚é¢æ¿ä¼šæ˜¾ç¤ºã€‚
- MyFloat_Visibleï¼Œå¯ä»¥ä½œä¸ºè¾“å…¥å¼•è„šæ˜¾ç¤ºï¼Œå³ä¾§ç»†èŠ‚é¢æ¿ä¼šæ˜¾ç¤ºã€‚ä½†æ˜¯æ— æ³•è¿æ¥å˜é‡ï¼Œæ„æ€æ˜¯åªèƒ½ä½œä¸ºå¸¸é‡ä½¿ç”¨ã€‚
- MyFloat_Hiddenï¼Œå¦‚åŒMyFloat_Normalä¸€æ ·ï¼Œåœ¨è“å›¾èŠ‚ç‚¹å’Œç»†èŠ‚é¢æ¿éƒ½éšè—èµ·æ¥ï¼Œåªæ˜¯ä½œä¸ºè‡ªå·±çš„å†…éƒ¨å€¼ä½¿ç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Input\Untitled.png)

## åŸç†ï¼š

æ ¹æ®å±æ€§ä¸Šçš„Metaæ ‡è®°æ¥åŒºåˆ†å¼•è„šçš„æ–¹å‘ã€‚å¯ä»¥åœ¨æºç é‡ŒæŸ¥çœ‹ERigVMPinDirection çš„å„ä¸ªç±»å‹ã€‚

```cpp
UENUM(BlueprintType)
enum class ERigVMPinDirection : uint8
{
	Input, // A const input value
	Output, // A mutable output value
	IO, // A mutable input and output value
	Visible, // A const value that cannot be connected to
	Hidden, // A mutable hidden value (used for interal state)
	Invalid // The max value for this enum - used for guarding.
};

ERigVMPinDirection FRigVMStruct::GetPinDirectionFromProperty(FProperty* InProperty)
{
	bool bIsInput = InProperty->HasMetaData(InputMetaName);
	bool bIsOutput = InProperty->HasMetaData(OutputMetaName);
	bool bIsVisible = InProperty->HasMetaData(VisibleMetaName);

	if (bIsVisible)
	{
		return ERigVMPinDirection::Visible;
	}
	
	if (bIsInput)
	{
		return bIsOutput ? ERigVMPinDirection::IO : ERigVMPinDirection::Input;
	} 
	
	if(bIsOutput)
	{
		return ERigVMPinDirection::Output;
	}

	return ERigVMPinDirection::Hidden;
}
```


ï»¿# Keywords

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹åœ¨å³é”®èœå•ä¸­çš„å…³é”®å­—ï¼Œæ–¹ä¾¿è¾“å…¥æŸ¥æ‰¾ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** FRigUnit
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è®¾å®šFRigUnitè“å›¾èŠ‚ç‚¹åœ¨å³é”®èœå•ä¸­çš„å…³é”®å­—ï¼Œæ–¹ä¾¿è¾“å…¥æŸ¥æ‰¾ã€‚

åŒFunctionä¸Šçš„Keywordsæœ‰ä¸€æ ·çš„ä½œç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigKeywords",Keywords="MyKey,OtherWord"))
struct INSIDER_API FRigUnit_MyRigKeywords: public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};

```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨è¾“å…¥Keywordsä¸­çš„å­—ç¬¦çš„æ—¶å€™ï¼Œä¹Ÿå¯ä»¥æ‰¾åˆ°è¯¥èŠ‚ç‚¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Keywords\Untitled.png)

## åŸç†ï¼š

```cpp
URigVMEdGraphUnitNodeSpawner* URigVMEdGraphUnitNodeSpawner::CreateFromStruct(UScriptStruct* InStruct, const FName& InMethodName, const FText& InMenuDesc, const FText& InCategory, const FText& InTooltip)
{
	FString KeywordsMetadata, TemplateNameMetadata;
	InStruct->GetStringMetaDataHierarchical(FRigVMStruct::KeywordsMetaName, &KeywordsMetadata);
	if(!TemplateNameMetadata.IsEmpty())
	{
		if(KeywordsMetadata.IsEmpty())
		{
			KeywordsMetadata = TemplateNameMetadata;
		}
		else
		{
			KeywordsMetadata = KeywordsMetadata + TEXT(",") + TemplateNameMetadata;
		}
	}
	MenuSignature.Keywords = FText::FromString(KeywordsMetadata);

}
```


ï»¿# MenuDescSuffix

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†FRigUnitåœ¨è“å›¾å³é”®èœå•é¡¹çš„åå­—åç¼€ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitç±»å‹ä¸Š
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æ ‡è¯†FRigUnitåœ¨è“å›¾å³é”®èœå•é¡¹çš„åå­—åç¼€ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigSuffix", MenuDescSuffix = "(MyVector)"))
struct INSIDER_API FRigUnit_MyRigSuffix: public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§å‡ºç°äº†"(MyVector)"çš„åç¼€ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\MenuDescSuffix\Untitled.png)

## åŸç†ï¼š

å¾—åˆ°è¯¥æ•°æ®ï¼Œç„¶åæ·»åŠ åˆ°DisplayNameåé¢ã€‚

```cpp
FString CategoryMetadata, DisplayNameMetadata, MenuDescSuffixMetadata;
Struct->GetStringMetaDataHierarchical(FRigVMStruct::CategoryMetaName, &CategoryMetadata);
Struct->GetStringMetaDataHierarchical(FRigVMStruct::DisplayNameMetaName, &DisplayNameMetadata);
Struct->GetStringMetaDataHierarchical(FRigVMStruct::MenuDescSuffixMetaName, &MenuDescSuffixMetadata);

if(DisplayNameMetadata.IsEmpty())
{
	DisplayNameMetadata = Struct->GetDisplayNameText().ToString();
}
if (!MenuDescSuffixMetadata.IsEmpty())
{
	MenuDescSuffixMetadata = TEXT(" ") + MenuDescSuffixMetadata;
}

FText MenuDesc = FText::FromString(DisplayNameMetadata + MenuDescSuffixMetadata);
```


ï»¿# NodeColor

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„RGBé¢œè‰²å€¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FRigUnit
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šFRigUnitè“å›¾èŠ‚ç‚¹çš„RGBé¢œè‰²å€¼ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRigColor",NodeColor="1 0 0"))
struct INSIDER_API FRigUnit_MyRigColor: public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	float MyFloat_Input = 123.f;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

åŠ ä¸ŠNodeColorä¹‹åï¼Œé¢œè‰²ä»å·¦å˜æˆå³ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\NodeColor\Untitled.png)

## åŸç†ï¼š

ä»Metaä¸­è·å–é¢œè‰²å€¼ã€‚

```cpp
FLinearColor FRigVMDispatchFactory::GetNodeColor() const
{
	if(const UScriptStruct* ScriptStruct = GetScriptStruct())
	{
		FString NodeColor;
		if (ScriptStruct->GetStringMetaDataHierarchical(FRigVMStruct::NodeColorMetaName, &NodeColor))
		{
			return FRigVMTemplate::GetColorFromMetadata(NodeColor);
		}
	}
	return FLinearColor::White;
}

```


ï»¿# Output

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å‡ºå¼•è„šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸­å±æ€§
- **å…³è”é¡¹ï¼š** [Input](Input/Input.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä½œä¸ºè¾“å‡ºå¼•è„šã€‚


ï»¿# RigVMTypeAllowed

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªUENUMå¯ä»¥åœ¨FRigUnitçš„UEnum*å±æ€§ä¸­è¢«é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UENUM
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šä¸€ä¸ªUENUMå¯ä»¥åœ¨FRigUnitçš„UEnum*å±æ€§ä¸­è¢«é€‰æ‹©ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UENUM(BlueprintType)
enum class ERigMyEnum : uint8
{
	First,
	Second,
	Third,
};

UENUM(BlueprintType, meta = (RigVMTypeAllowed))
enum class ERigMyEnumAllowed : uint8
{
	Cat,
	Dog,
	Tiger,
};

USTRUCT(meta = (DisplayName = "MyRigEnum"))
struct INSIDER_API FRigUnit_MyRigEnum : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	UEnum* MyEnum;

	UPROPERTY(meta = (Output))
	float MyFloat_Output = 123.f;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åœ¨é€‰é¡¹åˆ—è¡¨ä¸­åªæœ‰ERigMyEnumAllowedï¼Œæ²¡æœ‰ERigMyEnumã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\RigVMTypeAllowed\Untitled.png)

## åŸç†ï¼š

åœ¨ç”Ÿæˆé€‰é¡¹çš„æ—¶å€™ï¼Œåˆ¤æ–­ !Enum->IsAsset()è¯´æ˜æ˜¯C++é‡Œçš„æšä¸¾ï¼Œç„¶åå¿…é¡»æœ‰RigVMTypeAllowedã€‚

```cpp
void SRigVMEnumPicker::PopulateEnumOptions()
{
	EnumOptions.Reset();
	EnumOptions.Add(MakeShareable(new FString(TEXT("None"))));
	for (TObjectIterator<UEnum> EnumIt; EnumIt; ++EnumIt)
	{
		UEnum* Enum = *EnumIt;

		if (Enum->HasAnyFlags(RF_BeginDestroyed | RF_FinishDestroyed) || !Enum->HasAllFlags(RF_Public))
		{
			continue;
		}

		// Any asset based enum is valid
		if (!Enum->IsAsset())
		{
			// Native enums only allowed if contain RigVMTypeAllowed metadata
			if (!Enum->HasMetaData(TEXT("RigVMTypeAllowed")))
			{
				continue;
			}
		}

		EnumOptions.Add(MakeShareable(new FString(Enum->GetPathName())));
	}
}
```


ï»¿# TemplateName

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥FRigUnitæˆä¸ºä¸€ä¸ªæ³›å‹æ¨¡æ¿èŠ‚ç‚¹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FRigUnit
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥FRigUnitæˆä¸ºä¸€ä¸ªæ³›å‹æ¨¡æ¿èŠ‚ç‚¹ã€‚

ä¸åŒçš„FRigUnitåœ¨è®¾ç½®åˆ°åŒä¸€ä¸ªTemplateName ä¹‹åï¼Œä¼šåˆ†æå…¶Inputå’ŒOutputçš„å±æ€§çš„æ•´ä¸ªå‡½æ•°ç­¾åï¼Œæœ€ååˆ†æå‡ºå“ªäº›å±æ€§æ˜¯æ³›å‹å¼•è„šï¼ˆå³åŒåä¸åŒç±»å‹çš„å±æ€§ï¼‰ã€‚åœ¨è°ƒç”¨çš„æ—¶å€™ï¼Œè¾“å…¥çš„æ˜¯TemplateNodeï¼Œå³TemplateName å½¢æˆçš„èŠ‚ç‚¹ã€‚ç„¶åå†æ‰‹åŠ¨è¿æ¥å¼•è„šæ¥ç¡®å®šæœ€åçš„å‡½æ•°ç±»å‹ï¼Œä»è€Œæœ€åå†å®Œå…¨ç¡®å®šåº”è¯¥å®é™…åº”ç”¨åˆ°å“ªä¸€ä¸ªFRigUnitèŠ‚ç‚¹ã€‚

è¿™ä¸ªåŠŸèƒ½åœ¨å®ç°ä¸€äº›é€»è¾‘ç›¸åŒï¼Œä½†æ˜¯å‚æ•°ç±»å‹ç¨å¾®ä¸åŒçš„æ—¶å€™ï¼Œä¼šæ¯”è¾ƒä¾¿åˆ©ã€‚å¾€å¾€FRigUnit_MyTemplate_Floatå’ŒFRigUnit_MyTemplate_Intä¼šç»§æ‰¿äºä¸€ä¸ªåŸºç±»ï¼ˆä½†ä¸æ˜¯å¼ºåˆ¶ï¼‰ï¼Œåœ¨é‡Œé¢å®ç°å…¬ç”¨çš„é€»è¾‘æˆ–å±æ€§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "Set My float", TemplateName = "SetMyTemplate"))
struct INSIDER_API FRigUnit_MyTemplate_Float : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	float MyValue;

	UPROPERTY(meta = (Output))
	FString MyStringResult;
};

USTRUCT(meta = (DisplayName = "Set My int", TemplateName = "SetMyTemplate"))
struct INSIDER_API FRigUnit_MyTemplate_Int : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;
public:
	UPROPERTY(meta = (Input))
	int32 MyValue;

	UPROPERTY(meta = (Output))
	FString MyStringResult;
};
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§ä¸€å¼€å§‹çš„èŠ‚ç‚¹æ˜¯SetMyTemplateï¼Œç„¶åæ ¹æ®å¼•è„šç±»å‹çš„ä¸åŒï¼Œå†å®é™…ResolveæˆFRigUnit_MyTemplate_Float æˆ–è€…æ˜¯FRigUnit_MyTemplate_Int ã€‚å› ä¸ºæˆ‘æ²¡æœ‰å®ç°SetMyStringï¼Œæ‰€ä»¥FStringç±»å‹çš„æ˜¯ä¸èƒ½è¿æ¥åˆ°å¼•è„šçš„ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\RigVM\TemplateName\RigVM_Template.gif](RigVM_Template.gif)

## åŸç†ï¼š

æºç é‡Œæ¶‰åŠåˆ°è¿™ä¸€å—çš„ä»£ç æ¯”è¾ƒå¤šã€‚å¤§è‡´é€»è¾‘æ˜¯FRigUnitåœ¨åˆå§‹åŒ–çš„æ—¶å€™æ³¨å†Œåˆ°FRigVMRegistryé‡Œï¼Œå¦‚æœæœ‰TempalteNameåˆ™åˆ›å»ºä¸€ä¸ªFRigTemplateï¼Œä¹‹åè“å›¾å³é”®åˆ›å»ºçš„æ—¶å€™å®é™…åˆ›å»ºçš„æ˜¯URigTemplateNodeï¼Œç„¶åå†ç”±FRigDispatchæ¥åˆ†å‘åˆ°å®é™…çš„æœ€ç»ˆèŠ‚ç‚¹ã€‚

```cpp
void FRigVMRegistry::Register(const TCHAR* InName, FRigVMFunctionPtr InFunctionPtr, UScriptStruct* InStruct, const TArray<FRigVMFunctionArgument>& InArguments)
{
	FString TemplateMetadata;
	if (InStruct->GetStringMetaDataHierarchical(TemplateNameMetaName, &TemplateMetadata))
	{
	}
}
```


ï»¿# Varying

- **åŠŸèƒ½æè¿°ï¼š** ScriptStruct /Script/RigVM.RigVMFunction_GetDeltaTime
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æ”¾åœ¨USTRUCTä¸Šçš„æ—¶å€™ï¼Œå‘ç°ç”¨åœ¨IsDefinedAsVaryingè¿™ç§å‡½æ•°ä¸Šï¼Œä½†æ˜¯F5æ²¡æœ‰å‘ç°è°ƒç”¨çš„åœ°æ–¹ã€‚


ï»¿# Visible

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä¸ºå¸¸é‡å¼•è„šï¼Œæ— æ³•è¿æ¥å˜é‡ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** RigVMStruct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FRigUnitä¸­å±æ€§
- **å…³è”é¡¹ï¼š** [Input](../Input/Input.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šFRigUnitä¸‹çš„è¯¥å±æ€§ä¸ºå¸¸é‡å¼•è„šï¼Œæ— æ³•è¿æ¥å˜é‡ã€‚

Visibleå’ŒInput+Constantçš„æ•ˆæœæ˜¯ä¸€è‡´çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(meta = (DisplayName = "MyRig"))
struct INSIDER_API FRigUnit_MyRig : public FRigUnit
{
	GENERATED_BODY()

	RIGVM_METHOD()
		virtual void Execute() override;

public:
	UPROPERTY()
	float MyFloat_Normal;

	UPROPERTY(meta = (Input))
	float MyFloat_Input;

	UPROPERTY(meta = (Output))
	float MyFloat_Output;

	UPROPERTY(meta = (Input, Output))
	float MyFloat_IO;

	UPROPERTY(meta = (Hidden))
	float MyFloat_Hidden;

	UPROPERTY(meta = (Visible))
	float MyFloat_Visible;

	UPROPERTY(meta = (Input, Constant))
	float MyFloat_Constant;
};
```

## æµ‹è¯•æ•ˆæœï¼š

Visibleå’ŒInput+Constantçš„æ•ˆæœæ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿæ˜¯æˆä¸ºä¸€ä¸ªå¸¸é‡ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\RigVM\Visible\Untitled.png)

## åŸç†ï¼š

```cpp
UENUM(BlueprintType)
enum class ERigVMPinDirection : uint8
{
	Input, // A const input value
	Output, // A mutable output value
	IO, // A mutable input and output value
	Visible, // A const value that cannot be connected to
	Hidden, // A mutable hidden value (used for interal state)
	Invalid // The max value for this enum - used for guarding.
};

FRigVMPinInfo::FRigVMPinInfo(FProperty* InProperty, ERigVMPinDirection InDirection, int32 InParentIndex, const uint8* InDefaultValueMemory)
{
	bIsConstant = InProperty->HasMetaData(TEXT("Constant"));
}

void URigVMController::ConfigurePinFromProperty(FProperty* InProperty, URigVMPin* InOutPin, ERigVMPinDirection InPinDirection) const
{
		InOutPin->bIsConstant = InProperty->HasMetaData(TEXT("Constant"));
}

bool URigVMPin::CanBeBoundToVariable(const FRigVMExternalVariable& InExternalVariable, const FString& InSegmentPath) const
{
	if (bIsConstant)
	{
		return false;
	}
}
```


ï»¿# AllowedLocators

- **åŠŸèƒ½æè¿°ï¼š** ç”¨æ¥ç»™Sequencerå®šä½å¯ç»‘å®šçš„å¯¹è±¡
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Scene
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FUniversalObjectLocator
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ç”¨æ¥ç»™Sequencerå®šä½å¯ç»‘å®šçš„å¯¹è±¡ã€‚

çœ‹èµ·æ¥æ˜¯Sequencerç”¨æ¥å®šä½Actoråšå±æ€§ç»‘å®šçš„è¾…åŠ©å®šä½å™¨ã€‚åªç”¨åœ¨FUniversalObjectLocator è¿™ä¸ªå†™å¥½çš„å±æ€§é‡Œï¼Œä¸€èˆ¬æˆ‘ä»¬ç”¨ä¸åˆ°å»æ‰©å±•è¿™éƒ¨åˆ†ï¼Œå› æ­¤åªæ˜¯OnlyInternalã€‚

## æºç ä¸­æœç´¢å¾—åˆ°ï¼š

```cpp

	// Helper struct for Binding Properties UI for locators.
USTRUCT()
struct FMovieSceneUniversalLocatorInfo
{
	GENERATED_BODY()

	// Locator for the entry
	UPROPERTY(EditAnywhere, Category = "Default", meta=(AllowedLocators="Actor"))
	FUniversalObjectLocator Locator;

	// Flags for how to resolve the locator
	UPROPERTY()
	ELocatorResolveFlags ResolveFlags = ELocatorResolveFlags::None;
};
```

çœ‹èµ·æ¥æ˜¯å…è®¸å®šä½çš„å¯¹è±¡ç±»å‹ã€‚

## åŸç†ï¼š

```cpp
TMap<FName, TSharedPtr<ILocatorEditor>> ApplicableLocators;

void FUniversalObjectLocatorCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> StructPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		TArray<FString> AllowedTypes;
		if (PropertyHandle->HasMetaData("AllowedLocators"))
		{
			PropertyHandle->GetMetaData("AllowedLocators").ParseIntoArray(AllowedTypes, TEXT(","));
		}
}

FUniversalObjectLocatorEditorModule& Module = FModuleManager::Get().LoadModuleChecked<FUniversalObjectLocatorEditorModule>("UniversalObjectLocatorEditor");
for (TPair<FName, TSharedPtr<ILocatorEditor>> Pair : Module.LocatorEditors)
{
	if (AllowedTypes.Num() == 0 || AllowedTypes.Contains(Pair.Key.ToString()))
	{
		ApplicableLocators.Add(Pair.Key, Pair.Value);
	}
}
```


ï»¿# MakeEditWidget

- **åŠŸèƒ½æè¿°ï¼š** ä½¿FVectorå’ŒFTranformåœ¨åœºæ™¯ç¼–è¾‘å™¨é‡Œå‡ºç°ä¸€ä¸ªå¯ç§»åŠ¨çš„æ§ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Scene
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FVectorï¼ŒFTranform
- **å…³è”é¡¹ï¼š** [ValidateWidgetUsing](../ValidateWidgetUsing/ValidateWidgetUsing.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä½¿FVectorå’ŒFTranformåœ¨åœºæ™¯ç¼–è¾‘å™¨é‡Œå‡ºç°ä¸€ä¸ªå¯ç§»åŠ¨çš„æ§ä»¶ã€‚

è¿™æ ·ç›¸æ¯”ç›´æ¥çš„æ•°å€¼ç¼–è¾‘æ›´åŠ çš„ç›´è§‚ä¸€äº›ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API AMyActor_EditWidget :public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category="EditWidget")
	FVector MyVector;

	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category="EditWidget",meta=(MakeEditWidget))
	FVector MyVector_MakeEditWidget;
};

```

## æµ‹è¯•ç»“æœï¼š

åœ¨è“å›¾é‡Œç»§æ‰¿çš„AMyActor_EditWidget å­ç±»é‡ŒåŠ ä¸Šå¦å¤–ä¸€ä¸ªFTransformå˜é‡ï¼Œå¯ä»¥çœ‹è§â€œShow 3D Widgetâ€çš„é€‰é¡¹ï¼Œè¿™ä¸ªå’ŒMyVector_MakeEditWidgetéƒ½åœ¨åœºæ™¯é‡Œå‡ºç°äº†å¯ç§»åŠ¨çš„æ§ä»¶ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Scene\MakeEditWidget\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­å¦‚æœæ˜¯FVectoræˆ–FTransformï¼Œå¹¶ä¸”æœ‰MakeEditWidgetå±æ€§ï¼Œåˆ™å¯ä»¥åˆ›å»ºæ§ä»¶ã€‚

```cpp
/** Value of UPROPERTY can be edited with a widget in the editor (translation, rotation) */
static UNREALED_API const FName MD_MakeEditWidget;
/** Specifies a function used for validation of the current value of a property.  The function returns a string that is empty if the value is valid, or contains an error description if the value is invalid */
static UNREALED_API const FName MD_ValidateWidgetUsing;

bool FLegacyEdModeWidgetHelper::CanCreateWidgetForStructure(const UStruct* InPropStruct)
{
	return InPropStruct && (InPropStruct->GetFName() == NAME_Vector || InPropStruct->GetFName() == NAME_Transform);
}

bool FLegacyEdModeWidgetHelper::ShouldCreateWidgetForProperty(FProperty* InProp)
{
	return CanCreateWidgetForProperty(InProp) && InProp->HasMetaData(MD_MakeEditWidget);
}

```


ï»¿# ValidateWidgetUsing

- **åŠŸèƒ½æè¿°ï¼š** æä¾›ä¸€ä¸ªå‡½æ•°æ¥éªŒè¯å½“å‰å±æ€§å€¼æ˜¯å¦åˆæ³•ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Scene
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** å¸¦æœ‰MakeEditWidgetçš„FVectorï¼ŒFTransform
- **å…³è”é¡¹ï¼š** [MakeEditWidget](../MakeEditWidget/MakeEditWidget.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ValidateWidgetUsingæä¾›ä¸€ä¸ªå‡½æ•°æ¥éªŒè¯å½“å‰å±æ€§å€¼æ˜¯å¦åˆæ³•ã€‚

- å½“å‰å±æ€§è¦æœ‰MakeEditWidgetçš„æ ‡è®°
- å‡½æ•°çš„åŸå‹æ˜¯FString MyFunc()ï¼Œè¿”å›éç©ºè¡¨ç¤ºé”™è¯¯ä¿¡æ¯ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION()
	FString ValidateMyVector()
	{
		if (MyVector_MakeEditWidget_Validate.Length()>100.f)
		{
			return TEXT("Exceed max length:100");
		}
		return TEXT("");
	}

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "EditWidget", meta = (MakeEditWidget, ValidateWidgetUsing = "ValidateMyVector"))
	FVector MyVector_MakeEditWidget_Validate;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyVector_MakeEditWidget_Validateé•¿åº¦è¶…è¿‡100ä¹‹åï¼Œæ§ä»¶é¢œè‰²å˜æˆçº¢è‰²ï¼Œå¹¶ä¸”æ˜¾ç¤ºå‡ºé”™è¯¯çš„ä¿¡æ¯åœ¨æ§ä»¶ä¸Šã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Scene\ValidateWidgetUsing\Untitled.png)

## åŸç†ï¼š

é€»è¾‘æ¯”è¾ƒç®€å•ã€‚å‘ç°æœ‰éªŒè¯å‡½æ•°ï¼Œå°±è°ƒç”¨éªŒè¯å‡½æ•°æ¥éªŒè¯ã€‚å¦‚æœæœ‰é”™è¯¯ä¿¡æ¯ï¼Œå°±ä¸€èµ·æ”¹å˜æœ€ç»ˆè¾“å‡ºçš„é¢œè‰²å’Œæ˜¾ç¤ºæ–‡å­—ã€‚

```cpp
	static FLegacyEdModeWidgetHelper::FPropertyWidgetInfo CreateWidgetInfo(const TArray<FPropertyWidgetInfoChainElement>& Chain, bool bIsTransform, FProperty* CurrentProp, int32 Index = INDEX_NONE)
	{
		check(CurrentProp);
		FEdMode::FPropertyWidgetInfo WidgetInfo;
		WidgetInfo.PropertyValidationName = FName(*CurrentProp->GetMetaData(FEdMode::MD_ValidateWidgetUsing));
		
		return WidgetInfo;
	}
	
void FLegacyEdModeWidgetHelper::FPropertyWidgetInfo::GetTransformAndColor(UObject* BestSelectedItem, bool bIsSelected, FTransform& OutLocalTransform, FString& OutValidationMessage, FColor& OutDrawColor) const
{
	// Determine the desired color
	if (PropertyValidationName != NAME_None)
	{
		if (UFunction* ValidateFunc = BestSelectedItem->FindFunction(PropertyValidationName))
		{
			BestSelectedItem->ProcessEvent(ValidateFunc, &OutValidationMessage);

			// if we have a negative result, the widget color is red.
			OutDrawColor = OutValidationMessage.IsEmpty() ? OutDrawColor : FColor::Red;
		}
	}
}

void FLegacyEdModeWidgetHelper::DrawHUD(FEditorViewportClient* ViewportClient, FViewport* Viewport, const FSceneView* View, FCanvas* Canvas)
{
	FTransform LocalWidgetTransform;
	FString ValidationMessage;
	FColor WidgetColor;
	WidgetInfo.GetTransformAndColor(BestSelectedItem, bSelected, /*out*/ LocalWidgetTransform, /*out*/ ValidationMessage, /*out*/ WidgetColor);
	
	Canvas->DrawItem(TextItem);
}
```


ï»¿# ScriptConstant

- **åŠŸèƒ½æè¿°ï¼š** æŠŠä¸€ä¸ªé™æ€å‡½æ•°çš„è¿”å›å€¼åŒ…è£…æˆä¸ºä¸€ä¸ªå¸¸é‡å€¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ScriptConstantHost](ScriptConstantHost.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠä¸€ä¸ªé™æ€å‡½æ•°çš„è¿”å›å€¼åŒ…è£…æˆä¸ºä¸€ä¸ªå¸¸é‡å€¼ã€‚

- å‡½æ•°çš„åå­—å³ä¸ºå¸¸é‡çš„é»˜è®¤åç§°ï¼Œä½†ScriptConstantä¹Ÿå¯ä»¥é¢å¤–æä¾›ä¸€ä¸ªè‡ªå®šä¹‰åç§°ã€‚
- å¸¸é‡ä½œç”¨åŸŸé»˜è®¤å­˜åœ¨äºè¯¥é™æ€å‡½æ•°çš„å¤–éƒ¨ç±»ä¸­ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡ScriptConstantHostæ¥æŒ‡å®šåˆ°å¦å¤–ä¸€ä¸ªç±»å‹ä¸­ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyPythonConstantStruct
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_ConstantOwner :public UObject
{
	GENERATED_BODY()
public:
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_Constant_Test :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, meta = (ScriptConstant))
	static int32 MyIntConst() { return 123; }

	UFUNCTION(BlueprintPure, meta = (ScriptConstant = "MyOtherIntConst"))
	static int32 MyIntConst2() { return 456; }

	UFUNCTION(BlueprintPure, meta = (ScriptConstant))
	static FMyPythonConstantStruct MyStructConst() { return FMyPythonConstantStruct{ TEXT("Hello") }; }

	UFUNCTION(BlueprintPure, meta = (ScriptConstant = "MyOtherStructConst"))
	static FMyPythonConstantStruct MyStructConst2() { return FMyPythonConstantStruct{ TEXT("World") }; }

public:
	UFUNCTION(BlueprintPure, meta = (ScriptConstant="FirstString", ScriptConstantHost = "/Script/Insider.MyPython_ConstantOwner"))
	static FString MyStringConst() { return TEXT("First"); }
****};

```

## ç”Ÿæˆçš„Pyä»£ç ï¼š

```cpp
class MyPython_Constant_Test(Object):
    r"""
    My Python Constant Test
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptConstant.h
    
    """
    MY_OTHER_STRUCT_CONST: MyPythonConstantStruct #: (MyPythonConstantStruct): My Struct Const 2
    MY_STRUCT_CONST: MyPythonConstantStruct #: (MyPythonConstantStruct): My Struct Const
    MY_OTHER_INT_CONST: int #: (int32): My Int Const 2
    MY_INT_CONST: int #: (int32): My Int Const
    
class MyPython_ConstantOwner(Object):
    r"""
    **My Python Constant Owner
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptConstant.h
    
    """
    FIRST_STRING: str #: (str): My String Const
```

## è¿è¡Œçš„ç»“æœï¼š

å¯è§åœ¨ç±»ä¸­ç”Ÿæˆäº†ç›¸åº”çš„å¸¸é‡ã€‚è€ŒMyStringConstå› ä¸ºæŒ‡å®šäº†ScriptConstantHost è€Œç”Ÿæˆåœ¨åˆ«çš„ç±»ä¸­ã€‚

```cpp
LogPython: print(unreal.MyPython_Constant_Test.MY_INT_CONST)
LogPython: 123
LogPython: print(unreal.MyPython_Constant_Test.MY_OTHER_INT_CONST)
LogPython: 456
LogPython: print(unreal.MyPython_Constant_Test.MY_OTHER_STRUCT_CONST)
LogPython: <Struct 'MyPythonConstantStruct' (0x00000A0FC4051F00) {my_string: "World"}>
LogPython: print(unreal.MyPython_Constant_Test.MY_STRUCT_CONST)
LogPython: <Struct 'MyPythonConstantStruct' (0x00000A0FC4051EA0) {my_string: "Hello"}>
LogPython: print(unreal.MyPython_ConstantOwner.FIRST_STRING)
LogPython: First
```

## åŸç†ï¼š

ç”Ÿæˆçš„é€»è¾‘åœ¨è¿™ä¸ªGenerateWrappedConstant å‡½æ•°é‡Œã€‚

```cpp
auto GenerateWrappedConstant = [this, &GeneratedWrappedType, &OutGeneratedWrappedTypeReferences, &OutDirtyModules](const UFunction* InFunc)
{}
```


ï»¿# ScriptConstantHost

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ScriptConstantçš„åŸºç¡€ä¸Šï¼ŒæŒ‡å®šå¸¸é‡ç”Ÿæˆçš„æ‰€åœ¨ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [ScriptConstant](ScriptConstant.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨ScriptConstantçš„åŸºç¡€ä¸Šï¼ŒæŒ‡å®šå¸¸é‡ç”Ÿæˆçš„æ‰€åœ¨ç±»å‹ã€‚

æµ‹è¯•ä»£ç è§ScriptConstantã€‚ScriptConstantHostæŒ‡å®šçš„å­—ç¬¦ä¸²åº”è¯¥æ˜¯ä¸ªå¯¹è±¡è·¯å¾„ã€‚

```cpp
	UFUNCTION(BlueprintPure, meta = (ScriptConstant="FirstString", ScriptConstantHost = "/Script/Insider.MyPython_ConstantOwner"))
	static FString MyStringConst() { return TEXT("First"); }
```


ï»¿# ScriptDefaultBreak

- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [ScriptDefaultMake](ScriptDefaultMake.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

è§ScriptDefaultMakeçš„åŸç†å’Œæµ‹è¯•ä»£ç ã€‚


ï»¿# ScriptDefaultMake

- **åŠŸèƒ½æè¿°ï¼š** ç¦ç”¨ç»“æ„ä¸Šçš„HasNativeMakeï¼Œåœ¨è„šæœ¬é‡Œæ„é€ çš„æ—¶å€™ä¸è°ƒç”¨C++é‡Œçš„NativeMakeå‡½æ•°ï¼Œè€Œé‡‡ç”¨è„šæœ¬å†…å»ºçš„é»˜è®¤åˆå§‹åŒ–æ–¹å¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [ScriptDefaultBreak](ScriptDefaultBreak.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ç¦ç”¨ç»“æ„ä¸Šçš„HasNativeMakeï¼Œåœ¨è„šæœ¬é‡Œæ„é€ çš„æ—¶å€™ä¸è°ƒç”¨C++é‡Œçš„NativeMakeå‡½æ•°ï¼Œè€Œé‡‡ç”¨è„šæœ¬å†…å»ºçš„é»˜è®¤åˆå§‹åŒ–æ–¹å¼ã€‚

ScriptDefaultBreakä¹Ÿæ˜¯åŒç†ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

USTRUCT(BlueprintType, meta = (ScriptDefaultMake, ScriptDefaultBreak,HasNativeMake = "/Script/Insider.MyPython_MakeBreak_Test.MyNativeMake", HasNativeBreak = "/Script/Insider.MyPython_MakeBreak_Test.MyNativeBreak"))
struct INSIDER_API FMyPythonMBStructNative
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 MyInt = 0;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_MakeBreak_Test :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, meta = ())
	static FMyPythonMBStructNative MyNativeMake(int32 InInt) { return FMyPythonMBStructNative{ InInt,TEXT("Hello") }; }

	UFUNCTION(BlueprintPure, meta = ())
	static void MyNativeBreak(const FMyPythonMBStructNative& InStruct, int& outInt) { outInt = InStruct.MyInt + 123;  }
};

```

## ç”Ÿæˆçš„pyä»£ç ï¼š

æ— è®ºæœ‰æ²¡æœ‰åŠ ScriptDefaultMake, ScriptDefaultBreakï¼ŒMyPythonMBStructNativeç”Ÿæˆçš„pyä»£ç å…¶å®æ˜¯ä¸€æ ·çš„ã€‚ä¸åŒç‚¹åœ¨äºæ„æˆå’Œto_tupleæ—¶å€™çš„ç»“æœä¸åŒã€‚

```cpp
class MyPythonMBStructNative(StructBase):
    r"""
    My Python MBStruct Native
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMakeBreak.h
    
    **Editor Properties:** (see get_editor_property/set_editor_property)
    
    - ``my_int`` (int32):  [Read-Write]
    - ``my_string`` (str):  [Read-Write]
    """
    def __init__(self, int: int = 0) -> None:
        ...
    @property
    def my_int(self) -> int:
        r"""
        (int32):  [Read-Write]
        """
        ...
    @my_int.setter
    def my_int(self, value: int) -> None:
        ...
    @property
    def my_string(self) -> str:
        r"""
        (str):  [Read-Write]
        """
        ...
    @my_string.setter
    def my_string(self, value: str) -> None:
        ...
```

## è¿è¡Œçš„ç»“æœï¼š

- ç¬¬äºŒæ®µæ˜¯åŠ äº†ScriptDefaultMake, ScriptDefaultBreakåçš„æ•ˆæœã€‚æˆ‘æ•…æ„åœ¨C++çš„Makeå’ŒBreakå‡½æ•°é‡Œåšäº†ä¸€äº›ä¸ä¸€æ ·ï¼Œå¯ä»¥è§‚å¯Ÿåˆ°è°ƒç”¨åˆ°C++é‡Œçš„å‡½æ•°ã€‚
- ç¬¬ä¸€æ®µæ˜¯åœ¨ä»£ç é‡ŒåŠ ä¸ŠScriptDefaultMake, ScriptDefaultBreakåï¼ˆä¿ç•™HasNativeMakeï¼ŒHasNativeBreakï¼‰è°ƒç”¨çš„ç»“æœï¼Œå¯è§C++é‡Œçš„Make/Breakå‡½æ•°å°±æ²¡æœ‰å†è¢«è°ƒç”¨åˆ°äº†ã€‚

```cpp
LogPython: b=unreal.MyPythonMBStructNative()
LogPython: print(b)
LogPython: <Struct 'MyPythonMBStructNative' (0x0000085F2EE9E680) {my_int: 0, my_string: "Hello"}>
LogPython: print(b.to_tuple())
LogPython: (123,)

LogPython: b=unreal.MyPythonMBStructNative()
LogPython: print(b)
LogPython: <Struct 'MyPythonMBStructNative' (0x000005E6C3AAFDC0) {my_int: 0, my_string: ""}>
LogPython: print(b.to_tuple())
LogPython: (0, '')
```

## åŸç†ï¼š

åœ¨FindMakeBreakFunctionå‡½æ•°é‡Œï¼Œå¦‚æœå‘ç°æœ‰ScriptDefaultMakeæˆ–ScriptDefaultBreakæ ‡è®°ï¼Œå°±ä¸å»ä½¿ç”¨C++é‡Œç”±HasNativeMakeï¼ŒHasNativeBreakæŒ‡å®šçš„å‡½æ•°ã€‚

å¦å¤–pyé‡Œçš„ç»“æ„åˆå§‹åŒ–ä¼šè°ƒç”¨åˆ°é»˜è®¤çš„initæˆ–è€…ç»“æ„çš„makeå‡½æ•°ï¼Œè€Œto_tupleå°±ç›¸å½“äºbreakçš„ä½œç”¨ï¼Œä¼šè°ƒç”¨åˆ°é»˜è®¤çš„æ¯ä¸ªå±æ€§to_tupleæˆ–è€…æ˜¯ç»“æ„çš„è‡ªå®šä¹‰breakå‡½æ•°ã€‚

```cpp
const FName ScriptDefaultMakeMetaDataKey = TEXT("ScriptDefaultMake");
const FName ScriptDefaultBreakMetaDataKey = TEXT("ScriptDefaultBreak");

namespace UE::Python
{

/**
 * Finds the UFunction corresponding to the name specified by 'HasNativeMake' or 'HasNativeBreak' meta data key.
 * @param The structure to inspect for the 'HasNativeMake' or 'HasNativeBreak' meta data keys.
 * @param InNativeMetaDataKey The native meta data key name. Can only be 'HasNativeMake' or 'HasNativeBreak'.
 * @param InScriptDefaultMetaDataKey The script default meta data key name. Can only be 'ScriptDefaultMake' or 'ScriptDefaultBreak'.
 * @param NotFoundFn Function invoked if the structure specifies as Make or Break function, but the function couldn't be found.
 * @return The function, if the struct has the meta key and if the function was found. Null otherwise.
 */
template<typename NotFoundFuncT>
UFunction* FindMakeBreakFunction(const UScriptStruct* InStruct, const FName& InNativeMetaDataKey, const FName& InScriptDefaultMetaDataKey, const NotFoundFuncT& NotFoundFn)
{
	check(InNativeMetaDataKey == PyGenUtil::HasNativeMakeMetaDataKey || InNativeMetaDataKey == PyGenUtil::HasNativeBreakMetaDataKey);
	check(InScriptDefaultMetaDataKey == PyGenUtil::ScriptDefaultMakeMetaDataKey || InScriptDefaultMetaDataKey == PyGenUtil::ScriptDefaultBreakMetaDataKey);

	UFunction* MakeBreakFunc = nullptr;
	if (!InStruct->HasMetaData(InScriptDefaultMetaDataKey))  // <--- æœ‰äº†default, ä¼šç›´æ¥è¿”å›null
	{
		const FString MakeBreakFunctionName = InStruct->GetMetaData(InNativeMetaDataKey);
		if (!MakeBreakFunctionName.IsEmpty())
		{
			// Find the function.
			MakeBreakFunc = FindObject<UFunction>(/*Outer*/nullptr, *MakeBreakFunctionName, /*ExactClass*/true);
			if (!MakeBreakFunc)
			{
				NotFoundFn(MakeBreakFunctionName);
			}
		}
	}
	return MakeBreakFunc;
}
}

struct FFuncs
{
	static int Init(FPyWrapperStruct* InSelf, PyObject* InArgs, PyObject* InKwds)
	{
		const int SuperResult = PyWrapperStructType.tp_init((PyObject*)InSelf, InArgs, InKwds);
		if (SuperResult != 0)
		{
			return SuperResult;
		}

		return FPyWrapperStruct::MakeStruct(InSelf, InArgs, InKwds);
	}
};

GeneratedWrappedType->PyType.tp_init = (initproc)&FFuncs::Init;

// python wrapper ç»™æ¯ä¸ªç±»å‹éƒ½æ˜ å°„äº† to_tuple å‡½æ•°ï¼Œä¼šè°ƒç”¨ç±»å‹çš„ break å‡½æ•°è½¬æ¢ä¸º tuple
	static PyObject* ToTuple(FPyWrapperStruct* InSelf)
	{
			return FPyWrapperStruct::BreakStruct(InSelf);
	}
	
	....
	{ "to_tuple", PyCFunctionCast(&FMethods::ToTuple), METH_NOARGS, "to_tuple(self) -> Tuple[object, ...] -- break this Unreal struct into a tuple of its properties" },
```


ï»¿# ScriptMethod

- **åŠŸèƒ½æè¿°ï¼š** æŠŠé™æ€å‡½æ•°å¯¼å‡ºå˜æˆç¬¬ä¸€ä¸ªå‚æ•°çš„æˆå‘˜å‡½æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="a;b;c"
- **é™åˆ¶ç±»å‹ï¼š** static function
- **å…³è”é¡¹ï¼š** [ScriptMethodMutable](ScriptMethodMutable.md), [ScriptMethodSelfReturn](ScriptMethodSelfReturn.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠé™æ€å‡½æ•°å¯¼å‡ºå˜æˆç¬¬ä¸€ä¸ªå‚æ•°çš„æˆå‘˜å‡½æ•°ã€‚

- æŠŠfunc(Aï¼ŒB)å˜æˆA.func(B)ï¼Œè¿™æ ·å°±å¯ä»¥ç»™Aå¯¹è±¡æ·»åŠ æˆå‘˜å‡½æ•°æ–¹æ³•ã€‚æœ‰ç‚¹åƒC#é‡Œçš„æ‰©å±•æ–¹æ³•ã€‚
- ä¹Ÿå¯ä»¥ç›´æ¥å†æä¾›ä¸€ä¸ªåå­—æ¥æ”¹å˜åŒ…è£…åçš„æˆå‘˜å‡½æ•°çš„åç§°ã€‚æ³¨æ„ä¸ScriptNameåŒºåˆ†ï¼ŒScriptNameæ”¹å˜çš„æ˜¯æœ¬èº«å¯¼å‡ºåˆ°è„šæœ¬çš„åå­—ï¼Œè€ŒScriptMethodæ”¹å˜çš„æ˜¯ç»“æœæˆå‘˜å‡½æ•°çš„åå­—ã€‚æŠŠfunc(Aï¼ŒB)æ”¹æˆA.OtherFunc(B)ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_ScriptMethod :public UObject
{
	GENERATED_BODY()
public:
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyPythonStruct_ScriptMethod
{
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_ScriptMethod_Test :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod))
	static void MyFuncOnObject(UMyPython_ScriptMethod* obj, FString val);

	UFUNCTION(BlueprintCallable, meta = (ScriptMethod = "MySuperFuncOnObject;MyOtherFuncOnObject"))
	static void MyFuncOnObject2(UMyPython_ScriptMethod* obj, FString val);

public:
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod))
	static void MyFuncOnStruct(const FMyPythonStruct_ScriptMethod& myStruct, FString val);;
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åœ¨MyPythonStruct_ScriptMethodé‡Œå¢åŠ äº†my_func_on_structçš„æ–¹æ³•ï¼Œè€ŒMyPython_ScriptMethodé‡Œå¢åŠ äº†my_func_on_objectçš„æ–¹æ³•ã€‚å› æ­¤å¦‚æœåœ¨pyé‡Œä½ å°±å¯ä»¥æŠŠè¿™ä¸¤ä¸ªå‡½æ•°å½“ä½œæˆå‘˜å‡½æ•°ä¸€æ ·è°ƒç”¨ã€‚

å¦å¤–MyFuncOnObject2ä¸Šé¢è®¾ç½®äº†ä¸¤ä¸ªScriptMethod åˆ«ç§°ï¼Œä¹Ÿå¯ä»¥åœ¨MyPython_ScriptMethodé‡Œè§åˆ°ã€‚

```cpp
class MyPythonStruct_ScriptMethod(StructBase):
    r"""
    My Python Struct Script Method
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMethod.h
    
    """
    def __init__(self) -> None:
        ...
    def my_func_on_struct(self, val: str) -> None:
        r"""
        x.my_func_on_struct(val) -> None
        My Func on Struct
        
        Args:
            val (str):
        """
        ...

class MyPython_ScriptMethod(Object):
    r"""
    My Python Script Method
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMethod.h
    
    """
    def my_super_func_on_object(self, val: str) -> None:
        r"""
        x.my_super_func_on_object(val) -> None
        My Func on Object 2
        
        Args:
            val (str):
        """
        ...
     def my_other_func_on_object(self, val: str) -> None:
        r"""
        deprecated: 'my_other_func_on_object' was renamed to 'my_super_func_on_object'.
        """
        ...
    def my_func_on_object(self, val: str) -> None:
        r"""
        x.my_func_on_object(val) -> None
        My Func on Object
        
        Args:
            val (str):
        """
        ...
class MyPython_ScriptMethod_Test(Object):
    r"""
    My Python Script Method Test
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMethod.h
    
    """
    @classmethod
    def my_func_on_struct(cls, my_struct: MyPythonStruct_ScriptMethod, val: str) -> None:
        r"""
        X.my_func_on_struct(my_struct, val) -> None
        My Func on Struct
        
        Args:
            my_struct (MyPythonStruct_ScriptMethod): 
            val (str):
        """
        ...
    @classmethod
    def my_func_on_object2(cls, obj: MyPython_ScriptMethod, val: str) -> None:
        r"""
        X.my_func_on_object2(obj, val) -> None
        My Func on Object 2
        
        Args:
            obj (MyPython_ScriptMethod): 
            val (str):
        """
        ...
    @classmethod
    def my_func_on_object(cls, obj: MyPython_ScriptMethod, val: str) -> None:
        r"""
        X.my_func_on_object(obj, val) -> None
        My Func on Object
        
        Args:
            obj (MyPython_ScriptMethod): 
            val (str):
        """
        ...
```

## åŸç†ï¼š

åœ¨GenerateWrappedDynamicMethodä¸­æœ‰è¯¦ç»†çš„å¦‚ä½•æŠŠé™æ€å‡½æ•°åŒ…è£…æˆæˆå‘˜å‡½æ•°çš„è¿‡ç¨‹ã€‚æ„Ÿå…´è¶£çš„å¯ä»¥å»ç»†çœ‹ã€‚

```cpp
PyTypeObject* FPyWrapperTypeRegistry::GenerateWrappedClassType(const UClass* InClass, FGeneratedWrappedTypeReferences& OutGeneratedWrappedTypeReferences, TSet<FName>& OutDirtyModules, const EPyTypeGenerationFlags InGenerationFlags)
{
	// Should this function also be hoisted as a struct method or operator?
	if (InFunc->HasMetaData(PyGenUtil::ScriptMethodMetaDataKey))
	{
		GenerateWrappedDynamicMethod(InFunc, GeneratedWrappedMethodCopy);
	}
}
```


ï»¿# ScriptMethodMutable

- **åŠŸèƒ½æè¿°ï¼š** æŠŠScriptMethodçš„ç¬¬ä¸€ä¸ªconstç»“æ„å‚æ•°åœ¨è°ƒç”¨ä¸Šæ”¹æˆå¼•ç”¨å‚æ•°ï¼Œå‡½æ•°å†…ä¿®æ”¹çš„å€¼ä¼šä¿å­˜ä¸‹æ¥ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç»“æ„ç±»å‹
- **å…³è”é¡¹ï¼š** [ScriptMethod](ScriptMethod.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŠŠScriptMethodçš„ç¬¬ä¸€ä¸ªconstç»“æ„å‚æ•°åœ¨è°ƒç”¨ä¸Šæ”¹æˆå¼•ç”¨å‚æ•°ï¼Œå‡½æ•°å†…ä¿®æ”¹çš„å€¼ä¼šä¿å­˜ä¸‹æ¥ã€‚

- åœ¨constå‚æ•°ä¸Šå¦‚æœæƒ³æ”¹å˜å€¼ï¼Œä¾ç„¶è¦æ ‡è®°c++é‡Œçš„mutableã€‚
- è™½ç„¶pyç”Ÿæˆçš„ä»£ç ä¸€æ¨¡ä¸€æ ·ï¼Œä½†å®é™…è°ƒç”¨ä¸ŠScriptMethodMutableä¼šçœŸæ­£æ”¹å˜å‚æ•°çš„å€¼ï¼Œè€Œæ²¡æœ‰ScriptMethodMutableçš„å‡½æ•°å¹¶ä¸ä¼šæ”¹å˜å‚æ•°çš„åŸå§‹å€¼ã€‚
- ScriptMethodMutableå’ŒUPARAM(ref) åœ¨è°ƒç”¨æ•ˆæœä¸Šï¼Œéƒ½å¯ä»¥æ”¹å˜å‚æ•°çš„å€¼ã€‚ä½†åŒºåˆ«æ˜¯UPARAM(ref) ç”Ÿæˆçš„pyä»£ç ä¼šè¿”å›ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºè¿”å›å€¼ã€‚

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyPythonStruct_ScriptMethod
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	mutable FString MyString;

};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_ScriptMethod_Test :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod))
	static void SetStringOnStruct(const FMyPythonStruct_ScriptMethod& myStruct, FString val);

	UFUNCTION(BlueprintCallable, meta = (ScriptMethod, ScriptMethodMutable))
	static void SetStringOnStructMutable(const FMyPythonStruct_ScriptMethod& myStruct, FString val);

	UFUNCTION(BlueprintCallable, meta = (ScriptMethod, ScriptMethodMutable))
	static void SetStringOnStructViaRef(UPARAM(ref) FMyPythonStruct_ScriptMethod& myStruct, FString val);
};
```

## æµ‹è¯•æ•ˆæœï¼š

çœ‹pyé‡Œç”Ÿæˆçš„ä»£ç æ˜¯ä¸€è‡´çš„ï¼Œå¦‚æœç”¨UPARAM(ref)ï¼Œåˆ™åœ¨MyPython_ScriptMethod_Testé‡Œé¢ç”Ÿæˆçš„my_func_on_struct_via_refä¼šè¿”å›ç»“æ„MyPythonStruct_ScriptMethodæ¥è¾¾æˆå¼•ç”¨çš„æ•ˆæœã€‚

ç„¶è€Œmy_func_on_struct_mutableè¿”å›çš„æ˜¯Noneï¼ŒåŒä¸åŠ ScriptMethodMutableçš„my_func_on_structå¹¶æ²¡æœ‰åŒºåˆ«ã€‚ä½†æ˜¯å®é™…ä¸Šåœ¨çœŸæ­£è°ƒç”¨çš„æ—¶å€™ä¼šçœŸæ­£æœ‰åŒºåˆ«ã€‚

```cpp
class MyPythonStruct_ScriptMethod(StructBase):
    r"""
    My Python Struct Script Method
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMethod.h
    
    """
    def __init__(self) -> None:
        ...
    def my_func_on_struct_via_ref(self, val: str) -> None:
        r"""
        x.my_func_on_struct_via_ref(val) -> None
        My Func on Struct Via Ref
        
        Args:
            val (str):
        """
        ...
    def my_func_on_struct_mutable(self, val: str) -> None:
        r"""
        x.my_func_on_struct_mutable(val) -> None
        My Func on Struct Mutable
        
        Args:
            val (str):
        """
        ...
    def my_func_on_struct(self, val: str) -> None:
        r"""
        x.my_func_on_struct(val) -> None
        My Func on Struct
        
        Args:
            val (str):
        """
        ...

        
class MyPython_ScriptMethod_Test(Object):
    r"""
    My Python Script Method Test
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptMethod.h
    
    """
    @classmethod
    def my_func_on_struct_via_ref(cls, my_struct: MyPythonStruct_ScriptMethod, val: str) -> MyPythonStruct_ScriptMethod:
        r"""
        X.my_func_on_struct_via_ref(my_struct, val) -> MyPythonStruct_ScriptMethod
        My Func on Struct Via Ref
        
        Args:
            my_struct (MyPythonStruct_ScriptMethod): 
            val (str): 
        
        Returns:
            MyPythonStruct_ScriptMethod: 
        
            my_struct (MyPythonStruct_ScriptMethod):
        """
        ...
    @classmethod
    def my_func_on_struct_mutable(cls, my_struct: MyPythonStruct_ScriptMethod, val: str) -> None:
        r"""
        X.my_func_on_struct_mutable(my_struct, val) -> None
        My Func on Struct Mutable
        
        Args:
            my_struct (MyPythonStruct_ScriptMethod): 
            val (str):
        """
        ...
   @classmethod
    def my_func_on_struct(cls, my_struct: MyPythonStruct_ScriptMethod, val: str) -> None:
        r"""
        X.my_func_on_struct(my_struct, val) -> None
        My Func on Struct
        
        Args:
            my_struct (MyPythonStruct_ScriptMethod): 
            val (str):
        """
        ...
```

åœ¨UE Pythonæ§åˆ¶å°é‡Œè°ƒç”¨çš„è®°å½•ï¼Œåˆ†æè°ƒç”¨é¡ºåºï¼š

- ä¸€å¼€å§‹è°ƒç”¨set_string_on_struct_mutableï¼Œå†print(a)ï¼Œå¯ä»¥æ‰“å°å‡ºHelloï¼Œè¯´æ˜å€¼çœŸæ­£çš„è®¾ç½®åˆ°äº†aç»“æ„é‡Œã€‚
- å†å°è¯•set_string_on_structï¼Œå†print(a)ï¼Œæ— æ³•æ‰“å°å‡ºFFFï¼Œè¯´æ˜å€¼å¹¶æ²¡æœ‰è®¾ç½®åˆ°aç»“æ„é‡Œã€‚è¯´æ˜pyåœ¨è°ƒç”¨çš„æ—¶å€™å¾ˆå¯èƒ½æ„é€ äº†ä¸€ä¸ªä¸´æ—¶å€¼æ¥å½“ä½œè°ƒå¯¹è±¡ï¼Œè°ƒç”¨å®Œæˆçš„æ–°å€¼å¹¶æ²¡æœ‰è®¾ç½®åˆ°aå¯¹è±¡ä¸Šã€‚
- å†å°è¯•set_string_on_struct_via_refï¼Œå†print(a)ï¼Œå¯ä»¥æ‰“å°å‡ºFirstï¼Œè¯´æ˜ç”¨UPARAM(ref)å¯ä»¥ä¹Ÿè¾¾æˆæ”¹å˜å‚æ•°çš„æ•ˆæœã€‚

```cpp
LogPython: a=unreal.MyPythonStruct_ScriptMethod()
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x0000092D08CD6ED0) {my_string: ""}>
LogPython: a.set_string_on_struct_mutable("Hello")
LogBlueprintUserMessages: [None] UMyPython_ScriptMethod_Test::SetStringOnStructMutable
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x0000092D08CD6ED0) {my_string: "Hello"}>
LogPython: a.set_string_on_struct("FFF")
LogBlueprintUserMessages: [None] UMyPython_ScriptMethod_Test::SetStringOnStruct
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x0000092D08CD6ED0) {my_string: "Hello"}>
LogPython: a.set_string_on_struct_via_ref("First")
LogBlueprintUserMessages: [None] UMyPython_ScriptMethod_Test::SetStringOnStructViaRef
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x0000092D08CD6ED0) {my_string: "First"}>
```

## åŸç†ï¼š

åˆ¤æ–­å¦‚æœæœ‰ScriptMethodMutableï¼Œä¼šè®¾ç½®SelfReturnï¼Œä»è€Œå†æœ€åæŠŠå‡½æ•°è°ƒç”¨ä¸­çš„ä¸´æ—¶å€¼å¤åˆ¶ç»™åŸæœ¬çš„å‚æ•°å€¼ï¼Œè¾¾æˆå¯å˜å¼•ç”¨è°ƒç”¨çš„æ•ˆæœã€‚

```cpp
// The function may have been flagged as mutable, in which case we always consider it to need a 'self' return
if (!GeneratedWrappedDynamicMethod.SelfReturn.ParamProp && InFunc->HasMetaData(PyGenUtil::ScriptMethodMutableMetaDataKey))
{
	if (!SelfParam.ParamProp->IsA<FStructProperty>())
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodMutable' but the 'self' argument is not a struct."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	GeneratedWrappedDynamicMethod.SelfReturn = SelfParam;
}
```


ï»¿# ScriptMethodSelfReturn

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ScriptMethodçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šæŠŠè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼è¦å»è¦†ç›–è¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [ScriptMethod](ScriptMethod.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨ScriptMethodçš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šæŠŠè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼è¦å»è¦†ç›–è¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚

è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸæœ¬çš„å‡½æ•°å°±æ²¡æœ‰è¿”å›å€¼è¿”å›äº†ã€‚æ•ˆæœä¸Šå½¢å¦‚ï¼š

```cpp
C Func(A,B) -> void A::Func2(B)
è°ƒç”¨çš„æ—¶å€™ï¼š
ä» C=A.Func(B) -> 
void A::Func2(B)
{
	A=A.Func(B)
}
```

## æµ‹è¯•ä»£ç ï¼š

æ³¨æ„å› ä¸ºAppendStringOnStructViaRefå‚æ•°æ˜¯å¼•ç”¨å‚æ•°ï¼Œæ‰€ä»¥ä¸ºäº†ç»“æœåº”ç”¨åˆ°myStructï¼Œåœ¨å‡½æ•°ä½“å†…å°±ä¸éœ€è¦åˆ›å»ºä¸´æ—¶å€¼ï¼Œå¯ä»¥ç›´æ¥åœ¨myStructä¸Šé¢ä¿®æ”¹ã€‚å¦‚æœä¹Ÿç”¨ä¸´æ—¶å€¼çš„è¯ï¼ŒmyStructå°±æ— æ³•å¾—åˆ°ä¿®æ”¹ï¼Œä¹Ÿå°±å¤±å»äº†refå‚æ•°çš„æ„ä¹‰ã€‚

```cpp
public:
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod))
	static FMyPythonStruct_ScriptMethod AppendStringOnStruct(const FMyPythonStruct_ScriptMethod& myStruct, FString val)
	{
		FMyPythonStruct_ScriptMethod Result = myStruct;
		Result.MyString += val;
		return Result;
	}

	UFUNCTION(BlueprintCallable, meta = (ScriptMethod,ScriptMethodSelfReturn))
	static FMyPythonStruct_ScriptMethod AppendStringOnStructReturn(const FMyPythonStruct_ScriptMethod& myStruct, FString val)
	{
		FMyPythonStruct_ScriptMethod Result = myStruct;
		Result.MyString += val;
		return Result;
	}
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod, ScriptMethodMutable))
	static FMyPythonStruct_ScriptMethod AppendStringOnStructViaRef(UPARAM(ref) FMyPythonStruct_ScriptMethod& myStruct, FString val)
	{
		myStruct.MyString += val;
		return myStruct;
	}
	
//LogPython: Error: Function 'MyPython_ScriptMethod_Test.AppendStringOnStructViaRefReturn' is marked as 'ScriptMethodSelfReturn' but the 'self' argument is also marked as UPARAM(ref). This is not allowed.
//UFUNCTION(BlueprintCallable, meta = (ScriptMethod, ScriptMethodMutable,ScriptMethodSelfReturn))
//static FMyPythonStruct_ScriptMethod AppendStringOnStructViaRefReturn(UPARAM(ref) FMyPythonStruct_ScriptMethod& myStruct, FString val);
```

## ç”Ÿæˆçš„pyä»£ç ï¼š

å¯è§append_string_on_struct_returnæ˜¯æ²¡æœ‰è¿”å›å€¼äº†ã€‚è€Œappend_string_on_structæœ‰è¿”å›å€¼ã€‚append_string_on_struct_via_refä¹Ÿæœ‰è¿”å›å€¼ã€‚

```cpp
class MyPythonStruct_ScriptMethod(StructBase):
		 def append_string_on_struct_return(self, val: str) -> None:
        r"""
        x.append_string_on_struct_return(val) -> None
        Append String on Struct Return
        
        Args:
            val (str): 
        
        Returns:
            MyPythonStruct_ScriptMethod:
        """
        ...
    def append_string_on_struct(self, val: str) -> MyPythonStruct_ScriptMethod:
        r"""
        x.append_string_on_struct(val) -> MyPythonStruct_ScriptMethod
        Append String on Struct
        
        Args:
            val (str): 
        
        Returns:
            MyPythonStruct_ScriptMethod:
        """
        ...
	 def append_string_on_struct_via_ref(self, val: str) -> MyPythonStruct_ScriptMethod:
        r"""
        x.append_string_on_struct_via_ref(val) -> MyPythonStruct_ScriptMethod
        Append String on Struct Via Ref
        
        Args:
            val (str): 
        
        Returns:
            MyPythonStruct_ScriptMethod:
        """
        ...
```

æµ‹è¯•ä»£ç ï¼šè§‚å¯Ÿè¿è¡Œçš„ç»“æœä»¥åŠå¯¹è±¡çš„å†…å­˜åœ°å€ã€‚

- å¯ä»¥çœ‹å‡ºappend_string_on_structæ˜¯æœ‰è¿”å›å€¼çš„ï¼Œä½†æ˜¯æ”¹å˜çš„ç»“æœæ²¡æœ‰åº”ç”¨åˆ°å‚æ•°aä¸Šã€‚
- append_string_on_struct_returnå¯ä»¥åº”ç”¨åˆ°å‚æ•°aä¸Šï¼Œä½†æ˜¯æ²¡æœ‰è¿”å›å€¼ã€‚
- append_string_on_struct_via_refå¯ä»¥åº”ç”¨åˆ°å‚æ•°aä¸Šï¼ŒåŒæ—¶ä¹Ÿæœ‰è¿”å›å€¼ã€‚ä½†æ˜¯æ³¨æ„è¿”å›å€¼å’Œaå…¶å®å¹¶ä¸æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼Œå› ä¸ºå†…å­˜åœ°å€ä¸åŒã€‚
- ä½†æ˜¯æ³¨æ„ ScriptMethodSelfReturnå’ŒUPARAM(ref)ä¸èƒ½æ··ç”¨ï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼š  LogPython: Error: Function 'MyPython_ScriptMethod_Test.AppendStringOnStructViaRefReturn' is marked as 'ScriptMethodSelfReturn' but the 'self' argument is also marked as UPARAM(ref). This is not allowed.

```cpp
LogPython: a=unreal.MyPythonStruct_ScriptMethod()
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB08ED0) {my_string: ""}>
LogPython: b=a.append_string_on_struct("Hello")
LogPython: print(b)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB04010) {my_string: "Hello"}>
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB08ED0) {my_string: ""}>
LogPython: c=a.append_string_on_struct_return("Hello")
LogPython: print(c)
LogPython: None
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB08ED0) {my_string: "Hello"}>
LogPython: d=a.append_string_on_struct_via_ref("World")
LogPython: print(d)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB06110) {my_string: "HelloWorld"}>
LogPython: print(a)
LogPython: <Struct 'MyPythonStruct_ScriptMethod' (0x000008DEBAB08ED0) {my_string: "HelloWorld"}>
```

## åŸç†ï¼š

æŠŠè¾“å‡ºå‚æ•°çš„ç¬¬ä¸€ä¸ªå½“ä½œè¿”å›å‚æ•°ã€‚è¾“å‡ºå‚æ•°å…¶å®å°±æ˜¯å‡½æ•°é‡Œçš„è¿”å›å€¼ã€‚SelfReturnçš„æ„æ€æ˜¯è¿™ä¸ªå€¼ä¹‹åè¦å»è¦†ç›–æ‰è°ƒç”¨å¯¹è±¡çš„å€¼ï¼Œä¹Ÿå°±æ˜¯å‘ç”Ÿè°ƒç”¨çš„å¯¹è±¡ã€‚

```cpp
// The function may also have been flagged as having a 'self' return
if (InFunc->HasMetaData(PyGenUtil::ScriptMethodSelfReturnMetaDataKey))
{
	if (GeneratedWrappedDynamicMethod.SelfReturn.ParamProp)
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodSelfReturn' but the 'self' argument is also marked as UPARAM(ref). This is not allowed."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	else if (GeneratedWrappedDynamicMethod.MethodFunc.OutputParams.Num() == 0 || !GeneratedWrappedDynamicMethod.MethodFunc.OutputParams[0].ParamProp->HasAnyPropertyFlags(CPF_ReturnParm))
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodSelfReturn' but has no return value."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	else if (!SelfParam.ParamProp->IsA<FStructProperty>())
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodSelfReturn' but the 'self' argument is not a struct."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	else if (!GeneratedWrappedDynamicMethod.MethodFunc.OutputParams[0].ParamProp->IsA<FStructProperty>())
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodSelfReturn' but the return value is not a struct."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	else if (CastFieldChecked<const FStructProperty>(GeneratedWrappedDynamicMethod.MethodFunc.OutputParams[0].ParamProp)->Struct != CastFieldChecked<const FStructProperty>(SelfParam.ParamProp)->Struct)
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptMethodSelfReturn' but the return value is not the same type as the 'self' argument."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}
	else
	{
		GeneratedWrappedDynamicMethod.SelfReturn = MoveTemp(GeneratedWrappedDynamicMethod.MethodFunc.OutputParams[0]);
		GeneratedWrappedDynamicMethod.MethodFunc.OutputParams.RemoveAt(0, 1, EAllowShrinking::No);
	}
}

```


ï»¿# ScriptName

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å¯¼å‡ºåˆ°è„šæœ¬é‡Œæ—¶ä½¿ç”¨çš„åå­—
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šå¯¼å‡ºåˆ°è„šæœ¬ä¸­çš„åå­—ã€‚

- å¯ä»¥ä½¿ç”¨åœ¨UCLASSï¼ŒUSTRUCTï¼ŒUENUMï¼ŒUFUNCTIONï¼ŒUPROPERTYä¸Šä½¿ç”¨ï¼Œæ”¹å˜å…¶å¯¼å‡ºåˆ°è„šæœ¬çš„åå­—ã€‚
- å¦‚æœæ²¡æœ‰ä½¿ç”¨ScriptNameè‡ªå®šä¹‰åå­—ï¼Œåˆ™å¯¼å‡ºçš„åå­—æœªé»˜è®¤çš„pythonåŒ–çš„åå­—ã€‚å¦‚MyFunc()å˜æˆmy_func()ã€‚

åœ¨æµ‹è¯•Pythonçš„æ—¶å€™ï¼Œè®°å¾—æ‰“å¼€pythonæ’ä»¶ã€‚

å¯åœ¨\UnrealEngine\Engine\Plugins\Experimental\PythonScriptPlugin\Source\PythonScriptPlugin\Private\PyTest.hé‡Œè§åˆ°å¤§é‡å†™å¥½çš„æµ‹è¯•ç”¨ä¾‹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPythonTestLibary2 :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType,meta=(ScriptName="MyPythonLib"))
class INSIDER_API UMyPythonTestLibary :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	//unreal.MyPythonLib.my_script_func_default()
	UFUNCTION(BlueprintCallable,meta=())
	static void MyScriptFuncDefault()
	{
		UInsiderSubsystem::Get().PrintStringEx(nullptr, TEXT("MyScriptFuncDefault"));
	}

	//unreal.MyPythonLib.my_script_func()
	UFUNCTION(BlueprintCallable,meta=(ScriptName="MyScriptFunc"))
	static void MyScriptFunc_ScriptName()
	{
		UInsiderSubsystem::Get().PrintStringEx(nullptr, TEXT("MyScriptFunc_ScriptName"));
	}
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¼€å¯ç¼–è¾‘å™¨åï¼Œå¼•æ“ä¼šè‡ªåŠ¨æ ¹æ®ç±»å‹æ•°æ®ä¿¡æ¯åå°„ç”Ÿæˆå‘ç›¸åº”çš„å¯¼å‡ºåˆ°pyçš„èƒ¶æ°´ä»£ç ï¼Œæˆ‘ä»¬åœ¨C++ä¸­å®šä¹‰çš„ç±»å°±å¯ä»¥åœ¨\Intermediate\PythonStub\[unreal.py](http://unreal.py/)é‡ŒæŸ¥çœ‹å…¶å¯¼å‡ºçš„è„šæœ¬ä»£ç ã€‚

å¦‚ä¸Šçš„ç±»ï¼Œåœ¨unreal.pyç”Ÿæˆçš„pyä»£ç å¦‚ä¸‹ï¼š

- å¯è§UMyPythonTestLibary2 æ²¡æœ‰åŠ ScriptNameå°±æ˜¯é»˜è®¤çš„åå­—ï¼Œè€ŒUMyPythonTestLibary çš„åå­—å˜æˆäº†MyPythonLibã€‚
- MyScriptFuncDefaultçš„å¯¼å‡ºè„šæœ¬åå­—æ˜¯my_script_func_defaultï¼Œè€ŒMyScriptFunc_ScriptNameå› ä¸ºå†™äº†ScriptNameå˜æˆäº†MyScriptFunc

```cpp

class MyPythonTestLibary2(BlueprintFunctionLibrary):
    r"""
    My Python Test Libary 2
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPythonTest.h
    
    """
    ...
    
class MyPythonLib(BlueprintFunctionLibrary):
    r"""
    My Python Test Libary
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_Test.h
    
    """
    @classmethod
    def my_script_func_default(cls) -> None:
        r"""
        X.my_script_func_default() -> None
        My Script Func Default
        """
        ...
    @classmethod
    def my_script_func(cls) -> None:
        r"""
        X.my_script_func() -> None
        My Script Func Script Name
        """
        ...

```

## åŸç†ï¼š

åœ¨è·å–å„ä¸ªç±»å‹åå­—çš„æ—¶å€™ï¼Œä¼šå…ˆåˆ¤æ–­ScriptNameï¼Œå¦‚æœè·å¾—ï¼Œå°±ä½¿ç”¨è¯¥åå­—ã€‚å¦åˆ™åœ¨GetFieldPythonNameImplé‡Œä¼šå¯¹åå­—è¿›è¡ŒpythonåŒ–å¤„ç†ã€‚

```cpp
\Engine\Plugins\Experimental\PythonScriptPlugin\Source\PythonScriptPlugin\Private\PyGenUtil.cpp
const FName ScriptNameMetaDataKey = TEXT("ScriptName");

FString GetClassPythonName(const UClass* InClass)
{
	return GetFieldPythonNameImpl(InClass, ScriptNameMetaDataKey);
}

TArray<FString> GetDeprecatedClassPythonNames(const UClass* InClass)
{
	return GetDeprecatedFieldPythonNamesImpl(InClass, ScriptNameMetaDataKey);
}

FString GetStructPythonName(const UScriptStruct* InStruct)
{
	return GetFieldPythonNameImpl(InStruct, ScriptNameMetaDataKey);
}

TArray<FString> GetDeprecatedStructPythonNames(const UScriptStruct* InStruct)
{
	return GetDeprecatedFieldPythonNamesImpl(InStruct, ScriptNameMetaDataKey);
}

FString GetEnumPythonName(const UEnum* InEnum)
{
	return GetFieldPythonNameImpl(InEnum, ScriptNameMetaDataKey);
}

TArray<FString> GetDeprecatedEnumPythonNames(const UEnum* InEnum)
{
	return GetDeprecatedFieldPythonNamesImpl(InEnum, ScriptNameMetaDataKey);
}

FString GetFieldPythonNameImpl(const FFieldVariant& InField, const FName InMetaDataKey)
{
	FString FieldName;

	// First see if we have a name override in the meta-data
	if (GetFieldPythonNameFromMetaDataImpl(InField, InMetaDataKey, FieldName))
	{
		return FieldName;
	}
	
	//ã€‚ã€‚ã€‚	
}
```


ï»¿# ScriptNoExport

- **åŠŸèƒ½æè¿°ï¼š** ä¸å¯¼å‡ºè¯¥å‡½æ•°æˆ–å±æ€§åˆ°è„šæœ¬ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸å¯¼å‡ºè¯¥å‡½æ•°æˆ–å±æ€§åˆ°è„šæœ¬ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType, meta = (ScriptName = "MyPythonLib"))
class INSIDER_API UMyPythonTestLibary :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	static void MyScriptFunc_None();

	UFUNCTION(BlueprintCallable, meta = (ScriptNoExport))
	static void MyScriptFunc_NoExport();
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat = 123.f;

	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (ScriptNoExport))
	float MyFloat_NoExport = 123.f;
};
```

## æµ‹è¯•æ•ˆæœpyä»£ç ï¼š

å¯è§é»˜è®¤çš„å‡½æ•°å’Œå±æ€§éƒ½ä¼šå¯¼å‡ºåˆ°è„šæœ¬é‡Œã€‚è€ŒMyScriptFunc_NoExportå’ŒMyFloat_NoExportåœ¨pyé‡Œå¹¶æ²¡æœ‰ã€‚

```cpp
class MyPythonLib(BlueprintFunctionLibrary):
    r"""
    My Python Test Libary
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPythonTest.h
    
    """
     @property
    def my_float(self) -> float:
        r"""
        (float):  [Read-Write]
        """
        ...
    @my_float.setter
    def my_float(self, value: float) -> None:
        ...
    @classmethod
    def my_script_func_none(cls) -> None:
        r"""
        X.my_script_func_none() -> None
        My Script Func None
        """
        ...
```

## åŸç†ï¼š

æ ¹æ®è¿™ä¸ªScriptNoExportæ¥åˆ¤æ–­ä¸€ä¸ªå±æ€§æˆ–å‡½æ•°æ˜¯å¦å¯¼å‡ºã€‚

```cpp
bool IsScriptExposedProperty(const FProperty* InProp)
{
	return !InProp->HasMetaData(ScriptNoExportMetaDataKey) 
		&& InProp->HasAnyPropertyFlags(CPF_BlueprintVisible | CPF_BlueprintAssignable);
}

bool IsScriptExposedFunction(const UFunction* InFunc)
{
	return !InFunc->HasMetaData(ScriptNoExportMetaDataKey)
		&& InFunc->HasAnyFunctionFlags(FUNC_BlueprintCallable | FUNC_BlueprintEvent)
		&& !InFunc->HasMetaData(BlueprintGetterMetaDataKey)
		&& !InFunc->HasMetaData(BlueprintSetterMetaDataKey)
		&& !InFunc->HasMetaData(BlueprintInternalUseOnlyMetaDataKey)
		&& !InFunc->HasMetaData(CustomThunkMetaDataKey)
		&& !InFunc->HasMetaData(NativeBreakFuncMetaDataKey)
		&& !InFunc->HasMetaData(NativeMakeFuncMetaDataKey);
}
```


ï»¿# ScriptOperator

- **åŠŸèƒ½æè¿°ï¼š** æŠŠç¬¬ä¸€ä¸ªå‚æ•°ä¸ºç»“æ„çš„é™æ€å‡½æ•°åŒ…è£…æˆç»“æ„çš„è¿ç®—ç¬¦ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Script
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="a;b;c"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠç¬¬ä¸€ä¸ªå‚æ•°ä¸ºç»“æ„çš„é™æ€å‡½æ•°åŒ…è£…æˆç»“æ„çš„è¿ç®—ç¬¦ã€‚

- å¯ä»¥åŒ…å«å¤šä¸ªè¿ç®—ç¬¦ã€‚

ä¸åŒçš„è¿ç®—ç¬¦éœ€è¦åŒ¹é…ä¸åŒçš„å‡½æ•°ç­¾åã€‚è§„åˆ™è§å¦‚ä¸‹ï¼š

- boolè¿ç®—ç¬¦ï¼šbool
    - bool FuncName(const FMyStruct& Value);    //Valueçš„ç±»å‹å¯ä»¥æ˜¯const FMyStruct&æˆ–è€…ç›´æ¥FMyStruct
- ä¸€å…ƒè¿ç®—ç¬¦ï¼šneg (å–è´Ÿ)
    - FMyStruct FuncName(const FMyStruct&);
- æ¯”è¾ƒè¿ç®—ç¬¦ï¼š (==, !=, <, <=, >, >=)
    - bool FuncName(const FMyStruct, OtherType);  //OtherTypeå¯ä»¥æ˜¯å…¶ä»–ä»»ä½•ç±»å‹
- æ•°å­¦è¿ç®—ç¬¦ï¼š (+, -, *, /, %, &, |, ^, >>, <<)
    - ReturnType FuncName(const FMyStruct&, OtherType);   //ReturnType å’Œ OtherTypeå¯ä»¥æ˜¯å…¶ä»–ä»»ä½•ç±»å‹
- æ•°å­¦èµ‹å€¼è¿ç®—ç¬¦ï¼š(+=, -=, *=, /=, %=, &=, |=, ^=, >>=, <<=)
    - FMyStruct FuncName(const FMyStruct&, OtherType);   //OtherTypeå¯ä»¥æ˜¯å…¶ä»–ä»»ä½•ç±»å‹

å¯è§ï¼Œå¦‚æœæƒ³ä¸€ä¸ªå‡½æ•°åŒæ—¶æ”¯æŒæ™®é€šæ•°å­¦è¿ç®—ç¬¦å’Œèµ‹å€¼è¿ç®—ç¬¦ï¼Œå‡½æ•°ç­¾åå¯ä»¥æ˜¯ï¼š

FMyStruct FuncName(const FMyStruct&, OtherType);  //è¿™é‡ŒOtherTypeå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯FMyStruct 

è¿™ä¸ªä¹Ÿå¸¸å¸¸ä¸€èµ·é…åˆScriptMethodä½¿ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ç»“æ„ä¸­ä¸€èµ·æä¾›ä¸€ä¸ªè¿ç®—æˆå‘˜å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„åå­—è¿˜å¯ä»¥é€šè¿‡ScriptMethodæ¥è‡ªå®šä¹‰ã€‚

æºç é‡Œä¹Ÿå¸¸è§åˆ°å’ŒScriptMethodSelfReturnä½¿ç”¨çš„ä¾‹å­ï¼Œå¦‚+=è¿ç®—ç¬¦ä¸Šã€‚ä½†å…¶å®ScriptMethodSelfReturnä¸æ˜¯å¿…é¡»çš„ï¼Œåœ¨+=çš„æ—¶å€™ï¼Œè‡ªç„¶ä¼šæŠŠè¿”å›å€¼åº”ç”¨åˆ°ç¬¬ä¸€ä¸ªå‚æ•°ä¸Šã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyPythonMathStruct
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	int32 Value = 0;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyPython_Operator_Test :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, meta = (ScriptMethod=HasValue,ScriptOperator = "bool"))
	static bool IsValid(const FMyPythonMathStruct& InStruct) { return InStruct.Value != 0; }

	UFUNCTION(BlueprintCallable, meta = (ScriptOperator = "neg"))
	static FMyPythonMathStruct Neg(const FMyPythonMathStruct& InStruct) { return { -InStruct.Value }; }

	UFUNCTION(BlueprintCallable, meta = (ScriptOperator = "=="))
	static bool IsEqual(const FMyPythonMathStruct& A, const FMyPythonMathStruct& B) { return A.Value == B.Value; }

	UFUNCTION(BlueprintCallable, meta = (ScriptOperator = "+;+="))
	static FMyPythonMathStruct AddInt(FMyPythonMathStruct InStruct, const int32 InValue) { InStruct.Value += InValue; return InStruct; }
};

```

## ç”Ÿæˆçš„pyä»£ç ï¼š

å¯è§ï¼Œåœ¨pyé‡Œç”Ÿæˆäº†__bool__ï¼Œ__eq__ï¼Œ__add__ï¼Œ__iadd__ï¼Œ__neg__çš„å‡½æ•°ã€‚åŒæ—¶IsValidåŠ ä¸Šäº†ScriptMethodï¼Œå°±æœ‰äº†å¦ä¸€ä¸ªhas_valueå‡½æ•°ã€‚

```cpp
class MyPythonMathStruct(StructBase):
    r"""
    My Python Math Struct
    
    **C++ Source:**
    
    - **Module**: Insider
    - **File**: MyPython_ScriptOperator.h
    
    **Editor Properties:** (see get_editor_property/set_editor_property)
    
    - ``value`` (int32):  [Read-Write]
    """
    def __init__(self, value: int = 0) -> None:
        ...
    @property
    def value(self) -> int:
        r"""
        (int32):  [Read-Write]
        """
        ...
    @value.setter
    def value(self, value: int) -> None:
        ...
    def has_value(self) -> bool:
        r"""
        x.has_value() -> bool
        Is Valid
        
        Returns:
            bool:
        """
        ...
    def __bool__(self) -> bool:
        r"""
        Is Valid
        """
        ...
    def __eq__(self, other: object) -> bool:
        r"""
        **Overloads:**
        
        - ``MyPythonMathStruct`` Is Equal
        """
        ...
    def __add__(self, other: MyPythonMathStruct) -> None:
        r"""
        **Overloads:**
        
        - ``int32`` Add Int
        """
        ...
    def __iadd__(self, other: MyPythonMathStruct) -> None:
        r"""
        **Overloads:**
        
        - ``int32`` Add Int
        """
        ...
    def __neg__(self) -> None:
        r"""
        Neg
        """
        ...
```

## è¿›è¡Œè¿è¡Œçš„æµ‹è¯•ï¼š

å¯è§ç¡®å®æ”¯æŒäº†æ•°å­¦+=è¿ç®—ç¬¦å’Œboolçš„æ¯”è¾ƒã€‚

```cpp
LogPython: a=unreal.MyPythonMathStruct(3)
LogPython: print(a)
LogPython: <Struct 'MyPythonMathStruct' (0x0000074C90D5DCF0) {value: 3}>
LogPython: print(not a)
LogPython: False
LogPython: a+=3
LogPython: print(a)
LogPython: <Struct 'MyPythonMathStruct' (0x0000074C90D5DCF0) {value: 6}>
LogPython: print(-a)
LogPython: <Struct 'MyPythonMathStruct' (0x0000074C90D5DCF0) {value: -6}>
```

## åŸç†ï¼š

å…·ä½“çš„åŒ…è£…å‡½æ•°éƒ½åœ¨GenerateWrappedOperator é‡Œï¼Œå…·ä½“æƒ³äº†è§£çš„å¯ç»†çœ‹è¿™é‡Œã€‚

```cpp
auto GenerateWrappedOperator = [this, &OutGeneratedWrappedTypeReferences, &OutDirtyModules](const UFunction* InFunc, const PyGenUtil::FGeneratedWrappedMethod& InTypeMethod)
{
	// Only static functions can be hoisted onto other types
	if (!InFunc->HasAnyFunctionFlags(FUNC_Static))
	{
		REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Non-static function '%s.%s' is marked as 'ScriptOperator' but only static functions can be hoisted."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName());
		return;
	}

	// Get the list of operators to apply this function to
	TArray<FString> ScriptOperators;
	{
		const FString& ScriptOperatorsStr = InFunc->GetMetaData(PyGenUtil::ScriptOperatorMetaDataKey);
		ScriptOperatorsStr.ParseIntoArray(ScriptOperators, TEXT(";"));
	}

	// Go through and try and create a function for each operator, validating that the signature matches what the operator expects
	for (const FString& ScriptOperator : ScriptOperators)
	{
		PyGenUtil::FGeneratedWrappedOperatorSignature OpSignature;
		if (!PyGenUtil::FGeneratedWrappedOperatorSignature::StringToSignature(*ScriptOperator, OpSignature))
		{
			REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptOperator' but uses an unknown operator type '%s'."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName(), *ScriptOperator);
			continue;
		}

		PyGenUtil::FGeneratedWrappedOperatorFunction OpFunc;
		{
			FString SignatureError;
			if (!OpFunc.SetFunction(InTypeMethod.MethodFunc, OpSignature, &SignatureError))
			{
				REPORT_PYTHON_GENERATION_ISSUE(Error, TEXT("Function '%s.%s' is marked as 'ScriptOperator' but has an invalid signature for the '%s' operator: %s."), *InFunc->GetOwnerClass()->GetName(), *InFunc->GetName(), *ScriptOperator, *SignatureError);
				continue;
			}
		}

		// Ensure that we've generated a finalized Python type for this struct since we'll be adding this function as a operator on that type
		const UScriptStruct* HostedStruct = CastFieldChecked<const FStructProperty>(OpFunc.SelfParam.ParamProp)->Struct;
		if (GenerateWrappedStructType(HostedStruct, OutGeneratedWrappedTypeReferences, OutDirtyModules, EPyTypeGenerationFlags::ForceShouldExport))
		{
			// Find the wrapped type for the struct as that's what we'll actually add the operator to (via its meta-data)
			TSharedPtr<PyGenUtil::FGeneratedWrappedStructType> HostedStructGeneratedWrappedType = StaticCastSharedPtr<PyGenUtil::FGeneratedWrappedStructType>(GeneratedWrappedTypes.FindRef(PyGenUtil::GetTypeRegistryName(HostedStruct)));
			check(HostedStructGeneratedWrappedType.IsValid());
			StaticCastSharedPtr<FPyWrapperStructMetaData>(HostedStructGeneratedWrappedType->MetaData)->OpStacks[(int32)OpSignature.OpType].Funcs.Add(MoveTemp(OpFunc));
		}
	}
};
```


ï»¿# CommandLineID

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°UMovieSceneCaptureProtocolBaseçš„å­ç±»çš„åè®®ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Sequencer
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UMovieSceneCaptureProtocolBaseçš„å­ç±»ä¸Š
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æ ‡è®°UMovieSceneCaptureProtocolBaseçš„å­ç±»çš„åè®®ç±»å‹ã€‚

ç”¨æ¥åœ¨Sequcenceræ¸²æŸ“å¯¼å‡ºçš„æ—¶å€™é€‰æ‹©åˆ°æ­£ç¡®çš„å¤„ç†ç±»ã€‚ä¸€èˆ¬ä¹Ÿå°±å¼•æ“å†…éƒ¨ä½¿ç”¨ï¼Œé™¤éæƒ³è‡ªå·±è‡ªå®šä¹‰æ¸²æŸ“è¾“å‡ºçš„æ ¼å¼åè®®ç±»ã€‚

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Sequencer\CommandLineID\Untitled.png)

## åŸç†ï¼š

ç®€å•æ¥è¯´å°±æ˜¯é€šè¿‡é€‰æ‹©çš„æ ¼å¼åå­—æ¥æ‰¾åˆ°ç›¸å…³çš„ProtocolType Class

```cpp
void UMovieSceneCapture::Initialize(TSharedPtr<FSceneViewport> InSceneViewport, int32 PIEInstance)
{
			FString ImageProtocolOverrideString;
			if (   FParse::Value( FCommandLine::Get(), TEXT( "-MovieFormat=" ), ImageProtocolOverrideString )
			|| FParse::Value( FCommandLine::Get(), TEXT( "-ImageCaptureProtocol=" ), ImageProtocolOverrideString ) )
			{
				static const TCHAR* const CommandLineIDString = TEXT("CommandLineID");
				TArray<UClass*> AllProtocolTypes = FindAllCaptureProtocolClasses();
				for (UClass* Class : AllProtocolTypes)
				{
					bool bMetaDataMatch = Class->GetMetaData(CommandLineIDString) == ImageProtocolOverrideString;
					if ( bMetaDataMatch || Class->GetName() == ImageProtocolOverrideString )
					{
						OverrideClass = Class;
					}
				}
				ImageCaptureProtocolType = OverrideClass;		
			}
			
		if (FParse::Value( FCommandLine::Get(), TEXT( "-AudioCaptureProtocol=" ), AudioProtocolOverrideString ) )
		{
			static const TCHAR* const CommandLineIDString = TEXT("CommandLineID");
		}
	}
```


ï»¿# SequencerBindingResolverLibrary

- **åŠŸèƒ½æè¿°ï¼š** æŠŠå…·æœ‰SequencerBindingResolverLibraryæ ‡è®°çš„UBlueprintFunctionLibraryä½œä¸ºåŠ¨æ€ç»‘å®šçš„ç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Sequencer
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UClassä¸Šï¼Œä½†ä¸€èˆ¬æ˜¯UBlueprintFunctionLibrary
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŠŠå…·æœ‰SequencerBindingResolverLibraryæ ‡è®°çš„UBlueprintFunctionLibraryä½œä¸ºåŠ¨æ€ç»‘å®šçš„ç±»ã€‚åªæŠŠå®ƒé‡Œé¢çš„å‡½æ•°æ·»åŠ åˆ°å³é”®èœå•é‡Œã€‚

åŠ¨æ€ç»‘å®šæ˜¯Sequencerçš„ä¸€ä¸ªæ–°åŠŸèƒ½ï¼Œç®€å•æ¥è¯´å°±æ˜¯å…è®¸è®¾å®šå¥½çš„è½¨è¿¹å˜åŒ–åŠ¨æ€åº”ç”¨åˆ°è¿è¡Œæ—¶çš„å…¶ä»–Actorä¸Šï¼Œç”¨æ¥åšGameplayå’ŒSequenceçš„è¿‡åº¦åˆ‡æ¢ä¼šå¾ˆæœ‰ç”¨ã€‚æ›´ç»†è‡´ç”¨æ³•å¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼š[https://dev.epicgames.com/documentation/zh-cn/unreal-engine/dynamic-binding-in-sequencer](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/dynamic-binding-in-sequencer)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(meta=(SequencerBindingResolverLibrary), MinimalAPI)
class UMySequencerBindingResolverLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:

	/** Resolve the bound object to the player's pawn */
	UFUNCTION(BlueprintPure, Category="Sequencer|Insider", meta=(WorldContext="WorldContextObject"))
	static FMovieSceneDynamicBindingResolveResult ResolveToMyActor(UObject* WorldContextObject, FString ActorTag);
};
```

æºç ï¼š

```cpp
UCLASS(meta=(SequencerBindingResolverLibrary), MinimalAPI)
class UBuiltInDynamicBindingResolverLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:

	/** Resolve the bound object to the player's pawn */
	UFUNCTION(BlueprintPure, Category="Sequencer|Dynamic Binding", meta=(WorldContext="WorldContextObject"))
	static MOVIESCENE_API FMovieSceneDynamicBindingResolveResult ResolveToPlayerPawn(UObject* WorldContextObject, int32 PlayerControllerIndex = 0);
};

```

## æµ‹è¯•ç»“æœï¼š

åœ¨æ²¡æœ‰å®šä¹‰UMySequencerBindingResolverLibrary ä¹‹å‰ï¼Œå¼•æ“é‡Œæœ‰ä¸ªå†…å»ºçš„ResolveToPlayerPawnï¼Œå¯ä»¥æŠŠPlayerControllerIndex è§£æä¸ºPawnæ¥åŠ¨æ€ç»‘å®šåˆ°ç©å®¶çš„Pawnã€‚

å› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰è‡ªå·±çš„åŠ¨æ€ç»‘å®šå‡½æ•°ï¼Œæ¥è§£æä¸€ä¸ªFStringä¸ºä¸€ä¸ªActorï¼Œå¦‚ä»£ç é‡ŒResolveToMyActoræ‰€ç¤ºã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Sequencer\SequencerBindingResolverLibrary\Untitled.png)

## åŸç†ï¼š

FMovieSceneDynamicBindingCustomizationä¼šæœç´¢å¼•æ“é‡Œçš„æ‰€æœ‰ç±»ï¼Œä½†ä¸ºäº†ç¼©å‡èŒƒå›´ï¼Œå› æ­¤åªæœ‰åœ¨æ ‡æœ‰SequencerBindingResolverLibraryçš„ç±»ä¸‹é¢æ‰å»å‘ç°Resolverå‡½æ•°ã€‚

```cpp
void FMovieSceneDynamicBindingCustomization::CollectResolverLibraryBindActions(UBlueprint* Blueprint, FBlueprintActionMenuBuilder& MenuBuilder, bool bIsRebinding)
{
	// Add any class that has the "SequencerBindingResolverLibrary" meta as a target class.
//
// We don't consider *all* blueprint function libraries because there are many, many of them that expose
// functions that are, technically speaking, compatible with bound object resolution (i.e. they return
// a UObject pointer) but that are completely non-sensical in this context.
const static FName SequencerBindingResolverLibraryMeta("SequencerBindingResolverLibrary");
for (TObjectIterator<UClass> ClassIt; ClassIt; ++ClassIt)
{
	UClass* CurrentClass = *ClassIt;
	if (CurrentClass->HasMetaData(SequencerBindingResolverLibraryMeta))
	{
		FBlueprintActionFilter::Add(MenuFilter.TargetClasses, CurrentClass);
	}
}
}
```


ï»¿# TakeRecorderDisplayName

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUTakeRecorderSourceçš„æ˜¾ç¤ºåå­—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Sequencer
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UTakeRecorderSourceçš„å­ç±»ä¸Š
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šUTakeRecorderSourceçš„æ˜¾ç¤ºåå­—ã€‚

è¿™ä¸ªä¸€èˆ¬æ˜¯å¼•æ“å†…éƒ¨è‡ªå·±ç”¨ï¼Œé™¤éæƒ³è‡ªå·±è‡ªå®šä¹‰UTakeRecorderSourceæ‰ä¼šæ´¾ä¸Šç”¨åœºã€‚å› ä¸ºåŸç†å’Œå±•ç¤ºè¿‡äºç®€å•ï¼Œå› æ­¤å°±ä¸è‡ªå·±æ„å»ºæµ‹è¯•ä»£ç ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(Category="Actors", meta = (TakeRecorderDisplayName = "Player"))
class UTakeRecorderPlayerSource : public UTakeRecorderSource
{}
```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨å¼•æ“æºç ä¸­å¯è§æœ‰å¤šä¸ªUTakeRecorderSourceï¼Œå…¶ä¸Šéƒ½æ ‡äº†åå­—ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Sequencer\TakeRecorderDisplayName\Untitled.png)

## åŸç†ï¼š

ç”¨TakeRecorderDisplayNameæŒ‡å®šçš„åå­—æ¥ä½œä¸ºèœå•é¡¹çš„åå­—ã€‚

```cpp
TSharedRef<SWidget> SLevelSequenceTakeEditor::OnGenerateSourcesMenu()
{
		for (UClass* Class : SourceClasses)
		{
			TSubclassOf<UTakeRecorderSource> SubclassOf = Class;
		
			MenuBuilder.AddMenuEntry(
				FText::FromString(Class->GetMetaData(TEXT("TakeRecorderDisplayName"))),
				Class->GetToolTipText(true),
				FSlateIconFinder::FindIconForClass(Class),
				FUIAction(
					FExecuteAction::CreateSP(this, &SLevelSequenceTakeEditor::AddSourceFromClass, SubclassOf),
					FCanExecuteAction::CreateSP(this, &SLevelSequenceTakeEditor::CanAddSourceFromClass, SubclassOf)
				)
			);
		}
}
```


ï»¿# MatchedSerializers

- **åŠŸèƒ½æè¿°ï¼š** åªåœ¨NoExportTypes.hä¸­ä½¿ç”¨ï¼Œæ ‡æ˜é‡‡ç”¨ç»“æ„åºåˆ—åŒ–å™¨ã€‚æ˜¯å¦æ”¯æŒæ–‡æœ¬å¯¼å…¥å¯¼å‡º

- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS

- **å¼•æ“æ¨¡å—ï¼š** Serialization

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[MatchedSerializers](../../Specifier/UCLASS/Serialization/MatchedSerializers/MatchedSerializers.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

```cpp
if (!GetUnrealSourceFile().IsNoExportTypes())
{
	LogError(TEXT("The 'MatchedSerializers' class specifier is only valid in the NoExportTypes.h file"));
}
ParsedClassFlags |= CLASS_MatchedSerializers;
```

è·Ÿåœ¨Classä¸­æ ‡è®°MatchedSerializersæ˜¯ç­‰ä»·çš„


ï»¿# SkipUCSModifiedProperties

- **åŠŸèƒ½æè¿°ï¼š** è·³è¿‡åºåˆ—åŒ–Componenté‡ŒæŸä¸ªå±æ€§
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** ActorComponentä¸‹çš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

## åŸç†ï¼š

åªåœ¨ActorComponent.cppé‡Œç”¨åˆ°ï¼Œæ„Ÿè§‰æ˜¯ç”¨äºè·³è¿‡åºåˆ—åŒ–æŸä¸ªå±æ€§ã€‚
ä¹Ÿåªåœ¨UPrimitiveComponent é‡Œçš„BodyInstanceç”¨åˆ°ã€‚ç‰©ç†çš„è¡¨ç¤ºä¿¡æ¯æ˜¯è¿è¡Œæ—¶ç”Ÿæˆçš„ï¼Œç¡®å®ä¸éœ€è¦åºåˆ—åŒ–ã€‚ä½†å…¶å®æ ‡ä¸€ä¸ªTransientä¹Ÿå°±å¯ä»¥äº†ï¼Œåªèƒ½è¯´æ˜¯æ··ä¹±çš„ç”¨æ³•äº†ã€‚

```cpp
UCLASS(abstract, HideCategories=(Mobility, VirtualTexture), ShowCategories=(PhysicsVolume), MinimalAPI)
class UPrimitiveComponent : public USceneComponent, public INavRelevantInterface, public IInterface_AsyncCompilation, public IPhysicsComponent
{
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Collision, meta=(ShowOnlyInnerProperties, SkipUCSModifiedProperties))
	FBodyInstance BodyInstance;
}

		class FComponentPropertySkipper : public FArchive
		{
		public:
			FComponentPropertySkipper()
				: FArchive()
			{
				this->SetIsSaving(true);

				// Include properties that would normally skip tagged serialization (e.g. bulk serialization of array properties).
				ArPortFlags |= PPF_ForceTaggedSerialization;
			}

			virtual bool ShouldSkipProperty(const FProperty* InProperty) const override
			{
				static const FName MD_SkipUCSModifiedProperties(TEXT("SkipUCSModifiedProperties"));
				return (InProperty->HasAnyPropertyFlags(CPF_Transient)
					|| !InProperty->HasAnyPropertyFlags(CPF_Edit | CPF_Interp)
					|| InProperty->IsA<FMulticastDelegateProperty>()
#if WITH_EDITOR
					|| InProperty->HasMetaData(MD_SkipUCSModifiedProperties)
#endif
					);
			}
		} PropertySkipper;
```


ï»¿# NoGetter

- **åŠŸèƒ½æè¿°ï¼š** é˜»æ­¢UHTä¸ºè¯¥å±æ€§ç”Ÿæˆä¸€ä¸ªC++çš„getå‡½æ•°ï¼Œåªå¯¹ç¨€ç–ç±»çš„ç»“æ„æ•°æ®é‡Œçš„å±æ€§ç”Ÿæ•ˆã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY

- **å¼•æ“æ¨¡å—ï¼š** SparseDataType

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UCLASSï¼š[SparseClassDataType ](../../../Specifier/UCLASS/Blueprint/SparseClassDataType/SparseClassDataType.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

é˜»æ­¢UHTä¸ºè¯¥å±æ€§ç”Ÿæˆä¸€ä¸ªC++çš„getå‡½æ•°ï¼Œåªå¯¹ç¨€ç–ç±»çš„ç»“æ„æ•°æ®é‡Œçš„å±æ€§ç”Ÿæ•ˆã€‚

è¿™ä¸ªè¦å’ŒSparseClassDataTypesçš„ç”¨æ³•ä¸€èµ·é…åˆçœ‹ï¼Œä¸”NoGetterä¸å½±å“è“å›¾é‡Œå¯¹è¯¥å±æ€§çš„è®¿é—®ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMySparseClassData
{
	GENERATED_BODY()

	UPROPERTY(EditDefaultsOnly)
	int32 MyInt_EditDefaultOnly = 123;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	int32 MyInt_BlueprintReadOnly = 1024;

	// "GetByRef" means that Blueprint graphs access a const ref instead of a copy.
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (GetByRef))
	FString MyString_EditDefault_ReadOnly = TEXT("MyName");

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (NoGetter))
	FString MyString_EditDefault_NoGetter = TEXT("MyName");
};
```

## æµ‹è¯•ç»“æœï¼š

åœ¨ç”Ÿæˆçš„.generated.h"ä¸­ï¼Œä¼šå‘ç°MyString_EditDefault_NoGetter æ²¡æœ‰ç”Ÿæˆç›¸åº”çš„C++ getå‡½æ•°ã€‚

```cpp
// "MyClass_SparseClassDataTypes.generated.h"

#define FID_Hello_Source_Insider_Class_Trait_MyClass_SparseClassDataTypes_h_33_SPARSE_DATA_PROPERTY_ACCESSORS \
int32 GetMyInt_EditDefaultOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyInt_EditDefaultOnly; } \
int32 GetMyInt_BlueprintReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyInt_BlueprintReadOnly; } \
const FString& GetMyString_EditDefault_ReadOnly() const { return GetMySparseClassData(EGetSparseClassDataMethod::ArchetypeIfNull)->MyString_EditDefault_ReadOnly; }
```

è€Œè“å›¾é‡Œæ˜¯ä¾ç„¶å¯ä»¥è®¿é—®åˆ°çš„ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\SparseDataType\NoGetter\Untitled.png)

## åŸç†ï¼š

UHTåœ¨è¯†åˆ«åˆ°SparseDataStructåï¼Œä¼šä¸ºå…¶å†…éƒ¨çš„å±æ€§è°ƒç”¨AppendSparseDeclarationsç”Ÿæˆç›¸åº”çš„C++å±æ€§Getå‡½æ•°ï¼ˆå°±æ˜¯FID_Hello_Source_Insider_Class_Trait_MyClass_SparseClassDataTypes_h_33_SPARSE_DATA_PROPERTY_ACCESSORS é‚£äº›ï¼‰ã€‚è€Œå¦‚æœå±æ€§ä¸Šæ ‡ä¸ŠNoGetterï¼Œå°±æŠŠè¯¥å±æ€§ä»SparseDataStructé‡Œè¿‡æ»¤æ‰ã€‚

```cpp
	private static IEnumerable<UhtProperty> EnumerateSparseDataStructProperties(IEnumerable<UhtScriptStruct> sparseScriptStructs)
	{
		foreach (UhtScriptStruct sparseScriptStruct in sparseScriptStructs)
		{
			foreach (UhtProperty property in sparseScriptStruct.Properties)
			{
				if (!property.MetaData.ContainsKey(UhtNames.NoGetter))
				{
					yield return property;
				}
			}
		}
	}
```

ä½†è“å›¾é‡Œçš„å±æ€§ç»†èŠ‚é¢æ¿çš„å±æ€§è¿˜æ˜¯å­˜åœ¨çš„ï¼Œå› ä¸ºè“å›¾ç³»ç»Ÿä¼šåˆ†æSparseDataStructé‡Œçš„æ‰€æœ‰å±æ€§å¹¶åŠ åˆ°ç»†èŠ‚é¢æ¿é‡Œå»ã€‚è¿™éƒ¨åˆ†é€»è¾‘å¹¶æ²¡æœ‰åˆ¤æ–­NoGetterï¼Œå› æ­¤NoGetterä¸å½±å“å±æ€§åœ¨è“å›¾é‡Œçš„è®¿é—®ï¼Œåªå½±å“C++é‡Œçš„getå‡½æ•°ã€‚

```cpp
if (UScriptStruct* SparseClassDataStruct = ResolvedBaseClass->GetSparseClassDataStruct())
{
	SparseClassDataInstances.Add(ResolvedBaseClass, TTuple<UScriptStruct*, void*>(SparseClassDataStruct, ResolvedBaseClass->GetOrCreateSparseClassData()));

	for (TFieldIterator<FProperty> It(SparseClassDataStruct); It; ++It)
	{
		GetCategoryProperties(ClassesToConsider, *It, bShouldShowDisableEditOnInstance, bShouldShowHiddenProperties, CategoriesFromBlueprints, CategoriesFromProperties, SortedCategories);
	}
}

```


ï»¿# AllowedCharacters

- **åŠŸèƒ½æè¿°ï¼š** åªå…è®¸æ–‡æœ¬æ¡†é‡Œå¯ä»¥è¾“å…¥è¿™äº›å­—ç¬¦ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FName/FString/Fext
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åªå…è®¸æ–‡æœ¬æ¡†é‡Œå¯ä»¥è¾“å…¥è¿™äº›å­—ç¬¦ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, Category = AllowedCharactersTest, meta = (AllowedCharacters = "abcde"))
	FString MyString_AllowedCharacters;
	UPROPERTY(EditAnywhere, Category = AllowedCharactersTest, meta = (AllowedCharacters = "ä½ å¥½"))
	FString MyString_AllowedCharacters_Chinese;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§ç¬¬ä¸€ä¸ªåªèƒ½è¾“å…¥abcdeï¼Œè€Œfghäº§ç”Ÿäº†æŠ¥é”™ã€‚åœ¨æµ‹è¯•ä¸­æ–‡çš„æ—¶å€™ï¼Œå¦‚æœç²˜è´´è¿›å»å¯¹åº”çš„ä¸­æ–‡ï¼Œåˆ™æ˜¯OKçš„ã€‚å¦åˆ™ä¹Ÿä¼šäº§ç”ŸæŠ¥é”™ï¼Œä¸å…è®¸è¾“å…¥è¿›å»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\AllowedCharacters\Untitled.png)

## åŸç†ï¼š

SPropertyEditorTexté‡Œå®é™…ä¿å­˜äº†FCharRangeList çš„AllowedCharactersç”¨æ¥é™åˆ¶å­—ç¬¦ã€‚åŒæ ·åœ¨å­—ç¬¦ä¸²æ”¹å˜çš„æ—¶å€™ï¼ŒéªŒè¯å­—ç¬¦æ˜¯å¦åˆæ³•ã€‚

```cpp

FCharRangeList AllowedCharacters;

AllowedCharacters.InitializeFromString(PropertyHandle->GetMetaData(NAME_AllowedCharacters));

bool SPropertyEditorText::OnVerifyTextChanged(const FText& Text, FText& OutError)
{
	const FString& TextString = Text.ToString();

	if (MaxLength > 0 && TextString.Len() > MaxLength)
	{
		OutError = FText::Format(LOCTEXT("PropertyTextTooLongError", "This value is too long ({0}/{1} characters)"), TextString.Len(), MaxLength);
		return false;
	}

	if (!AllowedCharacters.IsEmpty())
	{
		if (!TextString.IsEmpty() && !AllowedCharacters.AreAllCharsIncluded(TextString))
		{
			TSet<TCHAR> InvalidCharacters = AllowedCharacters.FindCharsNotIncluded(TextString);
			FString InvalidCharactersString;
			for (TCHAR Char : InvalidCharacters)
			{
				if (!InvalidCharactersString.IsEmpty())
				{
					InvalidCharactersString.AppendChar(TEXT(' '));
				}
				InvalidCharactersString.AppendChar(Char);
			}
			OutError = FText::Format(LOCTEXT("PropertyTextCharactersNotAllowedError", "The value may not contain the following characters: {0}"), FText::FromString(InvalidCharactersString));
			return false;
		}
	}

	if (PropertyValidatorFunc.IsBound())
	{
		FText Result = PropertyValidatorFunc.Execute(TextString); 
		if (!Result.IsEmpty())
		{
			OutError = Result;
			return false;
		}
	}

	return true;
}
```

æ ¹æ®FCharRangeListçš„å®šä¹‰ï¼Œé™åˆ¶å­—ç¬¦çš„æ ¼å¼æ˜¯ï¼š

```cpp
/** Initializes this instance with the character ranges represented by the passed definition string.
*   A definition string contains characters and ranges of characters, one after another with no special separators between them.
*   Characters - and \ must be escaped like this: \- and \\
* 
*   Examples:
*       "aT._" <-- Letters 'a' and 'T', dot and underscore.
*       "a-zT._" <-- All letters from 'a' to 'z', letter 'T', dot and underscore.
*       "a-zA-Z0-9._" <-- All lowercase and uppercase letters, all digits, dot and underscore.
*       "a-zA-Z0-9\-\\._" <-- All lowercase and uppercase letters, all digits, minus sign, backslash, dot and underscore.
*/
```


ï»¿# GetKeyOptions

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºTMapé‡Œçš„FName/FStringä½œä¸ºKeyæä¾›ç»†èŠ‚é¢æ¿é‡Œé€‰é¡¹æ¡†çš„é€‰é¡¹å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TMapé‡ŒFName/FStringä½œä¸ºKey
- **å…³è”é¡¹ï¼š** [GetOptions](GetOptions/GetOptions.md)


ï»¿# GetOptions

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå¤–éƒ¨ç±»çš„å‡½æ•°æä¾›é€‰é¡¹ç»™FNameæˆ–FStringå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­ä¸‹æ‹‰é€‰é¡¹æ¡†æä¾›å€¼åˆ—è¡¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPARAM, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FString,FName
- **å…³è”é¡¹ï¼š** [GetKeyOptions](../GetKeyOptions.md), [GetValueOptions](../GetValueOptions.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªå¤–éƒ¨ç±»çš„å‡½æ•°æä¾›é€‰é¡¹ç»™FNameæˆ–FStringå±æ€§åœ¨ç»†èŠ‚é¢æ¿ä¸­ä¸‹æ‹‰é€‰é¡¹æ¡†æä¾›å€¼åˆ—è¡¨ã€‚

- åªä½œç”¨äºFNameæˆ–FStringå±æ€§ï¼ŒFTextä¸æ”¯æŒã€‚
- ä¹Ÿå¯ä»¥ç”¨åœ¨å®¹å™¨ä¸Šï¼Œæ¯”å¦‚TArrayï¼ŒTMapï¼ŒTSetã€‚
- ä¹Ÿå¯ç”¨åœ¨å†…éƒ¨ç»“æ„çš„å˜é‡ä¸Šã€‚è¿™é‡Œçš„å…³é”®ç‚¹æ˜¯åœ¨å¯»æ‰¾å‡½æ•°çš„æ—¶å€™ï¼Œæ˜¯é€šè¿‡æ‰¾åˆ°OuterObject::Functionæ¥çš„ï¼Œå› æ­¤å³ä½¿æ˜¯å†…éƒ¨ç»“æ„çš„å˜é‡ï¼Œä¹Ÿå¯ä»¥æ‰¾åˆ°å¤–éƒ¨classé‡Œçš„å‡½æ•°ã€‚ä½†å¦‚æœæ˜¯å¦å¤–ä¸€ä¸ªä¸ç›¸å…³çš„ç±»ï¼Œå°±å¿…é¡»ç”¨â€œModule.Class.Functionâ€è¿™ç§æ–¹å¼æ‰èƒ½æ‰¾åˆ°ï¼Œå¦åˆ™åªèƒ½è¿”å›ç©ºã€‚
- å‡½æ•°çš„åŸå‹æ˜¯TArray<FString> FuncName() ï¼Œè¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹ï¼Œå³ä½¿ç±»å‹æ˜¯FNameï¼Œå› ä¸ºå¼•æ“å†…éƒ¨ä¼šè‡ªå·±åšè½¬æ¢ã€‚
- å‡½æ•°å¯ä»¥æ˜¯æˆå‘˜å‡½æ•°ï¼Œæœ‰å¯ä»¥æ˜¯é™æ€å‡½æ•°ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyOptionsTest
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, meta = (GetOptions = "MyGetOptions_Static"))
	FString MyString_GetOptions;

	UPROPERTY(EditAnywhere, meta = (GetOptions = "MyGetOptions_Static"))
	TArray<FString> MyArray_GetOptions;

	UPROPERTY(EditAnywhere, meta = (GetOptions = "MyGetOptions_Static"))
	TSet<FString> MySet_GetOptions;

	UPROPERTY(EditAnywhere, meta = (GetOptions = "MyGetOptions_Static"))
	TMap<FString, int32> MyMap_GetOptions;
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Text :public UObject
{
public:
	UPROPERTY(EditAnywhere, Category = GetOptions)
	FString MyString_NoOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	FString MyString_GetOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	FName MyName_GetOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	FText MyText_GetOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	TArray<FString> MyArray_GetOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	TSet<FString> MySet_GetOptions;

	UPROPERTY(EditAnywhere, Category = GetOptions, meta = (GetOptions = "MyGetOptions"))
	TMap<FString, int32> MyMap_GetOptions;

	UFUNCTION()
	static TArray<FString> MyGetOptions_Static() { return TArray<FString>{"Cat", "Dog"}; }

	UFUNCTION()
	TArray<FString> MyGetOptions() { return TArray<FString>{"First", "Second", "Third"}; }
public:
	UPROPERTY(EditAnywhere, Category = GetOptionsStruct)
	FMyOptionsTest MyStruct_GetOptions;
public:
	UPROPERTY(EditAnywhere, Category = GetKeyValueOptions, meta = (GetKeyOptions = "MyGetOptions",GetValueOptions="MyGetOptions_Static"))
	TMap<FString, FName> MyMap_GetKeyValueOptions;
}
```

## æµ‹è¯•æ•ˆæœï¼š

æ ¹æ®ä¸‹å›¾ï¼Œå¯è§FTextå¹¶æ²¡æœ‰èµ·ä½œç”¨ã€‚å…¶ä»–å¸¦æœ‰GetOptionsæ ‡è®°çš„åœ¨ç»†èŠ‚é¢æ¿ä¸Šéƒ½æœ‰ä¸€ä¸ªä¸‹æ‹‰é€‰é¡¹æ¡†ã€‚

è€Œå¦å¤–å½“ä½¿ç”¨TMapçš„æ—¶å€™ï¼Œè¿˜å¯ä»¥ç”¨GetKeyOptions å’ŒGetValueOptionsæ¥åˆ†åˆ«å•ç‹¬ä¸ºKeyå’ŒValueæä¾›ä¸ä¸€æ ·çš„é€‰é¡¹åˆ—è¡¨ï¼Œè§MyMap_GetKeyValueOptionsã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\GetOptions\Untitled.png)

## åŸç†ï¼š

å¤§è‡´æµç¨‹æ˜¯ç”¨GetPropertyOptionsMetaDataKeyæ¥åˆ¤æ–­ä¸€ä¸ªå±æ€§æ˜¯å¦æ”¯æŒé€‰é¡¹æ¡†ç¼–è¾‘ï¼Œç„¶åé€šè¿‡

GetPropertyOptionsè°ƒç”¨æŒ‡å®šçš„å‡½æ•°æ¥è·å¾—é€‰é¡¹åˆ—è¡¨ï¼Œæœ€åæ ¹æ®è¿™ä¸ªåˆ—è¡¨çš„å€¼BuildComboBoxWidgetã€‚

```cpp
	void PropertyEditorUtils::GetPropertyOptions(TArray<UObject*>& InOutContainers, FString& InOutPropertyPath,
		TArray<TSharedPtr<FString>>& InOutOptions)
	{
		// Check for external function references
		if (InOutPropertyPath.Contains(TEXT(".")))
		{
			InOutContainers.Empty();
			UFunction* GetOptionsFunction = FindObject<UFunction>(nullptr, *InOutPropertyPath, true);

			if (ensureMsgf(GetOptionsFunction && GetOptionsFunction->HasAnyFunctionFlags(EFunctionFlags::FUNC_Static), TEXT("Invalid GetOptions: %s"), *InOutPropertyPath))
			{
				UObject* GetOptionsCDO = GetOptionsFunction->GetOuterUClass()->GetDefaultObject();
				GetOptionsFunction->GetName(InOutPropertyPath);
				InOutContainers.Add(GetOptionsCDO);
			}
		}

		if (InOutContainers.Num() > 0)
		{
			TArray<FString> OptionIntersection;
			TSet<FString> OptionIntersectionSet;

			for (UObject* Target : InOutContainers)
			{
				TArray<FString> StringOptions;
				{
					FEditorScriptExecutionGuard ScriptExecutionGuard;

					FCachedPropertyPath Path(InOutPropertyPath);
					if (!PropertyPathHelpers::GetPropertyValue(Target, Path, StringOptions))
					{
						TArray<FName> NameOptions;
						if (PropertyPathHelpers::GetPropertyValue(Target, Path, NameOptions))
						{
							Algo::Transform(NameOptions, StringOptions, [](const FName& InName) { return InName.ToString(); });
						}
					}
				}

				// If this is the first time there won't be any options.
				if (OptionIntersection.Num() == 0)
				{
					OptionIntersection = StringOptions;
					OptionIntersectionSet = TSet<FString>(StringOptions);
				}
				else
				{
					TSet<FString> StringOptionsSet(StringOptions);
					OptionIntersectionSet = StringOptionsSet.Intersect(OptionIntersectionSet);
					OptionIntersection.RemoveAll([&OptionIntersectionSet](const FString& Option){ return !OptionIntersectionSet.Contains(Option); });
				}

				// If we're out of possible intersected options, we can stop.
				if (OptionIntersection.Num() == 0)
				{
					break;
				}
			}

			Algo::Transform(OptionIntersection, InOutOptions, [](const FString& InString) { return MakeShared<FString>(InString); });
		}
	}
	
FName GetPropertyOptionsMetaDataKey(const FProperty* Property)
{
	// Only string and name properties can have options
	if (Property->IsA(FStrProperty::StaticClass()) || Property->IsA(FNameProperty::StaticClass()))
	{
		const FProperty* OwnerProperty = Property->GetOwnerProperty();
		static const FName GetOptionsName("GetOptions");
		if (OwnerProperty->HasMetaData(GetOptionsName))
		{
			return GetOptionsName;
		}

		// Map properties can have separate options for keys and values
		const FMapProperty* MapProperty = CastField<FMapProperty>(OwnerProperty);
		if (MapProperty)
		{
			static const FName GetKeyOptionsName("GetKeyOptions");
			if (MapProperty->HasMetaData(GetKeyOptionsName) && MapProperty->GetKeyProperty() == Property)
			{
				return GetKeyOptionsName;
			}

			static const FName GetValueOptionsName("GetValueOptions");
			if (MapProperty->HasMetaData(GetValueOptionsName) && MapProperty->GetValueProperty() == Property)
			{
				return GetValueOptionsName;
			}
		}
	}

	return NAME_None;
}

TSharedPtr<SWidget> SGraphPinString::TryBuildComboBoxWidget()
{
		PropertyEditorUtils::GetPropertyOptions(PropertyContainers, GetOptionsFunctionName, ComboBoxOptions);
}
```


ï»¿# GetValueOptions

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºTMapé‡Œçš„FName/FStringä½œValueæä¾›ç»†èŠ‚é¢æ¿é‡Œé€‰é¡¹æ¡†çš„é€‰é¡¹å€¼
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TMapé‡ŒFName/FStringä½œä¸ºValue
- **å…³è”é¡¹ï¼š** [GetOptions](GetOptions/GetOptions.md)


ï»¿# MaxLength

- **åŠŸèƒ½æè¿°ï¼š** åœ¨æ–‡æœ¬ç¼–è¾‘æ¡†é‡Œé™åˆ¶æ–‡æœ¬çš„æœ€å¤§é•¿åº¦
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** int32
- **é™åˆ¶ç±»å‹ï¼š** FName/FString/Fext
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨æ–‡æœ¬ç¼–è¾‘æ¡†é‡Œé™åˆ¶æ–‡æœ¬çš„æœ€å¤§é•¿åº¦ã€‚ä½†åœ¨C++æˆ–è“å›¾å±‚é¢è¿˜æ˜¯å¯ä»¥è‡ªå·±ä»»æ„å†™å…¥å€¼çš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, Category = MaxLengthTest, meta = (MaxLength = 10))
	FString MyString_MaxLength10 = TEXT("Hello");
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\MaxLength\Untitled.png)

## åŸç†ï¼š

åœ¨æ–‡æœ¬æ¡†é‡Œå­—ç¬¦ä¸²æ”¹å˜çš„æ—¶å€™ï¼Œæ£€æŸ¥å½“å‰çš„é•¿åº¦ï¼Œè¶…è¿‡åˆ™æŠ¥é”™ã€‚

å¦‚æœæ˜¯FNameå±æ€§ï¼Œåˆ™ä¼šæŠŠMaxLength ç»§ç»­é™åˆ¶åœ¨NAME_SIZE (1024)ä»¥å†…ã€‚

```cpp
MaxLength = PropertyHandle->GetIntMetaData(NAME_MaxLength);
if (InPropertyEditor->PropertyIsA(FNameProperty::StaticClass()))
{
	MaxLength = MaxLength <= 0 ? NAME_SIZE - 1 : FMath::Min(MaxLength, NAME_SIZE - 1);
}

bool SPropertyEditorText::OnVerifyTextChanged(const FText& Text, FText& OutError)
{
		const FString& TextString = Text.ToString();
	
		if (MaxLength > 0 && TextString.Len() > MaxLength)
		{
			OutError = FText::Format(LOCTEXT("PropertyTextTooLongError", "This value is too long ({0}/{1} characters)"), TextString.Len(), MaxLength);
			return false;
		}
	}
```


ï»¿# MultiLine

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—æ–‡æœ¬å±æ€§ç¼–è¾‘æ¡†æ”¯æŒæ¢è¡Œã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FName/FString/Fext
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä½¿å¾—æ–‡æœ¬å±æ€§ç¼–è¾‘æ¡†æ”¯æŒæ¢è¡Œã€‚æ¢è¡Œåçš„å­—ç¬¦ä¸²ä»¥â€\r\nâ€åˆ†éš”æ¢è¡Œã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, Category = MultiLineTest, meta = (MultiLine = true))
	FString MyString_MultiLine = TEXT("Hello");

	UPROPERTY(EditAnywhere, Category = MultiLineTest, meta = (MultiLine = true))
	FText MyText_MultiLine = INVTEXT("Hello");

	UPROPERTY(EditAnywhere, Category = MultiLineTest, meta = (MultiLine = true, PasswordField = true))
	FString MyString_MultiLine_Password = TEXT("Hello");

	UPROPERTY(EditAnywhere, Category = MultiLineTest, meta = (MultiLine = true, PasswordField = true))
	FText MyText_MultiLine_Password  = INVTEXT("Hello");
```

## æµ‹è¯•ç»“æœï¼š

æŒ‰ä½Shift+Enterå›è½¦æ¢è¡Œã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\MultiLine\Untitled.png)

## åŸç†ï¼š

åŸç†ä¹Ÿå¾ˆç®€å•ï¼Œæ ¹æ®bIsMultiLine åˆ›å»ºç‰¹å®šçš„å¤šè¡Œç¼–è¾‘æ§ä»¶SMultiLineEditableTextBoxã€‚

```cpp
void SPropertyEditorText::Construct( const FArguments& InArgs, const TSharedRef< class FPropertyEditor >& InPropertyEditor )
{
bIsMultiLine = PropertyHandle->GetBoolMetaData(NAME_MultiLine);
		
		if(bIsMultiLine)
		{
			ChildSlot
			[
				SAssignNew(HorizontalBox, SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(1.0f)
				[
					SAssignNew(MultiLineWidget, SMultiLineEditableTextBox)
					.Text(InPropertyEditor, &FPropertyEditor::GetValueAsText)
					.Font(InArgs._Font)
					.SelectAllTextWhenFocused(false)
					.ClearKeyboardFocusOnCommit(false)
					.OnTextCommitted(this, &SPropertyEditorText::OnTextCommitted)
					.OnVerifyTextChanged(this, &SPropertyEditorText::OnVerifyTextChanged)
					.SelectAllTextOnCommit(false)
					.IsReadOnly(this, &SPropertyEditorText::IsReadOnly)
					.AutoWrapText(true)
					.ModiferKeyForNewLine(EModifierKey::Shift)
					//.IsPassword( bIsPassword )
				]
			];
		
			PrimaryWidget = MultiLineWidget;
		}
	
}
```


ï»¿# PasswordField

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—æ–‡æœ¬å±æ€§æ˜¾ç¤ºä¸ºå¯†ç æ¡†
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FName/FString/Fext
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä½¿å¾—æ–‡æœ¬å±æ€§æ˜¾ç¤ºä¸ºå¯†ç æ¡†ã€‚æ³¨æ„è¯¥æ–‡æœ¬çš„å€¼åœ¨å†…å­˜é‡Œä¾ç„¶æ˜¯ç›´æ¥ä¿å­˜çš„ï¼Œå¹¶æ²¡æœ‰åŠ å¯†ï¼Œå› æ­¤è¦è‡ªå·±æ¥å¤„ç†å®‰å…¨é—®é¢˜ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, Category = PasswordTest)
	FString MyString = TEXT("Hello");

	UPROPERTY(EditAnywhere, Category = PasswordTest)
	FText MyText = INVTEXT("Hello");
public:
	UPROPERTY(EditAnywhere, Category = PasswordTest, meta = (PasswordField = true))
	FString MyString_Password = TEXT("Hello");

	UPROPERTY(EditAnywhere, Category = PasswordTest, meta = (PasswordField = true))
	FText MyText_Password = INVTEXT("Hello");
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\PasswordField\Untitled.png)

## åŸç†ï¼š

è¯¥å±æ€§ä¼šå¯¼è‡´Widgetçš„IsPasswordä¸ºtrueï¼Œä»æºç ä¹Ÿå¯ä»¥å¾—çŸ¥éœ€è¦æ³¨æ„PasswordField ä¸èƒ½å’ŒMultiLineå…±ç”¨ï¼Œä¼šå¯¼è‡´PasswordåŠŸèƒ½å¤±æ•ˆã€‚

```cpp
void SPropertyEditorText::Construct( const FArguments& InArgs, const TSharedRef< class FPropertyEditor >& InPropertyEditor )
{
		const bool bIsPassword = PropertyHandle->GetBoolMetaData(NAME_PasswordField);
		
		if(bIsMultiLine)
		{
			ChildSlot
			[
				SAssignNew(HorizontalBox, SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(1.0f)
				[
					SAssignNew(MultiLineWidget, SMultiLineEditableTextBox)
					.Text(InPropertyEditor, &FPropertyEditor::GetValueAsText)
					.Font(InArgs._Font)
					.SelectAllTextWhenFocused(false)
					.ClearKeyboardFocusOnCommit(false)
					.OnTextCommitted(this, &SPropertyEditorText::OnTextCommitted)
					.OnVerifyTextChanged(this, &SPropertyEditorText::OnVerifyTextChanged)
					.SelectAllTextOnCommit(false)
					.IsReadOnly(this, &SPropertyEditorText::IsReadOnly)
					.AutoWrapText(true)
					.ModiferKeyForNewLine(EModifierKey::Shift)
					//.IsPassword( bIsPassword )
				]
			];
		
			PrimaryWidget = MultiLineWidget;
		}
		else
		{
			ChildSlot
			[
				SAssignNew(HorizontalBox, SHorizontalBox)
				+SHorizontalBox::Slot()
				.FillWidth(1.0f)
				[
					SAssignNew( SingleLineWidget, SEditableTextBox )
					.Text( InPropertyEditor, &FPropertyEditor::GetValueAsText )
					.Font( InArgs._Font )
					.SelectAllTextWhenFocused( true )
					.ClearKeyboardFocusOnCommit(false)
					.OnTextCommitted( this, &SPropertyEditorText::OnTextCommitted )
					.OnVerifyTextChanged( this, &SPropertyEditorText::OnVerifyTextChanged )
					.SelectAllTextOnCommit( true )
					.IsReadOnly(this, &SPropertyEditorText::IsReadOnly)
					.IsPassword( bIsPassword )
				]
			];
		
			PrimaryWidget = SingleLineWidget;
		}
}
```


ï»¿# PropertyValidator

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åå­—æŒ‡å®šä¸€ä¸ªUFUNCTIONå‡½æ•°æ¥è¿›è¡Œæ–‡æœ¬çš„éªŒè¯
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** String/Text Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FName/FString/Fext
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç”¨åå­—æŒ‡å®šä¸€ä¸ªUFUNCTIONå‡½æ•°æ¥è¿›è¡Œæ–‡æœ¬çš„éªŒè¯ã€‚

è¿™ä¸ªå‡½æ•°å¿…é¡»æ˜¯ç”¨UFUNCTIONä¿®é¥°çš„ï¼Œè¿™æ ·æ‰èƒ½é€šè¿‡åå­—æ‰¾åˆ°ã€‚ä¸”å› ä¸ºæœç´¢çš„èŒƒå›´åœ¨æœ¬ç±»ä¸­ï¼Œå› æ­¤è¯¥å‡½æ•°å¿…é¡»å®šä¹‰åœ¨æœ¬ç±»ä¸­ã€‚å¦åˆ™ä¼šæŠ¥é”™ï¼šâ€œLogPropertyNode: Warning: PropertyValidator ufunction 'MyValidateMyString' on UMyProperty_Text::MyString_PropertyValidator not found.â€

å‡½æ•°çš„ç­¾åè§å¦‚ä¸‹ä»£ç ã€‚è¿”å›ç©ºçš„FTextä»£è¡¨æ²¡æœ‰é”™è¯¯ï¼Œå¦åˆ™å³æ˜¯é”™è¯¯ä¿¡æ¯ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, Category = PropertyValidatorTest, meta = (PropertyValidator = "MyValidateMyString"))
	FString MyString_PropertyValidator;

	UFUNCTION()
	static FText MyValidateMyString(const FString& Value)
	{
		if (Value.Len() <= 5 && Value.Contains("A"))
		{
			return FText();
		}
		return INVTEXT("This is invalid string");
	}
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\String\PropertyValidator\Untitled.png)

## åŸç†:

åŸç†ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œåˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚ä¸€æ˜¯å¦‚ä½•æ‰¾åˆ°å¹¶åˆ›å»ºè¯¥UFunctionï¼ŒäºŒæ˜¯è°ƒç”¨è¯¥å‡½æ•°æ¥éªŒè¯å­—ç¬¦ä¸²ã€‚

```cpp
const FString PropertyValidatorFunctionName = PropertyHandle->GetMetaData(NAME_PropertyValidator);
const UClass* OuterBaseClass = PropertyHandle->GetOuterBaseClass();
if (!PropertyValidatorFunctionName.IsEmpty() && OuterBaseClass)
{
	static TSet<FString> LoggedWarnings;
	
	UObject* ValidatorObject = OuterBaseClass->GetDefaultObject<UObject>();
	const UFunction* PropertyValidatorFunction = ValidatorObject->FindFunction(*PropertyValidatorFunctionName);
	if (PropertyValidatorFunction)
	{
		if (PropertyValidatorFunction->FunctionFlags & FUNC_Static)
		{
			PropertyValidatorFunc = FPropertyValidatorFunc::CreateUFunction(ValidatorObject, PropertyValidatorFunction->GetFName());
		}
		
bool SPropertyEditorText::OnVerifyTextChanged(const FText& Text, FText& OutError)
{
	const FString& TextString = Text.ToString();

	if (PropertyValidatorFunc.IsBound())
	{
		FText Result = PropertyValidatorFunc.Execute(TextString); 
		if (!Result.IsEmpty())
		{
			OutError = Result;
			return false;
		}
	}

	return true;
}
```


ï»¿# DataflowFlesh

- **åŠŸèƒ½æè¿°ï¼š** ScriptStruct /Script/DataflowNodes.FloatOverrideDataflowNode
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Struct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æ²¡æœ‰åœ¨æºç é‡Œæ‰¾åˆ°åº”ç”¨çš„ä¾‹å­


ï»¿# HasNativeBreak

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºè¯¥ç»“æ„æŒ‡å®šä¸€ä¸ªC++å†…çš„UFunctionå‡½æ•°ä½œä¸ºBreakèŠ‚ç‚¹çš„å®ç°
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å¼•æ“æ¨¡å—ï¼š** Struct
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [HasNativeMake](../HasNativeMake.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸ºè¯¥ç»“æ„æŒ‡å®šä¸€ä¸ªC++å†…çš„UFunctionå‡½æ•°ä½œä¸ºBreakèŠ‚ç‚¹çš„å®ç°

æŒ‡å®šä¸€ä¸ªstatic *UFunctionå‡½æ•°çš„å®Œæ•´è·¯å¾„å€¼ï¼Œä¸€èˆ¬æ˜¯â€/*Script/*Module.Class.Functionâ€*

è¿™ä¸ªå‡½æ•°ä¸€èˆ¬æ˜¯BlueprintThreadSafeï¼Œå› ä¸ºè¿™ç§çº¯Makeå’ŒBreakå‡½æ•°ä¸€èˆ¬ä¸å¸¦å‰¯ä½œç”¨ï¼Œå› æ­¤å¯ä»¥éšä¾¿çš„å¤šçº¿ç¨‹è°ƒç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//(BlueprintType = true, HasNativeBreak = /Script/Insider.MyHasNativeStructHelperLibrary.BreakMyHasNativeStruct, HasNativeMake = /Script/Insider.MyHasNativeStructHelperLibrary.MakeMyHasNativeStruct, ModuleRelativePath = Struct/MyStruct_NativeMakeBreak.h)
USTRUCT(BlueprintType, meta = (HasNativeBreak = "/Script/Insider.MyHasNativeStructHelperLibrary.BreakMyHasNativeStruct", HasNativeMake = "/Script/Insider.MyHasNativeStructHelperLibrary.MakeMyHasNativeStruct"))
struct INSIDER_API FMyStruct_HasNative
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyReadWrite;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	float MyReadOnly;
	UPROPERTY(EditAnywhere)
	float MyNotBlueprint;
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_HasDefaultMakeBreak
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyReadWrite;
	UPROPERTY(BlueprintReadOnly, EditAnywhere)
	float MyReadOnly;
	UPROPERTY(EditAnywhere)
	float MyNotBlueprint;
};

UCLASS()
class UMyHasNativeStructHelperLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintPure, meta = (BlueprintThreadSafe))
	static void BreakMyHasNativeStruct(const FMyStruct_HasNative& myStruct, float& outValue)
	{
		outValue = myStruct.MyReadWrite + myStruct.MyReadOnly + myStruct.MyNotBlueprint;
	}

	UFUNCTION(BlueprintPure, meta = (BlueprintThreadSafe))
	static FMyStruct_HasNative MakeMyHasNativeStruct(float value)
	{
		FMyStruct_HasNative result;
		result.MyReadWrite = value;
		result.MyReadOnly = value;
		result.MyNotBlueprint = value;
		return result;
	}
};
```

## è“å›¾èŠ‚ç‚¹ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Struct\HasNativeBreak\Untitled.png)

## åŸç†æ˜¯ï¼š

é€šè¿‡Metaé‡Œé…ç½®çš„å€¼å»æ‰¾UFunctionå‡½æ•°ï¼Œå› æ­¤æˆ‘ä»¬é…ç½®çš„æ—¶å€™éœ€è¦æä¾›çš„æ˜¯èƒ½æ‰¾åˆ°UFunctionçš„å®Œæ•´è·¯å¾„å€¼ã€‚è¿™ä¸ªå‡½æ•°çš„ç­¾åä¼šè‡ªåŠ¨çš„è¢«åå°„æå–ä¿¡æ¯åˆ°UK2Node_CallFunctionèŠ‚ç‚¹ä¸Šï¼Œä»è€Œæ„é€ å‡ºä¸åŒæ ·å¼çš„Makeå’ŒBreakè“å›¾èŠ‚ç‚¹ã€‚

```cpp
E:\P4V\Engine\Source\Editor\BlueprintGraph\Private\EdGraphSchema_K2.cpp

const FString& MetaData = StructType->GetMetaData(FBlueprintMetadata::MD_NativeMakeFunction);
const UFunction* Function = FindObject<UFunction>(nullptr, *MetaData, true);

UK2Node_CallFunction* CallFunctionNode;

if (Params.bTransient || Params.CompilerContext)
{
	CallFunctionNode = (Params.bTransient ? NewObject<UK2Node_CallFunction>(Graph) : Params.CompilerContext->SpawnIntermediateNode<UK2Node_CallFunction>(GraphNode, Params.SourceGraph));
	CallFunctionNode->SetFromFunction(Function);
	CallFunctionNode->AllocateDefaultPins();
}
else
{
	FGraphNodeCreator<UK2Node_CallFunction> MakeStructCreator(*Graph);
	CallFunctionNode = MakeStructCreator.CreateNode(false);
	CallFunctionNode->SetFromFunction(Function);
	MakeStructCreator.Finalize();
}

SplitPinNode = CallFunctionNode;
```


ï»¿# HasNativeMake

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºè¯¥ç»“æ„æŒ‡å®šä¸€ä¸ªC++å†…çš„UFunctionå‡½æ•°ä½œä¸ºMreakèŠ‚ç‚¹çš„å®ç°
- **ä½¿ç”¨ä½ç½®ï¼š** USTRUCT
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å…³è”é¡¹ï¼š** [HasNativeBreak](HasNativeBreak/HasNativeBreak.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# IgnoreForMemberInitializationTest

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—è¯¥å±æ€§å¿½ç•¥ç»“æ„çš„æœªåˆå§‹éªŒè¯ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Struct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** C++ç»“æ„ä¸‹çš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ä½¿å¾—è¯¥å±æ€§å¿½ç•¥ç»“æ„çš„æœªåˆå§‹éªŒè¯ã€‚

- æ‰€è°“æœªåˆå§‹åŒ–ï¼ŒæŒ‡çš„æ˜¯C++ç»“æ„é‡Œçš„å˜é‡æ²¡æœ‰åœ¨æ„é€ å‡½æ•°é‡Œåˆå§‹åŒ–ï¼Œä¹Ÿæ²¡æœ‰ç›´æ¥å†™ä¸Šåˆå§‹å€¼
- ç»“æ„æœªåˆå§‹éªŒè¯æŒ‡çš„æ˜¯å¼•æ“æä¾›çš„éªŒè¯å·¥å…·ï¼Œå¯é‡‡ç”¨æ§åˆ¶å°å‘½ä»¤â€œCoreUObject.AttemptToFindUninitializedScriptStructMembersâ€è°ƒç”¨ã€‚ç„¶åä¼šè¾“å‡ºå¼•æ“å†…æ‰€æœ‰æœªåˆå§‹åŒ–çš„å˜é‡ä¿¡æ¯ã€‚
- UEé‡Œçš„USTRUCTåªæ˜¯ä¸€ä¸ªçº¯C++ç»“æ„ï¼Œä¸åƒç”¨UCLASSå®šä¹‰çš„ç±»éƒ½æ˜¯ä¸€ä¸ªUObjectï¼Œåè€…çš„UPROPERTYå±æ€§ä¼šè‡ªåŠ¨çš„éƒ½åˆå§‹åŒ–ä¸º0ï¼Œè€Œç»“æ„é‡Œçš„UPROPERTYå¹¶ä¸ä¼šè‡ªåŠ¨çš„åˆå§‹åŒ–ï¼Œå› æ­¤å°±éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨çš„åˆå§‹åŒ–ã€‚
- ä»å®è·µæ¥è¯´ï¼Œå¦‚æœå¼€å‘è€…æ¸…æ¥šçŸ¥é“æŸå˜é‡æœªåˆå§‹åŒ–ä¸ä¼šå½±å“é€»è¾‘ï¼Œé‚£å³ä½¿æœªåˆå§‹åŒ–ä¹Ÿå¹¶æ²¡æœ‰å…³ç³»ã€‚ä½†ç°å®æ˜¯å¾€å¾€å¤§å®¶ç»å¤§å¤šæ•°æƒ…å†µä¸‹åªæ˜¯å•çº¯çš„çŠ¯æ‡’æˆ–è€…é—å¿˜ç»™å±æ€§åˆå§‹åŒ–ã€‚å› æ­¤è¿˜æ˜¯å»ºè®®å¤§å®¶å°½é‡ç»™ç»“æ„é‡Œçš„æ‰€æœ‰å±æ€§éƒ½åˆå§‹åŒ–å€¼ã€‚ä½†ä¸€äº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼ŒæŸäº›å±æ€§ç¡®å®ä¸é€‚åˆåˆå§‹åŒ–ï¼Œæ¯”å¦‚æºç ä¾‹å­é‡Œä¸€äº›FGuidå˜é‡ï¼Œåªåœ¨çœŸæ­£ç”¨åˆ°çš„æ—¶å€™æ‰æ‰‹åŠ¨èµ‹å€¼ï¼Œåœ¨è¿™ä¹‹å‰åˆå§‹åŒ–ä»€ä¹ˆå€¼å…¶å®éƒ½æ„ä¹‰ä¸å¤§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°±å¯ä»¥ç”¨IgnoreForMemberInitializationTestæ¥ä½¿è¯¥å±æ€§å¿½ç•¥è¿™ä¸ªéªŒè¯ï¼Œé¿å…è¾“å‡ºæŠ¥é”™ä¿¡æ¯ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_InitTest
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;

	UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(IgnoreForMemberInitializationTest))
	int32 MyProperty_IgnoreTest;
};
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyPropertyå› ä¸ºæ²¡æœ‰IgnoreForMemberInitializationTestå°±æŠ¥é”™äº†ã€‚

```cpp
åœ¨æ§åˆ¶å°è°ƒç”¨CoreUObject.AttemptToFindUninitializedScriptStructMembersåï¼š

LogClass: Error: IntProperty FMyStruct_InitTest::MyProperty is not initialized properly. Module:Insider File:Property/Struct/MyProperty_Struct.h
```

## åŸç†ï¼š

è¿™ä¸ªå‘½ä»¤è¡Œè°ƒç”¨AttemptToFindUninitializedScriptStructMembersï¼Œç»§è€Œç»§ç»­è°ƒç”¨FindUninitializedScriptStructMembersæ¥æŸ¥æ‰¾å‡ºUScriptStructä¸­çš„æœªåˆå§‹åŒ–å˜é‡ã€‚å…·ä½“çš„æ‰¾å‡ºæ–¹å¼å¯ä»¥åœ¨è¯¥å‡½æ•°ä¸­ç»†çœ‹ã€‚

```cpp

static void FindUninitializedScriptStructMembers(UScriptStruct* ScriptStruct, EScriptStructTestCtorSyntax ConstructorSyntax, TSet<const FProperty*>& OutUninitializedProperties)
{

		for (const FProperty* Property : TFieldRange<FProperty>(ScriptStruct, EFieldIteratorFlags::ExcludeSuper))
	{
#if	WITH_EDITORONLY_DATA
		static const FName NAME_IgnoreForMemberInitializationTest(TEXT("IgnoreForMemberInitializationTest"));
		if (Property->HasMetaData(NAME_IgnoreForMemberInitializationTest))
		{
			continue;
		}
#endif // WITH_EDITORONLY_DATA

}

//ç”±è¿™ä¸ªè°ƒç”¨
FStructUtils::AttemptToFindUninitializedScriptStructMembers();

// å‘½ä»¤è¡Œè°ƒç”¨
CoreUObject.AttemptToFindUninitializedScriptStructMembers
```


ï»¿# MakeStructureDefaultValue

- **åŠŸèƒ½æè¿°ï¼š** å­˜å‚¨BPä¸­è‡ªå®šä¹‰ç»“æ„é‡Œçš„å±æ€§çš„é»˜è®¤å€¼ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Struct
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** BPé‡Œçš„ç”¨æˆ·è‡ªå®šä¹‰Struct
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

å­˜å‚¨BPä¸­è‡ªå®šä¹‰ç»“æ„é‡Œçš„å±æ€§çš„é»˜è®¤å€¼ã€‚

- åœ¨C++ä¸­æˆ‘ä»¬å†™çš„USTRUCTçš„ç»“æ„é‡Œçš„å±æ€§é»˜è®¤å€¼å¹¶ä¸éœ€è¦å­˜å‚¨åœ¨å…ƒæ•°æ®ä¸­ï¼Œå› ä¸ºåœ¨åˆ›å»ºè¯¥ç»“æ„å®ä¾‹çš„æ—¶å€™ï¼Œå°±è‡ªç„¶ä¼šè°ƒç”¨è¯¥ç»“æ„çš„æ„é€ å‡½æ•°ï¼Œä»è€Œæ­£ç¡®åˆå§‹åŒ–å€¼ã€‚
- è€Œåœ¨è“å›¾ä¸­çš„ç”¨æˆ·è‡ªå®šä¹‰ç»“æ„ï¼Œå¹¶æ²¡æœ‰æ„é€ å‡½æ•°ä¹‹ç±»çš„æœºåˆ¶ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸“é—¨çš„Tabæ¥å¡«å†™å±æ€§çš„é»˜è®¤å€¼ã€‚è¿™äº›é»˜è®¤å€¼å°±ä¼šå­˜å‚¨åœ¨å±æ€§çš„å…ƒæ•°æ®ä¸­ã€‚
- 

## æµ‹è¯•ä»£ç ï¼š

åœ¨è“å›¾ä¸­å®šä¹‰ä¸€ä¸ªç»“æ„BP_StructDefaultTestï¼Œå¹¶å¡«ä¸Šé»˜è®¤å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Struct\MakeStructureDefaultValue\Untitled.png)

## æµ‹è¯•ç»“æœï¼š

ç”¨æµ‹è¯•å‘½ä»¤è¡Œæ‰“å°å‡ºå…¶ç›¸å…³çš„ä¿¡æ¯ï¼Œå¯ä»¥è§åˆ°MyIntå’ŒMyStringçš„çœŸæ­£å±æ€§åä»¥åŠMakeStructureDefaultValue çš„å€¼ã€‚

```cpp
[struct BP_StructDefaultTest	UserDefinedStruct->ScriptStruct->Struct->Field->Object	/Game/Struct/BP_StructDefaultTest.BP_StructDefaultTest]
(BlueprintType = true, Tooltip = )
	ObjectFlags:	RF_Public | RF_Standalone | RF_Transactional | RF_WasLoaded | RF_LoadCompleted 
	Outer:	Package /Game/Struct/BP_StructDefaultTest
StructFlags:	STRUCT_NoFlags
Size:	24
{
	(DisplayName = MyInt, Tooltip = , MakeStructureDefaultValue = 789)
	0-[4] int32 MyInt_3_CC664A574A072369083883B38EA2F129;
		PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash 
		ObjectFlags:	RF_Public | RF_LoadCompleted 
		Outer:	UserDefinedStruct /Game/Struct/BP_StructDefaultTest.BP_StructDefaultTest
		Path:	IntProperty /Game/Struct/BP_StructDefaultTest.BP_StructDefaultTest:MyInt_3_CC664A574A072369083883B38EA2F129
	(DisplayName = MyString, Tooltip = , MakeStructureDefaultValue = Hello)
	8-[16] FString MyString_6_D8FAF5D6454C781C2D5175ACF266C394;
		PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_HasGetValueTypeHash 
		ObjectFlags:	RF_Public | RF_LoadCompleted 
		Outer:	UserDefinedStruct /Game/Struct/BP_StructDefaultTest.BP_StructDefaultTest
		Path:	StrProperty /Game/Struct/BP_StructDefaultTest.BP_StructDefaultTest:MyString_6_D8FAF5D6454C781C2D5175ACF266C394
};
```

## åŸç†ï¼š

åœ¨BPä¸­ç»“æ„åˆ›å»ºå˜é‡ä¿å­˜çš„æ—¶å€™ï¼Œå¦‚æœå‘ç°é»˜è®¤å€¼ä¸ä¸ºç©ºï¼Œåˆ™è®¾ç½®åˆ°MakeStructureDefaultValueä¸­å»ã€‚ä¹‹åå†MakeStructçš„æ—¶å€™å°±å¯ä»¥ç”¨ä¸Šäº†ã€‚

```cpp
void UK2Node_MakeStruct::FMakeStructPinManager::CustomizePinData(UEdGraphPin* Pin, FName SourcePropertyName, int32 ArrayIndex, FProperty* Property) const
{
	const FString& MetadataDefaultValue = Property->GetMetaData(TEXT("MakeStructureDefaultValue"));
if (!MetadataDefaultValue.IsEmpty())
{
	Schema->SetPinAutogeneratedDefaultValue(Pin, MetadataDefaultValue);
	return;
}
}

static void FUserDefinedStructureCompilerInner::CreateVariables(UUserDefinedStruct* Struct, const class UEdGraphSchema_K2* Schema, FCompilerResultsLog& MessageLog)
{
	if (!VarDesc.DefaultValue.IsEmpty())
	{
		VarProperty->SetMetaData(TEXT("MakeStructureDefaultValue"), *VarDesc.DefaultValue);
	}
}
```


ï»¿# AllowAbstract

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºç±»å±æ€§ï¼ŒæŒ‡å®šæ˜¯å¦æ¥å—æŠ½è±¡ç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPARAM, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOf, FSoftClassPathï¼ŒUClass*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyCommonObject :public UObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType)
class INSIDER_API UMyCommonObjectChild :public UMyCommonObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType,Abstract)
class INSIDER_API UMyCommonObjectChildAbstract :public UMyCommonObject
{
	GENERATED_BODY()
public:
};

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowAbstractTest")
	TSubclassOf<UMyCommonObject> MyClass_NotAllowAbstract;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowAbstractTest", meta = (AllowAbstract))
	TSubclassOf<UMyCommonObject> MyClass_AllowAbstract;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§å¢åŠ äº†AllowAbstractçš„å±æ€§çš„ç±»é€‰æ‹©å™¨é‡Œå¢åŠ äº†UMyCommonObjectChildAbstract è¿™ä¸ªæŠ½è±¡ç±»ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\AllowAbstract\AllowAbstract.png](AllowAbstract.png)

## åŸç†ï¼š

å…¶ä¸­çš„ä¸€ä¸ªåˆ¤æ–­æ˜¯IsEditInlineClassAllowedçš„åˆ¤æ–­ï¼Œå…¶ä¸­æœ‰bAllowAbstractã€‚

```cpp
bool FPropertyHandleBase::GeneratePossibleValues(TArray<FString>& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems, TArray<FText>* OutDisplayNames)
{
	 if( Property->IsA(FClassProperty::StaticClass()) || Property->IsA(FSoftClassProperty::StaticClass()) )		
	{
		UClass* MetaClass = Property->IsA(FClassProperty::StaticClass()) 
			? CastFieldChecked<FClassProperty>(Property)->MetaClass
			: CastFieldChecked<FSoftClassProperty>(Property)->MetaClass;

		FString NoneStr( TEXT("None") );
		OutOptionStrings.Add( NoneStr );
		if (OutDisplayNames)
		{
			OutDisplayNames->Add(FText::FromString(NoneStr));
		}

		const bool bAllowAbstract = Property->GetOwnerProperty()->HasMetaData(TEXT("AllowAbstract"));
		const bool bBlueprintBaseOnly = Property->GetOwnerProperty()->HasMetaData(TEXT("BlueprintBaseOnly"));
		const bool bAllowOnlyPlaceable = Property->GetOwnerProperty()->HasMetaData(TEXT("OnlyPlaceable"));
		UClass* InterfaceThatMustBeImplemented = Property->GetOwnerProperty()->GetClassMetaData(TEXT("MustImplement"));

		if (!bAllowOnlyPlaceable || MetaClass->IsChildOf<AActor>())
		{
			for (TObjectIterator<UClass> It; It; ++It)
			{
				if (It->IsChildOf(MetaClass)
					&& PropertyEditorHelpers::IsEditInlineClassAllowed(*It, bAllowAbstract)
					&& (!bBlueprintBaseOnly || FKismetEditorUtilities::CanCreateBlueprintOfClass(*It))
					&& (!InterfaceThatMustBeImplemented || It->ImplementsInterface(InterfaceThatMustBeImplemented))
					&& (!bAllowOnlyPlaceable || !It->HasAnyClassFlags(CLASS_Abstract | CLASS_NotPlaceable)))
				{
					OutOptionStrings.Add(It->GetName());
					if (OutDisplayNames)
					{
						OutDisplayNames->Add(FText::FromString(It->GetName()));
					}
				}
			}
		}
	}
}

bool IsEditInlineClassAllowed( UClass* CheckClass, bool bAllowAbstract ) 
{
	return !CheckClass->HasAnyClassFlags(CLASS_Hidden|CLASS_HideDropDown|CLASS_Deprecated)
		&&	(bAllowAbstract || !CheckClass->HasAnyClassFlags(CLASS_Abstract));
}
```


ï»¿# AllowedClasses

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡å¿…é¡»å±äºæŸä¸€äº›ç±»å‹åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒUClass*ï¼ŒFSoftClassPathï¼ŒUObject*ï¼ŒFSoftObjectPathï¼ŒFPrimaryAssetIdï¼ŒFComponentReference,
- **å…³è”é¡¹ï¼š** [ExactClass](../ExactClass/ExactClass.md), [DisallowedClasses](../DisallowedClasses/DisallowedClasses.md), [GetAllowedClasses](../GetAllowedClasses/GetAllowedClasses.md), [GetDisallowedClasses](../GetDisallowedClasses/GetDisallowedClasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡å¿…é¡»å±äºæŸä¸€äº›ç±»å‹åŸºç±»ã€‚

- ç±»é€‰æ‹©å™¨çš„åº”ç”¨å±æ€§æ˜¯ï¼šTSubClassOfï¼ŒUClass*ï¼ŒFSoftClassPathã€‚ä¸èƒ½åº”ç”¨çš„å±æ€§æ˜¯ï¼šUScriptStruct*
- å¯¹è±¡é€‰æ‹©å™¨çš„åº”ç”¨å±æ€§æ˜¯ï¼šUObject*ï¼Œ FSoftObjectPathï¼ŒFPrimaryAssetIdï¼ŒFComponentReference
- è¿™äº›é€‰æ‹©å™¨å¾€å¾€ä¼šæ˜¾ç¤ºå‡ºä¸€å¤§ä¸²å¯¹è±¡èµ„æºæ¥ä¾›é€‰æ‹©ï¼Œå› æ­¤å°±å¯ä»¥ç”¨AllowedClassesæ¥é™å®šå…¶å¿…é¡»å±äºçš„ç±»å‹ã€‚
- AllowedClassesé‡Œå¯ä»¥ç”¨é€—å·éš”å¼€å¤šä¸ªç±»å‹ï¼Œå› æ­¤å¯ä»¥åŒæ—¶æ”¯æŒå¤šä¸ªç±»å‹ç­›é€‰ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|TSubclassOf")
	TSubclassOf<UObject> MyClass_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|TSubclassOf", meta = (AllowedClasses = "MyCommonObject"))
	TSubclassOf<UObject> MyClass_AllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|UClass*")
	UClass* MyClassPtr_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|UClass*", meta = (AllowedClasses = "MyCommonObject"))
	UClass* MyClassPtr_AllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftClassPath")
	FSoftClassPath MySoftClass_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftClassPath", meta = (AllowedClasses = "MyCommonObject"))
	FSoftClassPath MySoftClass_AllowedClasses;

	
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftObjectPath")
	UObject* MyObject_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftObjectPath", meta = (AllowedClasses = "/Script/Engine.Texture2D"))
	UObject* MyObject_AllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftObjectPath")
	FSoftObjectPath MySoftObject_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FSoftObjectPath", meta = (AllowedClasses = "/Script/Engine.Texture2D"))
	FSoftObjectPath MySoftObject_AllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FPrimaryAssetId")
	FPrimaryAssetId MyPrimaryAsset_NoAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "AllowedClassesTest|FPrimaryAssetId", meta = (AllowedClasses = "MyPrimaryDataAsset"))
	FPrimaryAssetId MyPrimaryAsset_AllowedClasses;
	
	
UCLASS(Blueprintable,BlueprintType)
class INSIDER_API AMyActor_Class :public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "AllowedClassesTest|FComponentReference", meta = (UseComponentPicker))
	FComponentReference MyComponentReference_NoAllowedClasses;

	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "AllowedClassesTest|FComponentReference", meta = (UseComponentPicker,AllowedClasses = "MyActorComponent"))
	FComponentReference MyComponentReference_AllowedClasses;
};

UCLASS(BlueprintType)
class INSIDER_API UMyPrimaryDataAsset :public UPrimaryDataAsset
{}
```

## æµ‹è¯•ç»“æœï¼š

- åœ¨ç±»é€‰æ‹©å™¨ä¸Šï¼Œå¯è§åŠ äº†AllowedClasses ä¹‹åï¼Œå°±é™å®šåˆ°MyCommonObjectçš„å­ç±»ä¸Šã€‚
- åœ¨å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒåŠ ä¸Šäº†AllowedClasses = "/Script/Engine.Texture2D"ä¹‹åï¼Œå°±æŠŠç±»å‹é™å®šåˆ°çº¹ç†ä¸Šã€‚
- åœ¨FPrimaryAssetId å±æ€§çš„èµ„äº§ç­›é€‰ä¸Šï¼ŒåŠ äº†AllowedClasses ä¹‹åï¼Œå¯ä»¥é™å®šåˆ°MyPrimaryDataAssetç±»å‹ï¼Œå›¾ä¸Šæ˜¯BP_MyPrimaryAssetã€‚æ³¨æ„ä¸€ä¸‹UMyPrimaryDataAsset éœ€è¦åœ¨ProjectSettingsé‡Œè®¾ç½®ä¸Šã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\AllowedClasses\AllowClasses.jpg](AllowClasses.jpg)

æµ‹è¯•FComponentReferenceçš„æ•ˆæœï¼š

ç»“åˆä¸Šè¿°ä»£ç ï¼Œå¯è§é»˜è®¤æƒ…å†µä¸‹ï¼ŒFComponentReferenceå¯é€‰æ‹©çš„èŒƒå›´æ˜¯å½“å‰Actorä¸‹æ‰€æœ‰Componentã€‚è€ŒåŠ ä¸ŠAllowedClassesåï¼Œå¯ä»¥æŠŠé€‰æ‹©çš„èŒƒå›´é™å®šåˆ°ä»£ç é‡Œæè¿°çš„MyActorComponentã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\AllowedClasses\AllowClasses_ComponentReference.jpg](AllowClasses_ComponentReference.jpg)

## åŸç†ï¼š

åœ¨æºç é‡Œæœç´¢å¯è§ï¼Œå¾€å¾€åœ¨å„ç§ç±»å‹çš„Customizationæˆ–SPropertyEditorXXXä¸Šï¼Œä¼šè¿›è¡ŒAllowedClasses å’ŒDisallowedClasses çš„åˆ¤æ–­ï¼Œä¹‹åå†å¯¹ç±»å‹è¿›è¡ŒIsChildOfçš„Filterç­›é€‰ã€‚

```cpp
void FPrimaryAssetIdCustomization::CustomizeHeader(TSharedRef<class IPropertyHandle> InStructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(StructPropertyHandle->GetMetaData("AllowedClasses"));
	DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(StructPropertyHandle->GetMetaData("DisallowedClasses"));
}
void FComponentReferenceCustomization::BuildClassFilters()
{
		const FString& AllowedClassesFilterString = PropertyHandle->GetMetaData(NAME_AllowedClasses);
		ParseClassFilters(AllowedClassesFilterString, AllowedActorClassFilters, AllowedComponentClassFilters);

		const FString& DisallowedClassesFilterString = PropertyHandle->GetMetaData(NAME_DisallowedClasses);
		ParseClassFilters(DisallowedClassesFilterString, DisallowedActorClassFilters, DisallowedComponentClassFilters);
}
void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		TArray<const UClass*> AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("AllowedClasses"));
		TArray<const UClass*> DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("DisallowedClasses"));
}

void PropertyEditorUtils::GetAllowedAndDisallowedClasses(const TArray<UObject*>& ObjectList, const FProperty& MetadataProperty, TArray<const UClass*>& AllowedClasses, TArray<const UClass*>& DisallowedClasses, bool bExactClass, const UClass* ObjectClass)
{
		AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("AllowedClasses"));
		DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("DisallowedClasses"));
		if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetAllowedClasses"))
		{
			const FString GetAllowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetAllowedClasses");
		}
		
		if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetDisallowedClasses"))
		{
			const FString GetDisallowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetDisallowedClasses");
		}
}

void SPropertyEditorAsset::InitializeClassFilters(const FProperty* Property)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *MetadataProperty, AllowedClassFilters, DisallowedClassFilters, bExactClass, ObjectClass);
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}

TSharedRef<SWidget> SPropertyEditorEditInline::GenerateClassPicker()
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}
```


ï»¿# AllowedTypes

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºFPrimaryAssetIdå¯ä»¥æŒ‡å®šå…è®¸çš„èµ„äº§ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** FPrimaryAssetId
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºFPrimaryAssetIdå¯ä»¥æŒ‡å®šå…è®¸çš„èµ„äº§ç±»å‹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_PrimaryAsset :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "PrimaryAsset")
	FPrimaryAssetId MyPrimaryAsset;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "PrimaryAsset",meta=(AllowedTypes="MyAsset"))
	FPrimaryAssetId MyPrimaryAsset_Allowed;
};

```

## æµ‹è¯•ç»“æœï¼š

åœ¨é¡¹ç›®ä¸­å·²ç»äº‹å…ˆå®šä¹‰äº†å¤šä¸ªUPrimaryDataAssetï¼Œä¹Ÿåœ¨ProjectSettingsé‡Œè®¾ç½®äº†ã€‚ï¼ˆå¦‚ä½•å®šä¹‰è¯·æŸ¥çœ‹åˆ«çš„æ–‡ç« è¯¦è§£ï¼‰ã€‚

å¯è§MyPrimaryAsset_Allowedçš„é€‰é¡¹åªæœ‰ä¸€ä¸ªäº†ï¼Œè¯´æ˜å—åˆ°äº†é™åˆ¶ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\AllowedTypes\Untitled.png)

## åŸç†ï¼š

åœ¨FPrimaryAssetId çš„å®šåˆ¶åŒ–FPrimaryAssetIdCustomizationä¸­ï¼Œä¼šæŸ¥çœ‹è¯¥æ ‡è®°ï¼Œè§£æAllowedTypesçš„å€¼å¹¶æŠŠå®ƒè®¾ç½®åˆ°æˆå‘˜å˜é‡AllowedTypesä¸­å»ï¼Œæœ€ç»ˆè¾¾æˆç­›é€‰ã€‚

```cpp
TArray<FPrimaryAssetType> FPrimaryAssetIdCustomization::AllowedTypes;

void FPrimaryAssetIdCustomization::CustomizeHeader(TSharedRef<class IPropertyHandle> InStructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	check(UAssetManager::IsInitialized());

	StructPropertyHandle = InStructPropertyHandle;

	const FString& TypeFilterString = StructPropertyHandle->GetMetaData("AllowedTypes");
	if( !TypeFilterString.IsEmpty() )
	{
		TArray<FString> CustomTypeFilterNames;
		TypeFilterString.ParseIntoArray(CustomTypeFilterNames, TEXT(","), true);

		for(auto It = CustomTypeFilterNames.CreateConstIterator(); It; ++It)
		{
			const FString& TypeName = *It;

			AllowedTypes.Add(*TypeName);
		}
	}
	
	IAssetManagerEditorModule::MakePrimaryAssetIdSelector(
	FOnGetPrimaryAssetDisplayText::CreateSP(this, &FPrimaryAssetIdCustomization::GetDisplayText),
	FOnSetPrimaryAssetId::CreateSP(this, &FPrimaryAssetIdCustomization::OnIdSelected),
	bAllowClear, AllowedTypes, AllowedClasses, DisallowedClasses)
	
	}
```


ï»¿# BaseClass

- **åŠŸèƒ½æè¿°ï¼š** åªåœ¨StateTreeæ¨¡å—ä¸­ä½¿ç”¨ï¼Œé™åˆ¶FStateTreeEditorNodeé€‰æ‹©çš„åŸºç±»ç±»å‹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FStateTreeEditorNodeå±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åªåœ¨StateTreeæ¨¡å—ä¸­ä½¿ç”¨ï¼Œé™åˆ¶FStateTreeEditorNodeé€‰æ‹©çš„åŸºç±»ç±»å‹ã€‚

## æºç ä¾‹å­ï¼š

```cpp

USTRUCT()
struct STATETREEEDITORMODULE_API FStateTreeTransition
{
	/** Conditions that must pass so that the transition can be triggered. */
	UPROPERTY(EditDefaultsOnly, Category = "Transition", meta = (BaseStruct = "/Script/StateTreeModule.StateTreeConditionBase", BaseClass = "/Script/StateTreeModule.StateTreeConditionBlueprintBase"))
	TArray<FStateTreeEditorNode> Conditions;
	
	UPROPERTY(EditDefaultsOnly, Category = "Tasks", meta = (BaseStruct = "/Script/StateTreeModule.StateTreeTaskBase", BaseClass = "/Script/StateTreeModule.StateTreeTaskBlueprintBase"))
	TArray<FStateTreeEditorNode> Tasks;
}
```

## æµ‹è¯•ç»“æœï¼š

å¯è§ï¼Œè™½ç„¶Conditionså’ŒTasksçš„ç±»å‹éƒ½æ˜¯FStateTreeEditorNodeï¼Œä½†æ˜¯é€‰é¡¹åˆ—è¡¨é‡Œçš„å†…å®¹æ˜¯ä¸åŒçš„ã€‚è¿™æ˜¯ç”±äºå…¶ä¸Šé¢çš„BaseStructå’ŒBaseClass ä¸åŒï¼Œåˆ†åˆ«é™å®šäº†ç»“æ„çš„åŸºç±»ç±»å‹ä»¥åŠè“å›¾ç±»çš„åŸºç±»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\BaseClass\Untitled.png)

## åŸç†ï¼š

åœ¨FStateTreeEditorNodeçš„UIå®šåˆ¶åŒ–ä¸Šè·å–è¯¥å±æ€§ï¼Œç„¶åç”¨æ¥è¿‡æ»¤å¯ç”¨çš„èŠ‚ç‚¹ç±»å‹ã€‚

```cpp
void FStateTreeEditorNodeDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		static const FName BaseClassMetaName(TEXT("BaseClass")); // TODO: move these names into one central place.
		const FString BaseClassName = StructProperty->GetMetaData(BaseClassMetaName);
		BaseClass = UClass::TryFindTypeSlow<UClass>(BaseClassName);
}

```


ï»¿# BaseStruct

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFInstancedStructå±æ€§é€‰é¡¹åˆ—è¡¨é€‰æ‹©çš„ç»“æ„éƒ½å¿…é¡»ç»§æ‰¿äºBaseStructæŒ‡å‘çš„ç»“æ„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FInstancedStruct
- **å…³è”é¡¹ï¼š** [ExcludeBaseStruct](../ExcludeBaseStruct.md), [StructTypeConst](../StructTypeConst.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šFInstancedStructå±æ€§é€‰é¡¹åˆ—è¡¨é€‰æ‹©çš„ç»“æ„éƒ½å¿…é¡»ç»§æ‰¿äºBaseStructæŒ‡å‘çš„ç»“æ„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

USTRUCT(BlueprintType)
struct INSIDER_API FMyCommonStruct
{
}ï¼›

USTRUCT(BlueprintType)
struct INSIDER_API FMyCommonStructChild:public FMyCommonStruct
{
	GENERATED_BODY()
};

USTRUCT(BlueprintType, DisplayName = "This is MyCommonStructChild")
struct INSIDER_API FMyCommonStructChild_HasDisplayName :public FMyCommonStruct
{
	GENERATED_BODY()
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Struct :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "InstancedStruct")
	FInstancedStruct MyStruct;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "InstancedStruct", meta = (BaseStruct = "/Script/Insider.MyCommonStruct"))
	FInstancedStruct MyStruct_BaseStruct;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "InstancedStruct", meta = (ExcludeBaseStruct, BaseStruct = "/Script/Insider.MyCommonStruct"))
	FInstancedStruct MyStruct_ExcludeBaseStruct;
	
		UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "InstancedStruct", meta = (StructTypeConst))
		FInstancedStruct MyStruct_Const;
};
```

## æµ‹è¯•ç»“æœï¼š

å¯è§MyStruct_BaseStructçš„é€‰æ‹©é™åˆ¶åœ¨FMyCommonStructçš„è‡ªå·±ä»¥åŠå­ç±»ã€‚

è€Œå¦‚æœä¸æƒ³è¦åŸºç±»æœ¬èº«ï¼Œåˆ™åŠ ä¸ŠExcludeBaseStructçš„MyStruct_ExcludeBaseStructå°±ä¸åŒ…å«FMyCommonStructäº†ã€‚

åŠ ä¸ŠStructTypeConstçš„MyStruct_Constå°±ä¸èƒ½ç¼–è¾‘äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\BaseStruct\Untitled.png)

## åŸç†ï¼š

æŠ½å–BaseStructçš„å…ƒä¿¡æ¯ä»¥å¡«å……åˆ°StructFilterä¸­å»ã€‚

```cpp

void FInstancedStructDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		static const FName NAME_BaseStruct = "BaseStruct";
	const FString& BaseStructName = StructProperty->GetMetaData(NAME_BaseStruct);
	if (!BaseStructName.IsEmpty())
	{
		BaseScriptStruct = UClass::TryFindTypeSlow<UScriptStruct>(BaseStructName);
		if (!BaseScriptStruct)
		{
			BaseScriptStruct = LoadObject<UScriptStruct>(nullptr, *BaseStructName);
		}
	}

}

TSharedRef<SWidget> FInstancedStructDetails::GenerateStructPicker()
{
	static const FName NAME_ExcludeBaseStruct = "ExcludeBaseStruct";
	static const FName NAME_HideViewOptions = "HideViewOptions";
	static const FName NAME_ShowTreeView = "ShowTreeView";

	const bool bExcludeBaseStruct = StructProperty->HasMetaData(NAME_ExcludeBaseStruct);
	const bool bAllowNone = !(StructProperty->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
	const bool bHideViewOptions = StructProperty->HasMetaData(NAME_HideViewOptions);
	const bool bShowTreeView = StructProperty->HasMetaData(NAME_ShowTreeView);
	
	StructFilter->BaseStruct = BaseScriptStruct;
	StructFilter->bAllowBaseStruct = !bExcludeBaseStruct;
	
}

```


ï»¿# BlueprintBaseOnly

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºç±»å±æ€§ï¼ŒæŒ‡å®šæ˜¯å¦åªæ¥å—å¯åˆ›å»ºè“å›¾å­ç±»çš„åŸºç±»
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOf, FSoftClassPathï¼ŒUClass*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

è¿™ä¸ªé™å®šåœ¨åªæƒ³è¦å¯å½“ä½œè“å›¾åŸºç±»çš„ç±»æ—¶ä¼šæ¯”è¾ƒæœ‰ç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyCommonObject :public UObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType)
class INSIDER_API UMyCommonObjectChild :public UMyCommonObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType, NotBlueprintable)
class INSIDER_API UMyCommonObjectChild_NotBlueprintable :public UMyCommonObject
{
	GENERATED_BODY()
public:
};

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "BlueprintBaseOnlyTest")
	TSubclassOf<UMyCommonObject> MyClass_NotBlueprintBaseOnly;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "BlueprintBaseOnlyTest", meta = (BlueprintBaseOnly))
	TSubclassOf<UMyCommonObject> MyClass_BlueprintBaseOnly;
```

## æµ‹è¯•æ•ˆæœï¼š

åŠ äº†BlueprintBaseOnlyçš„é™å®šåï¼ŒUMyCommonObjectChild_NotBlueprintable è¿™ä¸ªç±»å› ä¸ºNotBlueprintableå°±ä¸èƒ½è¢«é€‰æ‹©äº†ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\BlueprintBaseOnly\BlueprintBaseOnly.jpg](BlueprintBaseOnly.jpg)

## åŸç†ï¼š

å¦‚æœbBlueprintBaseOnly åˆ™éœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­CanCreateBlueprintOfClassï¼Œåè€…åˆ¤æ–­ä¸€ä¸ªç±»æ˜¯å¦å¯ä»¥åˆ›å»ºè“å›¾å­ç±»ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œå¦‚æœä¸€ä¸ªC++ç±»ï¼Œæ²¡æœ‰å®šä¹‰Blueprintableï¼Œåˆ™æ— æ³•åˆ›å»ºè“å›¾å­ç±»ï¼Œåˆ™ä¸ä¼šè¢«è¯¥å±æ€§é€‰æ‹©åˆ°ã€‚

æœ¬èº«æ˜¯è“å›¾ç±»çš„éƒ½æ˜¯å¯ä»¥å†åˆ›å»ºè“å›¾å­ç±»çš„ã€‚

```cpp
bool FPropertyHandleBase::GeneratePossibleValues(TArray<FString>& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems, TArray<FText>* OutDisplayNames)
{
	 if( Property->IsA(FClassProperty::StaticClass()) || Property->IsA(FSoftClassProperty::StaticClass()) )		
	{
		UClass* MetaClass = Property->IsA(FClassProperty::StaticClass()) 
			? CastFieldChecked<FClassProperty>(Property)->MetaClass
			: CastFieldChecked<FSoftClassProperty>(Property)->MetaClass;

		FString NoneStr( TEXT("None") );
		OutOptionStrings.Add( NoneStr );
		if (OutDisplayNames)
		{
			OutDisplayNames->Add(FText::FromString(NoneStr));
		}

		const bool bAllowAbstract = Property->GetOwnerProperty()->HasMetaData(TEXT("AllowAbstract"));
		const bool bBlueprintBaseOnly = Property->GetOwnerProperty()->HasMetaData(TEXT("BlueprintBaseOnly"));
		const bool bAllowOnlyPlaceable = Property->GetOwnerProperty()->HasMetaData(TEXT("OnlyPlaceable"));
		UClass* InterfaceThatMustBeImplemented = Property->GetOwnerProperty()->GetClassMetaData(TEXT("MustImplement"));

		if (!bAllowOnlyPlaceable || MetaClass->IsChildOf<AActor>())
		{
			for (TObjectIterator<UClass> It; It; ++It)
			{
				if (It->IsChildOf(MetaClass)
					&& PropertyEditorHelpers::IsEditInlineClassAllowed(*It, bAllowAbstract)
					&& (!bBlueprintBaseOnly || FKismetEditorUtilities::CanCreateBlueprintOfClass(*It))
					&& (!InterfaceThatMustBeImplemented || It->ImplementsInterface(InterfaceThatMustBeImplemented))
					&& (!bAllowOnlyPlaceable || !It->HasAnyClassFlags(CLASS_Abstract | CLASS_NotPlaceable)))
				{
					OutOptionStrings.Add(It->GetName());
					if (OutDisplayNames)
					{
						OutDisplayNames->Add(FText::FromString(It->GetName()));
					}
				}
			}
		}
	}
}
```


ï»¿# DisallowedClasses

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡æ’é™¤æ‰æŸä¸€äº›ç±»å‹åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒUClass*ï¼ŒFSoftClassPathï¼ŒFComponentReference
- **å…³è”é¡¹ï¼š** [AllowedClasses](../AllowedClasses/AllowedClasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„å¯¹è±¡æ’é™¤æ‰æŸä¸€äº›ç±»å‹åŸºç±»ã€‚

- ç±»é€‰æ‹©å™¨çš„åº”ç”¨å±æ€§æ˜¯ï¼šTSubClassOfï¼ŒUClass*ï¼ŒFSoftClassPathã€‚ä¸èƒ½åº”ç”¨çš„å±æ€§æ˜¯ï¼šUScriptStruct*
- å¯¹è±¡é€‰æ‹©å™¨çš„åº”ç”¨å±æ€§æ˜¯ï¼šFComponentReferenceã€‚ä¼šå‘ç°ç›¸æ¯”AllowedClasseså°‘äº†â€œUObject*ï¼Œ FSoftObjectPathï¼ŒFPrimaryAssetIdâ€ï¼Œè¿™æ˜¯å› ä¸ºè¿™3ä¸ªå¯¹åº”çš„UIæ˜¯SAssetPickerï¼Œè€Œè¿™ä¸ªé‡Œé¢å¹¶æ²¡æœ‰åº”ç”¨FARFilter.RecursiveClassPathsExclusionSetæ¥è¿›è¡Œæ’é™¤ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|TSubclassOf")
	TSubclassOf<UObject> MyClass_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|TSubclassOf", meta = (DisallowedClasses = "/Script/GameplayAbilities.AbilityAsync"))
	TSubclassOf<UObject> MyClass_DisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|UClass*")
	UClass* MyClassPtr_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|UClass*", meta = (DisallowedClasses = "/Script/GameplayAbilities.AbilityAsync"))
	UClass* MyClassPtr_DisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftClassPath")
	FSoftClassPath MySoftClass_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftClassPath", meta = (DisallowedClasses = "/Script/GameplayAbilities.AbilityAsync"))
	FSoftClassPath MySoftClass_DisallowedClasses;
public://Not work
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftObjectPath")
	UObject* MyObject_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftObjectPath", meta = (DisallowedClasses = "/Script/Engine.Texture2D"))
	UObject* MyObject_DisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftObjectPath")
	FSoftObjectPath MySoftObject_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FSoftObjectPath", meta = (DisallowedClasses = "/Script/Engine.Texture2D"))
	FSoftObjectPath MySoftObject_DisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FPrimaryAssetId")
	FPrimaryAssetId MyPrimaryAsset_NoDisallowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "DisallowedClassesTest|FPrimaryAssetId", meta = (DisallowedClasses = "MyPrimaryDataAsset"))
	FPrimaryAssetId MyPrimaryAsset_DisallowedClasses;
	
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_Class :public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "DisallowedClassesTest|FComponentReference", meta = (UseComponentPicker))
	FComponentReference MyComponentReference_NoDisallowedClasses;

	UPROPERTY(EditInstanceOnly, BlueprintReadWrite, Category = "DisallowedClassesTest|FComponentReference", meta = (UseComponentPicker, DisallowedClasses = "MyActorComponent"))
	FComponentReference MyComponentReference_DisallowedClasses;
};

```

## æµ‹è¯•æ•ˆæœï¼š

- åœ¨ç±»é€‰æ‹©å™¨ä¸Šï¼Œå¯è§åŠ äº†DisallowedClasses ä¹‹åï¼Œå°±æ’é™¤æ‰äº†AbilityAsyncç±»ã€‚
- è€Œåœ¨å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼Œå´æ²¡å¿…è¦å‘ç”Ÿä½œç”¨ã€‚äºŒè€…çš„å¯é€‰å¯¹è±¡åˆ—è¡¨æ˜¯ä¸€æ ·çš„ã€‚åŸå› æ˜¯å› ä¸ºSAssetPickerå¹¶æ²¡æœ‰å®é™…ä¸Šåº”ç”¨DisallowedClasses ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\DisallowedClasses\DisallowedClasses.jpg](DisallowedClasses.jpg)

è€Œåœ¨FComponentReferenceä¸Šçš„æµ‹è¯•æ•ˆæœæ˜¯ï¼š

DisallowedClasseså¯ä»¥æ’é™¤æ‰MyActorComponentã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\DisallowedClasses\DisallowedClasses_ComponentReference.jpg](DisallowedClasses_ComponentReference.jpg)

## åŸç†ï¼š

ä¸»è¦çš„åŸç†å·²ç»åœ¨AllowedClassesä¸Šå±•ç¤ºå‡ºæ¥ã€‚DisallowedClassesçš„æ•°æ®ä¸»è¦æ˜¯è®¾ç½®åˆ°DisallowedClassFiltersé‡Œé¢å»ã€‚ä¹‹ååœ¨åˆ›å»ºClassViewerçš„æ—¶å€™è®¾å®šåˆ°ClassFilterä¸Šï¼Œæœ€åå…¶å®è¿˜æ˜¯IsChildOfçš„åˆ¤æ–­ã€‚ä½†ä¹Ÿè¦æ³¨æ„å¹¶ä¸æ˜¯æ‰€æœ‰çš„ç±»å’Œå¯¹è±¡é€‰æ‹©å™¨éƒ½æœ‰ä½¿ç”¨DisallowedClassesï¼ŒAssetPickerä¸Šå°±å¹¶æ²¡æœ‰å®ç°ã€‚

```cpp
	TSharedRef<FPropertyEditorClassFilter> PropEdClassFilter = MakeShared<FPropertyEditorClassFilter>();
	PropEdClassFilter->ClassPropertyMetaClass = MetaClass;
	PropEdClassFilter->InterfaceThatMustBeImplemented = RequiredInterface;
	PropEdClassFilter->bAllowAbstract = bAllowAbstract;
	PropEdClassFilter->AllowedClassFilters = AllowedClassFilters;
	PropEdClassFilter->DisallowedClassFilters = DisallowedClassFilters;

	ClassViewerOptions.ClassFilters.Add(PropEdClassFilter);

	ClassFilter = FModuleManager::LoadModuleChecked<FClassViewerModule>("ClassViewer").CreateClassFilter(ClassViewerOptions);
	
	
template <typename TClass>
bool FPropertyEditorClassFilter::IsClassAllowedHelper(TClass InClass)
{
	bool bMatchesFlags = !InClass->HasAnyClassFlags(CLASS_Hidden | CLASS_HideDropDown | CLASS_Deprecated) &&
		(bAllowAbstract || !InClass->HasAnyClassFlags(CLASS_Abstract));

	if (bMatchesFlags && InClass->IsChildOf(ClassPropertyMetaClass)
		&& (!InterfaceThatMustBeImplemented || InClass->ImplementsInterface(InterfaceThatMustBeImplemented)))
	{
		auto PredicateFn = [InClass](const UClass* Class)
		{
			return InClass->IsChildOf(Class);
		};

		if (DisallowedClassFilters.FindByPredicate(PredicateFn) == nullptr &&
			(AllowedClassFilters.Num() == 0 || AllowedClassFilters.FindByPredicate(PredicateFn) != nullptr))
		{
			return true;
		}
	}

	return false;
}

void SAssetPicker::Construct( const FArguments& InArgs )
{
	if (InArgs._AssetPickerConfig.bAddFilterUI)
	{		
		// We create available classes here. These are used to hide away the type filters in the filter list that don't match this list of classes
		TArray<UClass*> FilterClassList;
		for(auto Iter = CurrentBackendFilter.ClassPaths.CreateIterator(); Iter; ++Iter)
		{
			FTopLevelAssetPath ClassName = (*Iter);
			UClass* FilterClass = FindObject<UClass>(ClassName);
			if(FilterClass)
			{
				FilterClassList.AddUnique(FilterClass);
			}
		}		
}
```


ï»¿# DisallowedStructs

- **åŠŸèƒ½æè¿°ï¼š** åªåœ¨SmartObjectæ¨¡å—ä¸­åº”ç”¨ï¼Œç”¨ä»¥åœ¨ç±»é€‰æ‹©å™¨ä¸­æ’é™¤æ‰æŸä¸ªç±»ä»¥åŠå­ç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åªåœ¨SmartObjectæ¨¡å—ä¸­åº”ç”¨ï¼Œç”¨ä»¥åœ¨ç±»é€‰æ‹©å™¨ä¸­æ’é™¤æ‰æŸä¸ªç±»ä»¥åŠå­ç±»ã€‚

## æºç ï¼š

```cpp
UPROPERTY(EditDefaultsOnly, Category = "SmartObject", meta=(DisallowedStructs="/Script/SmartObjectsModule.SmartObjectSlotAnnotation"))
TArray<FSmartObjectDefinitionDataProxy> DefinitionData;
```


ï»¿# ExactClass

- **åŠŸèƒ½æè¿°ï¼š** åœ¨åŒæ—¶è®¾ç½®AllowedClasseså’ŒGetAllowedClassesçš„æ—¶å€™ï¼ŒExactClassæŒ‡å®šåªå–è¿™ä¸¤ä¸ªé›†åˆä¸­ç±»å‹å®Œå…¨ä¸€è‡´çš„ç±»å‹äº¤é›†ï¼Œå¦åˆ™å–ä¸€è‡´çš„äº¤é›†å†åŠ ä¸Šå…¶å­ç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FSoftObjectPathï¼ŒUObject*
- **å…³è”é¡¹ï¼š** [AllowedClasses](../AllowedClasses/AllowedClasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨åŒæ—¶è®¾ç½®AllowedClasseså’ŒGetAllowedClassesçš„æ—¶å€™ï¼ŒExactClassæŒ‡å®šåªå–è¿™ä¸¤ä¸ªé›†åˆä¸­ç±»å‹å®Œå…¨ä¸€è‡´çš„ç±»å‹äº¤é›†ï¼Œå¦åˆ™å–ä¸€è‡´çš„äº¤é›†å†åŠ ä¸Šå…¶å­ç±»ã€‚

- åªä½œç”¨äºFSoftObjectPathå’ŒUObject*ï¼Œå› ä¸ºç›®å‰åªæœ‰SPropertyEditorAssetæ‰ç”¨åˆ°è¿™ä¸ªMetaã€‚
- åœ¨äºŒè€…åŒºåˆ†åº¦ä¸Šå¾ˆä¸å®¹æ˜“ç†è§£ã€‚å› ä¸ºå¦‚æœä¸€è‡´çš„ç±»å‹åˆšå¥½æ˜¯å…¶ä»–ç±»å‹çš„åŸºç±»ï¼Œåˆ™æœ‰æ²¡æœ‰å–åˆ°â€œå…¶å­ç±»â€æœ¬èº«ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚
- åœ¨æµ‹è¯•ä»£ç é‡Œï¼Œæ„å»ºäº†ä¸€ä¸ªæµ‹è¯•ä¾‹å­ï¼ŒAllowedClasses é‡Œå–Texture2Då’ŒTextureCubeï¼ŒGetAllowedClasses é‡Œå–TextureLightProfileå’ŒTextureCubeã€‚æˆ‘ä»¬çŸ¥é“TextureLightProfileæ˜¯ç»§æ‰¿äºTexture2Dçš„ã€‚å› æ­¤å¦‚æœExactClass==trueï¼Œåˆ™æœ€åçš„ç­›é€‰ç±»å‹æ˜¯TextureCubeï¼Œå› ä¸ºè¦ç±»å‹å®Œå…¨ä¸€è‡´ã€‚è€Œå¦‚æœExactClass==falseï¼Œåˆ™æœ€åçš„ç­›é€‰ç±»å‹æ˜¯TextureCubeå’ŒTextureLightProfileï¼Œå› ä¸ºTextureLightProfileæ˜¯ç»§æ‰¿äºå¯¹é¢çš„Texture2Dï¼Œå› æ­¤TextureLightProfileä¼šè¢«é€‰ä¸­ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UFUNCTION()
	TArray<UClass*> MyGetAllowedClassesFunc()
	{
		TArray<UClass*> classes;
		classes.Add(UTextureLightProfile::StaticClass());
		classes.Add(UTextureCube::StaticClass());
		return classes;
	}
	
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ExactClassTest|UObject*", meta = (AllowedClasses = "/Script/Engine.Texture2D,/Script/Engine.TextureCube",GetAllowedClasses = "MyGetAllowedClassesFunc"))
	UObject* MyObject_NoExactClass;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ExactClassTest|UObject*", meta = (ExactClass, AllowedClasses = "/Script/Engine.Texture2D,/Script/Engine.TextureCube",GetAllowedClasses = "MyGetAllowedClassesFunc"))
	UObject* MyObject_ExactClass;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ExactClassTest|FSoftObjectPath", meta = (AllowedClasses = "/Script/Engine.Texture2D,/Script/Engine.TextureCube",GetAllowedClasses = "MyGetAllowedClassesFunc"))
	FSoftObjectPath MySoftObject_NoExactClass;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ExactClassTest|FSoftObjectPath", meta = (ExactClass, AllowedClasses = "/Script/Engine.Texture2D,/Script/Engine.TextureCube",GetAllowedClasses = "MyGetAllowedClassesFunc"))
	FSoftObjectPath MySoftObject_ExactClass;
```

## æµ‹è¯•æ•ˆæœï¼š

- å¯è§æ²¡æœ‰ExactClassçš„æ—¶å€™ï¼Œç­›é€‰ç±»å‹æ˜¯TextureCubeå’ŒTextureLightProfileï¼Œæ€»å…±æœ‰18é¡¹ã€‚
- è€Œæœ‰ExactClassåï¼Œç­›é€‰ç±»å‹æ˜¯TextureCubeï¼Œæ€»å…±åªæœ‰12é¡¹ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\ExactClass\ExactClass.jpg](ExactClass.jpg)

## åŸç†ï¼š

ç»è¿‡æµ‹è¯•å’Œæºç é€»è¾‘æŸ¥çœ‹ï¼Œç¡®å®šExactClasså¿…é¡»é…åˆGetAllowedClassesæ¥ç”¨ï¼Œè€Œä¸”è¿˜å¿…é¡»AllowedClassesåŒæ—¶æœ‰ã€‚å› ä¸ºâ€œExactClassâ€å±æ€§ä¼ é€’åˆ°GetAllowedAndDisallowedClassesé‡Œã€‚åœ¨æ•´ä¸ªæºç ä¸­åªæ‰¾åˆ°è¿™ä¸ªåœ°æ–¹ä½¿ç”¨ã€‚è€Œç»§ç»­æ ¹æ®GetAllowedAndDisallowedClassesé‡Œé¢çš„é€»è¾‘ï¼Œå½“AllowedClasseså’ŒGetAllowedClassesé‡Œéƒ½æœ‰å€¼çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šè¿›bExactClass çš„åˆ¤æ–­ã€‚

- å¦‚æœbExactClass ==falseï¼Œåˆ™AllowedClasseså’ŒGetAllowedClassesé‡Œçš„å€¼ï¼Œè¦ç›¸ç­‰æˆ–è€…æ˜¯å¯¹æ–¹çš„å­ç±»æ‰å¯ä»¥ï¼Œæ„æ€å°±æ˜¯å¾—æ˜¯ä¸€ä¸ªç»§æ‰¿æ ‘é‡Œé¢çš„ï¼Œç„¶åæœ€ç»ˆå–å€¼çš„æ—¶å€™ä¼šå–å­ç±»ï¼Œè€Œä¸æ˜¯åŸºç±»ã€‚
- å¦‚æœbExactClass ==trueï¼Œåˆ™åªæœ‰AllowedClasseså’ŒGetAllowedClassesé‡Œä¸€è‡´ç›¸ç­‰çš„æ‰å¯ä»¥ã€‚

```cpp
void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
	//é»˜è®¤å°±æ˜¯falseï¼Œå› æ­¤æ²¡ç”¨åˆ°ExactClass
	PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}
void SPropertyEditorAsset::InitializeClassFilters(const FProperty* Property)
{
	if (Property == nullptr)
	{
		AllowedClassFilters.Add(ObjectClass);
		return;
	}

	// Account for the allowed classes specified in the property metadata
	const FProperty* MetadataProperty = GetActualMetadataProperty(Property);

	bExactClass = GetTagOrBoolMetadata(MetadataProperty, "ExactClass", false);
	
	TArray<UObject*> ObjectList;
	if (PropertyEditor && PropertyEditor->GetPropertyHandle()->IsValidHandle())
	{
		PropertyEditor->GetPropertyHandle()->GetOuterObjects(ObjectList);
	}
	else if (PropertyHandle.IsValid())
	{
		PropertyHandle->GetOuterObjects(ObjectList);
	}
	
	PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *MetadataProperty, AllowedClassFilters, DisallowedClassFilters, bExactClass, ObjectClass);
	
	if (AllowedClassFilters.Num() == 0)
	{
		// always add the object class to the filters
		AllowedClassFilters.Add(ObjectClass);
	}
}

void GetAllowedAndDisallowedClasses(const TArray<UObject*>& ObjectList, const FProperty& MetadataProperty, TArray<const UClass*>& AllowedClasses, TArray<const UClass*>& DisallowedClasses, bool bExactClass, const UClass* ObjectClass)
{
		TArray<const UClass*> CurrentAllowedClassFilters = MoveTemp(AllowedClasses);
			ensure(AllowedClasses.IsEmpty());
			for (const UClass* MergedClass : MergedClasses)
			{
				// Keep classes that match both allow list
				for (const UClass* CurrentClass : CurrentAllowedClassFilters)
				{
					if (CurrentClass == MergedClass || (!bExactClass && CurrentClass->IsChildOf(MergedClass)))
					{
						AllowedClasses.Add(CurrentClass);
						break;
					}
					if (!bExactClass && MergedClass->IsChildOf(CurrentClass))
					{
						AllowedClasses.Add(MergedClass);
						break;
					}
				}

}

```


ï»¿# ExcludeBaseStruct

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ä½¿ç”¨BaseStructçš„FInstancedStructå±æ€§ä¸Šå¿½ç•¥BaseStructæŒ‡å‘çš„ç»“æ„åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FInstancedStruct
- **å…³è”é¡¹ï¼š** [BaseStruct](BaseStruct/BaseStruct.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨ä½¿ç”¨BaseStructçš„FInstancedStructå±æ€§ä¸Šå¿½ç•¥BaseStructæŒ‡å‘çš„ç»“æ„åŸºç±»ã€‚


ï»¿# GetAllowedClasses

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»æˆ–å¯¹è±¡é€‰æ‹©å™¨ä¸Šï¼Œé€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šé€‰æ‹©çš„å¯¹è±¡å¿…é¡»å±äºæŸä¸€äº›ç±»å‹åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒUClass*ï¼ŒUObject*ï¼ŒFSoftObjectPath
Code: TArray<UClass*> FuncName() const;
- **å…³è”é¡¹ï¼š** [AllowedClasses](../AllowedClasses/AllowedClasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

AllowedClassæ˜¯ç”¨ç›´æ¥æŒ‡å®šç±»åå­—å­—ç¬¦ä¸²çš„æ–¹å¼æ¥é™å®šåŸºç±»ã€‚è€ŒGetAllowedClasseså°±æ›´è¿‘ä¸€æ­¥ï¼Œå…è®¸é€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥è¿”å›ç­›é€‰çš„åŸºç±»ã€‚åŠ¨æ€å’Œè‡ªå®šä¹‰çš„çµæ´»æ€§å°±æ›´é«˜äº†ã€‚

å½“ç„¶GetAllowedClassesä¸å¦‚AllowedClassæ”¯æŒé‚£ä¹ˆå¤šå±æ€§ç±»å‹ï¼Œåªæ”¯æŒï¼šTSubClassOfï¼ŒUClass*ï¼ŒUObject*ï¼ŒFSoftObjectPath

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UFUNCTION()
	TArray<UClass*> MyGetAllowedClassesFunc()
	{
			TArray<UClass*> classes;
			classes.Add(UMyCommonObject::StaticClass());
			classes.Add(UTexture2D::StaticClass());
			classes.Add(UMyPrimaryDataAsset::StaticClass());
			
			return classes;
	}

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|TSubclassOf")
	TSubclassOf<UObject> MyClass_NoGetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|TSubclassOf", meta = (GetAllowedClasses = "MyGetAllowedClassesFunc"))
	TSubclassOf<UObject> MyClass_GetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|UClass*")
	UClass* MyClassPtr_NoGetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|UClass*", meta = (GetAllowedClasses = "MyGetAllowedClassesFunc"))
	UClass* MyClassPtr_GetAllowedClasses;
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|FSoftObjectPath")
	UObject* MyObject_NoGetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|FSoftObjectPath", meta = (GetAllowedClasses = "MyGetAllowedClassesFunc"))
	UObject* MyObject_GetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|FSoftObjectPath")
	FSoftObjectPath MySoftObject_NoGetAllowedClasses;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetAllowedClassesTest|FSoftObjectPath", meta = (GetAllowedClasses = "MyGetAllowedClassesFunc"))
	FSoftObjectPath MySoftObject_GetAllowedClasses;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§Classé€‰æ‹©å™¨æŠŠå¯é€‰èŒƒå›´é™å®šåˆ°äº†è®¾å®šçš„3ä¸ªåŸºç±»ä¸Šã€‚è€Œå¯¹è±¡é€‰æ‹©å™¨ä¹ŸæŠŠå¯¹è±¡é™å®šåˆ°äº†è¿™3ä¸ªåŸºç±»ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\GetAllowedClasses\GetAllowClasses.jpg](GetAllowClasses.jpg)

## åŸç†ï¼š

é€šè¿‡æºç å‘ç°ï¼Œå¯ä»¥åº”ç”¨çš„å±æ€§åªæœ‰SPropertyEditorClasså’ŒSPropertyEditorAssetï¼Œè€Œè¿™å…¶å®å¯¹åº”ç€Classç±»å‹ï¼ˆæ²¡æœ‰FSoftClassPathï¼‰å’Œå¯¹åº”UObjectçš„Assetç±»å‹ï¼ˆFSoftObjectPathå¯¹åº”SPropertyEditorAssetï¼‰

```cpp
void SPropertyEditorAsset::InitializeClassFilters(const FProperty* Property)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *MetadataProperty, AllowedClassFilters, DisallowedClassFilters, bExactClass, ObjectClass);
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}

TSharedRef<SWidget> SPropertyEditorEditInline::GenerateClassPicker()
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}

void PropertyEditorUtils::GetAllowedAndDisallowedClasses(const TArray<UObject*>& ObjectList, const FProperty& MetadataProperty, TArray<const UClass*>& AllowedClasses, TArray<const UClass*>& DisallowedClasses, bool bExactClass, const UClass* ObjectClass)
{
	AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("AllowedClasses"));
	DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("DisallowedClasses"));
	
	bool bMergeAllowedClasses = !AllowedClasses.IsEmpty();

	if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetAllowedClasses"))
	{
		const FString GetAllowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetAllowedClasses");
	}

	if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetDisallowedClasses"))
	{
		const FString GetDisallowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetDisallowedClasses");
		if (!GetDisallowedClassesFunctionName.IsEmpty())
		{
			for (UObject* Object : ObjectList)
			{
				const UFunction* GetDisallowedClassesFunction = Object ? Object->FindFunction(*GetDisallowedClassesFunctionName) : nullptr;
				if (GetDisallowedClassesFunction)
				{
					DECLARE_DELEGATE_RetVal(TArray<UClass*>, FGetDisallowedClasses);
					DisallowedClasses.Append(FGetDisallowedClasses::CreateUFunction(Object, GetDisallowedClassesFunction->GetFName()).Execute());
				}
			}
		}
	}
}
```


ï»¿# GetDisallowedClasses

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»é€‰æ‹©å™¨ä¸Šï¼Œé€šè¿‡ä¸€ä¸ªå‡½æ•°æ¥æŒ‡å®šé€‰æ‹©çš„ç±»å‹åˆ—è¡¨ä¸­æ’é™¤æ‰æŸä¸€äº›ç±»å‹åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒUClass*
Code: TArray<UClass*> FuncName() const;
- **å…³è”é¡¹ï¼š** [AllowedClasses](../AllowedClasses/AllowedClasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

å¤§ä½“å’ŒGetAllowedClassesç›¸åŒï¼Œåªæ˜¯ç›¸åçš„ä½œç”¨ã€‚

ä½†ä½œç”¨çš„å±æ€§ç±»å‹å’ŒDisallowedClassesç›¸ä¼¼ï¼Œåªèƒ½ä½œç”¨åœ¨ç±»é€‰æ‹©å™¨ä¸Šã€‚å› æ­¤ç»è¿‡æµ‹è¯•ä¸‹æ¥ï¼Œåªèƒ½ä½œç”¨åœ¨TSubClassOfï¼ŒUClass*ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION()
TArray<UClass*> MyGetDisallowedClassesFunc()
{
	TArray<UClass*> classes;
	classes.Add(UAbilityAsync::StaticClass());
	classes.Add(UTexture2D::StaticClass());
	return classes;
}
	
	
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetDisallowedClassesTest|TSubclassOf")
TSubclassOf<UObject> MyClass_NoGetDisallowedClasses;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetDisallowedClassesTest|TSubclassOf", meta = (GetDisallowedClasses = "MyGetDisallowedClassesFunc"))
TSubclassOf<UObject> MyClass_GetDisallowedClasses;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetDisallowedClassesTest|UClass*")
UClass* MyClassPtr_NoGetDisallowedClasses;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "GetDisallowedClassesTest|UClass*", meta = (GetDisallowedClasses = "MyGetDisallowedClassesFunc"))
UClass* MyClassPtr_GetDisallowedClasses;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°åŠ äº†GetDisallowedClassesä¹‹åï¼Œé€‰æ‹©åˆ—è¡¨ä¸Šå°‘äº†ä¸€äº›ç±»å‹ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\GetDisallowedClasses\GetDisallowedClasses.jpg](GetDisallowedClasses.jpg)

## åŸç†ï¼š

è™½ç„¶SPropertyEditorClasså’ŒSPropertyEditorAssetéƒ½ç”¨ä¸Šäº†GetAllowedAndDisallowedClassesï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨GetDisallowedClassesã€‚ä½†æ˜¯SPropertyEditorAssetåé¢æ˜¯ç”¨çš„SAssetPickerï¼Œå®ƒé‡Œé¢ä¸ä¼šç”¨DisallowedClassesï¼Œå› æ­¤å®é™…ä¸ŠSPropertyEditorAssetæ˜¯ä¸æ”¯æŒGetDisallowedClassesçš„ï¼Œå› æ­¤UObject*ç±»å‹çš„å±æ€§ä¸æ”¯æŒGetDisallowedClassesã€‚

```cpp
void SPropertyEditorAsset::InitializeClassFilters(const FProperty* Property)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *MetadataProperty, AllowedClassFilters, DisallowedClassFilters, bExactClass, ObjectClass);
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}

TSharedRef<SWidget> SPropertyEditorEditInline::GenerateClassPicker()
{
		PropertyEditorUtils::GetAllowedAndDisallowedClasses(ObjectList, *Property, AllowedClassFilters, DisallowedClassFilters, false);
}

void PropertyEditorUtils::GetAllowedAndDisallowedClasses(const TArray<UObject*>& ObjectList, const FProperty& MetadataProperty, TArray<const UClass*>& AllowedClasses, TArray<const UClass*>& DisallowedClasses, bool bExactClass, const UClass* ObjectClass)
{
	AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("AllowedClasses"));
	DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(MetadataProperty.GetOwnerProperty()->GetMetaData("DisallowedClasses"));
	
	bool bMergeAllowedClasses = !AllowedClasses.IsEmpty();

	if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetAllowedClasses"))
	{
		const FString GetAllowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetAllowedClasses");
	}

	if (MetadataProperty.GetOwnerProperty()->HasMetaData("GetDisallowedClasses"))
	{
		const FString GetDisallowedClassesFunctionName = MetadataProperty.GetOwnerProperty()->GetMetaData("GetDisallowedClasses");
		if (!GetDisallowedClassesFunctionName.IsEmpty())
		{
			for (UObject* Object : ObjectList)
			{
				const UFunction* GetDisallowedClassesFunction = Object ? Object->FindFunction(*GetDisallowedClassesFunctionName) : nullptr;
				if (GetDisallowedClassesFunction)
				{
					DECLARE_DELEGATE_RetVal(TArray<UClass*>, FGetDisallowedClasses);
					DisallowedClasses.Append(FGetDisallowedClasses::CreateUFunction(Object, GetDisallowedClassesFunction->GetFName()).Execute());
				}
			}
		}
	}
}
```


ï»¿# HideViewOptions

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œéšè—åœ¨ç±»é€‰å–å™¨ä¸­ä¿®æ”¹æ˜¾ç¤ºé€‰é¡¹çš„åŠŸèƒ½ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒFSoftClassPathï¼ŒUClass*ï¼ŒUScriptStruct*ï¼ŒFInstancedStruct 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œéšè—åœ¨ç±»é€‰å–å™¨ä¸­ä¿®æ”¹æ˜¾ç¤ºé€‰é¡¹çš„åŠŸèƒ½ã€‚

åº”ç”¨çš„å±æ€§ç±»å‹æœ‰TSubClassOfï¼ŒFSoftClassPathï¼ŒUClass*ï¼ŒUScriptStruct*ï¼ŒFInstancedStruct è¿™ç§ç”¨äºé€‰æ‹©ç±»å‹çš„å±æ€§ã€‚å¦‚æœæ˜¯TSoftObjectPtræˆ–è€…FSoftObjectPathè¿™ç§ç”¨äºé€‰æ‹©å¯¹è±¡çš„åˆ™ä¸èµ·ä½œç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|TSubclassOf")
	TSubclassOf<UObject> MyClass_NotHideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|TSubclassOf", meta = (HideViewOptions))
	TSubclassOf<UObject> MyClass_HideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|UClass*")
	UClass* MyClassPtr_NotHideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|UClass*", meta = (HideViewOptions))
	UClass* MyClassPtr_HideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|FSoftClassPath")
	FSoftClassPath MySoftClass_NotHideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|FSoftClassPath", meta = (HideViewOptions))
	FSoftClassPath MySoftClass_HideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|UScriptStruct*")
	UScriptStruct* MyStructPtr_NotHideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|UScriptStruct*", meta = (HideViewOptions))
	UScriptStruct* MyStructPtr_HideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|FInstancedStruct")
	FInstancedStruct MyInstancedStruct_NotHideViewOptions;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HideViewOptionsTest|FInstancedStruct", meta = (HideViewOptions))
	FInstancedStruct MyInstancedStruct_HideViewOptions;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§å¦‚æœæ²¡æœ‰HideViewOptionsï¼Œåˆ™åœ¨å¼¹å‡ºæ¡†çš„è§’è½æœ‰ä¸ªé½¿è½®æˆ–è€…çœ¼ç›ç”¨äºä¿®æ”¹æ˜¾ç¤ºé€‰é¡¹ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\HideViewOptions\HideViewOptions.jpg](HideViewOptions.jpg)

## åŸç†ï¼š

åœ¨æºç ä¸­å¯¹äºTSubClassOfå’ŒUClass*æœ‰SPropertyEditorClassï¼Œå¯¹äºFSoftClassPathæœ‰FSoftClassPathCustomizationï¼Œå¯¹äºUScriptStruct*æœ‰SPropertyEditorStructï¼Œå¯¹äºFInstancedStruct æœ‰FInstancedStructDetailsæ¥è¿›è¡ŒUIå®šåˆ¶åŒ–ã€‚

```cpp
void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		const bool bShowTreeView = PropertyHandle->HasMetaData("ShowTreeView");
		const bool bHideViewOptions = PropertyHandle->HasMetaData("HideViewOptions");
		
	SNew(SClassPropertyEntryBox)
		.ShowTreeView(bShowTreeView)
		.HideViewOptions(bHideViewOptions)
		.ShowDisplayNames(bShowDisplayNames)
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}
void SPropertyEditorStruct::Construct(const FArguments& InArgs, const TSharedPtr< class FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}
TSharedRef<SWidget> FInstancedStructDetails::GenerateStructPicker()
{
		const bool bExcludeBaseStruct = StructProperty->HasMetaData(NAME_ExcludeBaseStruct);
		const bool bAllowNone = !(StructProperty->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
		const bool bHideViewOptions = StructProperty->HasMetaData(NAME_HideViewOptions);
		const bool bShowTreeView = StructProperty->HasMetaData(NAME_ShowTreeView);
}
```


ï»¿# MetaClass

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨è½¯å¼•ç”¨å±æ€§ä¸Šï¼Œé™å®šè¦é€‰æ‹©çš„å¯¹è±¡çš„åŸºç±»
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FSoftClassPathï¼ŒFSoftObjectPath
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨åœ¨è½¯å¼•ç”¨å±æ€§ä¸Šï¼Œé™å®šè¦é€‰æ‹©çš„èµ„æºçš„åŸºç±»ã€‚

è½¯å¼•ç”¨å±æ€§æŒ‡çš„æ˜¯FSoftClassPathå’ŒFSoftObjectPathï¼Œè¿™ç±»å±æ€§æœ¬èº«å¹¶æ²¡æœ‰åƒTSubClassOfä¸€æ ·æœ¬èº«çš„ç±»å‹é™åˆ¶ï¼Œå› æ­¤å¯ä»¥é¢å¤–çš„åŠ MetaClassæ¥é™åˆ¶è¦é€‰æ‹©çš„å¯¹è±¡çš„æ‰€å±äºçš„åŸºç±»ã€‚

MetaClassé‡Œçš„å€¼ä¹Ÿå¯ä»¥æ˜¯"/Script/Engine.Actorâ€è¿™ç§ObjectPathã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|TSubclassOf")
TSubclassOf<UObject> MyClass_NotMetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|TSubclassOf", meta = (MetaClass = "MyCommonObject"))
TSubclassOf<UObject> MyClass_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftClassPath")
FSoftClassPath MySoftClass_NotMetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftClassPath", meta = (MetaClass = "MyCommonObject"))
FSoftClassPath MySoftClass_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftClassPath", meta = (MetaClass = "MyCommonObject"))
TSoftClassPtr<UObject> MySoftClassPtrT_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|UClass*")
UClass* MyClassPtr_NotMetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|UClass*", meta = (MetaClass = "MyCommonObject"))
UClass* MyClassPtr_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftObjectPath")
FSoftObjectPath MySoftObject_NotMetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftObjectPath", meta = (MetaClass = "MyCustomAsset"))
FSoftObjectPath MySoftObject_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|FSoftObjectPath", meta = (MetaClass = "MyCustomAsset"))
TSoftObjectPtr<UObject> MySoftObjectPtrT_MetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|UScriptStruct*")
UScriptStruct* MyStructPtr_NotMetaClass;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaClassTest|UScriptStruct*", meta = (MetaClass="MyCommonStruct"))
UScriptStruct* MyStructPtr_MetaClass;
```

## æµ‹è¯•æ•ˆæœï¼š

æµ‹è¯•æ•ˆæœï¼Œåªæœ‰MySoftClass_MetaClasså’ŒMySoftObject_MetaClassçš„é€‰æ‹©åˆ—è¡¨é‡Œè¿›è¡Œäº†ç­›é€‰ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\MetaClass\MetaClass.jpg](MetaClass.jpg)

## åŸç†ï¼š

åœ¨æºç é‡Œæœç´¢ï¼Œå‘ç°FSoftClassPathå’ŒFSoftObjectPathéƒ½æœ‰è¿›è¡Œç±»å‹å®šåˆ¶åŒ–ï¼Œæ ¹æ®MetaClassåˆ†åˆ«è®¾å®šåˆ°SClassPropertyEntryBoxå’ŒSObjectPropertyEntryBoxçš„MetaClasså’ŒAllowedClassä¸Šã€‚

å‘ç°TSoftObjectPtrå’ŒTSoftClassPtrå¹¶æ²¡æœ‰è¿›è¡Œå®šåˆ¶åŒ–ï¼Œå› æ­¤æ²¡æœ‰æ”¯æŒè¯¥åŠŸèƒ½ã€‚UScriptStruct*æœ¬èº«ä¹Ÿä¸æ”¯æŒè¯¥åŠŸèƒ½ï¼Œè™½ç„¶ä¹Ÿæ˜¯é€‰æ‹©ç±»å‹ã€‚

```cpp
void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	const FString& MetaClassName = PropertyHandle->GetMetaData("MetaClass");
	const FString& RequiredInterfaceName = PropertyHandle->GetMetaData("RequiredInterface"); // This was the old name, switch to MustImplement to synchronize with class property
	const FString& MustImplementName = PropertyHandle->GetMetaData("MustImplement");
	TArray<const UClass*> AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("AllowedClasses"));
	TArray<const UClass*> DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("DisallowedClasses"));
	const bool bAllowAbstract = PropertyHandle->HasMetaData("AllowAbstract");
	const bool bIsBlueprintBaseOnly = PropertyHandle->HasMetaData("IsBlueprintBaseOnly") || PropertyHandle->HasMetaData("BlueprintBaseOnly");
	const bool bAllowNone = !(PropertyHandle->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
	const bool bShowTreeView = PropertyHandle->HasMetaData("ShowTreeView");
	const bool bHideViewOptions = PropertyHandle->HasMetaData("HideViewOptions");
	const bool bShowDisplayNames = PropertyHandle->HasMetaData("ShowDisplayNames");

	const UClass* const MetaClass = !MetaClassName.IsEmpty()
	? FEditorClassUtils::GetClassFromString(MetaClassName)
	: UObject::StaticClass();
	
	SNew(SClassPropertyEntryBox)
	.MetaClass(MetaClass)
	
	}
	
void FSoftObjectPathCustomization::CustomizeHeader( TSharedRef<IPropertyHandle> InStructPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils )
{
	const FString& MetaClassName = InStructPropertyHandle->GetMetaData("MetaClass");
	UClass* MetaClass = !MetaClassName.IsEmpty()
		? FEditorClassUtils::GetClassFromString(MetaClassName)
		: UObject::StaticClass();
	TSharedRef<SObjectPropertyEntryBox> ObjectPropertyEntryBox = SNew(SObjectPropertyEntryBox)
		.AllowedClass(MetaClass)
		.PropertyHandle(InStructPropertyHandle)
		.ThumbnailPool(StructCustomizationUtils.GetThumbnailPool());
}
```


ï»¿# MetaStruct

- **åŠŸèƒ½æè¿°ï¼š** è®¾å®šåˆ°UScriptStruct*å±æ€§ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„ç±»å‹çš„çˆ¶ç»“æ„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UScriptStruct*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è®¾å®šåˆ°UScriptStruct*å±æ€§ä¸Šï¼ŒæŒ‡å®šé€‰æ‹©çš„ç±»å‹çš„çˆ¶ç»“æ„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaStructTest|UScriptStruct*", meta = ())
	UScriptStruct* MyStructPtr_NoMetaStruct;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MetaStructTest|UScriptStruct*", meta = (MetaStruct = "MyCommonStruct"))
	UScriptStruct* MyStructPtr_MetaStruct;
```

## æµ‹è¯•ç»“æœï¼š

æ‹¥æœ‰MetaStruct çš„å¯ä»¥æŠŠç±»å‹åˆ—è¡¨ç­›é€‰åˆ°MyCommonStructçš„å­ç±»ä¸Šã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\MetaStruct\MetaStruct.jpg](MetaStruct.jpg)

## åŸç†ï¼š

æ‰¾åˆ°MetaStructåè®¾ç½®åˆ°StructFilterä¸Šçš„MetaStruct ï¼Œæœ€åè¿›è¡Œç­›é€‰ã€‚å®šä¹‰äº†é€‰æ‹©ç»“æ„çš„åŸºç±»ã€‚

```cpp
void SPropertyEditorStruct::Construct(const FArguments& InArgs, const TSharedPtr< class FPropertyEditor >& InPropertyEditor)
{
		const FString& MetaStructName = Property->GetOwnerProperty()->GetMetaData(TEXT("MetaStruct"));
		if (!MetaStructName.IsEmpty())
		{
						MetaStruct = UClass::TryFindTypeSlow<UScriptStruct>(MetaStructName, EFindFirstObjectOptions::EnsureIfAmbiguous);
						if (!MetaStruct)
						{
							MetaStruct = LoadObject<UScriptStruct>(nullptr, *MetaStructName);
						}
		}
}

virtual bool FPropertyEditorStructFilter::IsStructAllowed(const FStructViewerInitializationOptions& InInitOptions, const UScriptStruct* InStruct, TSharedRef<FStructViewerFilterFuncs> InFilterFuncs) override
{
	if (InStruct->IsA<UUserDefinedStruct>())
	{
		// User Defined Structs don't support inheritance, so only include them if we have don't a MetaStruct set
		return MetaStruct == nullptr;
	}

	// Query the native struct to see if it has the correct parent type (if any)
	return !MetaStruct || InStruct->IsChildOf(MetaStruct);
}
```


ï»¿# MustImplement

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šTSubClassOfæˆ–FSoftClassPathå±æ€§é€‰æ‹©çš„ç±»å¿…é¡»å®ç°è¯¥æ¥å£
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOf, FSoftClassPathï¼ŒUClass*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šTSubClassOfæˆ–FSoftClassPathå±æ€§é€‰æ‹©çš„ç±»å¿…é¡»å®ç°è¯¥æ¥å£ã€‚

- TSubClassOfï¼ŒFSoftClassPathï¼Œè¿˜æœ‰åŸå§‹çš„UClass*å±æ€§éƒ½å¯ä»¥ç”¨æ¥æ‰¾åˆ°ä¸€ä¸ªUClass*ï¼ŒåŒºåˆ«æ˜¯UClass*æ˜¯ç¡¬å¼•ç”¨åˆ°ä¸€ä¸ªå…·ä½“çš„ç±»å¯¹è±¡ï¼Œè€ŒFSoftClassPathæ˜¯è½¯å¼•ç”¨åˆ°ç±»å¯¹è±¡çš„è·¯å¾„ï¼Œä¸è¿‡è¿™äºŒè€…éƒ½æ˜¯æ³›æ³›çš„UClass*ï¼Œå¹¶æ²¡æœ‰å¯¹å­ç±»å‹è¿›è¡Œçº¦æŸã€‚è€ŒTSubClassOf<T>è™½ç„¶ä¹Ÿæ˜¯ç¡¬å¼•ç”¨ç±»å¯¹è±¡ï¼Œä½†æ˜¯è¿›ä¸€æ­¥æŠŠç±»å‹çš„é€‰æ‹©èŒƒå›´é™åˆ¶åˆ°äº†Tçš„å­ç±»ä¸Šï¼Œåœ¨å¾ˆå¤šæ—¶å€™ä¼šæ›´åŠ çš„ä¾¿åˆ©ï¼Œç‰¹åˆ«æ˜¯ä½ å·²ç»çŸ¥é“ä½ çš„å­ç±»èŒƒå›´ã€‚æ¯”å¦‚TSubClassOf<AActor>æˆ–TSubClassOf<UUserWidget>ã€‚
- åœ¨è¿™ç§ç”¨äºé€‰æ‹©Classçš„å±æ€§ä¸Šï¼Œå¦‚æœä¸è¿›è¡Œé™åˆ¶åˆ™ä¼šæŠŠå¼•æ“é‡Œçš„æ‰€æœ‰ç±»éƒ½æ‰¾å‡ºæ¥è®©ä½ é€‰æ‹©ï¼Œä¸æ˜¯é‚£ä¹ˆä¾¿åˆ©ã€‚
- å› æ­¤å¼•æ“é‡Œå¢åŠ äº†ä¸€äº›è¿›ä¸€æ­¥ç­›é€‰çš„æœºåˆ¶ã€‚MustImplementå°±æ˜¯ç”¨äºç­›é€‰æŒ‡å®šclasså±æ€§å¿…é¡»å®ç°æŸä¸ªæ¥å£ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyCommonInterfaceChild :public UObject, public IMyCommonInterface
{
	GENERATED_BODY()
};

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|TSubclassOf")
TSubclassOf<UObject> MyClass_NoMustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|TSubclassOf", meta = (MustImplement = "MyCommonInterface"))
TSubclassOf<UObject> MyClass_MustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|TSubclassOf", meta = (MustImplement = "/Script/UMG.UserListEntry"))
TSubclassOf<UUserWidget> MyWidgetClass_MustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|FSoftClassPath")
FSoftClassPath MySoftClass_NoMustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|FSoftClassPath", meta = (MustImplement = "MyCommonInterface"))
FSoftClassPath MySoftClass_MustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|FSoftClassPath", meta = (MustImplement = "/Script/UMG.UserListEntry"))
FSoftClassPath MySoftWidgetClass_MustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|UClass*")
UClass* MyClassStar_NoMustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|UClass*", meta = (MustImplement = "MyCommonInterface"))
UClass* MyClassStar_MustImplement;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MustImplementTest|UClass*", meta = (MustImplement = "/Script/UMG.UserListEntry"))
UClass* MyWidgetClassStar_MustImplement;
	
UFUNCTION(BlueprintCallable, meta=(Category="MustImplementTest|TSubclassOf"))
static void SetMyClassMustImplement(UPARAM(meta=(MustImplement="MyCommonInterface")) TSubclassOf<UObject> MNyClass){}
```

## æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°ç¬¬ä¸€ä¸ªæ²¡æœ‰ç­›é€‰çš„ç»“æœï¼Œç¬¬äºŒå’Œç¬¬ä¸‰ä¸ªæœ‰äº†ç­›é€‰åçš„ç»“æœã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\MustImplement\MustImplement.png](MustImplement.png)

ä¹Ÿå¯ä»¥æ”¾åœ¨åœ¨å‡½æ•°é‡Œä½œä¸ºå‚æ•°ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\MustImplement\Untitled.png)

## åŸç†ï¼š

åœ¨FPropertyHandleBaseç”Ÿæˆå¯èƒ½å€¼çš„æ—¶å€™ï¼Œå¯ä»¥çœ‹åˆ°åšäº†ä¸€ç³»åˆ—çš„ç­›é€‰ã€‚

```cpp

void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	PropertyHandle = InPropertyHandle;

	const FString& MetaClassName = PropertyHandle->GetMetaData("MetaClass");
	const FString& RequiredInterfaceName = PropertyHandle->GetMetaData("RequiredInterface"); // This was the old name, switch to MustImplement to synchronize with class property
	const FString& MustImplementName = PropertyHandle->GetMetaData("MustImplement");
	TArray<const UClass*> AllowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("AllowedClasses"));
	TArray<const UClass*> DisallowedClasses = PropertyCustomizationHelpers::GetClassesFromMetadataString(PropertyHandle->GetMetaData("DisallowedClasses"));
	const bool bAllowAbstract = PropertyHandle->HasMetaData("AllowAbstract");
	const bool bIsBlueprintBaseOnly = PropertyHandle->HasMetaData("IsBlueprintBaseOnly") || PropertyHandle->HasMetaData("BlueprintBaseOnly");
	const bool bAllowNone = !(PropertyHandle->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
	const bool bShowTreeView = PropertyHandle->HasMetaData("ShowTreeView");
	const bool bHideViewOptions = PropertyHandle->HasMetaData("HideViewOptions");
	const bool bShowDisplayNames = PropertyHandle->HasMetaData("ShowDisplayNames");
	
	const UClass* const MetaClass = !MetaClassName.IsEmpty()
		? FEditorClassUtils::GetClassFromString(MetaClassName)
		: UObject::StaticClass();
	const UClass* const RequiredInterface = !RequiredInterfaceName.IsEmpty()
		? FEditorClassUtils::GetClassFromString(RequiredInterfaceName)
		: FEditorClassUtils::GetClassFromString(MustImplementName);
}

TSharedRef<SWidget> SGraphPinClass::GenerateAssetPicker()
{
		if (UEdGraphNode* ParentNode = GraphPinObj->GetOwningNode())
		{
			FString PossibleInterface = ParentNode->GetPinMetaData(GraphPinObj->PinName, TEXT("MustImplement"));
			if (!PossibleInterface.IsEmpty())
			{
				Filter->RequiredInterface = UClass::TryFindTypeSlow<UClass>(PossibleInterface);
			}
		}

}

bool FPropertyHandleBase::GeneratePossibleValues(TArray<FString>& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems, TArray<FText>* OutDisplayNames)
{
	 if( Property->IsA(FClassProperty::StaticClass()) || Property->IsA(FSoftClassProperty::StaticClass()) )		
	{
		UClass* MetaClass = Property->IsA(FClassProperty::StaticClass()) 
			? CastFieldChecked<FClassProperty>(Property)->MetaClass
			: CastFieldChecked<FSoftClassProperty>(Property)->MetaClass;

		FString NoneStr( TEXT("None") );
		OutOptionStrings.Add( NoneStr );
		if (OutDisplayNames)
		{
			OutDisplayNames->Add(FText::FromString(NoneStr));
		}

		const bool bAllowAbstract = Property->GetOwnerProperty()->HasMetaData(TEXT("AllowAbstract"));
		const bool bBlueprintBaseOnly = Property->GetOwnerProperty()->HasMetaData(TEXT("BlueprintBaseOnly"));
		const bool bAllowOnlyPlaceable = Property->GetOwnerProperty()->HasMetaData(TEXT("OnlyPlaceable"));
		UClass* InterfaceThatMustBeImplemented = Property->GetOwnerProperty()->GetClassMetaData(TEXT("MustImplement"));

		if (!bAllowOnlyPlaceable || MetaClass->IsChildOf<AActor>())
		{
			for (TObjectIterator<UClass> It; It; ++It)
			{
				if (It->IsChildOf(MetaClass)
					&& PropertyEditorHelpers::IsEditInlineClassAllowed(*It, bAllowAbstract)
					&& (!bBlueprintBaseOnly || FKismetEditorUtilities::CanCreateBlueprintOfClass(*It))
					&& (!InterfaceThatMustBeImplemented || It->ImplementsInterface(InterfaceThatMustBeImplemented))
					&& (!bAllowOnlyPlaceable || !It->HasAnyClassFlags(CLASS_Abstract | CLASS_NotPlaceable)))
				{
					OutOptionStrings.Add(It->GetName());
					if (OutDisplayNames)
					{
						OutDisplayNames->Add(FText::FromString(It->GetName()));
					}
				}
			}
		}
	}
}
```


ï»¿# OnlyPlaceable

- **åŠŸèƒ½æè¿°ï¼š** ç”¨åœ¨ç±»å±æ€§ä¸Šï¼ŒæŒ‡å®šæ˜¯å¦åªæ¥å—å¯è¢«æ”¾ç½®åˆ°åœºæ™¯é‡Œçš„Actor
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOf, FSoftClassPathï¼ŒUClass*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

å¯ä»¥æ’é™¤æ‰ä¸€äº›AInfoç­‰ä¸èƒ½æ”¾è¿›åœºæ™¯é‡Œçš„Actorç±»ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(Blueprintable,BlueprintType)
class INSIDER_API AMyActor :public AActor
{
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActorChild_Placeable :public AMyActor
{
	GENERATED_BODY()
};

UCLASS(Blueprintable, BlueprintType,NotPlaceable)
class INSIDER_API AMyActorChild_NotPlaceable :public AMyActor
{
	GENERATED_BODY()
};

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OnlyPlaceableTest")
	TSubclassOf<AMyActor> MyActor_NotOnlyPlaceable;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OnlyPlaceableTest", meta = (OnlyPlaceable))
	TSubclassOf<AMyActor> MyActor_OnlyPlaceable;
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§AMyActorChild_NotPlaceable ç±»å› ä¸ºåŠ äº†NotPlaceableæ ‡è®°ï¼Œå°±ä¸èƒ½è¢«MyActor_OnlyPlaceableå±æ€§é€‰æ‹©ä¸Šã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\OnlyPlaceable\OnlyPlaceable.jpg](OnlyPlaceable.jpg)

## åŸç†ï¼š

```cpp
bool FPropertyHandleBase::GeneratePossibleValues(TArray<FString>& OutOptionStrings, TArray< FText >& OutToolTips, TArray<bool>& OutRestrictedItems, TArray<FText>* OutDisplayNames)
{
	 if( Property->IsA(FClassProperty::StaticClass()) || Property->IsA(FSoftClassProperty::StaticClass()) )		
	{
		UClass* MetaClass = Property->IsA(FClassProperty::StaticClass()) 
			? CastFieldChecked<FClassProperty>(Property)->MetaClass
			: CastFieldChecked<FSoftClassProperty>(Property)->MetaClass;

		FString NoneStr( TEXT("None") );
		OutOptionStrings.Add( NoneStr );
		if (OutDisplayNames)
		{
			OutDisplayNames->Add(FText::FromString(NoneStr));
		}

		const bool bAllowAbstract = Property->GetOwnerProperty()->HasMetaData(TEXT("AllowAbstract"));
		const bool bBlueprintBaseOnly = Property->GetOwnerProperty()->HasMetaData(TEXT("BlueprintBaseOnly"));
		const bool bAllowOnlyPlaceable = Property->GetOwnerProperty()->HasMetaData(TEXT("OnlyPlaceable"));
		UClass* InterfaceThatMustBeImplemented = Property->GetOwnerProperty()->GetClassMetaData(TEXT("MustImplement"));

		if (!bAllowOnlyPlaceable || MetaClass->IsChildOf<AActor>())
		{
			for (TObjectIterator<UClass> It; It; ++It)
			{
				if (It->IsChildOf(MetaClass)
					&& PropertyEditorHelpers::IsEditInlineClassAllowed(*It, bAllowAbstract)
					&& (!bBlueprintBaseOnly || FKismetEditorUtilities::CanCreateBlueprintOfClass(*It))
					&& (!InterfaceThatMustBeImplemented || It->ImplementsInterface(InterfaceThatMustBeImplemented))
					&& (!bAllowOnlyPlaceable || !It->HasAnyClassFlags(CLASS_Abstract | CLASS_NotPlaceable)))
				{
					OutOptionStrings.Add(It->GetName());
					if (OutDisplayNames)
					{
						OutDisplayNames->Add(FText::FromString(It->GetName()));
					}
				}
			}
		}
	}
}
```


ï»¿# RowType

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFDataTableRowHandle å±æ€§çš„å¯é€‰è¡Œç±»å‹çš„åŸºç±»ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** FDataTableRowHandle
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šFDataTableRowHandle å±æ€§çš„å¯é€‰è¡Œç±»å‹çš„åŸºç±»ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMyCommonRow : public FTableRowBase
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FString MyString;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FVector MyVector;
};

UCLASS(BlueprintType)
class INSIDER_API UMyProperty_RowType :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "RowTypeTest")
	FDataTableRowHandle MyRowHandle;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "RowTypeTest", meta = (RowType = "/Script/Insider.MyCommonRow"))
	FDataTableRowHandle MyRowHandle_RowType;
};

```

## æµ‹è¯•ç»“æœï¼š

åœ¨ç¼–è¾‘å™¨ä¸­åˆ›å»ºåŸºäºFMyCommonRow çš„DataTableï¼Œå³DT_MyCommonRowã€‚å½“ç„¶é¡¹ç›®é‡Œä¹Ÿæœ‰åˆ«çš„RowStructçš„DataTableã€‚

å¯ä»¥è§åˆ°MyRowHandle_RowTypeçš„é€‰é¡¹è¢«é™å®šåˆ°äº†DT_MyCommonRowï¼Œè€Œä¸”RowNameä¹Ÿæ­£ç¡®çš„æ˜¾ç¤ºäº†å‡ºæ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\RowType\Untitled.png)

## åŸç†ï¼š

ä¹Ÿæ˜¯é’ˆå¯¹äºFDataTableRowHandleè¿™ä¸ªç±»å‹è¿›è¡ŒUIçš„å®šåˆ¶åŒ–ï¼Œå¦‚æœæœ‰è¯¥RowTypeæ•°æ®ï¼Œåˆ™èµ‹å€¼åˆ°RowFilterStruct ï¼Œä»è€Œå®Œæˆç­›é€‰ã€‚

```cpp
void FDataTableCustomizationLayout::CustomizeHeader(TSharedRef<class IPropertyHandle> InStructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		if (StructPropertyHandle->HasMetaData(TEXT("RowType")))
		{
			const FString& RowType = StructPropertyHandle->GetMetaData(TEXT("RowType"));
			RowTypeFilter = FName(*RowType);
			RowFilterStruct = UClass::TryFindTypeSlow<UScriptStruct>(RowType);
		}

}

bool FDataTableCustomizationLayout::ShouldFilterAsset(const struct FAssetData& AssetData)
{
	if (!RowTypeFilter.IsNone())
	{
		static const FName RowStructureTagName("RowStructure");
		FString RowStructure;
		if (AssetData.GetTagValue<FString>(RowStructureTagName, RowStructure))
		{
			if (RowStructure == RowTypeFilter.ToString())
			{
				return false;
			}

			// This is slow, but at the moment we don't have an alternative to the short struct name search
			UScriptStruct* RowStruct = UClass::TryFindTypeSlow<UScriptStruct>(RowStructure);
			if (RowStruct && RowFilterStruct && RowStruct->IsChildOf(RowFilterStruct))
			{
				return false;
			}
		}
		return true;
	}
	return false;
}

RegisterCustomPropertyTypeLayout("DataTableRowHandle", FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FDataTableCustomizationLayout::MakeInstance));

```


ï»¿# ShowDisplayNames

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Classå’ŒStructå±æ€§ä¸Šï¼ŒæŒ‡å®šç±»é€‰æ‹©å™¨æ˜¾ç¤ºå¦å¤–çš„æ˜¾ç¤ºåç§°è€Œä¸æ˜¯ç±»åŸå§‹çš„åå­—ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒFSoftClassPathï¼ŒUClass*ï¼ŒUScriptStruct*
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨Classå’ŒStructå±æ€§ä¸Šï¼ŒæŒ‡å®šç±»é€‰æ‹©å™¨æ˜¾ç¤ºå¦å¤–çš„æ˜¾ç¤ºåç§°è€Œä¸æ˜¯ç±»åŸå§‹çš„åå­—ã€‚

ç±»çš„æ˜¾ç¤ºåç§°æŒ‡çš„æ˜¯åŠ åœ¨UCLASSæˆ–USTUCTä¸Šçš„DisplayNameä¸Šçš„åå­—ï¼Œè¿™å¾€å¾€æ˜¯å¯¹ç”¨æˆ·æ›´å‹å¥½çš„åå­—ã€‚ç±»çš„åŸå§‹åå­—å°±æ˜¯ç±»çš„ç±»å‹åã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType, NotBlueprintable,DisplayName="This is MyCommonObjectChild")
class INSIDER_API UMyCommonObjectChild_HasDisplayName :public UMyCommonObject
{
	GENERATED_BODY()
public:
};

USTRUCT(BlueprintType,DisplayName="This is MyCommonStructChild")
struct INSIDER_API FMyCommonStructChild_HasDisplayName:public FMyCommonStruct
{
	GENERATED_BODY()
};

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|TSubclassOf", meta = ())
TSubclassOf<UMyCommonObjectChild_HasDisplayName> MyClass_NotShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|TSubclassOf", meta = (ShowDisplayNames))
TSubclassOf<UMyCommonObjectChild_HasDisplayName> MyClass_ShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|UClass*", meta = (AllowedClasses = "MyCommonObjectChild_HasDisplayName"))
UClass* MyClassPtr_NotShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|UClass*", meta = (AllowedClasses = "MyCommonObjectChild_HasDisplayName", ShowDisplayNames))
UClass* MyClassPtr_ShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|FSoftClassPath", meta = (MetaClass = "MyCommonObjectChild_HasDisplayName"))
FSoftClassPath MySoftClass_NotShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|FSoftClassPath", meta = (MetaClass = "MyCommonObjectChild_HasDisplayName", ShowDisplayNames))
FSoftClassPath MySoftClass_ShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|UScriptStruct*", meta = (MetaStruct = "MyCommonStructChild_HasDisplayName"))
UScriptStruct* MyStructPtr_NotShowDisplayNames;

UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowDisplayNamesTest|UScriptStruct*", meta = (MetaStruct = "MyCommonStructChild_HasDisplayName", ShowDisplayNames))
UScriptStruct* MyStructPtr_ShowDisplayNames;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§åŠ ä¸ŠShowDisplayNamesåï¼Œæ˜¾ç¤ºåœ¨åˆ—è¡¨é‡Œçš„æ˜¯â€œThis is XXXâ€çš„æ›´å‹å¥½çš„åå­—ï¼Œå¦åˆ™å°±æ˜¯ç›´æ¥çš„ç±»åã€‚

ä¸ºäº†è®©æ•ˆæœæ›´åŠ ç›´è§‚ï¼Œä¸Šé¢çš„æµ‹è¯•ä»£ç é‡Œä¹ŸåŠ ä¸Šäº†MetaClassï¼ŒMetaStructï¼ŒAllowedClasses ç”¨æ¥é™å®šé€‰æ‹©èŒƒå›´ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\ShowDisplayNames\ShowDisplayNames.jpg](ShowDisplayNames.jpg)

## åŸç†ï¼š

åœ¨æºç ä¸­å¯è§ï¼Œå¦‚æœæ‰“å¼€äº†bShowDisplayNames ï¼Œåˆ™æœ€åæ˜¾ç¤ºçš„æ˜¯(Class,Struct)â†’GetDisplayNameTextè€Œä¸æ˜¯(Class,Struct)â†’GetNameã€‚

å› ä¸ºFInstancedStructDetailsé‡Œå¹¶æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªMetaï¼Œå› æ­¤å¹¶ä¸æ”¯æŒè¯¥é€‰é¡¹ã€‚

```cpp
void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
	const bool bShowDisplayNames = PropertyHandle->HasMetaData("ShowDisplayNames");
	SNew(SClassPropertyEntryBox)
	.ShowDisplayNames(bShowDisplayNames)
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}
void SPropertyEditorStruct::Construct(const FArguments& InArgs, const TSharedPtr< class FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}

static FText GetClassDisplayName(const UObject* Object, bool bShowDisplayNames)
{
	const UClass* Class = Cast<UClass>(Object);
	if (Class != nullptr)
	{
		if (bShowDisplayNames)
		{
			return Class->GetDisplayNameText();
		}
		
		UBlueprint* BP = UBlueprint::GetBlueprintFromClass(Class);
		if(BP != nullptr)
		{
			return FText::FromString(BP->GetName());
		}
	}
	return (Object) ? FText::FromString(Object->GetName()) : LOCTEXT("InvalidObject", "None");
}

FText SPropertyEditorStruct::GetDisplayValue() const
{
		static bool bIsReentrant = false;
	
		auto GetStructDisplayName = [this](const UObject* InObject) -> FText
		{
			if (const UScriptStruct* Struct = Cast<UScriptStruct>(InObject))
			{
				return bShowDisplayNames
					? Struct->GetDisplayNameText()
					: FText::AsCultureInvariant(Struct->GetName());
			}
			return LOCTEXT("None", "None");
		};
	}
```


ï»¿# ShowTreeView

- **åŠŸèƒ½æè¿°ï¼š** ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œä½¿å¾—åœ¨ç±»é€‰å–å™¨ä¸­æ˜¾ç¤ºä¸ºæ ‘å½¢è€Œä¸æ˜¯åˆ—è¡¨ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** TSubClassOfï¼ŒFSoftClassPathï¼ŒUClass*ï¼ŒUScriptStruct*ï¼ŒFInstancedStruct 
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

ç”¨äºé€‰æ‹©Classæˆ–Structçš„å±æ€§ä¸Šï¼Œä½¿å¾—åœ¨ç±»é€‰å–å™¨ä¸­æ˜¾ç¤ºä¸ºæ ‘å½¢è€Œä¸æ˜¯åˆ—è¡¨ã€‚

åº”ç”¨çš„å±æ€§ç±»å‹æœ‰TSubClassOfï¼ŒFSoftClassPathï¼ŒUClass*ï¼ŒUScriptStruct*ï¼ŒFInstancedStruct è¿™ç§ç”¨äºé€‰æ‹©ç±»å‹çš„å±æ€§ã€‚å¦‚æœæ˜¯TSoftObjectPtræˆ–è€…FSoftObjectPathè¿™ç§ç”¨äºé€‰æ‹©å¯¹è±¡çš„åˆ™ä¸èµ·ä½œç”¨ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|TSubclassOf")
	TSubclassOf<UObject> MyClass_NotShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|TSubclassOf", meta = (ShowTreeView))
	TSubclassOf<UObject> MyClass_ShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|UClass*")
	UClass* MyClassPtr_NotShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|UClass*", meta = (ShowTreeView))
	UClass* MyClassPtr_ShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|FSoftClassPath")
	FSoftClassPath MySoftClass_NotShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|FSoftClassPath", meta = (ShowTreeView))
	FSoftClassPath MySoftClass_ShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|UScriptStruct*")
	UScriptStruct* MyStructPtr_NotShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|UScriptStruct*", meta = (ShowTreeView))
	UScriptStruct* MyStructPtr_ShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|FInstancedStruct")
	FInstancedStruct MyInstancedStruct_NotShowTreeView;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "ShowTreeViewTest|FInstancedStruct", meta = (ShowTreeView))
	FInstancedStruct MyInstancedStruct_ShowTreeView;
```

## æµ‹è¯•ç»“æœï¼š

å¯è§å¸¦æœ‰ShowTreeViewçš„å±æ€§ï¼Œåœ¨å¼¹å‡ºçš„é€‰æ‹©æ¡†ä¸Šæ˜¾ç¤ºçš„æ˜¯æ ‘å½¢è€Œä¸æ˜¯åˆ—è¡¨ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\TypePicker\ShowTreeView\ShowTreeView.jpg](ShowTreeView.jpg)

## åŸç†ï¼š

åœ¨æºç ä¸­å¯¹äºTSubClassOfå’ŒUClass*æœ‰SPropertyEditorClassï¼Œå¯¹äºFSoftClassPathæœ‰FSoftClassPathCustomizationï¼Œå¯¹äºUScriptStruct*æœ‰SPropertyEditorStructï¼Œå¯¹äºFInstancedStruct æœ‰FInstancedStructDetailsæ¥è¿›è¡ŒUIå®šåˆ¶åŒ–ã€‚

```cpp
void FSoftClassPathCustomization::CustomizeHeader(TSharedRef<IPropertyHandle> InPropertyHandle, FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		const bool bShowTreeView = PropertyHandle->HasMetaData("ShowTreeView");
		const bool bHideViewOptions = PropertyHandle->HasMetaData("HideViewOptions");
		
	SNew(SClassPropertyEntryBox)
		.ShowTreeView(bShowTreeView)
		.HideViewOptions(bHideViewOptions)
		.ShowDisplayNames(bShowDisplayNames)
}

void SPropertyEditorClass::Construct(const FArguments& InArgs, const TSharedPtr< FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}
void SPropertyEditorStruct::Construct(const FArguments& InArgs, const TSharedPtr< class FPropertyEditor >& InPropertyEditor)
{
		bShowViewOptions = Property->GetOwnerProperty()->HasMetaData(TEXT("HideViewOptions")) ? false : true;
		bShowTree = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowTreeView"));
		bShowDisplayNames = Property->GetOwnerProperty()->HasMetaData(TEXT("ShowDisplayNames"));
}
TSharedRef<SWidget> FInstancedStructDetails::GenerateStructPicker()
{
		const bool bExcludeBaseStruct = StructProperty->HasMetaData(NAME_ExcludeBaseStruct);
		const bool bAllowNone = !(StructProperty->GetMetaDataProperty()->PropertyFlags & CPF_NoClear);
		const bool bHideViewOptions = StructProperty->HasMetaData(NAME_HideViewOptions);
		const bool bShowTreeView = StructProperty->HasMetaData(NAME_ShowTreeView);
}
```


ï»¿# StructTypeConst

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šFInstancedStructå±æ€§çš„ç±»å‹ä¸èƒ½åœ¨ç¼–è¾‘å™¨è¢«é€‰æ‹©ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** FInstancedStruct
- **å…³è”é¡¹ï¼š** [BaseStruct](BaseStruct/BaseStruct.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šFInstancedStructå±æ€§çš„ç±»å‹ä¸èƒ½åœ¨ç¼–è¾‘å™¨è¢«é€‰æ‹©ã€‚

ç”¨å¤„å¾€å¾€æ˜¯åœ¨ä¹‹åäº¤ç»™ç”¨æˆ·åœ¨ä»£ç é‡Œåˆå§‹åŒ–ã€‚

## åŸç†ï¼š

å¦‚æœæœ‰è¯¥æ ‡è®°ï¼Œå°±ç¦ç”¨ç¼–è¾‘çš„æ§ä»¶ã€‚

```cpp
void FInstancedStructDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow& HeaderRow, IPropertyTypeCustomizationUtils& StructCustomizationUtils)
{
		static const FName NAME_StructTypeConst = "StructTypeConst";
		const bool bEnableStructSelection = !StructProperty->HasMetaData(NAME_StructTypeConst);
			
			
			.IsEnabled(bEnableStructSelection)

}
```


ï»¿# CppFromBpEvent

- **ä½¿ç”¨ä½ç½®ï¼š** Todo
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¿™æ˜¯ä¸ªåœ¨C++ä¸­å®šä¹‰çš„è“å›¾äº‹ä»¶ã€‚

æ—©æœŸçš„UHTä¼šä½¿ç”¨è¿™ä¸ªå…ƒæ•°æ®ï¼Œä¸è¿‡ç°åœ¨çš„å¼•æ“ç‰ˆæœ¬å·²ç»ä¸ç”¨è¿™ä¸ªäº†ã€‚

## åŸç†ä»£ç ï¼š

```cpp
public static class UhtFunctionParser
{
	private static UhtParseResult ParseUFunction(UhtParsingScope parentScope, UhtToken token)
	{
		if (function.MetaData.ContainsKey(UhtNames.CppFromBpEvent))
		{
						function.FunctionFlags |= EFunctionFlags.Event;
		}
	}
}
```


ï»¿# CustomThunk

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTä¸ä¸ºè¯¥å‡½æ•°ç”Ÿæˆè“å›¾è°ƒç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œè€Œéœ€è¦ç”¨æˆ·è‡ªå®šä¹‰ç¼–å†™ã€‚

- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION

- **å¼•æ“æ¨¡å—ï¼š** UHT

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

- **å…³è”é¡¹ï¼š** 

  UFUNCTIONï¼š[ServiceRequest](../../Specifier/UFUNCTION/Network/ServiceRequest.md), [CustomThunk](../../Specifier/UFUNCTION/UHT/CustomThunk/CustomThunk.md)

- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…


ï»¿# DocumentationPolicy

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ–‡æ¡£éªŒè¯çš„è§„åˆ™ï¼Œå½“å‰åªèƒ½è®¾ä¸ºStrict
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨UHTçš„ValidateDocumentationPolicyå‡½æ•°é‡Œï¼Œä¼šå‘ç°è¿™ä¸ªå€¼ä¸»è¦æ˜¯ç”¨æ¥åˆ¤æ–­ç±»å‹æˆ–å­—æ®µä¸Šæ˜¯å¦æœ‰æä¾›Commentæˆ–Tooltipï¼Œæˆ–è€…Floatå˜é‡æ˜¯å¦é…äº†å¯¹åº”çš„â€œUIMin / UIMaxâ€ï¼Œä»¥ä¾¿æå–å‡ºæ¥è¿™äº›ä¿¡æ¯ç”Ÿæˆå¯¹åº”çš„æ–‡æ¡£ã€‚

å½“å‰åªæœ‰ä¸€ä¸ªé…ç½®æ˜¯Strictï¼Œé‡Œé¢é»˜è®¤æ˜¯å¼€å¯äº†æ‰€æœ‰çš„æ£€æŸ¥ã€‚æ‰€æœ‰å¯ä»¥ç†è§£ä¸ºåœ¨C++æºç é‡Œé…ç½®ä¸ŠDocumentationPolicy=Strictï¼Œå°±æ„å‘³ç€æƒ³è¦å¼•æ“æ¥æ£€æŸ¥æ–‡æ¡£é…ç½®ã€‚

```cpp
_documentationPolicies["Strict"] = new()
{
	ClassOrStructCommentRequired = true,
	FunctionToolTipsRequired = true,
	MemberToolTipsRequired = true,
	ParameterToolTipsRequired = true,
	FloatRangesRequired = true,
};

protected override void ValidateDocumentationPolicy(UhtDocumentationPolicy policy)
	{
		if (policy.ClassOrStructCommentRequired)
		{
			string classTooltip = MetaData.GetValueOrDefault(UhtNames.ToolTip);
			if (classTooltip.Length == 0 || classTooltip.Equals(EngineName, StringComparison.OrdinalIgnoreCase))
			{
				this.LogError($"{EngineType.CapitalizedText()} '{SourceName}' does not provide a tooltip / comment (DocumentationPolicy).");
			}
		}
//ã€‚ã€‚ã€‚
}
```

## æºç ä¸­çš„ç±»ä¼¼ä¾‹å­ï¼š

```cpp
USTRUCT(meta=(DisplayName="Set Transform", Category="Transforms", TemplateName = "Set Transform", DocumentationPolicy = "Strict", Keywords="SetBoneTransform,SetControlTransform,SetInitialTransform,SetSpaceTransform", NodeColor="0, 0.364706, 1.0", Varying))
struct CONTROLRIG_API FRigUnit_SetTransform : public FRigUnitMutable
{
}
```

## è‡ªå·±çš„æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType, meta = (DocumentationPolicy=Strict))
class INSIDER_API UMyClass_DocumentationPolicy :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;

	//This is a float
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (UIMin = "0.0", UIMax = "100.0"))
	float MyFloat_WithValidate;

	
	UFUNCTION(meta = (DocumentationPolicy=Strict))
	void MyFunc(){}

	/**
	 *	Test Func for validate param
	 * 	@param keyOtherName The name of Key
	 *	@param keyValue
	 */
	UFUNCTION(BlueprintCallable, meta = (DocumentationPolicy=Strict))
		int MyFunc_ValidateParamFailed(FString keyName,int keyValue){return 0;}//å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ª@paramæ‰ä¼šå¼€å¯å‚æ•°æ³¨é‡Šçš„éªŒè¯

	/**
	 *	Test Func for validate param
	 *
	 *	@param keyName The name of key
	 *	@param keyValue The value of key
	 *	@return Return operation result
	 */
	UFUNCTION(meta = (DocumentationPolicy=Strict))
	int MyFunc_ValidateParam(FString keyName,int keyValue){return 0;}
};

USTRUCT(BlueprintType, meta = (DocumentationPolicy=Strict))
struct INSIDER_API FMyStruct_DocumentationPolicy 
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float MyFloat;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString MyString;
};

UENUM(BlueprintType, meta = (DocumentationPolicy=Strict))
enum class EMyEnum_DocumentationPolicy :uint8
{
	First,
	Second,
	Third,
};

// This a tooltip / comment
UCLASS(BlueprintType, meta = (DocumentationPolicy = Strict))
class INSIDER_API UMyClass_DocumentationPolicy_TypeA :public UObject
{
	GENERATED_BODY()
};

/**
*	This a tooltip / comment
*
*/
UCLASS(BlueprintType, meta = (DocumentationPolicy = Strict))
class INSIDER_API UMyClass_DocumentationPolicy_TypeB :public UObject
{
	GENERATED_BODY()
};

UCLASS(BlueprintType, meta = (DocumentationPolicy = Strict,ToolTip="This a tooltip"))	//Cannot use ShortToolTip
class INSIDER_API UMyClass_DocumentationPolicy_TypeC :public UObject
{
	GENERATED_BODY()
};
```

## äº§ç”Ÿçš„UHTç¼–è¯‘æŠ¥é”™ï¼š

```cpp
error : Class 'UMyClass_DocumentationPolicy' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'UMyClass_DocumentationPolicy::MyFloat' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'UMyClass_DocumentationPolicy::MyString' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'UMyClass_DocumentationPolicy::MyFloat' does not provide a valid UIMin / UIMax(DocumentationPolicy).
error : Function 'UMyClass_DocumentationPolicy::MyFunc' does not provide a tooltip / comment(DocumentationPolicy).
error : Function 'UMyClass_DocumentationPolicy::MyFunc' does not provide a comment(DocumentationPolicy).
error : Function 'UMyClass_DocumentationPolicy::MyFunc_ValidateParamFailed' doesn't provide a tooltip for parameter 'keyName' (DocumentationPolicy).
error : Function 'UMyClass_DocumentationPolicy::MyFunc_ValidateParamFailed' doesn't provide a tooltip for parameter 'keyValue' (DocumentationPolicy).
error : Function 'UMyClass_DocumentationPolicy::MyFunc_ValidateParamFailed' provides a tooltip for an unknown parameter 'keyOtherName'
error : Struct 'FMyStruct_DocumentationPolicy' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'FMyStruct_DocumentationPolicy::MyFloat' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'FMyStruct_DocumentationPolicy::MyString' does not provide a tooltip / comment(DocumentationPolicy).
error : Property 'FMyStruct_DocumentationPolicy::MyFloat' does not provide a valid UIMin / UIMax(DocumentationPolicy).
error : Enum 'EMyEnum_DocumentationPolicy' does not provide a tooltip / comment(DocumentationPolicy)
error : Enum entry 'EMyEnum_DocumentationPolicy::EMyEnum_DocumentationPolicy::First' does not provide a tooltip / comment(DocumentationPolicy)
error : Enum entry 'EMyEnum_DocumentationPolicy::EMyEnum_DocumentationPolicy::Second' does not provide a tooltip / comment(DocumentationPolicy)
error: Enum entry 'EMyEnum_DocumentationPolicy::EMyEnum_DocumentationPolicy::Third' does not provide a tooltip / comment(DocumentationPolicy)
```


ï»¿# FieldNotifyInterfaceParam

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå‡½æ•°çš„æŸä¸ªå‚æ•°æä¾›FieldNotifyçš„ViewModelä¿¡æ¯ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** FieldNotify
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** å‡½æ•°é‡Œæœ‰å…¶ä»–FFieldNotificationId å‚æ•°
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šå‡½æ•°çš„æŸä¸ªå‚æ•°æä¾›FieldNotifyçš„ViewModelä¿¡æ¯ã€‚

è¯¥å‚æ•°ä¸ºä¹‹åçš„FFieldNotificationIdå‚æ•°çš„æä¾›ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œè¿™æ ·FieldIdçš„é€‰é¡¹æ¡†æ‰çŸ¥é“æœ‰å“ªäº›å¯é€‰å€¼ã€‚

## æºç ä¾‹å­ï¼š

```cpp
	/** Broadcast that the Field value changed. */
	UFUNCTION(BlueprintCallable, Category = "FieldNotification", meta = (FieldNotifyInterfaceParam="Object", DisplayName = "Broadcast Field Value Changed"))
	static void BroadcastFieldValueChanged(UObject* Object, FFieldNotificationId FieldId);

```

## è“å›¾æ•ˆæœï¼š

åœ¨UserWidgeté‡Œæµ‹è¯•ï¼Œå¯è§æ²¡æœ‰è¿æ¥åˆ°å‚æ•°çš„Targeté»˜è®¤ä¸ºå½“å‰çš„UserWidgetï¼Œåˆ™FieldIdæ˜¯3ä¸ªå€¼ã€‚è€Œè¿æ¥åˆ°æˆ‘ä»¬è‡ªå®šä¹‰çš„ViewModelåï¼Œåˆ™æ”¹å˜ä¸ºæˆ‘ä»¬ä¸‹é¢å®šä¹‰çš„å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\UHT\FieldNotifyInterfaceParam\Untitled.png)

## åŸç†ï¼š

```cpp
TSharedRef<SWidget> SFieldNotificationGraphPin::GetDefaultValueWidget()
{
	UEdGraphPin* SelfPin = GraphPinObj->GetOwningNode()->FindPin(UEdGraphSchema_K2::PSC_Self);
	if (UK2Node_CallFunction* CallFunction = Cast<UK2Node_CallFunction>(GraphPinObj->GetOwningNode()))
	{
		if (UFunction* Function = CallFunction->GetTargetFunction())
		{
			const FString& PinName = Function->GetMetaData("FieldNotifyInterfaceParam");
			if (PinName.Len() != 0)
			{
				SelfPin = GraphPinObj->GetOwningNode()->FindPin(*PinName);
			}
		}
	}

	return SNew(SFieldNotificationPicker)
		.Value(this, &SFieldNotificationGraphPin::GetValue)
		.OnValueChanged(this, &SFieldNotificationGraphPin::SetValue)
		.FromClass_Static(Private::GetPinClass, SelfPin)
		.Visibility(this, &SGraphPin::GetDefaultValueVisibility);
}
```


ï»¿# IncludePath

- **åŠŸèƒ½æè¿°ï¼š** è®°å½•UClassçš„å¼•ç”¨è·¯å¾„
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UCLASSä¸Šçš„ä¿¡æ¯
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

è®°å½•UClassçš„å¼•ç”¨è·¯å¾„ã€‚

å¼€å‘è€…ä¸€èˆ¬ä¹Ÿä¸ç”¨ç®¡è¿™ä¸ªå€¼ã€‚

æœ‰ä¸€ä¸ªä½œç”¨æ˜¯åœ¨UHTç”Ÿæˆ.gen.cppçš„æ—¶å€™ï¼Œåœ¨å¤´æ–‡ä»¶éƒ¨åˆ†æ–¹ä¾¿å¼•ç”¨åˆ°è¯¥ç±»çš„å¤´æ–‡ä»¶ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Template :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	int32 MyFunc(FString str){return 0;}
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty = 123;
};
```

## å…¶ç±»å‹ä¿¡æ¯ï¼š

```cpp
[class MyProperty_Template	Class->Struct->Field->Object	/Script/Insider.MyProperty_Template]
(BlueprintType = true, IncludePath = Property/MyProperty_Template.h, ModuleRelativePath = Property/MyProperty_Template.h)
	ObjectFlags:	RF_Public | RF_Standalone | RF_Transient 
	Outer:	Package /Script/Insider
	ClassHierarchy:	MyProperty_Template:Object
	ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
	Size:	56
	Within:	Object
	ClassConfigName:	Engine
{
	(Category = MyProperty_Template, ModuleRelativePath = Property/MyProperty_Template.h)
	48-[4] int32 MyProperty;
		PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
		ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
		Outer:	Class /Script/Insider.MyProperty_Template
		Path:	IntProperty /Script/Insider.MyProperty_Template:MyProperty
	[func MyFunc	Function->Struct->Field->Object	/Script/Insider.MyProperty_Template:MyFunc]
	(ModuleRelativePath = Property/MyProperty_Template.h)
		ObjectFlags:	RF_Public | RF_Transient 
		Outer:	Class /Script/Insider.MyProperty_Template
		FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
		NumParms:	2
		ParmsSize:	20
		ReturnValueOffset:	16
		RPCId:	0
		RPCResponseId:	0
		public int32 MyFunc(FString str)final;
	{
		0-[16] FString str;
			PropertyFlags:	CPF_Parm | CPF_ZeroConstructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
			ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
			Outer:	Function /Script/Insider.MyProperty_Template:MyFunc
			Path:	StrProperty /Script/Insider.MyProperty_Template:MyFunc:str
		16-[4] int32 ReturnValue;
			PropertyFlags:	CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReturnParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
			ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
			Outer:	Function /Script/Insider.MyProperty_Template:MyFunc
			Path:	IntProperty /Script/Insider.MyProperty_Template:MyFunc:ReturnValue
	};
};
```

## åŸç†ï¼š

åŒæ ·ä¹Ÿæ˜¯åœ¨UHTä¸­åˆ†æåæ·»åŠ çš„ã€‚å…·ä½“çš„é€»è¾‘å€¼è¯·è§ModuleRelativePathä¸­çš„åŸç†ä»£ç éƒ¨åˆ†ã€‚

```cpp
protected override void UhtClass::ResolveSuper(UhtResolvePhase resolvePhase)
{
	switch (ClassType)
	{
				case UhtClassType.Class:
					{
							MetaData.Add(UhtNames.IncludePath, HeaderFile.IncludeFilePath);
					}
	}
}

```


ï»¿# ModuleRelativePath

- **åŠŸèƒ½æè¿°ï¼š** è®°å½•ç±»å‹å®šä¹‰çš„çš„å¤´æ–‡ä»¶è·¯å¾„ï¼Œä¸ºå…¶å¤„äºæ¨¡å—çš„å†…éƒ¨ç›¸å¯¹è·¯å¾„ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** Any
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

è®°å½•å½“å‰å…ƒç±»å‹å®šä¹‰çš„çš„å¤´æ–‡ä»¶è·¯å¾„ï¼Œä¸ºç›¸å¯¹æ¨¡å—çš„ç›¸å¯¹è·¯å¾„ã€‚

å¯¹äºå¼€å‘è€…æ¥è¯´ä¸€èˆ¬ä¸ç”¨ç®¡ï¼Œä½†æ˜¯å¼•æ“ç¼–è¾‘å™¨ä¼šç”¨å®ƒæ¥å®šä½æŸä¸ªç±»å‹æ˜¯åœ¨å“ªä¸ª.hé‡Œå®šä¹‰çš„ï¼Œä»è€Œåœ¨ä½ åŒå‡»ç±»å‹çš„æ—¶å€™ï¼Œå¯ä»¥ä¸ºä½ åœ¨VSé‡Œæ‰“å¼€ç›¸åº”çš„å¤´æ–‡ä»¶ã€‚å…·ä½“çš„é€»è¾‘å¯ä»¥å»FSourceCodeNavigationé‡ŒæŸ¥çœ‹ã€‚

å’ŒIncludePathçš„åŒºåˆ«æ˜¯ï¼ŒModuleRelativePath åœ¨å„ç§ç±»å‹ä¿¡æ¯ä¸Šéƒ½æœ‰ï¼Œè€ŒIncludePathåªç”¨äºUCLASSä¸Šã€‚å¦å¤–ModuleRelativePath çš„å€¼å¯ä»¥åŒ…å«â€œClasses/Public/Internal/Privateâ€è¿™4ä¸ªä»¥å¼€å¤´ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¹Ÿç¡®å®ä¼šå»ºè®®æŠŠ.h.cppåˆ’åˆ†åˆ°è¿™4ä¸ªæ–‡ä»¶å¤¹é‡Œã€‚è€ŒIncludeFilePath çš„å€¼å°±ä¼šå»æ‰è¿™ä¸ªå¤´ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_Template :public UObject
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
	int32 MyFunc(FString str){return 0;}
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty = 123;
};
```

## å…¶å…ƒç±»å‹ä¿¡æ¯æ‰“å°ï¼š

å¯ä»¥å‘ç°ModuleRelativePath åœ¨ç±»ï¼Œå±æ€§å’Œå‡½æ•°ä¸Šéƒ½æœ‰è¯¥ä¿¡æ¯ã€‚

è€ŒIncludePathåªæœ‰åœ¨UCLASSä¸Šæ‰æœ‰ã€‚

```cpp
[class MyProperty_Template	Class->Struct->Field->Object	/Script/Insider.MyProperty_Template]
(BlueprintType = true, IncludePath = Property/MyProperty_Template.h, ModuleRelativePath = Property/MyProperty_Template.h)
	ObjectFlags:	RF_Public | RF_Standalone | RF_Transient 
	Outer:	Package /Script/Insider
	ClassHierarchy:	MyProperty_Template:Object
	ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
	Size:	56
	Within:	Object
	ClassConfigName:	Engine
{
	(Category = MyProperty_Template, ModuleRelativePath = Property/MyProperty_Template.h)
	48-[4] int32 MyProperty;
		PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
		ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
		Outer:	Class /Script/Insider.MyProperty_Template
		Path:	IntProperty /Script/Insider.MyProperty_Template:MyProperty
	[func MyFunc	Function->Struct->Field->Object	/Script/Insider.MyProperty_Template:MyFunc]
	(ModuleRelativePath = Property/MyProperty_Template.h)
		ObjectFlags:	RF_Public | RF_Transient 
		Outer:	Class /Script/Insider.MyProperty_Template
		FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
		NumParms:	2
		ParmsSize:	20
		ReturnValueOffset:	16
		RPCId:	0
		RPCResponseId:	0
		public int32 MyFunc(FString str)final;
	{
		0-[16] FString str;
			PropertyFlags:	CPF_Parm | CPF_ZeroConstructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
			ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
			Outer:	Function /Script/Insider.MyProperty_Template:MyFunc
			Path:	StrProperty /Script/Insider.MyProperty_Template:MyFunc:str
		16-[4] int32 ReturnValue;
			PropertyFlags:	CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReturnParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
			ObjectFlags:	RF_Public | RF_MarkAsNative | RF_Transient 
			Outer:	Function /Script/Insider.MyProperty_Template:MyFunc
			Path:	IntProperty /Script/Insider.MyProperty_Template:MyFunc:ReturnValue
	};
};

```

## åŸç†ï¼š

åœ¨UHTåˆ†æçš„æ—¶å€™ï¼Œè‡ªåŠ¨çš„ä¸ºç±»å‹åŠ ä¸Šå¤´æ–‡ä»¶çš„è·¯å¾„ä¿¡æ¯ã€‚

ä»æºç é€»è¾‘å¯ä»¥çœ‹å‡ºï¼ŒModuleRelativePath çš„å€¼å¯ä»¥åŒ…å«â€œClasses/Public/Internal/Privateâ€è¿™4ä¸ªä»¥å¼€å¤´ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¹Ÿç¡®å®ä¼šå»ºè®®æŠŠ.h.cppåˆ’åˆ†åˆ°è¿™4ä¸ªæ–‡ä»¶å¤¹é‡Œã€‚è€ŒIncludeFilePath çš„å€¼å°±ä¼šå»æ‰è¿™ä¸ªå¤´ã€‚

```cpp

public enum UhtHeaderFileType
{

	/// <summary>
	/// Classes folder
	/// </summary>
	Classes,

	/// <summary>
	/// Public folder
	/// </summary>
	Public,

	/// <summary>
	/// Internal folder
	/// </summary>
	Internal,

	/// <summary>
	/// Private folder
	/// </summary>
	Private,
}

public static void AddModuleRelativePathToMetaData(UhtMetaData metaData, UhtHeaderFile headerFile)
{
	metaData.Add(UhtNames.ModuleRelativePath, headerFile.ModuleRelativeFilePath);
}

//åˆ†ææ–‡ä»¶è·¯å¾„
private void StepPrepareHeaders(UhtPackage package, IEnumerable<string> headerFiles, UhtHeaderFileType headerFileType)
{
	string typeDirectory = headerFileType.ToString() + '/';
	
	headerFile.ModuleRelativeFilePath = normalizedFullFilePath[stripLength..];
	if (normalizedFullFilePath[stripLength..].StartsWith(typeDirectory, true, null))
	{
					stripLength += typeDirectory.Length;
	}
	headerFile.IncludeFilePath = normalizedFullFilePath[stripLength..];
}	

```


ï»¿# NativeConstTemplateArg

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªconstçš„æ¨¡æ¿å‚æ•°ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªconstçš„æ¨¡æ¿å‚æ•°ã€‚

åœ¨æºç é‡Œå¹¶æ²¡æœ‰æ‰¾åˆ°ä½¿ç”¨çš„åœ°æ–¹ã€‚åªæœ‰åœ¨UHTä¸­ç”¨åˆ°ã€‚

åœ¨UHTä¸­æŸ¥çœ‹ä¸»è¦æ˜¯UhtArrayPropertyå’ŒUhtObjectPropertyBaseï¼ŒUhtOptionalPropertyã€‚


ï»¿# BindWidget

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UUserWidgetå­ç±»é‡Œå±æ€§
- **å…³è”é¡¹ï¼š** [BindWidgetOptional](../BindWidgetOptional/BindWidgetOptional.md), [OptionalWidget](../OptionalWidget.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ã€‚

ä¸€ç§å¹³å¸¸é€šç”¨çš„ç¼–ç¨‹èŒƒå¼æ˜¯åœ¨C++ä¸­å®šä¹‰ä¸€ä¸ªUUserWidgetå­ç±»ï¼Œç„¶åå†åœ¨UMGä¸­ç»§æ‰¿äºè¿™ä¸ªC++ç±»ï¼Œè¿™æ ·å°±èƒ½æŠŠä¸€äº›é€»è¾‘æ”¾åœ¨C++ä¸­å®ç°ï¼Œè€Œåœ¨UMGä¸­æ’å¸ƒæ§ä»¶ã€‚è¿™ä¸ªæ—¶å€™å¸¸å¸¸å°±ä¼šæœ‰ä¸ªéœ€æ±‚ï¼šéœ€è¦åœ¨C++ä¸­ç”¨å±æ€§å¼•ç”¨åˆ°UMGä¸­å®šä¹‰çš„å…·ä½“æ§ä»¶ã€‚

- åœ¨C++é‡Œå¸¸è§çš„ä½œæ³•æ˜¯ç”¨WidgetTree->FindWidgetæ¥é€šè¿‡æ§ä»¶åå­—æŸ¥æ‰¾ã€‚ä½†å¦‚æœç±»é‡Œå®šä¹‰æœ‰å‡ åä¸ªæ§ä»¶ï¼Œä¸€ä¸€è¿™ä¹ˆåšå°±å¾ˆç¹çã€‚
- å› æ­¤æ›´ä¾¿åˆ©çš„æ–¹å¼æ˜¯åœ¨C++é‡Œå®šä¹‰åŒåçš„æ§ä»¶å±æ€§ï¼Œè¿™æ ·å°±ä¼šè‡ªåŠ¨çš„å…³è”èµ·æ¥ï¼ŒUMGè“å›¾å¯¹è±¡åœ¨åˆ›å»ºåå¼•æ“ä¼šè‡ªåŠ¨çš„ç»™C++ä¸­çš„Widgetå±æ€§è‡ªåŠ¨èµ‹å€¼åˆ°åŒåçš„æ§ä»¶ã€‚
- å¿…é¡»è¦æŒ‡å‡ºï¼šBindWidgetåªæ˜¯ç”¨ä½œUMGç¼–è¾‘å™¨çš„ç¼–è¾‘å’Œç¼–è¯‘æç¤ºï¼Œè®©ä½ è®°å¾—è¦ä¸€ä¸€æŠŠåå­—å…³è”ä¸Šã€‚åœ¨C++é‡Œå®šä¹‰çš„è¯¥å±æ€§ï¼Œè¦è®°å¾—åœ¨UMGé‡Œä¹Ÿåˆ›å»ºåŒåæ§ä»¶ã€‚åœ¨UMGä¸­åˆ›å»ºæˆ–æ›´æ”¹çš„æ§ä»¶åå­—æ—¶ï¼ŒçŸ¥é“åœ¨C++ä¸­æœ‰ä¸€ä¸ªåŒåå±æ€§æ¥å…³è”æ¥æ”¶ï¼Œå°±ä¸ä¼šæŠ¥é”™ï¼Œå¦åˆ™ä¼šæç¤ºå’ŒC++å®šä¹‰çš„åå­—å†²çªã€‚
- æ€»ç»“BindWidgetçš„ä½œç”¨æœ‰äºŒï¼šä¸€æ˜¯æé†’UMGä¸€å®šè¦ç›¸åº”çš„åˆ›å»ºåŒåæ§ä»¶ï¼Œå¦åˆ™ç¼–è¯‘æŠ±é”™è¯¯ã€‚äºŒæ˜¯åœ¨å®šä¹‰åŒC++é‡Œå±æ€§åŒåçš„æ§ä»¶çš„æ—¶å€™ï¼Œè®©UMGä¸ä¼šæŠ¥é”™ã€‚
- ç”¨æ³•å»ºè®®æ˜¯ä¸ºæ‰€æœ‰ä½ æƒ³è¦ç»‘å®šçš„åŒåå±æ€§éƒ½æ˜¾å¼çš„åŠ ä¸ŠBindWidgetï¼Œä¸è¦ä¾èµ–å«ç³Šé»˜è®¤çš„è‡ªåŠ¨åŒåç»‘å®šæœºåˆ¶ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_BindWidget :public UUserWidget
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	class UTextBlock* MyTextBlock_NotFound;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	class UTextBlock* MyTextBlock_SameName;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget))
	class UTextBlock* MyTextBlock_Bind;
};

void UMyProperty_BindWidget::RunTest()
{
	//C++é‡ŒæŸ¥æ‰¾Widgetçš„æ–¹å¼
	UTextBlock* bindWidget= WidgetTree->FindWidget(TEXT("MyTextBlock_Bind"));
	check(bindWidget==MyTextBlock_Bind);
}
```

## æµ‹è¯•æ•ˆæœï¼š

æµ‹è¯•æ“ä½œæ˜¯åœ¨C++ä¸­å®šä¹‰å¦‚ä¸Šå›¾çš„UUserWidgetåŸºç±»ï¼Œç„¶ååœ¨UMGä¸­åˆ›å»ºè“å›¾å­ç±»ã€‚æ§ä»¶çš„åˆ—è¡¨å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

- ä¸ºäº†å¯¹æ¯”éªŒè¯ï¼Œåˆ†åˆ«åœ¨C++å’Œè“å›¾ä¸­å®šä¹‰3ä¸ªæ§ä»¶ï¼Œæœ‰åŒåçš„å’ŒéåŒåçš„ã€‚ç„¶ååœ¨CreateWidetååœ¨C++ä¸­è°ƒè¯•æŸ¥çœ‹è¿™3ä¸ªå±æ€§å€¼ã€‚
- å¯ä»¥å‘ç°MyTextBlock_Bindå’ŒMyTextBlock_SameNameéƒ½è‡ªåŠ¨çš„å…³è”ä¸Šäº†å€¼ï¼Œå‘ç°å…³è”å±æ€§å€¼çš„é€»è¾‘å…¶è·Ÿæœ‰æ²¡æœ‰æ ‡ä¸ŠBindWidgetå¹¶æ²¡æœ‰å…³ç³»ã€‚ä½†æ˜¯å¦‚æœåœ¨MyTextBlock_SameNameå‹¾ä¸Šå˜é‡ï¼Œä¹Ÿä¼šæŠ¥åå­—å†²çªçš„é”™ã€‚è¿™æ˜¯å› ä¸ºå‹¾ä¸Šå˜é‡ï¼Œä¼šåœ¨è“å›¾ä¸­åˆ›å»ºä¸€ä¸ªå±æ€§ï¼Œè¿™æ ·è‡ªç„¶å°±å’ŒC++é‡Œçš„å†²çªã€‚è€Œæ²¡æœ‰å‹¾ä¸Šå˜é‡çš„æ—¶å€™ï¼ŒMyTextBlock_SameNameæœ¬è´¨ä¸Šåªæ˜¯ä¸€ä¸ªåœ¨WidgetTreeä¸‹çš„å¯¹è±¡ï¼Œç¼–è¾‘å™¨å¯ä»¥æç¤ºåŒåå†²çªï¼ˆC++é‡Œå…ˆå®šä¹‰ç„¶åUMGé‡Œå†å®šä¹‰ï¼‰ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä¸æç¤ºï¼ˆBindWidgetçš„ä½œç”¨äº†å…¶å®ï¼‰ã€‚ä½†å¦‚æœæ˜¯ä¹Ÿè¦ç›¸åº”åˆ›å»ºBPé‡Œçš„MyTextBlock_SameNameå˜é‡ï¼Œè¿™ä¸ªå†²çªå°±æ˜¯å¿…ç„¶å­˜åœ¨äº†ã€‚è¿™ä¸ªæ—¶å€™å¦‚æœæ²¡æœ‰åŠ ä¸ŠBindWidgetï¼Œå¼•æ“å°±ä¼šè®¤ä¸ºè¿™æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ä¸åŒçš„å±æ€§ï¼ˆå‡å¦‚ä½ åœ¨C++é‡Œæ˜æ˜æ²¡å†™BindWidgetè€Œå¼•æ“è‡ªä½œä¸»å¼ ç»™ä½ BindWidgetäº†ï¼Œå®é™…å¯èƒ½åè€Œå‡ºç°æ›´å¤šè«åé”™è¯¯ï¼‰ã€‚åªæœ‰æ˜¾å¼çš„åŠ ä¸ŠBindWidgetï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬ä¸ºMyTextBlock_Bindå‹¾ä¸Šå˜é‡ï¼Œå¼•æ“çŸ¥é“C++é‡Œå·²ç»æœ‰ä¸ªC++å±æ€§äº†ï¼Œå°±æ²¡å¿…è¦å†åˆ›å»ºä¸€ä¸ªè“å›¾å±æ€§äº†ï¼ˆè¿™ä¸ªæ—¶å€™BPé¢æ¿é‡Œæ²¡æœ‰ï¼‰ã€‚
- MyTextBlock_NotFoundå¹¶æ²¡æœ‰å€¼ï¼Œè¿™å¾ˆç¬¦åˆé€»è¾‘ï¼Œå› ä¸ºæˆ‘ä»¬ä¹Ÿæ²¡æœ‰åœ¨UMGä¸­å®šä¹‰è¯¥æ§ä»¶ã€‚ä½†æ˜¯å€¼å¾—æ³¨æ„çš„æ˜¯å‡å¦‚æˆ‘ä»¬å°è¯•åœ¨UMGä¸­å®šä¹‰è¯¥åå­—çš„æ§ä»¶ï¼Œä¼šæŠ¥é”™æç¤ºåå­—å·²ç»è¢«å ç”¨ã€‚ä¹Ÿå¾ˆæ­£å¸¸ï¼Œå› ä¸ºè¿™å°±åƒC++ç±»çš„å­ç±»é‡Œå®šä¹‰æˆå‘˜å˜é‡ï¼Œè‚¯å®šä¸èƒ½å‡ºç°æˆå‘˜å˜é‡å†²çªã€‚ä½†å‡å¦‚æˆ‘ä»¬å®šä¹‰MyTextBlock_Bindå°±ä¸ä¼šæŠ¥è¿™ä¸ªâ€œåå­—å ç”¨â€çš„é”™ï¼Œå› ä¸ºå¼•æ“çŸ¥é“C++é‡Œæœ‰ä¸€ä¸ªåŒåå±æ€§æ˜¯è¦ç”¨æ¥å¼•ç”¨è¯¥æ§ä»¶ã€‚å› æ­¤è¿™æ‰æ˜¯BindWidgetçš„ç²¾ç¡®ä½œç”¨å«ä¹‰ï¼Œåªæ˜¯ä½œä¸ºæç¤ºã€‚è¿™ä¸ªæ—¶å€™å¯èƒ½æœ‰äººä¼šé—®é‚£æˆ‘çš„UMGé‡Œçš„MyTextBlock_SameNameæ˜¯æ€ä¹ˆåˆ›å»ºä¸Šå»çš„ï¼Ÿä¸æ˜¯ä¼šæŠ¥é”™å—ï¼Ÿç­”æ¡ˆæ˜¯å…ˆåœ¨UMGé‡Œå®šä¹‰å¥½ï¼Œç„¶åå†åœ¨C++é‡Œå®šä¹‰ï¼Œè¿™æ ·å°±ä¸ä¼šæŠ¥é”™äº†ã€‚
- å‡å¦‚æœ€åMyTextBlock_Bindæ²¡æœ‰åœ¨UMGä¸­å®šä¹‰ï¼Œé‚£ä¹ˆUMGåœ¨ç¼–è¯‘çš„æ—¶å€™ä¼šæŠ¥æƒ³è¦ç»‘å®šçš„æ§ä»¶æ‰¾ä¸åˆ°ï¼Œæé†’ä½ è‡ªå·±è¯´æƒ³è¦BindWidgetç»“æœä½ åˆä¸åˆ›å»ºã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\BindWidget\Untitled.png)

## åŸç†ï¼š

åˆ¤æ–­ä¸€ä¸ªå±æ€§æ˜¯å¦æ˜¯BindWidgetçš„å‡½æ•°æ˜¯IsBindWidgetPropertyè¿™ä¸ªå‡½æ•°ã€‚

åœ¨æ§ä»¶æ”¹åæˆ–ç¼–è¯‘çš„æ—¶å€™ï¼Œç”¨æ¥åˆ¤æ–­æ˜¯å¦è¦ç”Ÿæˆé”™è¯¯æç¤ºçš„æ“ä½œåœ¨FinishCompilingClassï¼Œå¤§è‡´é€»è¾‘å°±æ˜¯æ ¹æ®IsBindWidgetPropertyåˆ¤æ–­è¯¥æ§ä»¶æ˜¯å¦æƒ³è¦ç»‘å®šï¼Œç„¶åæ ¹æ®å½“å‰æƒ…å†µï¼Œç”Ÿæˆæç¤ºã€‚

è€Œå› ä¸ºåŒåè€Œè‡ªåŠ¨å…³è”å€¼çš„é€»è¾‘æ“ä½œåœ¨UWidgetBlueprintGeneratedClass::InitializeWidgetStaticï¼Œé€»è¾‘å…¶å®æ˜¯éå†WidgetTreeä¸‹çš„æ§ä»¶ï¼Œæ ¹æ®å…¶åå­—å»C++ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°å°±è‡ªåŠ¨çš„èµ‹å€¼ã€‚

```cpp
void UWidgetBlueprintGeneratedClass::InitializeWidgetStatic()
{
	// Find property with the same name as the template and assign the new widget to it.
	if (FObjectPropertyBase** PropPtr = ObjectPropertiesMap.Find(Widget->GetFName()))
	{
		FObjectPropertyBase* Prop = *PropPtr;
		check(Prop);
		Prop->SetObjectPropertyValue_InContainer(UserWidget, Widget);
		UObject* Value = Prop->GetObjectPropertyValue_InContainer(UserWidget);
		check(Value == Widget);
	}
	
}

void FWidgetBlueprintCompilerContext::FinishCompilingClass(UClass* Class)
{
	// Check that all BindWidget properties are present and of the appropriate type
	for (TFObjectPropertyBase<UWidget*>* WidgetProperty : TFieldRange<TFObjectPropertyBase<UWidget*>>(ParentClass))
	{
		bool bIsOptional = false;
	
		if (FWidgetBlueprintEditorUtils::IsBindWidgetProperty(WidgetProperty, bIsOptional))
		{}
	}
	
}

bool FWidgetBlueprintEditorUtils::IsBindWidgetProperty(const FProperty* InProperty, bool& bIsOptional)
{
	if ( InProperty )
	{
		bool bIsBindWidget = InProperty->HasMetaData("BindWidget") || InProperty->HasMetaData("BindWidgetOptional");
		bIsOptional = InProperty->HasMetaData("BindWidgetOptional") || ( InProperty->HasMetaData("OptionalWidget") || InProperty->GetBoolMetaData("OptionalWidget") );

		return bIsBindWidget;
	}

	return false;
}
```


ï»¿# BindWidgetAnim

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥UWidgetAnimationå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGä¸‹çš„æŸä¸ªåŠ¨ç”»
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡ŒUWidgetAnimationå±æ€§
- **å…³è”é¡¹ï¼š** [BindWidgetAnimOptional](../BindWidgetAnimOptional/BindWidgetAnimOptional.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥UWidgetAnimationå±æ€§ä¸€å®šè¦ç»‘å®šåˆ°UMGä¸‹çš„æŸä¸ªåŠ¨ç”»ã€‚

ä½œç”¨åŒBindWidgetç±»ä¼¼ï¼Œéƒ½æ˜¯ç”¨æ¥æŠŠC++çš„å±æ€§å’ŒBPé‡Œçš„æ§ä»¶æˆ–åŠ¨ç”»èµ‹å€¼ç»‘å®šèµ·æ¥ã€‚ä½†åˆæœ‰ä¸€äº›åŒºåˆ«ï¼š

- UWidgetAnimationå’ŒWidgetä¸åŒï¼ŒWidgetçš„å±æ€§å’Œæ§ä»¶åªè¦åŒåå°±å¯ä»¥è‡ªåŠ¨ç»‘å®šèµ·æ¥ï¼Œè€ŒUWidgetAnimationå°±ä¸å…è®¸ä¸åŠ BindWidgetAnimè€ŒåŒåï¼Œå¦åˆ™ä¼šåå­—å†²çªæŠ¥é”™ã€‚è¿™æ˜¯ç”±äºUMGé‡Œåˆ›å»ºçš„Widgeté»˜è®¤æ˜¯ä¸åˆ›å»ºBPå˜é‡çš„ï¼Œå­æ§ä»¶åªæ˜¯WidgetTreeä¸‹çš„ä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯åŠ¨ç”»æ˜¯é»˜è®¤ä¼šåˆ›å»ºBPå˜é‡çš„ã€‚å› æ­¤å³ä½¿æ˜¯UMGé‡Œå…ˆå®šä¹‰åŠ¨ç”»ï¼Œç„¶åC++é‡Œå†å®šä¹‰åŒåå±æ€§ï¼Œä¹Ÿæ˜¯ä¼šè¿‡ä¸äº†ç¼–è¯‘çš„ã€‚
- UWidgetAnimationå±æ€§å¿…é¡»å¾—æ˜¯Transientï¼Œå¦åˆ™ä¹Ÿä¼šæŠ¥é”™ã€‚æˆ‘æƒ³è¿™æ˜¯å› ä¸ºUWidgetAnimationè‡ªç„¶ä¼šåœ¨BPé‡Œä½œä¸ºå­å¯¹è±¡åºåˆ—åŒ–ï¼Œè€Œä¸éœ€è¦åœ¨C++åºåˆ—çš„æ—¶å€™è®¿é—®åˆ°è¯¥å±æ€§ï¼Œå› æ­¤å¼ºåˆ¶Transientä»¥å…ä¸å°å¿ƒåºåˆ—åŒ–å®ƒã€‚å¦å¤–UWidgetAnimationåªæ˜¯ç”¨ä½œè¡¨ç°ï¼Œå› æ­¤å…¶å®ä¹Ÿä¼šè‡ªåŠ¨çš„åŠ ä¸ŠCPF_RepSkipï¼Œè·³è¿‡ç½‘ç»œå¤åˆ¶ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_BindWidget :public UUserWidget
{
	GENERATED_BODY()
	UMyProperty_BindWidget(const FObjectInitializer& ObjectInitializer);

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	class UWidgetAnimation* MyAnimation_NotFound;
	//UPROPERTY(EditAnywhere, BlueprintReadWrite)
	//class UWidgetAnimation* MyAnimation_SameName;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient, meta = (BindWidgetAnim))
	class UWidgetAnimation* MyAnimation_Bind;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient, meta = (BindWidgetAnimOptional))
	class UWidgetAnimation* MyAnimation_BindOptional;
};
```

## æµ‹è¯•æ•ˆæœï¼š

æµ‹è¯•è¿‡ç¨‹å’ŒBindWidgetç±»ä¼¼ï¼Œåœ¨C++å’ŒUMGä¸­å®šä¹‰ä¸åŒç±»å‹å±æ€§å’ŒåŠ¨ç”»å¯¹è±¡ã€‚å¯ä»¥æ ¹æ®VSé‡Œå®é™…å¯¹è±¡çš„å€¼å‘ç°ï¼š

- MyAnimation_Bindå’ŒMyAnimation_BindOptionaléƒ½è‡ªåŠ¨çš„ç»‘å®šäº†æ­£ç¡®çš„åŠ¨ç”»å¯¹è±¡ã€‚
- æ²¡æœ‰åŠ BindWidgetAnimçš„MyAnimation_SameNameå¿…é¡»æ³¨é‡Šæ‰ï¼Œå¦åˆ™ä¼šå’ŒUMGé‡Œçš„MyAnimation_SameNameåå­—å†²çªã€‚
- å†æä¸€ä¸‹ï¼Œä¸èƒ½åƒWidgeté‡Œä¸€æ ·å…ˆUMGé‡Œå®šä¹‰åŠ¨ç”»ï¼Œç„¶åå†C++å®šä¹‰åŒåå±æ€§ï¼Œå› ä¸ºWidgetAnimationæ˜¯ä¸€å®šä¼šåˆ›å»ºBPå˜é‡çš„ï¼Œè¿™æ˜¯å…³é”®ä¸åŒã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\BindWidgetAnim\Untitled.png)

## åŸç†ï¼š

å¤§è‡´é€»è¾‘å’ŒBindWidgetç±»ä¼¼ï¼Œéƒ½æ˜¯åˆ¤æ–­å±æ€§æ˜¯å¦BindWidgetAnimã€‚ç„¶åç›¸åº”çš„åœ¨ç¼–è¯‘å’Œæ”¹åçš„æ—¶å€™åˆ¤æ–­ã€‚ 

å…³äºåŠ¨ç”»å˜é‡è®¾ç½®PropertyFlagsçš„é€»è¾‘åœ¨CreateClassVariablesFromBlueprinté‡Œï¼Œå¯ä»¥çœ‹è§åŠ ä¸Šäº†4ä¸ªå±æ€§ï¼Œæ˜ç¡®äº†ä¸è¦åºåˆ—åŒ–è¯¥å±æ€§ã€‚

è€Œä¸ºUWidgetAnimation*å±æ€§è‡ªåŠ¨ç»‘å®šèµ‹å€¼çš„é€»è¾‘åœ¨BindAnimationsStaticï¼Œä¸€çœ¼å°±æ‡‚ã€‚

```cpp
bool FWidgetBlueprintEditorUtils::IsBindWidgetAnimProperty(const FProperty* InProperty, bool& bIsOptional)
{
	if (InProperty)
	{
		bool bIsBindWidgetAnim = InProperty->HasMetaData("BindWidgetAnim") || InProperty->HasMetaData("BindWidgetAnimOptional");
		bIsOptional = InProperty->HasMetaData("BindWidgetAnimOptional");

		return bIsBindWidgetAnim;
	}

	return false;
}

void FWidgetBlueprintCompilerContext::CreateClassVariablesFromBlueprint()
{
	for (UWidgetAnimation* Animation : WidgetBP->Animations)
	{
		FEdGraphPinType WidgetPinType(UEdGraphSchema_K2::PC_Object, NAME_None, Animation->GetClass(), EPinContainerType::None, true, FEdGraphTerminalType());
		FProperty* AnimationProperty = CreateVariable(Animation->GetFName(), WidgetPinType);
	
		if ( AnimationProperty != nullptr )
		{
			const FString DisplayName = Animation->GetDisplayName().ToString();
			AnimationProperty->SetMetaData(TEXT("DisplayName"), *DisplayName);
	
			AnimationProperty->SetMetaData(TEXT("Category"), TEXT("Animations"));
	
			AnimationProperty->SetPropertyFlags(CPF_Transient);
			AnimationProperty->SetPropertyFlags(CPF_BlueprintVisible);
			AnimationProperty->SetPropertyFlags(CPF_BlueprintReadOnly);
			AnimationProperty->SetPropertyFlags(CPF_RepSkip);
	
			WidgetAnimToMemberVariableMap.Add(Animation, AnimationProperty);
		}
	}
}

void FWidgetBlueprintCompilerContext::FinishCompilingClass(UClass* Class)
{
	if (!WidgetAnimProperty->HasAnyPropertyFlags(CPF_Transient))
	{
			const FText BindWidgetAnimTransientError = LOCTEXT("BindWidgetAnimTransient", "The property @@ uses BindWidgetAnim, but isn't Transient!");
			MessageLog.Error(*BindWidgetAnimTransientError.ToString(), WidgetAnimProperty);
	}
}

void UWidgetBlueprintGeneratedClass::BindAnimationsStatic(UUserWidget* Instance, const TArrayView<UWidgetAnimation*> InAnimations, const TMap<FName, FObjectPropertyBase*>& InPropertyMap)
{
	// Note: It's not safe to assume here that the UserWidget class type is a UWidgetBlueprintGeneratedClass!
	// - @see InitializeWidgetStatic()

	for (UWidgetAnimation* Animation : InAnimations)
	{
		if (Animation->GetMovieScene())
		{
			// Find property with the same name as the animation and assign the animation to it.
			if (FObjectPropertyBase*const* PropPtr = InPropertyMap.Find(Animation->GetMovieScene()->GetFName()))
			{
				check(*PropPtr);
				(*PropPtr)->SetObjectPropertyValue_InContainer(Instance, Animation);
			}
		}
	}
}
```


ï»¿# BindWidgetAnimOptional

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥UWidgetAnimationå±æ€§å¯ä»¥è¦ç»‘å®šåˆ°UMGä¸‹çš„æŸä¸ªåŠ¨ç”»ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡ŒUWidgetAnimationå±æ€§
- **å…³è”é¡¹ï¼š** [BindWidgetAnim](../BindWidgetAnim/BindWidgetAnim.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åŒBindWidgetOptionalä½œç”¨ä¹Ÿç±»ä¼¼ï¼Œåœ¨ä¸ç»‘å®šçš„æ—¶å€™åœ¨ç¼–è¯‘ç»“æœé‡Œä¼šæœ‰ä¸€ä¸ªæç¤ºï¼Œè€Œä¸æ˜¯åƒBindWidgetä¸€æ ·å¼ºåˆ¶çš„é”™è¯¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\BindWidgetAnimOptional\Untitled.png)

è‡ªç„¶çš„ä¹Ÿè¯´è¿‡ä¸èƒ½åƒWidgetä¸€æ ·ï¼Œä¸åŠ BindWidgetå°±è‡ªåŠ¨é»˜è®¤ç»‘å®šã€‚

å› æ­¤ç”¨æ³•ä¸Šè¦å˜›åŠ BindWidgetAnimï¼Œè¦å˜›åŠ BindWidgetAnimOptionalã€‚


ï»¿# BindWidgetOptional

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§å¯ä»¥ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡Œå±æ€§
- **å…³è”é¡¹ï¼š** [BindWidget](../BindWidget/BindWidget.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§å¯ä»¥ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚

å¤§è‡´ä½œç”¨å’ŒBindWidgetä¸€æ ·ï¼ŒåŒºåˆ«æ˜¯ï¼š

- BindWidgetOptionalé¡¾åæ€ä¹‰æ˜¯å¯é€‰çš„ï¼Œæ„æ€æ˜¯UMGé‡Œå³ä½¿ä¸å®šä¹‰è¯¥æ§ä»¶åœ¨ç¼–è¯‘çš„æ—¶å€™ä¹Ÿä¸ä¼šæŠ¥é”™ã€‚ç¼–è¯‘ä¼šé€šè¿‡ï¼Œä½†æ˜¯ä¼šæç¤ºè­¦å‘Šç¼ºå°‘æ§ä»¶ã€‚
- 
- å’Œä¸åŠ BindWidgetOptionalçš„æ§ä»¶åŒåå±æ€§çš„åŒºåˆ«æ˜¯ï¼Œå‰è€…åœ¨UMGé‡Œå®šä¹‰åŒåæ§ä»¶çš„æ—¶å€™ä¸ä¼šæŠ¥é”™ï¼Œä½†åè€…æ˜¯ä¼šæç¤ºåŒåå†²çªæŠ¥é”™ã€‚

BindWidgetOptionalçš„å†™æ³•æœ‰ä¸¤ç§ï¼š
BindWidgetOptionalå¯ä»¥çœ‹ä½œæ˜¯BindWidgetå’ŒOptionalWidgetçš„åˆå¹¶ç‰ˆã€‚

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_BindWidget :public UUserWidget
{
	GENERATED_BODY()
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	class UTextBlock* MyTextBlock_SameName;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidgetOptional))
	class UTextBlock* MyTextBlock_Optional1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (BindWidget, OptionalWidget))
	class UTextBlock* MyTextBlock_Optional2;
};
```

## æµ‹è¯•æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\BindWidgetOptional\Untitled.png)

## åŸç†ï¼š

```cpp

bool FWidgetBlueprintEditorUtils::IsBindWidgetProperty(const FProperty* InProperty, bool& bIsOptional)
{
	if ( InProperty )
	{
		bool bIsBindWidget = InProperty->HasMetaData("BindWidget") || InProperty->HasMetaData("BindWidgetOptional");
		bIsOptional = InProperty->HasMetaData("BindWidgetOptional") || ( InProperty->HasMetaData("OptionalWidget") || InProperty->GetBoolMetaData("OptionalWidget") );

		return bIsBindWidget;
	}

	return false;
}
```


ï»¿# DefaultGraphNode

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°å¼•æ“é»˜è®¤åˆ›å»ºçš„è“å›¾èŠ‚ç‚¹ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æ ‡è®°å¼•æ“é»˜è®¤åˆ›å»ºçš„è“å›¾èŠ‚ç‚¹ã€‚

è¿™æ ·å°±å¯ä»¥åœ¨åˆ¤æ–­è“å›¾å†…æ˜¯å¦æœ‰ç”¨æˆ·æ‰‹åŠ¨åˆ›å»ºçš„èŠ‚ç‚¹æ—¶ï¼Œè¿‡æ»¤æ‰å¼•æ“è‡ªåŠ¨åˆ›å»ºçš„é‚£äº›ã€‚

åªåœ¨å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·ä¸éœ€è¦è‡ªå·±ä½¿ç”¨ã€‚

## åŸç†ï¼š

```cpp

static bool BlueprintEditorImpl::GraphHasUserPlacedNodes(UEdGraph const* InGraph)
{
	bool bHasUserPlacedNodes = false;

	for (UEdGraphNode const* Node : InGraph->Nodes)
	{
		if (Node == nullptr)
		{
			continue;
		}

		if (!Node->GetOutermost()->GetMetaData()->HasValue(Node, FNodeMetadata::DefaultGraphNode))
		{
			bHasUserPlacedNodes = true;
			break;
		}
	}

	return bHasUserPlacedNodes;
}
```


ï»¿# DesignerRebuild

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šWidgeté‡Œçš„æŸä¸ªå±æ€§å€¼æ”¹å˜ååº”è¯¥é‡æ–°åˆ·æ–°UMGçš„é¢„è§ˆç•Œé¢ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡Œå±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šWidgeté‡Œçš„æŸä¸ªå±æ€§å€¼æ”¹å˜ååº”è¯¥é‡æ–°åˆ·æ–°UMGçš„é¢„è§ˆç•Œé¢ã€‚

é¦–å…ˆæƒ³åˆ°çš„é—®é¢˜æ˜¯ï¼Œå“ªç§å±æ€§éœ€è¦ç”¨åˆ°è¯¥DesignerRebuildæ ‡è®°ï¼Ÿ

è¿™ä¸ªå±æ€§å¾ˆå°‘éœ€è¦ç”¨åˆ°ï¼Œä¸€èˆ¬Widgeté‡Œçš„å±æ€§åœ¨æ›´æ–°åä¹Ÿåªéœ€è¦æ›´æ–°è‡ªå·±çš„æ˜¾ç¤ºï¼Œä¸éœ€è¦åˆ·æ–°æ•´ä¸ªç•Œé¢ï¼Œæ¯”å¦‚å­—å·ã€‚éœ€è¦ç”¨åˆ°çš„æƒ…å†µæƒ³æ¥æœ‰äºŒï¼š

1. ä¸€äº›å±æ€§çš„æ”¹å˜ä¼šå¤§å¤§çš„æ”¹å˜å…¶æ§ä»¶æ ·å¼ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åšåˆ°ç²¾ç»†åŒ–çš„åªé‡ç»˜è‡ªå·±ï¼Œä½†å¹²è„†æ•´ä¸ªé¢„è§ˆç•Œé¢åˆ·æ–°ä¸€ä¸‹å¾—äº†ï¼Œåæ­£æ˜¯ç¼–è¾‘å™¨ç¯å¢ƒã€‚æ¯”å¦‚UTextBlock çš„bSimpleTextModeï¼Œå’ŒUListViewBase ä¸‹çš„EntryWidgetClassï¼Œéƒ½ä¼šå¤§å¤§çš„æ”¹å˜è‡ªå·±ã€‚
2. ä¸€äº›å±æ€§å¯èƒ½å½±å“åˆ°æ•´ä¸ªç•Œé¢åˆ«çš„ä¸œè¥¿çš„æ—¶å€™ï¼Œè¿™ä¸ªæ—¶å€™ä¹Ÿæ—¶å€™å¹²è„†å…¨éƒ¨åˆ·æ–°ä¸€ä¸‹ã€‚æ²¡æ‰¾åˆ°æ°å½“çš„ä¾‹å­ï¼Œä½†å¦‚æœç”¨æˆ·è‡ªå·±çš„æ§ä»¶æœ‰è¿™ä¸ªéœ€æ±‚ï¼Œå°±å¯ä»¥æ ‡ä¸Šã€‚

## æºç é‡Œçš„ä¾‹å­æ˜¯ï¼š

```cpp

UCLASS(meta=(DisplayName="Text"), MinimalAPI)
class UTextBlock : public UTextLayoutWidget
{
	/**
	 * If this is enabled, text shaping, wrapping, justification are disabled in favor of much faster text layout and measurement.
	 * This feature is only suitable for "simple" text (ie, text containing only numbers or basic ASCII) as it disables the complex text rendering support required for certain languages (such as Arabic and Thai).
	 * It is significantly faster for text that can take advantage of it (particularly if that text changes frequently), but shouldn't be used for localized user-facing text.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Performance, AdvancedDisplay, meta=(AllowPrivateAccess = "true", DesignerRebuild))
	bool bSimpleTextMode;
}

UCLASS(Abstract, NotBlueprintable, hidedropdown, meta = (EntryInterface = UserListEntry), MinimalAPI)
class UListViewBase : public UWidget
{
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = ListEntries, meta = (DesignerRebuild, AllowPrivateAccess = true, MustImplement = "/Script/UMG.UserListEntry"))
	TSubclassOf<UUserWidget> EntryWidgetClass;
}
```

## UTextBlockçš„æµ‹è¯•æ•ˆæœï¼š

å¯ä»¥å‘ç°åœ¨æ”¹å˜bSimpleTextModeçš„æ—¶å€™ï¼Œå·¦ä¾§é¢„è§ˆç•Œé¢ä¼šä¸€ä¸‹ä¸‹çš„åœ¨è·³åŠ¨åˆ·æ–°ã€‚è€Œåœ¨ç‚¹å‡»æ”¹å˜åˆ«çš„æŒ‰é’®çš„æ—¶å€™å°±æ²¡æœ‰è¯¥æ•ˆæœã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Widget\DesignerRebuild\DesignerRebuild1.gif](DesignerRebuild1.gif)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_BindWidget :public UUserWidget
{
public:
	UPROPERTY(EditAnywhere, Category = Design)
	int32 MyInt = 123;

	UPROPERTY(EditAnywhere, Category = Design, meta = (DesignerRebuild))
	int32 MyInt_DesignerRebuild = 123;
}
```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§åœ¨æ”¹å˜æ™®é€šçš„å±æ€§MyInt çš„æ—¶å€™ï¼Œç•Œé¢å¹¶ä¸ä¼šåˆ·æ–°ã€‚è€Œåœ¨æ”¹å˜MyInt_DesignerRebuild çš„æ—¶å€™ï¼Œç•Œé¢å·¦ä¸Šè§’çš„æ•°å­—åœ¨è·³åŠ¨ï¼ˆè™½ç„¶æ•´ä¸ªç•Œé¢å…¶å®å¹¶æ²¡æœ‰ä»€ä¹ˆå®è´¨å˜åŒ–ï¼‰ã€‚

![D:\github\UnrealSpecifiers\Doc\Meta\Widget\DesignerRebuild\DesignerRebuild2.gif](DesignerRebuild2.gif)

## åŸç†ï¼š

åœ¨Widgeté‡Œçš„å¸¦æœ‰DesignerRebuildçš„æŸå±æ€§æ”¹å˜ä¹‹åï¼Œä¼šé€šçŸ¥InvalidatePreviewä»¥ä¾¿æ›´æ–°ç¼–è¾‘å™¨é‡Œçš„é¢„è§ˆçª—å£ã€‚

```cpp

void SWidgetDetailsView::NotifyPostChange(const FPropertyChangedEvent& PropertyChangedEvent, FEditPropertyChain* PropertyThatChanged)
{
	const static FName DesignerRebuildName("DesignerRebuild");

	//...
	// If the property that changed is marked as "DesignerRebuild" we invalidate
	// the preview.
	if ( PropertyChangedEvent.Property->HasMetaData(DesignerRebuildName) || PropertyThatChanged->GetActiveMemberNode()->GetValue()->HasMetaData(DesignerRebuildName) )
	{
		const bool bViewOnly = true;
		BlueprintEditor.Pin()->InvalidatePreview(bViewOnly);
	}
}
```


ï»¿# DisableNativeTick

- **åŠŸèƒ½æè¿°ï¼š** ç¦ç”¨è¯¥UserWidgetçš„NativeTickã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UserWidgetçš„å­ç±»
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ç¦ç”¨è¯¥UserWidgetçš„NativeTickã€‚

å¦‚æœåªæœ‰C++ç±»åˆ™ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºçº¯C++çš„Widgetæ²¡æœ‰WidgetBPClass ã€‚

è€Œä¸”BPçš„å­ç±»è¦åˆ é™¤Tickè“å›¾èŠ‚ç‚¹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType, meta=())
class INSIDER_API UMyWidget_WithNativeTick :public UUserWidget
{
	GENERATED_BODY()
public:
	virtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override
	{
		Super::NativeTick(MyGeometry, InDeltaTime);
		UKismetSystemLibrary::PrintString(nullptr, TEXT("WithNativeTick"), true);
	}
};

UCLASS(BlueprintType,meta=(DisableNativeTick))
class INSIDER_API UMyWidget_DisableNativeTick :public UUserWidget
{
	GENERATED_BODY()
public:
	virtual void NativeTick(const FGeometry& MyGeometry, float InDeltaTime) override
	{
		Super::NativeTick(MyGeometry, InDeltaTime);
		UKismetSystemLibrary::PrintString(nullptr, TEXT("DisableNativeTick"), true);
	}
};
```

## æµ‹è¯•æ•ˆæœï¼š

åœ¨è“å›¾ä¸­åˆ†åˆ«åˆ›å»ºUMyWidget_WithNativeTick å’ŒUMyWidget_DisableNativeTick çš„å­ç±»UMG_WithTickå’ŒUMG_DisableTickã€‚ç„¶åæŠŠä»–ä»¬éƒ½æ·»åŠ åˆ°ä¸€ä¸ªUMGé‡Œï¼Œæ·»åŠ åˆ°å±å¹•ä¸Šåè§‚å¯ŸNativeTickçš„è°ƒç”¨æƒ…å†µã€‚

å¯è§åªæœ‰WithNativeTickè°ƒç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\DisableNativeTick\Untitled.png)

## åŸç†ï¼š

åœ¨UCLASSä¸Šæ ‡è®°ä¼šå¯¼è‡´UMGè“å›¾çš„bClassRequiresNativeTick=falseã€‚ç»§è€Œåœ¨UUserWidgetçš„UpdateCanTické‡Œåˆ¤æ–­ã€‚å¦‚æœWidgetBPClassä¸ä¸ºç©ºï¼ˆæ˜¯è“å›¾å­ç±»ï¼‰ä¸”ClassRequiresNativeTickä¸ºfalseï¼ŒbCanTick æ‰ä¸€å¼€å§‹ä¸ºfalseã€‚ç„¶ååˆ¤æ–­bHasScriptImplementedTickåˆ™è¦æ±‚è“å›¾ä¸­æ²¡æœ‰EventTickï¼ˆé»˜è®¤ä¼šåˆ›å»ºï¼Œè‡ªå·±è¦æ‰‹åŠ¨åˆ æ‰ï¼‰ã€‚ç„¶ååé¢ç»§ç»­åˆ¤æ–­è¦æ²¡æœ‰å»¶è¿Ÿè“å›¾èŠ‚ç‚¹ï¼Œæ²¡æœ‰åŠ¨ç”»ã€‚æ€»ä¹‹å°±æ˜¯è¿™ä¸ªWidgetè¦çœŸçš„æ²¡æœ‰Tickçš„éœ€æ±‚ï¼Œåˆ™å¯ä»¥çœŸçš„æœ€åbCanTick=falseã€‚

```cpp

void UWidgetBlueprint::UpdateTickabilityStats(bool& OutHasLatentActions, bool& OutHasAnimations, bool& OutClassRequiresNativeTick)
{
		static const FName DisableNativeTickMetaTag("DisableNativeTick");
		const bool bClassRequiresNativeTick = !NativeParent->HasMetaData(DisableNativeTickMetaTag);
		OutClassRequiresNativeTick = bClassRequiresNativeTick;

}

void FWidgetBlueprintCompilerContext::CopyTermDefaultsToDefaultObject(UObject* DefaultObject)
{
		WidgetBP->UpdateTickabilityStats(bClassOrParentsHaveLatentActions, bClassOrParentsHaveAnimations, bClassRequiresNativeTick);
		WidgetClass->SetClassRequiresNativeTick(bClassRequiresNativeTick);
}

void UUserWidget::UpdateCanTick() 
{
		UWidgetBlueprintGeneratedClass* WidgetBPClass = Cast<UWidgetBlueprintGeneratedClass>(GetClass());
		bCanTick |= !WidgetBPClass || WidgetBPClass->ClassRequiresNativeTick();
		bCanTick |= bHasScriptImplementedTick;
		bCanTick |= World->GetLatentActionManager().GetNumActionsForObject(this) != 0;
		bCanTick |= ActiveSequencePlayers.Num() > 0;
		bCanTick |= QueuedWidgetAnimationTransitions.Num() > 0;
		SafeGCWidget->SetCanTick(bCanTick);
}
```


ï»¿# EntryClass

- **åŠŸèƒ½æè¿°ï¼š** é™å®šEntryWidgetClasså±æ€§ä¸Šå¯é€‰ç±»å¿…é¡»ç»§æ‰¿è‡ªçš„åŸºç±»ï¼Œç”¨åœ¨DynamicEntryBoxå’ŒListViewè¿™ä¸¤ä¸ªWidgetä¸Šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UPROPERTY
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»
- **å…³è”é¡¹ï¼š** [EntryInterface](EntryInterface/EntryInterface.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…


ï»¿# EntryInterface

- **åŠŸèƒ½æè¿°ï¼š** é™å®šEntryWidgetClasså±æ€§ä¸Šå¯é€‰ç±»å¿…é¡»å®ç°çš„æ¥å£ï¼Œç”¨åœ¨DynamicEntryBoxå’ŒListViewè¿™ä¸¤ä¸ªWidgetä¸Šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UCLASS, UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»
- **å…³è”é¡¹ï¼š** [EntryClass](../EntryClass.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

é™å®šEntryWidgetClasså±æ€§ä¸Šå¯é€‰ç±»å¿…é¡»å®ç°çš„æ¥å£ï¼Œç”¨åœ¨DynamicEntryBoxå’ŒListViewè¿™ä¸¤ä¸ªWidgetä¸Šã€‚

ä»¥ListViewä¸ºä¾‹ï¼Œæœ¯è¯­EntryæŒ‡çš„æ˜¯åˆ—è¡¨ä¸­æ˜¾ç¤ºçš„å­æ§ä»¶ï¼Œè€ŒItemæŒ‡çš„æ˜¯åˆ—è¡¨èƒŒåçš„æ•°æ®å…ƒç´ ã€‚æ¯”å¦‚åˆ—è¡¨èƒŒåŒ…æœ‰1000ä¸ªå…ƒç´ (Item)ï¼Œä½†æ˜¯åŒæ—¶åªèƒ½å‘ˆç°10ä¸ªæ§ä»¶(Entry)åœ¨ç•Œé¢ä¸Šã€‚

å› æ­¤EntryInterfaceå’ŒEntryClassï¼Œé¡¾åæ€ä¹‰ï¼ŒæŒ‡çš„æ˜¯EntryWidgetä¸Šè¦å®ç°çš„æ¥å£å’Œå…¶åŸºç±»ã€‚

ç”¨æ³•å±•ç¤ºï¼Œä»¥ä¸‹éƒ½ç”¨ListViewä¸¾ä¾‹ï¼ŒDynamicBoxåŒç†ã€‚

```cpp
//1. ListViewä½œä¸ºåˆ«çš„Widgetçš„å±æ€§ï¼Œå› æ­¤ä¼šåœ¨Propertyä¸Šè¿›è¡ŒMetaçš„æå–åˆ¤æ–­ã€‚
//è¯¥å±æ€§å¿…é¡»æ˜¯BindWidgetï¼Œæ‰èƒ½è‡ªåŠ¨ç»‘å®šåˆ°UMGé‡Œçš„æ§ä»¶ï¼ŒåŒæ—¶ä½œä¸ºC++ propertyæ‰èƒ½è¢«æšä¸¾åˆ°ã€‚
 class UMyUserWidget : public UUserWidget
 {
		UPROPERTY(BindWidget, meta = (EntryClass = MyListEntryWidget,EntryInterface = MyUserListEntry ))
		UListViewBase* MyListView;
 }

//2. å¦‚æœåœ¨Propertyä¸Šæ²¡æœ‰æ‰¾åˆ°æ”¹Metaï¼Œä¹Ÿä¼šå°è¯•åœ¨Widget Classèº«ä¸Šç›´æ¥æ‰¾
UCLASS(meta = (EntryClass = MyListEntryWidget, EntryInterface = "/Script/UMG.UserObjectListEntry"))
class UMyListView : public UListViewBase, public ITypedUMGListView<UObject*>
{}

//3.ä¹‹ååœ¨ClassPickerçš„æ—¶å€™ï¼ŒEntryClassæŒ‡å®šå…¶çˆ¶ç±»ï¼ŒEntryInterfaceæŒ‡å®šç±»å¿…é¡»å®ç°çš„æ¥å£
```

## æºç ä¸­çš„ç”¨æ³•ï¼š

```cpp
UCLASS(Abstract, NotBlueprintable, hidedropdown, meta = (EntryInterface = UserListEntry), MinimalAPI)
class UListViewBase : public UWidget
{
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = ListEntries, meta = (DesignerRebuild, AllowPrivateAccess = true, MustImplement = "/Script/UMG.UserListEntry"))
	TSubclassOf<UUserWidget> EntryWidgetClass;
}

UCLASS(meta = (EntryInterface = "/Script/UMG.UserObjectListEntry"), MinimalAPI)
class UListView : public UListViewBase, public ITypedUMGListView<UObject*>
{}

//å…¶ä¸­UserObjectListEntryæ¥å£ç»§æ‰¿è‡ªUserListEntryï¼ŒEntry Widgetéƒ½å¾—ç»§æ‰¿è‡ªè¯¥æ¥å£ã€‚
UINTERFACE(MinimalAPI)
class UUserObjectListEntry : public UUserListEntry
{}

SNew(SClassPropertyEntryBox)
.AllowNone(false)
.IsBlueprintBaseOnly(true)
.RequiredInterface(RequiredEntryInterface)
.MetaClass(EntryBaseClass ? EntryBaseClass : UUserWidget::StaticClass())
.SelectedClass(this, &FDynamicEntryWidgetDetailsBase::GetSelectedEntryClass)
.OnSetClass(this, &FDynamicEntryWidgetDetailsBase::HandleNewEntryClassSelected)
```

åœ¨FDynamicEntryWidgetDetailsBaseä¸­åˆ¤æ–­EntryInterfaceå’ŒEntryClassï¼Œç„¶ååœ¨SClassPropertyEntryBoxä¸­é™å®šå±æ€§ç»†èŠ‚é¢æ¿ClassPickerçš„å¯é€‰ç±»ã€‚FDynamicEntryWidgetDetailsBaseæ˜¯FListViewBaseDetailså’ŒFDynamicEntryBoxDetailsçš„åŸºç±»ï¼Œå› æ­¤ListViewå’ŒDynamicBoxçš„å±æ€§ç»†èŠ‚é¢æ¿éƒ½ç”±å®ƒè¿›è¡Œå®šåˆ¶åŒ–ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyEntryWidget :public UUserWidget, public IUserObjectListEntry
{
	GENERATED_BODY()
public:
	virtual void NativeOnListItemObjectSet(UObject* ListItemObject) override;
public:
	UPROPERTY(meta = (BindWidget))
	class UTextBlock* ValueTextBlock;
};

//////////////////////////////////////////////////////////////////////////

UINTERFACE(MinimalAPI)
class UMyCustomListEntry : public UUserObjectListEntry
{
	GENERATED_UINTERFACE_BODY()
};

class IMyCustomListEntry : public IUserObjectListEntry
{
	GENERATED_IINTERFACE_BODY()
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyCustomEntryWidget :public UUserWidget, public IMyCustomListEntry
{
	GENERATED_BODY()
public:
	virtual void NativeOnListItemObjectSet(UObject* ListItemObject) override;
public:
	UPROPERTY(meta = (BindWidget))
	class UTextBlock* ValueTextBlock;
};

//////////////////////////////////////////////////////////////////////////

UCLASS()
class INSIDER_API UMyListContainerWidget :public UUserWidget
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (BindWidget, EntryClass = MyCustomEntryWidget, EntryInterface = MyCustomListEntry))
	class UListView* MyListView;
};
```

## è“å›¾ä¸­çš„æ•ˆæœï¼š

å¦‚æœMyListViewä¸Šæ²¡æœ‰æŒ‡å®šEntryClassæˆ–EntryInterfaceï¼Œåˆ™åœ¨ListViewçš„EntryWidgetClasså±æ€§ä¸Šå¯ä»¥é€‰æ‹©è“å›¾åˆ›å»ºçš„UMG_MyEntry(ç»§æ‰¿è‡ªC++çš„UMyEntryWidget)ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\EntryInterface\Untitled.png)

å¦‚æœå¦‚ä¸Šé¢ä»£ç ä¸­æ‰€ç¤ºï¼Œæˆ‘ä»¬æ–°åˆ›å»ºä¸€ä¸ªæ¥å£ä¸ºMyCustomListEntryï¼Œå¹¶ä¸”ä¹Ÿæ–°å»ºä¸€ä¸ªæ–°çš„MyCustomEntryWidgetï¼Œç„¶ååœ¨MyListViewå±æ€§ä¸ŠæŒ‡å®šEntryClassæˆ–EntryInterfaceï¼ˆå¯ä»¥ä¸€èµ·ä¹Ÿå¯ä»¥å•ä¸ªï¼‰ï¼Œåˆ™ListViewçš„EntryWidgetClasså±æ€§å¯é€‰çš„ç±»å°±è¢«é™åˆ¶ä½äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\EntryInterface\Untitled%201.png)

è¿˜æœ‰ä¸€ç§ç”¨æ³•æ˜¯å½“ä½ æƒ³è‡ªå®šä¹‰ä¸€ä¸ªListViewï¼Œå¯ä»¥é€‰æ‹©ç»§æ‰¿è‡ªListViewBaseï¼Œç„¶ååœ¨è¿™ä¸ªå­ç±»ä¸Šç›´æ¥é™å®šEntryClassæˆ–EntryInterfaceï¼Œæ•ˆæœå’Œä¸Šå›¾æ˜¯ä¸€æ ·çš„ã€‚

```cpp
UCLASS(meta = (EntryClass = MyCustomEntryWidget, EntryInterface = MyCustomListEntry))
class UMyListView : public UListViewBase, public ITypedUMGListView<UObject*>
{}
```


ï»¿# IsBindableEvent

- **åŠŸèƒ½æè¿°ï¼š** æŠŠä¸€ä¸ªåŠ¨æ€å•æ’­å§”æ‰˜æš´éœ²åˆ°UMGè“å›¾é‡Œä»¥ç»‘å®šç›¸åº”äº‹ä»¶ã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡ŒåŠ¨æ€å•æ’­å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŠŠä¸€ä¸ªåŠ¨æ€å•æ’­å§”æ‰˜æš´éœ²åˆ°UMGè“å›¾é‡Œä»¥ç»‘å®šç›¸åº”äº‹ä»¶ã€‚

éœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼š

- å¿…é¡»æ˜¯åŠ¨æ€å§”æ‰˜ï¼Œå°±æ˜¯DYNAMICçš„é‚£äº›ï¼Œè¿™æ ·æ‰å¯ä»¥åœ¨è“å›¾é‡Œåºåˆ—åŒ–ã€‚
- åŠ¨æ€å¤šæ’­å§”æ‰˜ï¼ˆDECLARE_DYNAMIC_MULTICAST_DELEGATEï¼‰é»˜è®¤å°±å¯ä»¥åœ¨UMGé‡Œç»‘å®šäº‹ä»¶ï¼Œå› æ­¤æ²¡æœ‰å¿…è¦åŠ IsBindableEventã€‚å¾€å¾€ä¹Ÿé…åˆåŠ ä¸ŠBlueprintAssignableä»¥ä¾¿ä¹Ÿå¯ä»¥åœ¨è“å›¾é‡Œæ‰‹åŠ¨ç»‘å®šã€‚
- åŠ¨æ€å•æ’­å§”æ‰˜ï¼ˆDECLARE_DYNAMIC_DELEGATEï¼‰é»˜è®¤æ˜¯ä¸åœ¨UMGé‡Œæš´éœ²çš„ã€‚ä½†å¯ä»¥åŠ ä¸ŠIsBindableEventä»¥ä¾¿å¯ä»¥åœ¨å…¶å®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šç»‘å®šã€‚
- UMGé‡Œçš„æ§ä»¶äº‹ä»¶ä¸ºä»€ä¹ˆè¦æœ‰å¤šæ’­å’Œå•æ’­ï¼Ÿå…¶å®å¤šæ’­å’Œå•æ’­é™¤äº†æ•°é‡ä¸åŒä»¥å¤–ï¼Œæœ€å¤§çš„ä¸åŒæ˜¯å¤šæ’­æ²¡æœ‰è¿”å›å€¼ã€‚è¿™ä¸ªä¾‹å­å¯ä»¥å¯¹æ¯”UButtonä¸‹çš„OnClickedå¤šæ’­äº‹ä»¶å’ŒUImageä¸‹çš„OnMouseButtonDownEventå•æ’­å§”æ‰˜ï¼Œå‰è€…æ˜¯ç‚¹å‡»çš„äº‹ä»¶ï¼Œå·²ç»æ˜¯ä¸ªâ€œç»“æœâ€äº‹ä»¶äº†ï¼Œç‚¹å‡»äº‹ä»¶å¯èƒ½è¢«å¤šä¸ªåœ°æ–¹å“åº”ï¼Œå› æ­¤è¦è®¾è®¡æˆå¤šæ’­ã€‚è€Œåè€…çš„OnMouseButtonDownEventæ˜¯é¼ æ ‡æŒ‰ä¸‹çš„äº‹ä»¶ï¼Œæœ‰ä¸€ä¸ªé‡è¦çš„é€»è¾‘æ˜¯ä¼šæ ¹æ®è¿”å›å€¼FEventReplyçš„ä¸åŒè€Œå†³å®šè¯¥äº‹ä»¶æ˜¯å¦ç»§ç»­è·¯ç”±ä¸Šå»ï¼Œå› æ­¤åªèƒ½ç”¨å•æ’­ï¼Œåªèƒ½ç»‘å®šä¸€ä¸ªã€‚

## æºç ä¾‹å­ï¼š

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnButtonClickedEvent);
class UButton : public UContentWidget
{
	UPROPERTY(BlueprintAssignable, Category="Button|Event")
	FOnButtonClickedEvent OnClicked;
}

DECLARE_DYNAMIC_DELEGATE_RetVal_TwoParams(FEventReply, FOnPointerEvent, FGeometry, MyGeometry, const FPointerEvent&, MouseEvent);
class UImage : public UWidget
{
		UPROPERTY(EditAnywhere, Category=Events, meta=( IsBindableEvent="True" ))
		FOnPointerEvent OnMouseButtonDownEvent;
}
```

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyProperty_BindWidget :public UUserWidget
{
public:
	DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnMyClickedMulticastDelegate);

	UPROPERTY(EditAnywhere, BlueprintAssignable, Category = MyEvent)
	FOnMyClickedMulticastDelegate MyClickedMulticastDelegate;

public:
	DECLARE_DYNAMIC_DELEGATE_RetVal_OneParam(FString,FOnMyClickedDelegate,int32,MyValue);

	UPROPERTY(EditAnywhere, Category = MyEvent)
	FOnMyClickedDelegate MyClickedDelegate_Default;

	UPROPERTY(EditAnywhere, Category = MyEvent)
	FOnMyClickedDelegate MyClickedEvent;

	UPROPERTY(EditAnywhere, Category = MyEvent, meta = (IsBindableEvent = "True"))
	FOnMyClickedDelegate MyClickedDelegate_Bind;
}
```

## æµ‹è¯•ç»“æœï¼š

æ“ä½œæ­¥éª¤æ˜¯åœ¨UMG_BindTestå¤–å†åˆ›å»ºä¸€ä¸ªUMGï¼Œç„¶åè®©UMG_BindTestæˆä¸ºå­æ§ä»¶ï¼Œç„¶åè§‚å¯Ÿå…¶å®ä¾‹ä¸Šçš„äº‹ä»¶ç»‘å®šï¼Œå¦‚ä¸‹å›¾å³ä¾§æ‰€ç¤ºã€‚

- å¯ä»¥å‘ç°åŠ¨æ€å¤šæ’­å§”æ‰˜é»˜è®¤å°±ä¼šå‡ºç°å¯ä»¥ç»‘å®šçš„+å®šåˆ¶åŒ–æŒ‰é’®ï¼Œå¦‚MyClickedMulticastDelegateã€‚
- åŠ¨æ€å¤šæ’­å§”æ‰˜åŠ ä¸ŠBlueprintAssignableï¼ˆä¸èƒ½åŠ åœ¨å•æ’­å§”æ‰˜ä¸Šï¼‰äº†ä¹‹åï¼Œå°±å¯ä»¥åœ¨è“å›¾é‡Œç»‘å®šäº‹ä»¶ï¼Œå¦‚å·¦ä¸‹ä¾§å›¾ã€‚
- åŠ äº†IsBindableEvent çš„MyClickedDelegate_Bindï¼Œå¯ä»¥çœ‹è§å‡ºç°äº†å¯ä»¥Bindçš„ä¸‹æ‹‰æŒ‰é’®ï¼Œç»‘å®šä¹‹åå¯ä»¥æ˜¾ç¤ºå‡½æ•°åå­—ï¼Œä¹Ÿå¯ä»¥æ¸…é™¤ã€‚
- æ²¡æœ‰åŠ IsBindableEvent çš„MyClickedDelegate_Defaultå°±æ²¡æœ‰å‡ºç°åœ¨å¯ç»‘å®šçš„æŒ‰é’®ï¼Œä½ åªèƒ½åœ¨C++é‡Œè‡ªå·±ç»‘å®šäº†ã€‚
- æ²¡æœ‰åŠ IsBindableEvent çš„MyClickedEventå› ä¸ºåå­—ä»¥Eventç»“å°¾ä¹Ÿå‡ºç°äº†å¯ç»‘å®šçš„æŒ‰é’®ï¼Œè¿™åªèƒ½è¯´æ˜¯å½“å‰çš„ä¸€ä¸ªæ½œè§„åˆ™ã€‚æºç æ³¨é‡Šä¹Ÿè¯´ä»¥åä¼šå»é™¤ã€‚
- å¦å¤–è¿™äº›å§”æ‰˜æˆ‘è™½ç„¶éƒ½åŠ ä¸Šäº†EditAnywhereï¼Œä½†å…¶å®ä½ ä¹ŸçŸ¥é“è¿™å¹¶æ²¡æ³•åŠæ³•ç¼–è¾‘ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Meta\Widget\IsBindableEvent\Untitled.png)

## åŸç†ï¼š

å¯¹äºWidgetçš„ç»†èŠ‚é¢æ¿ï¼Œå¼•æ“ä¹Ÿå®šä¹‰äº†å„ç§Customizationã€‚å…¶ä¸­å¯¹åº”çš„å°±æ˜¯FBlueprintWidgetCustomizationã€‚å…¶é’ˆå¯¹ç»‘å®šçš„éƒ¨åˆ†çš„ä»£ç å¦‚ä¸‹ã€‚

ä»£ç ä¹Ÿå¾ˆå®¹æ˜“ç†è§£ï¼ŒåŠ¨æ€å¤šæ’­å§”æ‰˜é»˜è®¤éƒ½å‡ºç°ç»‘å®šï¼ŒåŠ¨æ€å•æ’­å§”æ‰˜æœ‰åŠ IsBindableEventæˆ–è€…åå­—ä»¥Eventç»“å°¾å°±ä¹Ÿåˆ›å»ºç»‘å®šæŒ‰é’®ã€‚

```cpp
PropertyView->RegisterInstancedCustomPropertyLayout(UWidget::StaticClass(), FOnGetDetailCustomizationInstance::CreateStatic(&FBlueprintWidgetCustomization::MakeInstance, BlueprintEditorRef, BlueprintEditorRef->GetBlueprintObj()));

void FBlueprintWidgetCustomization::PerformBindingCustomization(IDetailLayoutBuilder& DetailLayout, const TArrayView<UWidget*> Widgets)
{
	static const FName IsBindableEventName(TEXT("IsBindableEvent"));

	bCreateMulticastEventCustomizationErrorAdded = false;
	if ( Widgets.Num() == 1 )
	{
		UWidget* Widget = Widgets[0];
		UClass* PropertyClass = Widget->GetClass();

		for ( TFieldIterator<FProperty> PropertyIt(PropertyClass, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt )
		{
			FProperty* Property = *PropertyIt;

			if ( FDelegateProperty* DelegateProperty = CastField<FDelegateProperty>(*PropertyIt) )
			{
				//TODO Remove the code to use ones that end with "Event".  Prefer metadata flag.
				if ( DelegateProperty->HasMetaData(IsBindableEventName) || DelegateProperty->GetName().EndsWith(TEXT("Event")) )
				{
					CreateEventCustomization(DetailLayout, DelegateProperty, Widget);
				}
			}
			else if ( FMulticastDelegateProperty* MulticastDelegateProperty = CastField<FMulticastDelegateProperty>(Property) )
			{
				CreateMulticastEventCustomization(DetailLayout, Widget->GetFName(), PropertyClass, MulticastDelegateProperty);
			}
		}
	}
}
```


ï»¿# OptionalWidget

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šåœ¨C++ç±»ä¸­è¯¥Widgetå±æ€§å¯ä»¥ç»‘å®šåˆ°UMGçš„æŸä¸ªåŒåæ§ä»¶ï¼Œä¹Ÿå¯ä»¥ä¸ç»‘å®šã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UPROPERTY
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **é™åˆ¶ç±»å‹ï¼š** UWidgetå­ç±»é‡Œå±æ€§
- **å…³è”é¡¹ï¼š** [BindWidget](BindWidget/BindWidget.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å¿…é¡»é…åˆBindWidgetä½¿ç”¨ã€‚

BindWidget+OptionalWidget=BindWidgetOptional


ï»¿# ViewmodelBlueprintWidgetExtension

- **åŠŸèƒ½æè¿°ï¼š** ç”¨æ¥éªŒè¯InListItemsçš„Objectç±»å‹æ˜¯å¦ç¬¦åˆEntryWidgetClassçš„MVVMç»‘å®šçš„ViewModelPropertyã€‚
- **ä½¿ç”¨ä½ç½®ï¼š** UFUNCTION
- **å¼•æ“æ¨¡å—ï¼š** Widget Property
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

ç”¨æ¥éªŒè¯InListItemsçš„Objectç±»å‹æ˜¯å¦ç¬¦åˆEntryWidgetClassçš„MVVMç»‘å®šçš„ViewModelPropertyã€‚

å½“å‰åªåœ¨ListViewé‡Œè¯¥å‡½æ•°ä½¿ç”¨ã€‚

## åŸç†ï¼š

```cpp
UCLASS(meta = (EntryInterface = "/Script/UMG.UserObjectListEntry"), MinimalAPI)
class UListView : public UListViewBase, public ITypedUMGListView<UObject*>
{
	UFUNCTION(BlueprintCallable, Category = ListView, meta = (AllowPrivateAccess = true, DisplayName = "Set List Items", ViewmodelBlueprintWidgetExtension = "EntryViewModel"))
	UMG_API void BP_SetListItems(const TArray<UObject*>& InListItems);
}

void UMVVMViewBlueprintListViewBaseExtension::Precompile(UE::MVVM::Compiler::IMVVMBlueprintViewPrecompile* Compiler, UWidgetBlueprintGeneratedClass* Class)
{
}
```


# Abstract

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šæ­¤ç±»ä¸ºæŠ½è±¡åŸºç±»ã€‚å¯è¢«ç»§æ‰¿ï¼Œä½†ä¸å¯ç”Ÿæˆå¯¹è±¡ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_Abstract](../../../../Flags/EClassFlags/CLASS_Abstract.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šæ­¤ç±»ä¸ºæŠ½è±¡åŸºç±»ã€‚å¯è¢«ç»§æ‰¿ï¼Œä½†ä¸å¯ç”Ÿæˆå¯¹è±¡ã€‚

ä¸€èˆ¬æ˜¯ç”¨åœ¨XXXBaseåŸºç±»ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
	ClassFlags:	CLASS_Abstract | CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed
*/
UCLASS(Blueprintable, abstract)
class INSIDER_API UMyClass_Abstract :public UObject
{
	GENERATED_BODY()
};

//æµ‹è¯•è¯­å¥ï¼š
UMyClass_Abstract* obj=NewObject<UMyClass_Abstract>();
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨è“å›¾ä¸­çš„ConstructObjectä¸ä¼šå‡ºç°è¯¥ç±»ã€‚åŒæ—¶åœ¨C++ä¸­NewObjectä¹Ÿä¼šæŠ¥é”™ã€‚

![D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Abstract\image.png](image.png)

## åŸç†ï¼š

åœ¨NewObjectçš„æ—¶å€™ä¼šè¿›è¡ŒAbstractçš„åˆ¤æ–­ã€‚

```cpp
bool StaticAllocateObjectErrorTests( const UClass* InClass, UObject* InOuter, FName InName, EObjectFlags InFlags)
{
	// Validation checks.
	if( !InClass )
	{
		UE_LOG(LogUObjectGlobals, Fatal, TEXT("Empty class for object %s"), *InName.ToString() );
		return true;
	}

	// for abstract classes that are being loaded NOT in the editor we want to error.  If they are in the editor we do not want to have an error
	if (FScopedAllowAbstractClassAllocation::IsDisallowedAbstractClass(InClass, InFlags))
	{
		if ( GIsEditor )
		{
			const FString ErrorMsg = FString::Printf(TEXT("Class which was marked abstract was trying to be loaded in Outer %s.  It will be nulled out on save. %s %s"), *GetPathNameSafe(InOuter), *InName.ToString(), *InClass->GetName());
			// if we are trying instantiate an abstract class in the editor we'll warn the user that it will be nulled out on save
			UE_LOG(LogUObjectGlobals, Warning, TEXT("%s"), *ErrorMsg);
			ensureMsgf(false, TEXT("%s"), *ErrorMsg);
		}
		else
		{
			UE_LOG(LogUObjectGlobals, Fatal, TEXT("%s"), *FString::Printf( TEXT("Can't create object %s in Outer %s: class %s is abstract"), *InName.ToString(), *GetPathNameSafe(InOuter), *InClass->GetName()));
			return true;
		}
	}
	}
	
	bool FScopedAllowAbstractClassAllocation::IsDisallowedAbstractClass(const UClass* InClass, EObjectFlags InFlags)
{
	if (((InFlags& RF_ClassDefaultObject) == 0) && InClass->HasAnyClassFlags(CLASS_Abstract))
	{
		if (AllowAbstractCount == 0)
		{
			return true;
		}
	}

	return false;
}
```

# Blueprintable

- **åŠŸèƒ½æè¿°ï¼š** å¯ä»¥åœ¨è“å›¾é‡Œè¢«ç»§æ‰¿ï¼Œéšå«çš„ä½œç”¨ä¹Ÿå¯å½“å˜é‡ç±»å‹
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaæ·»åŠ [IsBlueprintBase](../../../../Meta/Blueprint/IsBlueprintBase.md)å’Œ[BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å…³è”é¡¹ï¼š** [NotBlueprintable](../NotBlueprintable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¯ä»¥åœ¨è“å›¾é‡Œè¢«ç»§æ‰¿ï¼Œéšå«çš„ä½œç”¨ä¹Ÿå¯å½“å˜é‡ç±»å‹ã€‚

å½“è®¾ç½®Blueprintableæ ‡è®°çš„æ—¶å€™ï¼Œä¼šéšå«çš„è®¾ç½®ä¸ŠBlueprintType = trueçš„metadataã€‚å»é™¤çš„æ—¶å€™ï¼Œä¹Ÿä¼šç›¸åº”çš„å»é™¤æ‰BlueprintType = trueã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
(BlueprintType = true, IncludePath = Class/MyClass_Blueprintable.h, IsBlueprintBase = true, ModuleRelativePath = Class/MyClass_Blueprintable.h)
*/
UCLASS(Blueprintable)
class INSIDER_API UMyClass_Blueprintable :public UObject
{
	GENERATED_BODY()
};

/*
(IncludePath = Class/MyClass_Blueprintable.h, IsBlueprintBase = false, ModuleRelativePath = Class/MyClass_Blueprintable.h)
*/
UCLASS(NotBlueprintable)
class INSIDER_API UMyClass_NotBlueprintable :public UObject
{
	GENERATED_BODY()
};

/*
(BlueprintType = true, IncludePath = Class/MyClass_Blueprintable.h, IsBlueprintBase = true, ModuleRelativePath = Class/MyClass_Blueprintable.h)
*/
UCLASS(Blueprintable)
class INSIDER_API UMyClass_NotBlueprintable_To_Blueprintable :public UMyClass_NotBlueprintable
{
	GENERATED_BODY()
};

/*
(IncludePath = Class/MyClass_Blueprintable.h, IsBlueprintBase = false, ModuleRelativePath = Class/MyClass_Blueprintable.h)
*/
UCLASS(NotBlueprintable)
class INSIDER_API UMyClass_Blueprintable_To_NotBlueprintable :public UMyClass_Blueprintable
{
	GENERATED_BODY()
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

åªæœ‰å¸¦æœ‰Blueprintableæ‰å¯ä»¥è¢«é€‰åšåŸºç±»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Blueprintable\Untitled.png)

ä¸è¿‡æ˜¯å¦èƒ½å¤Ÿå½“åšå˜é‡çš„è§„åˆ™ï¼Œè¿˜æ˜¯ä¼šä¾èµ–çˆ¶ç±»çš„Blueprintæ ‡è®°ã€‚å› æ­¤ä»¥ä¸‹è¿™3ä¸ªéƒ½æ˜¯å¯ä»¥å½“åšå˜é‡çš„ã€‚

å…¶ä¸­UMyClass_Blueprintable_To_NotBlueprintableå¯ä»¥å½“åšå˜é‡æ˜¯å› ä¸ºçˆ¶ç±»UMyClass_Blueprintableå¯ä»¥å½“åšå˜é‡ï¼Œå› æ­¤å°±ç»§æ‰¿äº†ä¸‹æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Blueprintable\Untitled%201.png)

## åŸç†ï¼š

å¯è§MD_IsBlueprintBaseçš„åˆ¤æ–­ç”¨æ¥å†³å®šæ˜¯å¦èƒ½åˆ›å»ºå­ç±»

```cpp
bool FKismetEditorUtilities::CanCreateBlueprintOfClass(const UClass* Class)
{
	bool bCanCreateBlueprint = false;
	
	if (Class)
	{
		bool bAllowDerivedBlueprints = false;
		GConfig->GetBool(TEXT("Kismet"), TEXT("AllowDerivedBlueprints"), /*out*/ bAllowDerivedBlueprints, GEngineIni);

		bCanCreateBlueprint = !Class->HasAnyClassFlags(CLASS_Deprecated)
			&& !Class->HasAnyClassFlags(CLASS_NewerVersionExists)
			&& (!Class->ClassGeneratedBy || (bAllowDerivedBlueprints && !IsClassABlueprintSkeleton(Class)));

		const bool bIsBPGC = (Cast<UBlueprintGeneratedClass>(Class) != nullptr);

		const bool bIsValidClass = Class->GetBoolMetaDataHierarchical(FBlueprintMetadata::MD_IsBlueprintBase)
			|| (Class == UObject::StaticClass())
			|| (Class == USceneComponent::StaticClass() || Class == UActorComponent::StaticClass())
			|| bIsBPGC;  // BPs are always considered inheritable
			
		bCanCreateBlueprint &= bIsValidClass;
	}
	
	return bCanCreateBlueprint;
}
```

# BlueprintType

- **åŠŸèƒ½æè¿°ï¼š** å¯å½“åšå˜é‡ç±»å‹
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** Metaå¢åŠ [BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å…³è”é¡¹ï¼š** [NotBlueprintType ](../NotBlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¯å½“åšå˜é‡ç±»å‹ã€‚

å…³é”®æ˜¯è®¾ç½®BlueprintTypeå’ŒNotBlueprintTypeè¿™ä¸¤ä¸ªmetadata.

## ç¤ºä¾‹ä»£ç ï¼š

```cpp

/*
(BlueprintType = true, IncludePath = Class/MyClass_BlueprintType.h, ModuleRelativePath = Class/MyClass_BlueprintType.h)
 */
UCLASS(BlueprintType)
class INSIDER_API UMyClass_BlueprintType :public UObject
{
	GENERATED_BODY()
};

/*
(IncludePath = Class/MyClass_BlueprintType.h, ModuleRelativePath = Class/MyClass_BlueprintType.h)
*/
UCLASS()
class INSIDER_API UMyClass_BlueprintType_Child :public UMyClass_BlueprintType
{
	GENERATED_BODY()
};

/*
(IncludePath = Class/MyClass_BlueprintType.h, ModuleRelativePath = Class/MyClass_BlueprintType.h, NotBlueprintType = true)
*/
UCLASS(NotBlueprintType)
class INSIDER_API UMyClass_NotBlueprintType :public UObject
{
	GENERATED_BODY()
};

/*
(BlueprintType = true, IncludePath = Class/MyClass_BlueprintType.h, ModuleRelativePath = Class/MyClass_BlueprintType.h)
*/
UCLASS(BlueprintType)
class INSIDER_API UMyClass_NotBlueprintType_To_BlueprintType:public UMyClass_NotBlueprintType
{
	GENERATED_BODY()
};

/*
(IncludePath = Class/MyClass_BlueprintType.h, ModuleRelativePath = Class/MyClass_BlueprintType.h, NotBlueprintType = true)
*/
UCLASS(NotBlueprintType)
class INSIDER_API UMyClass_BlueprintType_To_NotBlueprintType:public UMyClass_BlueprintType
{
	GENERATED_BODY()
};

```

## ç¤ºä¾‹ç»“æœï¼š

å¸¦æœ‰BlueprintType =trueçš„æ‰å¯ä»¥å½“ä½œå˜é‡

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\BlueprintType\Untitled.png)

## åŸç†ï¼š

åœ¨UEdGraphSchema_K2::IsAllowableBlueprintVariableTypeçš„3ä¸ªé‡è½½å‡½æ•°åˆ†åˆ«åˆ¤æ–­UEnumï¼ŒUClassï¼ŒUScriptStructèƒ½å¦å½“ä½œå˜é‡ã€‚

```cpp
ç”¨UEdGraphSchema_K2::IsAllowableBlueprintVariableTypeæ¥åˆ¤æ–­

const UClass* ParentClass = InClass;
while(ParentClass)
{
	// Climb up the class hierarchy and look for "BlueprintType" and "NotBlueprintType" to see if this class is allowed.
	if(ParentClass->GetBoolMetaData(FBlueprintMetadata::MD_AllowableBlueprintVariableType)
		|| ParentClass->HasMetaData(FBlueprintMetadata::MD_BlueprintSpawnableComponent))
	{
		return true;
	}
	else if(ParentClass->GetBoolMetaData(FBlueprintMetadata::MD_NotAllowableBlueprintVariableType))
	{
		return false;
	}
	ParentClass = ParentClass->GetSuperClass();
}
```

# Const

- **åŠŸèƒ½æè¿°ï¼š** è¡¨ç¤ºæœ¬ç±»çš„å†…éƒ¨å±æ€§ä¸å¯åœ¨è“å›¾ä¸­è¢«ä¿®æ”¹ï¼Œåªè¯»ä¸å¯å†™ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_Abstract](../../../../Flags/EClassFlags/CLASS_Const.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¡¨ç¤ºæœ¬ç±»çš„å†…éƒ¨å±æ€§ä¸å¯åœ¨è“å›¾ä¸­è¢«ä¿®æ”¹ï¼Œåªè¯»ä¸å¯å†™ã€‚

ç»§æ‰¿çš„è“å›¾ç±»ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å…¶å®å°±æ˜¯è‡ªåŠ¨çš„ç»™æœ¬ç±»å’Œå­ç±»ä¸Šæ·»åŠ constçš„æ ‡å¿—ã€‚æ³¨æ„åªæ˜¯åœ¨è“å›¾é‡Œæ£€æŸ¥ï¼ŒC++ä¾ç„¶å¯ä»¥éšæ„æ”¹å˜ï¼Œéµå¾ªC++çš„è§„åˆ™ã€‚æ‰€ä»¥è¿™ä¸ªconstæ˜¯åªç»™è“å›¾ç”¨çš„ï¼Œåœ¨è“å›¾é‡Œæ£€æŸ¥ã€‚å‡½æ•°ä¾ç„¶å¯ä»¥éšä¾¿è°ƒç”¨ï¼Œåªæ˜¯æ²¡æœ‰å±æ€§çš„Setæ–¹æ³•äº†ï¼Œä¹Ÿä¸èƒ½æ”¹å˜äº†ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
	ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_Const | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed
*/
UCLASS(Blueprintable, Const)
class INSIDER_API UMyClass_Const :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty = 123;
	UFUNCTION(BlueprintCallable)
	void MyFunc() { ++MyProperty; }
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨è“å›¾å­ç±»ä¸­å°è¯•ä¿®æ”¹å±æ€§ä¼šæŠ¥é”™ã€‚

![D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Const\image.png](image.png)

è·Ÿè“å›¾Class Settingsé‡Œæ‰“å¼€è¿™ä¸ªå¼€å…³è®¾å®šçš„ä¸€æ ·

![image.png](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Const\image%201.png)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\Const\Untitled.png)

## åŸç†ï¼š

Constç±»ç”Ÿæˆçš„å®ä¾‹å±æ€§å¯¹å¸¦æœ‰constçš„æ ‡è®°ï¼Œä»è€Œé˜»æ­¢ä¿®æ”¹è‡ªèº«çš„å±æ€§ã€‚

```cpp
void FKCHandler_VariableSet::InnerAssignment(FKismetFunctionContext& Context, UEdGraphNode* Node, UEdGraphPin* VariablePin, UEdGraphPin* ValuePin)
{
	if (!(*VariableTerm)->IsTermWritable())
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("WriteConst_Error", "Cannot write to const @@").ToString(), VariablePin);
	}
}

bool FBPTerminal::IsTermWritable() const
{
	return !bIsLiteral && !bIsConst;
}
```

# HideFunctions

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œéšè—æ‰æŸäº›å‡½æ•°ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [HideFunctions](../../../../Meta/Blueprint/HideFunctions.md)
- **å…³è”é¡¹ï¼š** [ShowFunctions](../ShowFunctions.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œéšè—æ‰æŸäº›å‡½æ•°ã€‚

- åœ¨è“å›¾ä¸­é¼ æ ‡å³é”®ä¾ç„¶å¯ä»¥æŸ¥çœ‹åˆ°è¯¥ç±»ä¸‹BlueprintCallableçš„å‡½æ•°ï¼Œä¾ç„¶å¯ä»¥è°ƒç”¨ï¼Œæœ¬æ ‡è®°åªæ˜¯ç”¨åœ¨ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨ä¸Šã€‚
- HideFunctionså…¶å®åªèƒ½å¡«å‡½æ•°åå­—ï¼Œæƒ³è¦éšè—ä¸€ä¸ªç›®å½•ä¸‹çš„å‡½æ•°ï¼Œæ˜¯éœ€è¦HideCategorieså†é¢å¤–å®šä¹‰çš„ã€‚

æºç ä¸­åªæœ‰ä¸€ä¸ªåœ°æ–¹ç”¨åˆ°ï¼Œä¸€ä¸ªå¾ˆå¥½çš„ç¤ºä¾‹æ˜¯UCameraComponentä¸­å®šä¹‰çš„SetFieldOfViewå’ŒSetAspectRatioï¼Œå¯¹UCineCameraComponent æ¥è¯´æ˜¯æ— æ„ä¹‰çš„ï¼Œå› æ­¤éšè—æ‰ä¼šæ›´å¥½ã€‚

```cpp
class ENGINE_API UCameraComponent : public USceneComponent
{
UFUNCTION(BlueprintCallable, Category = Camera)
	virtual void SetFieldOfView(float InFieldOfView) { FieldOfView = InFieldOfView; }
UFUNCTION(BlueprintCallable, Category = Camera)
	void SetAspectRatio(float InAspectRatio) { AspectRatio = InAspectRatio; }
}

UCLASS(HideCategories = (CameraSettings), HideFunctions = (SetFieldOfView, SetAspectRatio), Blueprintable, ClassGroup = Camera, meta = (BlueprintSpawnableComponent), Config = Engine)
class CINEMATICCAMERA_API UCineCameraComponent : public UCameraComponent
```

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, HideFunctions = (MyFunc1, MyEvent2),hideCategories= EventCategory2)
class INSIDER_API AMyClass_HideFunctions :public AActor
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable)
		void MyFunc1() {}

	UFUNCTION(BlueprintCallable)
		void MyFunc2() {}

	UFUNCTION(BlueprintCallable, Category = "FuncCategory1")
		void MyFuncInCategory1() {}

	UFUNCTION(BlueprintCallable, Category = "FuncCategory2")
		void MyFuncInCategory2() {}

public:
UFUNCTION(BlueprintImplementableEvent)
		void MyEvent1();

	UFUNCTION(BlueprintImplementableEvent)
		void MyEvent2();

	UFUNCTION(BlueprintImplementableEvent, Category = "EventCategory1")
		void MyEventInCategory1();

	UFUNCTION(BlueprintImplementableEvent, Category = "EventCategory2")
		void MyEventInCategory2();
};

UCLASS(Blueprintable, ShowFunctions = (MyEvent2),showCategories= EventCategory2)
class INSIDER_API AMyClass_ShowFunctions :public AMyClass_HideFunctions
{
	GENERATED_BODY()
public:

};
```

## ç¤ºä¾‹æ•ˆæœï¼š

å‘ç°Callableçš„å‡½æ•°æ˜¯ä¾ç„¶å¯ä»¥è°ƒç”¨çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\HideFunctions\Untitled.png)

åœ¨HideFunctionå­ç±»é‡Œï¼Œå‡½æ•°é‡è½½ä¼šå‘ç°å°‘ä¸¤ä¸ª

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\HideFunctions\Untitled%201.png)

åœ¨ShowFunctionçš„å­ç±»é‡Œå¯ä»¥é‡æ–°æ‰“å¼€Event2å’ŒEventCategory2

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\HideFunctions\Untitled%202.png)

## åŸç†ï¼š

åŸç†æ˜¾ç¤ºï¼ŒHideFunctionså…¶å®åªèƒ½å¡«å‡½æ•°åå­—ï¼Œæƒ³è¦éšè—ä¸€ä¸ªç›®å½•ä¸‹çš„å‡½æ•°ï¼Œæ˜¯éœ€è¦HideCategorieså†é¢å¤–å®šä¹‰çš„ã€‚

```cpp
bool IsFunctionHiddenFromClass( const UFunction* InFunction,const UClass* Class )
	{
		bool bResult = false;
		if( InFunction )
		{
			bResult = Class->IsFunctionHidden( *InFunction->GetName() );

			static const FName FunctionCategory(TEXT("Category")); // FBlueprintMetadata::MD_FunctionCategory
			if( !bResult && InFunction->HasMetaData( FunctionCategory ) )
			{
				FString const& FuncCategory = InFunction->GetMetaData(FunctionCategory);
				bResult = FEditorCategoryUtils::IsCategoryHiddenFromClass(Class, FuncCategory);
			}
		}
		return bResult;
	}
```

# NeedsDeferredDependencyLoading

- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagså¢åŠ [CLASS_NeedsDeferredDependencyLoading](../../../Flags/EClassFlags/CLASS_NeedsDeferredDependencyLoading.md)

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(NeedsDeferredDependencyLoading, MinimalAPI)
class UBlueprintGeneratedClass : public UClass, public IBlueprintPropertyGuidProvider
{
}
```

## åŸç†ï¼š

```cpp
if (ClassFlags.HasAnyFlags(EClassFlags.NeedsDeferredDependencyLoading) && !IsChildOf(Session.UClass))
{
	// CLASS_NeedsDeferredDependencyLoading can only be set on classes derived from UClass
	this.LogError($"'NeedsDeferredDependencyLoading' is set on '{SourceName}' but the flag can only be used with classes derived from UClass.");
}
```

# NotBlueprintable

- **åŠŸèƒ½æè¿°ï¼š** ä¸å¯åœ¨è“å›¾é‡Œç»§æ‰¿ï¼Œéšå«ä½œç”¨ä¹Ÿä¸å¯å½“ä½œå˜é‡
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaå»é™¤[IsBlueprintBase](../../../Meta/Blueprint/IsBlueprintBase.md)å’Œ[BlueprintType](../../../Meta/Blueprint/BlueprintType.md)
- **å…³è”é¡¹ï¼š** [Blueprintable](Blueprintable/Blueprintable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…**



# NotBlueprintType

- **åŠŸèƒ½æè¿°ï¼š** ä¸å¯å½“åšå˜é‡ç±»å‹
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** Metaç§»é™¤[BlueprintType](../../../Meta/Blueprint/BlueprintType.md)
- **å…³è”é¡¹ï¼š** [BlueprintType](BlueprintType/BlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…**

# ShowFunctions

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œé‡æ–°æ‰“å¼€æŸäº›å‡½æ•°ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å»é™¤[HideFunctions](../../../Meta/Blueprint/HideFunctions.md)
- **å…³è”é¡¹ï¼š** [HideFunctions](HideFunctions/HideFunctions.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…**

åœ¨å­ç±»çš„å‡½æ•°è¦†ç›–åˆ—è¡¨é‡Œé‡æ–°æ‰“å¼€æŸäº›å‡½æ•°ã€‚

æµ‹è¯•ä»£ç å’Œæ•ˆæœå›¾è§HideFunctionsã€‚

## åŸç†ï¼š

UHTä¸­çš„ä»£ç ï¼Œå¯è§ShowFunctionsçš„ä½œç”¨å°±æ˜¯å»é™¤æ‰ä¹‹å‰è®¾ç½®çš„HideFunctionsã€‚

```cpp
private void MergeCategories()
{
	MergeShowCategories();

	// Merge ShowFunctions and HideFunctions
	AppendStringListMetaData(SuperClass, UhtNames.HideFunctions, HideFunctions);
	foreach (string value in ShowFunctions)
	{
		HideFunctions.RemoveSwap(value);
	}
	ShowFunctions.Clear();
}
```

# SparseClassDataType

- **åŠŸèƒ½æè¿°ï¼š** è®©Actorçš„ä¸€äº›é‡å¤ä¸å˜çš„æ•°æ®å­˜æ”¾åœ¨ä¸€ä¸ªå…±åŒçš„ç»“æ„é‡Œï¼Œä»¥è¾¾åˆ°å‡å°‘å†…å®¹ä½¿ç”¨é‡çš„ç›®çš„
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [SparseClassDataTypes](../../../../Meta/Blueprint/SparseClassDataTypes.md)
- **å…³è”é¡¹ï¼š** [NoGetter](../../../../Meta/SparseDataType/NoGetter/NoGetter.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¿™æ˜¯ä¸ªé‡æ„å’Œæ€§èƒ½ä¼˜åŒ–çš„ç‚¹ã€‚åœ¨ä½¿ç”¨SparseClassDataTypeçš„æ—¶å€™ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä¸€æ˜¯ä»¥å‰çš„Actoræƒ³åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ¥ä¼˜åŒ–ï¼ŒäºŒæ˜¯æ–°åˆ›å»ºçš„Actorä¸€å¼€å§‹å°±æƒ³ä½¿ç”¨è¿™ä¸ªç‰¹æ€§ã€‚

## ç¤ºä¾‹ç”¨æ³•ï¼š

åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

ä¸€ï¼Œæ—§çš„Actorå­˜åœ¨å†—ä½™å±æ€§

ç®€è€Œè¨€ä¹‹æ˜¯é‚£äº›ä¸ä¼šåœ¨BPæ”¹å˜çš„å±æ€§ã€‚C++æ–¹é¢ï¼Œå¦‚æœæœ‰ä¿®æ”¹è¿™äº›å±æ€§ï¼Œä¹Ÿè¦ä¿®æ”¹ä¸ºä½¿ç”¨Getå‡½æ•°æ¥è·å¾—ï¼Œä»è€Œè½¬åˆ°SparseDataStructé‡Œå»ã€‚

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_SparseClassDataTypes :public AActor
{
	GENERATED_BODY()

public:
	UPROPERTY(EditDefaultsOnly)
		int32 MyInt_EditDefaultOnly = 123;

	UPROPERTY(BlueprintReadOnly)
		int32 MyInt_BlueprintReadOnly = 1024;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
		FString MyString_EditDefault_ReadOnly = TEXT("MyName");

	UPROPERTY(EditAnywhere)
		float MyFloat_EditAnywhere = 555.f;

	UPROPERTY(BlueprintReadWrite)
		float MyFloat_BlueprintReadWrite = 666.f;
};
```

æ”¹ä¸ºä»¥ä¸‹çš„ä»£ç ã€‚æŠŠå±æ€§ç”¨WITH_EDITORONLY_DATAåŒ…èµ·æ¥ï¼Œä»¥ç¤ºæ„åªåœ¨editorä¸‹åšæ“ä½œï¼Œåœ¨runtimeæ˜¯å·²ç»æ¶ˆé™¤çš„ã€‚åŠ ä¸Š_DEPRECATEDåç¼€æ ‡è®°ä¹Ÿæ˜¯ä¸ºäº†è¿›ä¸€æ­¥æé†’åŸå…ˆBPé‡Œçš„è®¿é—®è¦å»é™¤ã€‚é‡è½½MoveDataToSparseClassDataStructä»¥ä¾¿æŠŠç°åœ¨BP Class Defaultsé‡Œé…ç½®çš„å€¼æ‹·è´ç»™æ–°çš„FMySparseClassDataç»“æ„æ•°å€¼ã€‚

```cpp
USTRUCT(BlueprintType)
struct FMySparseClassData
{
    GENERATED_BODY()

    UPROPERTY(EditDefaultsOnly)
        int32 MyInt_EditDefaultOnly = 123;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
        int32 MyInt_BlueprintReadOnly = 1024;

    // "GetByRef" means that Blueprint graphs access a const ref instead of a copy.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta=(GetByRef))
        FString MyString_EditDefault_ReadOnly = TEXT("MyName");
};

UCLASS(Blueprintable, BlueprintType,SparseClassDataTypes= MySparseClassData)
class INSIDER_API AMyActor_SparseClassDataTypes :public AActor
{
	GENERATED_BODY()

public:
#if WITH_EDITOR
	// ~ This function transfers existing data into FMySparseClassData.
	virtual void MoveDataToSparseClassDataStruct() const override;
#endif // WITH_EDITOR
public:
#if WITH_EDITORONLY_DATA
	UPROPERTY()
		int32 MyInt_EditDefaultOnly_DEPRECATED = 123;

	UPROPERTY()
		int32 MyInt_BlueprintReadOnly_DEPRECATED = 1024;

	UPROPERTY()
		FString MyString_EditDefault_ReadOnly_DEPRECATED = TEXT("MyName");
#endif // WITH_EDITORONLY_DATA
public:
	UPROPERTY(EditAnywhere)
		float MyFloat_EditAnywhere = 555.f;

	UPROPERTY(BlueprintReadWrite)
		float MyFloat_BlueprintReadWrite = 666.f;
};

//cpp
#if WITH_EDITOR
void AMyActor_SparseClassDataTypes::MoveDataToSparseClassDataStruct() const
{
	// make sure we don't overwrite the sparse data if it has been saved already
	UBlueprintGeneratedClass* BPClass = Cast<UBlueprintGeneratedClass>(GetClass());
	if (BPClass == nullptr || BPClass->bIsSparseClassDataSerializable == true)
	{
		return;
	}

	Super::MoveDataToSparseClassDataStruct();

#if WITH_EDITORONLY_DATA
	// Unreal Header Tool (UHT) will create GetMySparseClassData automatically.
	FMySparseClassData* SparseClassData = GetMySparseClassData();

	// Modify these lines to include all Sparse Class Data properties.
	SparseClassData->MyInt_EditDefaultOnly = MyInt_EditDefaultOnly_DEPRECATED;
	SparseClassData->MyInt_BlueprintReadOnly = MyInt_BlueprintReadOnly_DEPRECATED;
	SparseClassData->MyString_EditDefault_ReadOnly = MyString_EditDefault_ReadOnly_DEPRECATED;
#endif // WITH_EDITORONLY_DATA

}
#endif // WITH_EDITOR
```

åœ¨BPçš„PostLoadåŠ è½½ä¹‹åï¼Œä¼šè‡ªåŠ¨çš„è°ƒç”¨MoveDataToSparseClassDataStructï¼Œæ‰€ä»¥è¦åœ¨å†…éƒ¨æ£€æµ‹bIsSparseClassDataSerializable.

```cpp
void UBlueprintGeneratedClass::PostLoadDefaultObject(UObject* Object)
{
	FScopeLock SerializeAndPostLoadLock(&SerializeAndPostLoadCritical);

	Super::PostLoadDefaultObject(Object);

	if (Object == ClassDefaultObject)
	{
		// Rebuild the custom property list used in post-construct initialization logic. Note that PostLoad() may have altered some serialized properties.
		UpdateCustomPropertyListForPostConstruction();

		// Restore any property values from config file
		if (HasAnyClassFlags(CLASS_Config))
		{
			ClassDefaultObject->LoadConfig();
		}
	}

#if WITH_EDITOR
	Object->MoveDataToSparseClassDataStruct();

	if (Object->GetSparseClassDataStruct())
	{
		// now that any data has been moved into the sparse data structure we can safely serialize it
		bIsSparseClassDataSerializable = true;
	}

	ConformSparseClassData(Object);
#endif
}
```

åœ¨UClassä¸‹

```cpp
protected:
	/** This is where we store the data that is only changed per class instead of per instance */
	void* SparseClassData;

	/** The struct used to store sparse class data. */
	UScriptStruct* SparseClassDataStruct;

åœ¨æ„é€ UClassçš„æ—¶å€™ï¼Œä¼šSetSparseClassDataStructæ¥æŠŠç»“æ„ä¼ è¿›å»ï¼Œå› æ­¤å°±æŠŠç»“æ„å…³è”èµ·æ¥ã€‚
UClass* Z_Construct_UClass_AMyActor_SparseClassDataTypes()
{
	if (!Z_Registration_Info_UClass_AMyActor_SparseClassDataTypes.OuterSingleton)
	{
		UECodeGen_Private::ConstructUClass(Z_Registration_Info_UClass_AMyActor_SparseClassDataTypes.OuterSingleton, Z_Construct_UClass_AMyActor_SparseClassDataTypes_Statics::ClassParams);
		Z_Registration_Info_UClass_AMyActor_SparseClassDataTypes.OuterSingleton->SetSparseClassDataStruct(AMyActor_SparseClassDataTypes::StaticGetMySparseClassDataScriptStruct());
	}
	return Z_Registration_Info_UClass_AMyActor_SparseClassDataTypes.OuterSingleton;
}
```

æ³¨æ„æ­¤æ—¶BPé‡Œæ²¡æ³•blueprint get é‚£äº›ReadOnlyçš„å˜é‡çš„ï¼Œå› ä¸ºæœ‰_DEPRECATEDåœ¨å ç”¨ç€ã€‚ä¸€ç§æ–¹æ³•æ˜¯è‡ªå·±å†é¢å¤–å®šä¹‰Gettteræ–¹æ³•ï¼š

```cpp
UFUNCTION(BlueprintPure)
int32 GetMyMyInt_BlueprintReadOnly()const
{
	return GetMySparseClassData()->MyInt_BlueprintReadOnly; 
}
```

äºŒï¼Œå¦ä¸€ç§æ–¹æ³•æ˜¯åœ¨MoveDataToSparseClassDataStructä¹‹åï¼ˆè®°å¾—è¦æ‰“å¼€ç¼–è¾‘å™¨ï¼Œå¹¶ä¸”æ‰“å¼€å­ç±»BPè“å›¾åä¿å­˜ï¼‰å°±å¹²è„†åˆ é™¤æ‰AMyActor_SparseClassDataTypesé‡Œçš„å†—ä½™å±æ€§ï¼Œå…¨éƒ¨ä½¿ç”¨FMySparseClassDataä¸­çš„å€¼ã€‚ä»è€Œå˜æˆï¼š

```cpp
USTRUCT(BlueprintType)
struct FMySparseClassData
{
    GENERATED_BODY()

    UPROPERTY(EditDefaultsOnly)
        int32 MyInt_EditDefaultOnly = 123;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
        int32 MyInt_BlueprintReadOnly = 1024;

    // "GetByRef" means that Blueprint graphs access a const ref instead of a copy.
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta=(GetByRef))
        FString MyString_EditDefault_ReadOnly = TEXT("MyName");
};

UCLASS(Blueprintable, BlueprintType,SparseClassDataTypes= MySparseClassData)
class INSIDER_API AMyActor_SparseClassDataTypes :public AActor
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere)
		float MyFloat_EditAnywhere = 555.f;

	UPROPERTY(BlueprintReadWrite)
		float MyFloat_BlueprintReadWrite = 666.f;
};
```

è¿™æ ·å°±è¾¾åˆ°äº†æœ€ç»ˆçš„æ•ˆæœï¼Œè¿™ä¸ªæ•ˆæœä¹Ÿå¯¹æ–°çš„Actorè¦é‡‡ç”¨å†—ä½™å±æ€§çš„ç»“æœä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚æ³¨æ„æ­¤æ—¶ï¼Œåœ¨BPé‡Œæ˜¯ä¾ç„¶å¯ä»¥è®¿é—®BlueprintReadOnlyå±æ€§çš„ï¼Œå› ä¸ºUHTå’ŒBPç³»ç»Ÿå·²ç»å¸®æˆ‘ä»¬åŠ äº†ä¸€å±‚è®¿é—®æ–¹ä¾¿çš„æ§åˆ¶ã€‚

## ç¤ºä¾‹æ•ˆæœï¼š

UHTä¼šå¸®æˆ‘ä»¬ç”ŸæˆC++è®¿é—®å‡½æ•°ï¼š

```cpp
#define FID_Hello_Source_Insider_Class_Trait_MyClass_SparseClassDataTypes_h_30_SPARSE_DATA \
FMySparseClassData* GetMySparseClassData(); \
FMySparseClassData* GetMySparseClassData() const; \
const FMySparseClassData* GetMySparseClassData(EGetSparseClassDataMethod GetMethod) const; \
static UScriptStruct* StaticGetMySparseClassDataScriptStruct(); \
int32 GetMyInt_EditDefaultOnly() \
{ \
	return GetMySparseClassData()->MyInt_EditDefaultOnly; \
} \
int32 GetMyInt_EditDefaultOnly() const \
{ \
	return GetMySparseClassData()->MyInt_EditDefaultOnly; \
} \
int32 GetMyInt_BlueprintReadOnly() \
{ \
	return GetMySparseClassData()->MyInt_BlueprintReadOnly; \
} \
int32 GetMyInt_BlueprintReadOnly() const \
{ \
	return GetMySparseClassData()->MyInt_BlueprintReadOnly; \
} \
const FString& GetMyString_EditDefault_ReadOnly() \
{ \
	return GetMySparseClassData()->MyString_EditDefault_ReadOnly; \
} \
const FString& GetMyString_EditDefault_ReadOnly() const \
{ \
	return GetMySparseClassData()->MyString_EditDefault_ReadOnly; \
}
```

åœ¨BPä¸­ä¾ç„¶å¯ä»¥è®¿é—®ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\SparseClassDataType\Untitled.png)

åœ¨Class Defaultsé‡Œä¹Ÿå¯ä»¥æ”¹å˜å€¼ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Blueprint\SparseClassDataType\Untitled%201.png)

# AdvancedClassDisplay

- **åŠŸèƒ½æè¿°ï¼š**  æŠŠè¯¥ç±»ä¸‹çš„æ‰€æœ‰å±æ€§éƒ½é»˜è®¤æ˜¾ç¤ºåœ¨é«˜çº§ç›®å½•ä¸‹
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaå¢åŠ [AdvancedClassDisplay](../../../../Meta/DetailsPanel/AdvancedClassDisplay.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…**

è®©è¿™ä¸ªç±»çš„æ‰€æœ‰å±æ€§æ˜¾ç¤ºåœ¨æœ¬èº«ç±»çš„Detailé¢æ¿çš„â€œé«˜çº§â€æ ç›®ä¸‹æ˜¾ç¤ºã€‚

ä½†æ˜¯å¯ä»¥é€šè¿‡åœ¨å•ä¸ªå±æ€§ä¸Šä½¿ç”¨SimpleDisplayæ¥é‡è½½æ‰ã€‚åœ¨æœç´¢äº†ä¸€ç•ªæºç åï¼Œå‘ç°ä½¿ç”¨AdvancedClassDisplayçš„åªæœ‰3ä¸ªActorï¼Œä¸”è¿™3ä¸ªActoré‡Œéƒ½æ²¡æœ‰å†å®šä¹‰å±æ€§ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable,AdvancedClassDisplay)
class INSIDER_API UMyClass_AdvancedClassDisplay :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,SimpleDisplay)
		int32 MyProperty_Simple;
};

UCLASS(Blueprintable)
class INSIDER_API UMyClass_NoAdvancedClassDisplay :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SimpleDisplay)
		int32 MyProperty_Simple;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

MyProperty_Simpleå³ä½¿åœ¨AdvancedClassDisplayçš„ç±»ä¸­ä¹Ÿä¾ç„¶æ˜¯ç®€å•çš„æ˜¾ç¤ºã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\AdvancedClassDisplay\Untitled.png)

## åŸç†ï¼š

```cpp
// Property is advanced if it is marked advanced or the entire class is advanced and the property not marked as simple
static const FName Name_AdvancedClassDisplay("AdvancedClassDisplay");
bool bAdvanced = Property.IsValid() ? ( Property->HasAnyPropertyFlags(CPF_AdvancedDisplay) || ( !Property->HasAnyPropertyFlags( CPF_SimpleDisplay ) && Property->GetOwnerClass() && Property->GetOwnerClass()->GetBoolMetaData(Name_AdvancedClassDisplay) ) ) : false;
```

# AutoCollapseCategories

- **åŠŸèƒ½æè¿°ï¼š**  AutoCollapseCategoriesè¯´æ˜ç¬¦ä½¿çˆ¶ç±»ä¸Šçš„ AutoExpandCategories è¯´æ˜ç¬¦çš„åˆ—å‡ºç±»åˆ«çš„æ•ˆæœæ— æ•ˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [AutoCollapseCategories](../../../../Meta/DetailsPanel/AutoCollapseCategories.md)ï¼Œå»é™¤[AutoExpandCategories](../../../../Meta/DetailsPanel/AutoExpandCategories.md)
- **å…³è”é¡¹ï¼š** [DontAutoCollapseCategories](../DontAutoCollapseCategories.md)ã€[AutoExpandCategories](../AutoExpandCategories/AutoExpandCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, AutoCollapseCategories = ("MyGroup2|MyGroup22"))
class INSIDER_API UMyClass_AutoCollapseCategories :public UMyClass_AutoExpandCategories
{
	GENERATED_BODY()
public:
};
```

## ç¤ºä¾‹ç»“æœï¼š

å…³é—­äº†Group22çš„å±•å¼€ï¼Œä½†æ˜¯444çš„å±•å¼€ä¾ç„¶ç»§æ‰¿äº†

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\AutoCollapseCategories\Untitled.png)

# AutoExpandCategories

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šæ­¤ç±»çš„å¯¹è±¡åœ¨ç»†èŠ‚é¢æ¿ä¸­åº”è¯¥è‡ªåŠ¨å±•å¼€çš„Categoryã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å»é™¤[AutoCollapseCategories](../../../../Meta/DetailsPanel/AutoCollapseCategories.md)ï¼Œå¢åŠ [AutoExpandCategories](../../../../Meta/DetailsPanel/AutoExpandCategories.md)
- **å…³è”é¡¹ï¼š** [AutoCollapseCategories](../AutoCollapseCategories/AutoCollapseCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

æŒ‡å®šæ­¤ç±»çš„å¯¹è±¡åœ¨ç»†èŠ‚é¢æ¿ä¸­åº”è¯¥è‡ªåŠ¨å±•å¼€çš„Categoryã€‚

- è¿™é‡Œé¢çš„Categoryå¯ä»¥å¡«å¤šä¸ªï¼Œå¯¹åº”æœ¬ç±»ä¸­å±æ€§èº«ä¸Šå®šä¹‰çš„Categoryã€‚
- å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç¼–è¾‘å™¨ä¼šè‡ªåŠ¨çš„ä¿å­˜å±æ€§ç›®å½•çš„å±•å¼€å…³é—­çŠ¶æ€ã€‚å½±å“å±æ€§æ˜¯å¦å±•å¼€ï¼Œè¿˜ä¼šå—åˆ°DetailPropertyExpansionçš„é…ç½®çš„å½±å“ï¼Œåœ¨æ‰“å¼€çª—å£åï¼ŒSDetailsViewBase::UpdateFilteredDetails()ä¼šä¿å­˜å½“å‰å±•å¼€çš„å±æ€§é¡¹ç›®ï¼Œåº”è¯¥æ˜¯ä¸ºäº†ä¸‹æ¬¡æ‰“å¼€çš„æ—¶å€™è‡ªåŠ¨å±•å¼€ã€‚ä¿å­˜çš„ä»£ç ä¸ºGConfig->SetSingleLineArray(TEXT("DetailPropertyExpansion"), *Struct->GetName(), ExpandedPropertyItems, GEditorPerProjectIni); ä»è€Œåœ¨\Hello\Saved\Config\WindowsEditor\EditorPerProjectUserSettings.iniä¸‹ä¿å­˜ã€‚å› æ­¤ä¸ºäº†æ›´å¥½çš„æµ‹è¯•è¯¥å…ƒæ•°æ®çš„ä½œç”¨çŠ¶æ€ã€‚åº”è¯¥æ‰‹åŠ¨å…ˆæ¸…é™¤ä¸€ä¸‹iniä¸­çš„ä¿å­˜å€¼åå†æµ‹è¯•ã€‚

```cpp
[DetailCategories]
MyClass_AutoExpandCategories.MyClass_AutoExpandCategories=False
MyClass_AutoExpandCategories.MyGroup1=False
MyClass_AutoExpandCategories.MyGroup2=False
MyClass_AutoExpandCategories.MyGroup3=True
MyClass_AutoExpandCategories.MyGroup4=True

[DetailPropertyExpansion]
GeometryCache="\"Object.GeometryCache.Materials\" \"Object.GeometryCache.Tracks\" "
Object="\"Object.MyGroup2.MyGroup2|MyGroup22\" \"Object.MyGroup4.MyGroup4|MyGroup44\" \"Object.MyGroup4.MyGroup4|MyGroup44.MyGroup4|MyGroup44|MyGroup444\" "
GeometryCacheCodecV1="\"Object.GeometryCache.TopologyRanges\" "
GeometryCacheCodecBase="\"Object.GeometryCache.TopologyRanges\" "
MassSettings="\"Object.Mass\" "
DeveloperSettings=
SmartObjectSettings="\"Object.SmartObject\" "
MyClass_ShowCategories=
MyClass_ShowCategoriesChild=
MyClass_DontCollapseCategories="\"Object.MyGroup2.MyGroup2|MyGroup22\" \"Object.MyGroup3.MyGroup3|MyGroup33\" \"Object.MyGroup3.MyGroup3|MyGroup33.MyGroup3|MyGroup33|MyGroup333\" "
MyClass_CollapseCategories="\"Object.MyGroup2.MyGroup2|MyGroup22\" \"Object.MyGroup3.MyGroup3|MyGroup33\" \"Object.MyGroup3.MyGroup3|MyGroup33.MyGroup3|MyGroup33|MyGroup333\" "
MyClass_AutoExpandCategories="\"Object.MyGroup2.MyGroup2|MyGroup22\" \"Object.MyGroup4.MyGroup4|MyGroup44\" \"Object.MyGroup4.MyGroup4|MyGroup44.MyGroup4|MyGroup44|MyGroup444\" "
MyClass_AutoExpandCategoriesCompare=
MyClass_AutoCollapseCategories="\"Object.MyGroup2.MyGroup2|MyGroup22\" \"Object.MyGroup4.MyGroup4|MyGroup44\" \"Object.MyGroup4.MyGroup4|MyGroup44.MyGroup4|MyGroup44|MyGroup444\" "
```

æ ¹æ®ä»£ç æœç´¢è§„åˆ™ï¼ŒAutoExpandCategories å’ŒAutoCollapseCategoriesçš„å€¼è¦ç”¨ç©ºæ ¼éš”å¼€ã€‚é¡¶å±‚ç›®å½•ä¸€å¼€å§‹é»˜è®¤å°±æ˜¯æ‰“å¼€çš„ï¼Œæ‰€ä»¥AutoExpandCategories ä¸€èˆ¬ç”¨åœ¨å­å±‚ç›®å½•ã€‚è€Œä¸”è¿˜æœ‰ä¸ªé™åˆ¶æ˜¯å¿…é¡»ä¸€çº§ä¸€çº§éƒ½æ‰“å¼€ã€‚ç›´æ¥æ‰“å¼€æœ€å­ç›®å½•è¿˜ä¸è¡Œã€‚å› æ­¤åœ¨ç¤ºä¾‹ä»£ç é‡Œå¿…é¡»è¦æŠŠä¸­é—´çš„äºŒçº§ç›®å½•"MyGroup4|MyGroup44"ä¹Ÿéƒ½å¾—å†™ä¸Šã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, AutoExpandCategories = ("MyGroup2|MyGroup22", "MyGroup4|MyGroup44","MyGroup4|MyGroup44|MyGroup444"))
class INSIDER_API UMyClass_AutoExpandCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup1")
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2")
		int Property_Group2;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2|MyGroup22")
		int Property_Group22;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup3|MyGroup33")
		int Property_Group33;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup4|MyGroup44|MyGroup444")
		int Property_Group444;
};

æºç é‡Œæœ€å¤æ‚çš„æ ·ä¾‹ï¼š
UCLASS(Config = Engine, PerObjectConfig, BlueprintType, AutoCollapseCategories = ("Data Layer|Advanced"), AutoExpandCategories = ("Data Layer|Editor", "Data Layer|Advanced|Runtime"))
class ENGINE_API UDataLayerInstance : public UObject

å¯ä»¥æ‰“å¼€å­ç›®å½•ï¼šUCLASS(Blueprintable, AutoExpandCategories = ("MyGroup2|MyGroup22", "MyGroup4|MyGroup44","MyGroup4|MyGroup44|MyGroup444"))
ä¸å¯ä»¥æ‰“å¼€å­ç›®å½•ï¼šUCLASS(Blueprintable, AutoExpandCategories = ("MyGroup2|MyGroup22", "MyGroup4|MyGroup44|MyGroup444"))
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨Saved\EditorPerProjectUserSettingsä¸­åˆ é™¤æ‰DetailCategoriesä»¥åŠDetailPropertyExpansionä¸‹çš„MyClass_AutoCollapseCategorieså€¼ä¹‹åå†ç”¨testprops class=MyClass_AutoExpandCategoriesæ¥æ‰“å¼€è¯¥çª—å£ï¼š

é€šè¿‡å¯¹æ¯”å¯ä»¥çœ‹å‡ºExpandç¡®å®å¯ä»¥è‡ªåŠ¨å±•å¼€å­ç›®å½•æ–¹ä¾¿ç«‹é©¬ç¼–è¾‘ã€‚è¦æ±‚æ˜¯AutoExpandCategories é‡Œå¡«çš„ç›®å½•è¦å’Œå±æ€§ä¸Šçš„CategoryåŒ¹é…

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\AutoExpandCategories\Untitled.png)

## åŸç†ï¼š

UClassé‡Œæå–AutoExpandCategorieså’ŒAutoCollapseCategoriesçš„å…ƒæ•°æ®æ¥åˆ¤æ–­Categoryæ˜¯å¦åº”è¯¥æ˜¾ç¤ºã€‚

```cpp
if (BaseClass->IsAutoExpandCategory(*CategoryName.ToString())		&&	!BaseClass->IsAutoCollapseCategory(*CategoryName.ToString()))
	{
		NewCategoryNode->SetNodeFlags(EPropertyNodeFlags::Expanded, true);
	}

bool UClass::IsAutoExpandCategory(const TCHAR* InCategory) const
{
	static const FName NAME_AutoExpandCategories(TEXT("AutoExpandCategories"));
	if (const FString* AutoExpandCategories = FindMetaData(NAME_AutoExpandCategories))
	{
		return !!FCString::StrfindDelim(**AutoExpandCategories, InCategory, TEXT(" "));
	}
	return false;
}

bool UClass::IsAutoCollapseCategory(const TCHAR* InCategory) const
{
	static const FName NAME_AutoCollapseCategories(TEXT("AutoCollapseCategories"));
	if (const FString* AutoCollapseCategories = FindMetaData(NAME_AutoCollapseCategories))
	{
		return !!FCString::StrfindDelim(**AutoCollapseCategories, InCategory, TEXT(" "));
	}
	return false;
}

```

# ClassGroup

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šç»„ä»¶åœ¨Actorçš„AddComponenté¢æ¿é‡Œçš„åˆ†ç»„ï¼Œä»¥åŠåœ¨è“å›¾å³é”®èœå•ä¸­çš„åˆ†ç»„ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category, Editor
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="a|b|c"
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [ClassGroupNames](../../../../Meta/DetailsPanel/ClassGroupNames.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŒ‡å®šç»„ä»¶åœ¨Actorçš„AddComponenté¢æ¿é‡Œçš„åˆ†ç»„ï¼Œä»¥åŠåœ¨è“å›¾å³é”®èœå•ä¸­çš„åˆ†ç»„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp

//ClassGroup å¿…é¡»æ˜¯BlueprintSpawnableComponentæ‰æœ‰æ•ˆ
/*
(BlueprintSpawnableComponent = , BlueprintType = true, ClassGroupNames = MyGroup|MySubGroup, IncludePath = Class/MyComponent_ClassGroup.h, IsBlueprintBase = true, ModuleRelativePath = Class/MyComponent_ClassGroup.h)
*/
UCLASS(Blueprintable,ClassGroup="MyGroup|MySubGroup", meta = (BlueprintSpawnableComponent))
class INSIDER_API UMyComponent_ClassGroup:public UActorComponent
{
	GENERATED_BODY()
public:
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨æ·»åŠ ç»„ä»¶çš„æ—¶å€™ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\ClassGroup\Untitled.png)

åœ¨è“å›¾ä¸­å³é”®AddComponentï¼Œè¯¥æµ‹è¯•åªå¯¹å¸¦æœ‰BlueprintSpawnableComponentçš„UActorComponentèµ·ä½œç”¨ï¼Œå› ä¸ºåªæœ‰BlueprintSpawnableComponentæ‰å¯åœ¨è“å›¾ä¸­åŠ¨æ€æ·»åŠ ç»„ä»¶ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\ClassGroup\Untitled%201.png)

## åŸç†ï¼š

Metadataä¸­çš„ClassGroupNamesï¼Œè¢«ä½¿ç”¨æ–¹æ³•æ˜¯UClass::GetClassGroupNamesï¼Œè¿™ä¸ªåˆæ˜¯åœ¨BlueprintComponentNodeSpawnerä¸­è¢«ä½¿ç”¨ã€‚è¿˜æœ‰ä¸€ä¸ªä½¿ç”¨åœ°æ–¹æ˜¯ComponentTypeRegistry.cppä¸­ï¼Œä¹Ÿæ˜¯åœ¨åˆ¤æ–­Componentã€‚å› æ­¤è¿™ä¸ªClassGroupç¡®å®æ˜¯åªè¢«Componentä½¿ç”¨çš„ã€‚

```cpp
static FText GetDefaultMenuCategory(const TSubclassOf<UActorComponent> ComponentClass)
	{
		TArray<FString> ClassGroupNames;
		ComponentClass->GetClassGroupNames(ClassGroupNames);

if (FKismetEditorUtilities::IsClassABlueprintSpawnableComponent(Class))
				{
					TArray<FString> ClassGroupNames;
					Class->GetClassGroupNames(ClassGroupNames);
```

# CollapseCategories

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨ç±»çš„å±æ€§é¢æ¿é‡Œéšè—æ‰€æœ‰å¸¦Categoryçš„å±æ€§ï¼Œä½†æ˜¯åªå¯¹å¸¦æœ‰å¤šä¸ªåµŒå¥—Categoryçš„å±æ€§æ‰èµ·ä½œç”¨ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_CollapseCategories](../../../../Flags/EClassFlags/CLASS_CollapseCategories.md)
- **å…³è”é¡¹ï¼š** [DontCollapseCategories](../DontCollapseCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…**

åœ¨ç±»çš„å±æ€§é¢æ¿é‡Œéšè—æ‰€æœ‰å¸¦Categoryçš„å±æ€§ï¼Œä½†æ˜¯åªå¯¹å¸¦æœ‰å¤šä¸ªåµŒå¥—Categoryçš„å±æ€§æ‰èµ·ä½œç”¨ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
ClassFlags: CLASS_MatchedSerializers | CLASS_Native | CLASS_CollapseCategories | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed
*/
UCLASS(Blueprintable, CollapseCategories)
class INSIDER_API UMyClass_CollapseCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup1")
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2|MyGroup22")
		int Property_Group22;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup3|MyGroup33|MyGroup333")
		int Property_Group333;
};

/*
ClassFlags: CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
*/
UCLASS(Blueprintable, dontCollapseCategories)
class INSIDER_API UMyClass_DontCollapseCategories :public UMyClass_CollapseCategories
{
	GENERATED_BODY()
public:
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

ç¬¬ä¸€ä¸ªæ˜¯UMyClass_CollapseCategories çš„æ•ˆæœï¼Œç¬¬äºŒä¸ªæ˜¯UMyClass_DontCollapseCategories çš„æ•ˆæœï¼Œå¯è§ä¸€äº›å±æ€§è¢«éšè—äº†èµ·æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\CollapseCategories\Untitled.png)

## åŸç†ï¼š

```cpp
if (Specifier == TEXT("collapseCategories"))
{
	// Class' properties should not be shown categorized in the editor.
	ClassFlags |= CLASS_CollapseCategories;
}
else if (Specifier == TEXT("dontCollapseCategories"))
{
	// Class' properties should be shown categorized in the editor.
	ClassFlags &= ~CLASS_CollapseCategories;
}
```

# ComponentWrapperClass

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šè¯¥ç±»ä¸ºä¸€ä¸ªç®€å•çš„å°è£…ç±»ï¼Œå¿½ç•¥æ‰å­ç±»çš„Categoryç›¸å…³è®¾ç½®ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [IgnoreCategoryKeywordsInSubclasses](../../../../Meta/DetailsPanel/IgnoreCategoryKeywordsInSubclasses.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…**

æŒ‡å®šè¯¥ç±»ä¸ºä¸€ä¸ªç®€å•çš„å°è£…ç±»ï¼Œå¿½ç•¥æ‰å­ç±»çš„Categoryç›¸å…³è®¾ç½®ã€‚

å¦‚åå­—æ‰€è¯´ï¼Œä¸ºä¸€ä¸ªç»„ä»¶çš„åŒ…è£…ç±»ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªActorç®€å•çš„åªåŒ…å«ä¸€ä¸ªComponentã€‚è¿™ç§ç®€å•çš„åŒ…è£…å…³ç³»ï¼Œå…¸å‹çš„ä¾‹å­æ˜¯ALightåŒ…è£…ULightComponentï¼ŒASkeletalMeshActoråŒ…è£…USkeletalMeshComponentã€‚

æ§åˆ¶å­ç±»ä¸Šé¢å®šä¹‰çš„hideCategorieså’ŒshowCategorieséƒ½è¢«å¿½ç•¥ï¼Œè€Œç›´æ¥é‡‡ç”¨åŸºç±»ä¸Šçš„ç›®å½•å®šä¹‰ï¼Œä¹Ÿå°±æ˜¯æœ¬ç»„ä»¶åŒ…è£…ç±»ä¸Šçš„ç›®å½•è®¾ç½®ã€‚å½“å‰æºç é‡Œåªæœ‰BlueprintEditorUtils.cppåœ¨ç”¨ï¼Œè€Œè¿™æ˜¯è“å›¾æ‰“å¼€çš„è¿‡ç¨‹ï¼Œå› æ­¤è¿™ä¸ªåªæœ‰åœ¨åŒå‡»æ‰“å¼€ä¸€ä¸ªè“å›¾çš„æ—¶å€™æ‰èµ·ä½œç”¨ã€‚æ™®é€šçš„UObjectç±»ï¼Œç›´æ¥ç”¨testpropsåˆ›å»ºçš„çª—å£ï¼Œå› ä¸ºä¸æ˜¯åŒå‡»æ‰“å¼€è“å›¾ï¼Œå› æ­¤æ˜¯æ— æ³•ç”Ÿæ•ˆçš„ã€‚

ComponentWrapperClassåœ¨æºç é‡Œæœäº†ä¸€ä¸‹ï¼Œåªæœ‰ä¸€äº›Actoråœ¨ç”¨ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType, ComponentWrapperClass, hideCategories = MyGroup3)	//ä¾ç„¶ä¼šæ˜¾ç¤ºå‡ºProperty_Group3
class AMyActor_ComponentWrapperClass : public AActor
{
	GENERATED_UCLASS_BODY()
public:
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
		class UPointLightComponent* PointLightComponent;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup3)
		int Property_Group3;
};

UCLASS(Blueprintable, BlueprintType, hideCategories = MyGroup3)
class AMyActor_NoComponentWrapperClass : public AActor //Property_Group3ä¼šè¢«éšè—
{
	GENERATED_UCLASS_BODY()
public:
	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
		class UPointLightComponent* PointLightComponent;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup3)
		int Property_Group3;
};
```

## å­ç±»çš„å®é™…ä½œç”¨æ•ˆæœï¼š

å­ç±»é‡Œçš„MyGroup3å³ä½¿è¢«éšè—äº†èµ·æ¥ï¼Œä¹Ÿè¿˜æ˜¯æ˜¾ç¤ºäº†å‡ºæ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\ComponentWrapperClass\Untitled.png)

## åŸç†ï¼š

ComponentWrapperClasså®é™…ä¼šé€ æˆIgnoreCategoryKeywordsInSubclasses=trueçš„å…ƒæ•°æ®æ·»åŠ ã€‚å› æ­¤åœ¨æœ‰äº†IgnoreCategoryKeywordsInSubclasseså…ƒæ•°æ®ä¹‹åï¼Œå°±ä¸ä¼šåˆ¤æ–­ä¹‹åçš„ShowCategoriesç­‰è®¾ç½®äº†ã€‚

å½“å‰æºç é‡Œåªæœ‰BlueprintEditorUtils.cppåœ¨ç”¨ï¼Œè€Œè¿™æ˜¯è“å›¾æ‰“å¼€çš„è¿‡ç¨‹ï¼Œå› æ­¤è¿™ä¸ªåªæœ‰åœ¨åŒå‡»æ‰“å¼€ä¸€ä¸ªè“å›¾çš„æ—¶å€™æ‰èµ·ä½œç”¨ã€‚æ™®é€šçš„UObjectç±»ï¼Œç›´æ¥ç”¨testpropsåˆ›å»ºçš„çª—å£ï¼Œå› ä¸ºä¸æ˜¯åŒå‡»æ‰“å¼€è“å›¾ï¼Œå› æ­¤æ˜¯æ— æ³•ç”Ÿæ•ˆçš„ã€‚

```cpp
case EClassMetadataSpecifier::ComponentWrapperClass:
	MetaData.Add(NAME_IgnoreCategoryKeywordsInSubclasses, TEXT("true"));    //"IgnoreCategoryKeywordsInSubclasses"
	break;
////////////////////////////////////////////////////////////////////////////////
E:\P4V\Engine\Source\Editor\UnrealEd\Private\Kismet2\BlueprintEditorUtils.cpp
void FBlueprintEditorUtils::RecreateClassMetaData(UBlueprint* Blueprint, UClass* Class, bool bRemoveExistingMetaData)

if (!ParentClass->HasMetaData(FBlueprintMetadata::MD_IgnoreCategoryKeywordsInSubclasses)) //å¦‚æœæ²¡æœ‰è¿™ä¸ªè®¾ç½®
		{
			// we want the categories just as they appear in the parent class 
			// (set bHomogenize to false) - especially since homogenization 
			// could inject spaces

			//ä»¥ä¸‹è¿™äº›æ“ä½œæ˜¯å½“æ²¡æœ‰è¿™ä¸ªè®¾ç½®çš„æ—¶å€™ï¼Œå­ç±»ä¼šç»§æ‰¿çˆ¶ç±»çš„ç›®å½•è®¾ç½®ã€‚
			FEditorCategoryUtils::GetClassHideCategories(ParentClass, AllHideCategories, /*bHomogenize =*/false);
			if (ParentClass->HasMetaData(TEXT("ShowCategories")))
			{
				Class->SetMetaData(TEXT("ShowCategories"), *ParentClass->GetMetaData("ShowCategories"));
			}
			if (ParentClass->HasMetaData(TEXT("AutoExpandCategories")))
			{
				Class->SetMetaData(TEXT("AutoExpandCategories"), *ParentClass->GetMetaData("AutoExpandCategories"));
			}
			if (ParentClass->HasMetaData(TEXT("AutoCollapseCategories")))
			{
				Class->SetMetaData(TEXT("AutoCollapseCategories"), *ParentClass->GetMetaData("AutoCollapseCategories"));
			}
			if (ParentClass->HasMetaData(TEXT("PrioritizeCategories")))
			{
				Class->SetMetaData(TEXT("PrioritizeCategories"), *ParentClass->GetMetaData("PrioritizeCategories"));
			}
		}
```

# DontAutoCollapseCategories

- **åŠŸèƒ½æè¿°ï¼š**  ä½¿åˆ—å‡ºçš„ç±»åˆ«çš„ç»§æ‰¿è‡ªçˆ¶ç±»çš„AutoCollapseCategoriesè¯´æ˜ç¬¦æ— æ•ˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings="aï¼Œbï¼Œc"
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å»é™¤[AutoCollapseCategories](../../../Meta/DetailsPanel/AutoCollapseCategories.md)
- **å…³è”é¡¹ï¼š** [AutoCollapseCategories](AutoCollapseCategories/AutoCollapseCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

æ ¹æ®ä»£ç ï¼Œåªæ˜¯ç®€å•çš„ç§»é™¤AutoCollapseCategoriesï¼Œå’ŒAutoExpandCategoriesçš„åŒºåˆ«å°±æ˜¯ä¸ä¼šè‡ªåŠ¨åŠ ä¸€ä¸ªå±•å¼€ã€‚åœ¨æºç é‡Œæœäº†ä¸€ä¸‹ï¼Œå¹¶æ²¡æœ‰ä½¿ç”¨åˆ°ã€‚è€Œä¸”å½“å‰çš„æºç å®ç°æœ‰bugï¼Œåšä¸åˆ°å»é™¤ã€‚

```cpp
case EClassMetadataSpecifier::AutoExpandCategories:

	FHeaderParser::RequireSpecifierValue(*this, PropSpecifier);

	for (FString& Value : PropSpecifier.Values)
	{
		AutoCollapseCategories.RemoveSwap(Value);
		AutoExpandCategories.AddUnique(MoveTemp(Value));
	}
	break;

case EClassMetadataSpecifier::AutoCollapseCategories:

	FHeaderParser::RequireSpecifierValue(*this, PropSpecifier);

	for (FString& Value : PropSpecifier.Values)
	{
		AutoExpandCategories.RemoveSwap(Value);
		AutoCollapseCategories.AddUnique(MoveTemp(Value));
	}
	break;
case EClassMetadataSpecifier::DontAutoCollapseCategories:

	FHeaderParser::RequireSpecifierValue(*this, PropSpecifier);

	for (const FString& Value : PropSpecifier.Values)
	{
			AutoCollapseCategories.RemoveSwap(Value);//å½“å‰AutoCollapseCategoriesçš„å€¼è¿˜æ˜¯ç©ºçš„ã€‚å»é™¤æ˜¯æ²¡æœ‰ç”¨çš„
	}
	break;

æ”¹åŠ¨ï¼š
FUnrealClassDefinitionInfo::MergeClassCategories()æ”¾æœ€åï¼š
// Merge DontAutoCollapseCategories and AutoCollapseCategories
	for (const FString& Value : DontAutoCollapseCategories)
	{
		AutoCollapseCategories.RemoveSwap(Value);
	}
	DontAutoCollapseCategories.Empty();

æ”¹ä¸ºï¼š
case EClassMetadataSpecifier::DontAutoCollapseCategories:

			FHeaderParser::RequireSpecifierValue(*this, PropSpecifier);

			for (FString& Value : PropSpecifier.Values)
			{
				DontAutoCollapseCategories.AddUnique(MoveTemp(Value));
				//AutoCollapseCategories.RemoveSwap(Value);
			}
			break;
```

# DontCollapseCategories

- **åŠŸèƒ½æè¿°ï¼š**  ä½¿ç»§æ‰¿è‡ªåŸºç±»çš„CollapseCatogoriesè¯´æ˜ç¬¦æ— æ•ˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å»é™¤[CLASS_CollapseCategories](../../../Flags/EClassFlags/CLASS_CollapseCategories.md)
- **å…³è”é¡¹ï¼š** [CollapseCategories](CollapseCategories/CollapseCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…**

ç†è®ºä¸Šæ˜¯å»é™¤ç±»æ ‡å¿—ä¸Šçš„CLASS_CollapseCategoriesæ ‡å¿—ã€‚å¯ä»¥é‡æ–°æ‰“å¼€æ‰€æœ‰çš„å±æ€§æ˜¾ç¤ºã€‚

# HideCategories

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œéšè—æŸäº›Categoryçš„å±æ€§ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **å…³è”é¡¹ï¼š** [ShowCategories](../ShowCategories/ShowCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…**

åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œéšè—æŸäº›Categoryçš„å±æ€§ã€‚

æ³¨æ„ï¼Œè¦å…ˆåœ¨ç±»é‡Œå®šä¹‰å±æ€§ç„¶åè®¾ç½®å®ƒçš„Categoryã€‚HideCategoriesçš„ä¿¡æ¯ä¼šè¢«UHTåˆ†æï¼Œå¹¶ä¿å­˜åˆ°UClassçš„å…ƒæ•°æ®é‡Œå»ã€‚HideCategoriesçš„ä¿¡æ¯å¯ä»¥è¢«å­ç±»ç»§æ‰¿ä¸‹æ¥ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, hideCategories = MyGroup1)
class INSIDER_API UMyClass_HideCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup1)
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2 | MyGroup3")
		int Property_Group23;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
};

/*
(BlueprintType = true, HideCategories = MyGroup2 | MyGroup3, IncludePath = Class/Display/MyClass_ShowCategories.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_ShowCategories.h)
*/

UCLASS(Blueprintable, showCategories = MyGroup1, hideCategories = "MyGroup2 | MyGroup3")
class INSIDER_API UMyClass_HideCategoriesChild :public UMyClass_ShowCategories
{
	GENERATED_BODY()
public:

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2")
		int Property_Group2;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup3")
		int Property_Group3;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup4)
		int Property_Group4;
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

æ³¨æ„è¿™é‡Œï¼Œå•ç‹¬çš„MyGroup2å’ŒMyGroup3ä¹Ÿéƒ½æ²¡æœ‰æ˜¾ç¤ºã€‚æ‰€ä»¥åˆ¤æ–­çš„æ ‡å‡†åªè¦ç›®å½•ç¬¦åˆæŸä¸ªç›®å½•åå­—åŒ¹é…å°±è¡Œã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\HideCategories\Untitled.png)

## åŸç†ï¼š

åœ¨GetClassHideCategoriesä¸­æ£€æŸ¥ClassHideCategoriesMetaKeyå…ƒæ•°æ®ã€‚

```cpp
void  FEditorCategoryUtils::GetClassShowCategories(const UStruct* Class, TArray<FString>& CategoriesOut)
{
	CategoriesOut.Empty();

	using namespace FEditorCategoryUtilsImpl;
	if (Class->HasMetaData(ClassShowCategoriesMetaKey))
	{
		const FString& ShowCategories = Class->GetMetaData(ClassShowCategoriesMetaKey);
		ShowCategories.ParseIntoArray(CategoriesOut, TEXT(" "), /*InCullEmpty =*/true);

		for (FString& Category : CategoriesOut)
		{
			Category = GetCategoryDisplayString(FText::FromString(Category)).ToString();
		}
	}
}

void FEditorCategoryUtils::GetClassHideCategories(const UStruct* Class, TArray<FString>& CategoriesOut, bool bHomogenize)
{
	CategoriesOut.Empty();

	using namespace FEditorCategoryUtilsImpl;
	if (Class->HasMetaData(ClassHideCategoriesMetaKey))
	{
		const FString& HideCategories = Class->GetMetaData(ClassHideCategoriesMetaKey);

		HideCategories.ParseIntoArray(CategoriesOut, TEXT(" "), /*InCullEmpty =*/true);
		
		if (bHomogenize)
		{
			for (FString& Category : CategoriesOut)
			{
				Category = GetCategoryDisplayString(Category);
			}
		}
	}
}
```

# PrioritizeCategories

- **åŠŸèƒ½æè¿°ï¼š**  æŠŠæŒ‡å®šçš„å±æ€§ç›®å½•ä¼˜å…ˆæ˜¾ç¤ºåœ¨ç»†èŠ‚é¢æ¿çš„å‰é¢ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [PrioritizeCategories](../../../../Meta/DetailsPanel/PrioritizeCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŠŠæŒ‡å®šçš„å±æ€§ç›®å½•ä¼˜å…ˆæ˜¾ç¤ºåœ¨ç»†èŠ‚é¢æ¿çš„å‰é¢ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, PrioritizeCategories= ("MyGroup3|MyGroup33|MyGroup333","MyGroup1"))
class INSIDER_API UMyClass_PrioritizeCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup1")
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2|MyGroup22")
		int Property_Group22;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup3|MyGroup33|MyGroup333")
		int Property_Group333;
};
```

## ç¤ºä¾‹ç»“æœï¼š

å¯è§Property_Group333æ’åˆ°äº†æœ€å‰é¢ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\PrioritizeCategories\Untitled.png)

## åŸç†ï¼š

åœ¨UClass::GetPrioritizeCategories(TArray<FString>& OutPrioritizedCategories)ä¸­è·å–ä¼˜å…ˆçº§ç›®å½•ã€‚åŸç†æ˜¯æŒ‰ç…§æŒ‡å®šçš„é¡ºåºæ”¾åˆ°SortedCategoriesé‡Œï¼Œæ‰€ä»¥å°±ä¼šè¢«é¦–å…ˆåˆ›å»ºå‡ºå±æ€§ç›®å½•æ¥ã€‚

```cpp
TArray<FString> ClassPrioritizeCategories;
Class->GetPrioritizeCategories(ClassPrioritizeCategories);
for (const FString& ClassPrioritizeCategory : ClassPrioritizeCategories)
{
	FName PrioritizeCategoryName = FName(ClassPrioritizeCategory);
	SortedCategories.AddUnique(PrioritizeCategoryName);
	PrioritizeCategories.AddUnique(PrioritizeCategoryName);
}

```

# ShowCategories

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œæ˜¾ç¤ºæŸäº›Categoryçš„å±æ€§ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Category
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=(abcï¼Œ"d|e"ï¼Œ"x|y|z")
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [HideCategories](../../../../Meta/DetailsPanel/HideCategories.md)
- **å…³è”é¡¹ï¼š** [HideCategories](../HideCategories/HideCategories.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

åœ¨ç±»çš„ClassDefaultså±æ€§é¢æ¿é‡Œæ˜¾ç¤ºæŸäº›Categoryçš„å±æ€§ã€‚ä½¿åˆ—å‡ºçš„ç±»åˆ«çš„ç»§æ‰¿è‡ªåŸºç±»çš„HideCategoriesè¯´æ˜ç¬¦æ— æ•ˆã€‚

ShowCategoriesä¼šè¢«UHTåˆ†æï¼Œä½†ä¸ä¼šè¢«ä¿å­˜åˆ°UClassçš„å…ƒæ•°æ®é‡Œå»ã€‚å®ƒä½œç”¨çš„æ–¹å¼æ˜¯å¯ä»¥æŠ¹å»ä¹‹å‰åŸºç±»è®¾ç½®çš„HideCategoriesçš„å±æ€§ã€‚ShowCategorieså¯ä»¥è¢«å­ç±»ç»§æ‰¿ä¸‹æ¥ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
(BlueprintType = true, HideCategories = MyGroup1, IncludePath = Class/Display/MyClass_ShowCategories.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_ShowCategories.h)
*/
UCLASS(Blueprintable, hideCategories = MyGroup1)
class INSIDER_API UMyClass_ShowCategories :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup1)
		int Property_Group1;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2 | MyGroup3")
		int Property_Group23;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int Property_NotInGroup;
};

/*
(BlueprintType = true, HideCategories = MyGroup2 | MyGroup3, IncludePath = Class/Display/MyClass_ShowCategories.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_ShowCategories.h)
*/

UCLASS(Blueprintable, showCategories = MyGroup1, hideCategories = "MyGroup2 | MyGroup3")
class INSIDER_API UMyClass_ShowCategoriesChild :public UMyClass_ShowCategories
{
	GENERATED_BODY()
public:

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup2")
		int Property_Group2;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MyGroup3")
		int Property_Group3;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MyGroup4)
		int Property_Group4;
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Category\ShowCategories\Image\Untitled.png)

## åŸç†ï¼š

å…¶å®å®é™…ä¸ŠUHTä¿å­˜çš„åªåœ¨HideCategoriesé‡Œï¼Œè¿™ç‚¹é€šè¿‡å¯¹ç±»çš„å…ƒæ•°æ®æŸ¥çœ‹å°±å¯çŸ¥ã€‚

```cpp
void  FEditorCategoryUtils::GetClassShowCategories(const UStruct* Class, TArray<FString>& CategoriesOut)
{
	CategoriesOut.Empty();

	using namespace FEditorCategoryUtilsImpl;
	if (Class->HasMetaData(ClassShowCategoriesMetaKey))
	{
		const FString& ShowCategories = Class->GetMetaData(ClassShowCategoriesMetaKey);
		ShowCategories.ParseIntoArray(CategoriesOut, TEXT(" "), /*InCullEmpty =*/true);

		for (FString& Category : CategoriesOut)
		{
			Category = GetCategoryDisplayString(FText::FromString(Category)).ToString();
		}
	}
}

void FEditorCategoryUtils::GetClassHideCategories(const UStruct* Class, TArray<FString>& CategoriesOut, bool bHomogenize)
{
	CategoriesOut.Empty();

	using namespace FEditorCategoryUtilsImpl;
	if (Class->HasMetaData(ClassHideCategoriesMetaKey))
	{
		const FString& HideCategories = Class->GetMetaData(ClassHideCategoriesMetaKey);

		HideCategories.ParseIntoArray(CategoriesOut, TEXT(" "), /*InCullEmpty =*/true);
		
		if (bHomogenize)
		{
			for (FString& Category : CategoriesOut)
			{
				Category = GetCategoryDisplayString(Category);
			}
		}
	}
}
```

# Config

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šé…ç½®æ–‡ä»¶çš„åå­—ï¼ŒæŠŠè¯¥å¯¹è±¡çš„å€¼ä¿å­˜åˆ°inié…ç½®æ–‡ä»¶ä¸­ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **ä½œç”¨æœºåˆ¶ï¼š** Configæ–‡ä»¶åå­˜åœ¨FName UClass::ClassConfigNameè¿™ä¸ªå‚æ•°é‡Œ
- **å…³è”é¡¹ï¼š** [PerObjectConfig](PerObjectConfig.md)ã€[ConfigDoNotCheckDefaults](ConfigDoNotCheckDefaults.md)ã€[DefaultConfig](DefaultConfig/DefaultConfig.md)ã€[GlobalUserConfig](GlobalUserConfig/GlobalUserConfig.md)ã€[ProjectUserConfig](ProjectUserConfig/ProjectUserConfig.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šé…ç½®æ–‡ä»¶çš„åå­—ï¼ŒæŠŠè¯¥å¯¹è±¡çš„å€¼ä¿å­˜åˆ°inié…ç½®æ–‡ä»¶ä¸­ã€‚

- ä¸€æ•´ä¸ªç±»åœ¨iniä¸­åªæœ‰ä¸€ä¸ªèŠ‚çš„å€¼ï¼Œå› æ­¤ä¸€èˆ¬æ˜¯ä¿å­˜çš„CDOå¯¹è±¡ï¼Œä½†ä¹Ÿå¯ä»¥ç”¨æ™®é€šå¯¹è±¡ã€‚
- Configæ–‡ä»¶åç§°çš„å…ƒæ•°æ®å€¼ä¿å­˜åœ¨FName UClass::ClassConfigNameã€‚
- é»˜è®¤æ˜¯ä¿å­˜åœ¨Saved/XXX.iniçš„Localæ–‡ä»¶ä¸­ã€‚
- æ­¤è¯´æ˜ç¬¦ä¼šä¼ æ’­åˆ°æ‰€æœ‰å­ç±»å¹¶ä¸”æ— æ³•ä½¿æ­¤è¯´æ˜ç¬¦æ— æ•ˆï¼Œä½†æ˜¯å­ç±»å¯é€šè¿‡é‡æ–°å£°æ˜configè¯´æ˜ç¬¦å¹¶æä¾›ä¸åŒçš„ConfigNameæ¥æ›´æ”¹é…ç½®æ–‡ä»¶ã€‚
- å¸¸è§çš„ConfigNameå€¼æ˜¯â€œEngineâ€ã€â€œEditorâ€ã€â€œInputâ€å’Œâ€œGameâ€ã€‚
- å¯ä»¥è‡ªå·±æ‰‹åŠ¨è°ƒç”¨SaveConfigå’ŒLoadConfigæ¥è¯»å†™é…ç½®å€¼ã€‚CDOçš„å€¼ä¼šè¢«å¼•æ“è‡ªå·±çš„ä»é…ç½®ä¸­è¯»å–è€Œæ›´æ–°ã€‚
- æƒ³ä¿å­˜åˆ°é…ç½®æ–‡ä»¶é‡Œçš„å±æ€§è¦ç›¸åº”çš„ç”¨UPROPERTY(config)ä¿®é¥°ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Config = Game)
class INSIDER_API UMyClass_Config :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;
};

//æµ‹è¯•ä»£ç 
UMyClass_Config* testObject = NewObject<UMyClass_Config>(GetTransientPackage(),TEXT("testObject"));
testObject->SaveConfig();

//ç”Ÿæˆ
\Hello\Saved\Config\WindowsEditor\Game.ini
[/Script/Insider.MyClass_Config]
MyPropertyWithConfig=123
```

## åŸç†ï¼š

åœ¨å¼•æ“å¯åŠ¨çš„æ—¶å€™UObjectLoadAllCompiledInDefaultPropertiesä¼šåŠ è½½æ‰€æœ‰Classçš„CDOï¼Œåœ¨å¤šä¸ªè°ƒç”¨é“¾æ¡ä¹‹åä¼šè‡ªåŠ¨çš„è°ƒç”¨CDOçš„LoadConfigæ¥åˆå§‹åŒ–CDOçš„å€¼ã€‚

```cpp
static void UObjectLoadAllCompiledInDefaultProperties(TArray<UClass*>& OutAllNewClasses)
{
	for (UClass* Class : NewClasses)
	{
		UE_LOG(LogUObjectBootstrap, Verbose, TEXT("GetDefaultObject Begin %s %s"), *Class->GetOutermost()->GetName(), *Class->GetName());
		Class->GetDefaultObject();
		UE_LOG(LogUObjectBootstrap, Verbose, TEXT("GetDefaultObject End %s %s"), *Class->GetOutermost()->GetName(), *Class->GetName());
	}
}
```

# ConfigDoNotCheckDefaults

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šåœ¨ä¿å­˜é…ç½®å€¼çš„æ—¶å€™å¿½ç•¥ä¸Šä¸€çº§çš„é…ç½®å€¼çš„ä¸€è‡´æ€§æ£€æŸ¥ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_ConfigDoNotCheckDefaults](../../../Flags/EClassFlags/CLASS_ConfigDoNotCheckDefaults.md)
- **å…³è”é¡¹ï¼š** [Config](Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

æŒ‡å®šåœ¨ä¿å­˜é…ç½®å€¼çš„æ—¶å€™å¿½ç•¥ä¸Šä¸€çº§çš„é…ç½®å€¼çš„ä¸€è‡´æ€§æ£€æŸ¥ã€‚

- åœ¨ä¿å­˜é…ç½®çš„æ—¶å€™ï¼Œå†³å®šæ˜¯å¦è¦å…ˆæ ¹æ®Baseæˆ–Defaultçš„é…ç½®æ¥æ£€æŸ¥å±æ€§æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸€è‡´å°±ä¸ç”¨åºåˆ—åŒ–å†™å…¥ä¸‹æ¥ã€‚ä½†åŠ ä¸Šè¿™ä¸ªæ ‡å¿—åï¼Œå³ä½¿åŒä¸Šä¸€ä¸ªå±‚çº§çš„é…ç½®å€¼ç›¸åŒä¹Ÿæ— è®ºå¦‚ä½•éƒ½è¦ä¿å­˜ä¸‹æ¥ã€‚

UCLASS(config=XXX,configdonotcheckdefaults)ï¼šè¡¨ç¤ºè¿™ä¸ªç±»å¯¹åº”çš„é…ç½®æ–‡ä»¶ä¸ä¼šæ£€æŸ¥XXXå±‚çº§ä¸Šå±‚çš„DefaultXXXé…ç½®æ–‡ä»¶æ˜¯å¦æœ‰è¯¥ä¿¡æ¯ï¼ˆåé¢ä¼šè§£é‡Šå±‚çº§ï¼‰ï¼Œå°±ç›´æ¥å­˜å‚¨åˆ°Savedç›®å½•ä¸‹ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Config = Game)
class INSIDER_API UMyClass_Config :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;
};

UCLASS(Config = Game,configdonotcheckdefaults)
class INSIDER_API UMyClass_ConfigDoNotCheckDefaults :public UMyClass_Config
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfigSub = 123;
};

UCLASS(Config = Game)
class INSIDER_API UMyClass_ConfigDefaultChild :public UMyClass_Config
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfigSub = 123;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

```cpp
void UMyClass_Config_Test::TestConfigCheckDefaultSave()
{
	auto* testObject = NewObject<UMyClass_ConfigDoNotCheckDefaults>(GetTransientPackage(), TEXT("testObjectCheckDefault"));
	auto* testObject2 = NewObject<UMyClass_ConfigDefaultChild>(GetTransientPackage(), TEXT("testObjectDefaultChild"));

	testObject->SaveConfig();
	testObject2->SaveConfig();
}

ç”Ÿæˆï¼š
[/Script/Insider.MyClass_Config]
MyPropertyWithConfig=777

[/Script/Insider.MyClass_ConfigDoNotCheckDefaults]
MyPropertyWithConfigSub=123
MyPropertyWithConfig=777

[/Script/Insider.MyClass_ConfigDefaultChild]
MyPropertyWithConfigSub=123
```

ç”±æ­¤å¯è§ï¼ŒMyClass_ConfigDoNotCheckDefaultsä¸­çš„MyPropertyWithConfigçš„å€¼é»˜è®¤è·ŸUMyClass_Configä¸­çš„777å€¼ä¸€è‡´ï¼Œä½†æ˜¯ä¾ç„¶ä¼šå†™å…¥è¿›æ¥ã€‚åœ¨MyClass_ConfigDefaultChildç±»ä¸­ï¼ŒMyPropertyWithConfigçš„å€¼å› ä¸ºæ²¡æœ‰æ”¹å˜ï¼Œå°±ä¼šè¢«ç•¥è¿‡ã€‚

åœ¨æºç é‡Œæœconfigdonotcheckdefaultsçš„æ—¶å€™å‘ç°å¸¸å¸¸å’Œdefaultconfigé…åˆä½¿ç”¨ã€‚ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨configdonotcheckdefaultsï¼Ÿæ„Ÿè§‰æ˜¯ä¸ºäº†ä¿æŒè‡ªå·±çš„å®Œæ•´æ€§ï¼Œæ— è®ºå¦‚ä½•éƒ½è¦å…¨éƒ¨å†™å…¥è¿›å»ã€‚åœ¨defaultConfigçš„æ—¶å€™ï¼Œå°±å¯ä»¥ä¸ç®¡Baseé‡Œçš„å€¼ï¼Œéƒ½å†™å…¥ä¸€ä»½åˆ°Defaulté…ç½®é‡Œï¼Œè¿™æ ·åœ¨ç¼–è¾‘ä¸Šæ›´åŠ çš„å®Œæ•´ã€‚

## åŸç†ï¼š

```cpp
const bool bShouldCheckIfIdenticalBeforeAdding = !GetClass()->HasAnyClassFlags(CLASS_ConfigDoNotCheckDefaults) && !bPerObject && bIsPropertyInherited;
//ç®€å•çš„ç¤ºä¾‹åˆ¤æ–­
if (!bPropDeprecated && (!bShouldCheckIfIdenticalBeforeAdding || !Property->Identical_InContainer(this, SuperClassDefaultObject, Index)))
{
	FString	Value;
	Property->ExportText_InContainer( Index, Value, this, this, this, PortFlags );
	Config->SetString( *Section, *Key, *Value, PropFileName );
}
else
{
	// If we are not writing it to config above, we should make sure that this property isn't stagnant in the cache.
	Config->RemoveKey( *Section, *Key, PropFileName );
}
```

# DefaultConfig

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯Project/Config/DefaultXXX.iniã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_DefaultConfig](../../../../Flags/EClassFlags/CLASS_DefaultConfig.md)
- **å…³è”é¡¹ï¼š** [Config](../Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯Project/Config/DefaultXXX.iniã€‚

- è€Œä¸æ˜¯é»˜è®¤çš„Saved/XXX.ini
- ä¸€èˆ¬ç”¨åœ¨ç¼–è¾‘å™¨é‡ŒæŠŠSettingsè‡ªåŠ¨ä¿å­˜åˆ°Project/Config/DefaultXXX.inié‡Œå»

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Config = MyGame,DefaultConfig)
class INSIDER_API UMyClass_DefaultConfig :public UDeveloperSettings
{
	GENERATED_BODY()
public:
	/** Gets the settings container name for the settings, either Project or Editor */
	virtual FName GetContainerName() const override { return TEXT("Project"); }
	/** Gets the category for the settings, some high level grouping like, Editor, Engine, Game...etc. */
	virtual FName GetCategoryName() const override { return TEXT("MyGame"); }
	/** The unique name for your section of settings, uses the class's FName. */
	virtual FName GetSectionName() const override { return TEXT("MyGame"); }
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;
};

//ä¿å­˜çš„ç»“æœï¼š
//Config/DefaultMyGame.ini
[/Script/Insider.MyClass_DefaultConfig]
MyPropertyWithConfig=888

```

## ç¤ºä¾‹ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Config\DefaultConfig\Untitled.png)

## åŸç†ï¼š

ä»£ç é‡Œè¦ä½¿ç”¨Settings->TryUpdateDefaultConfigFile();ï¼Œä½†å‘ç°TryUpdateDefaultConfigFileä¸ç®¡æœ‰æ²¡æœ‰DefaultConfigéƒ½å¯ä»¥è°ƒç”¨ï¼Œéƒ½å¯ä»¥ä¿å­˜åˆ°Defaulté‡Œã€‚å› æ­¤åº”è¯¥è°ƒç”¨å“ªä¸ªSaveConfigï¼ˆTryUpdateDefaultConfigFileï¼ŒUpdateGlobalUserConfigFileï¼ŒUpdateProjectUserConfigFileï¼‰æ˜¯å¯ä»¥æ‰‹åŠ¨æŒ‡å®šçš„ã€‚

ä½†æ˜¯åœ¨ç¼–è¾‘å™¨é‡Œç¼–è¾‘çš„æ—¶å€™ï¼Œåˆ™å¯ä»¥é€šè¿‡å†™å¥½çš„ä»£ç æ¥å¤„ç†å¥½é€»è¾‘ã€‚å¦‚SSettingsEditor.cppé‡ŒNotifyPostChangeä¸­è°ƒç”¨Section->Save();åˆ™å¯ä»¥åœ¨å†…éƒ¨å†è°ƒç”¨å¦‚ä¸‹ä»£ç ï¼š

```cpp
bool FSettingsSection::Save()
{
	if (ModifiedDelegate.IsBound() && !ModifiedDelegate.Execute())
	{
		return false;
	}

	if (SaveDelegate.IsBound())
	{
		return SaveDelegate.Execute();
	}

	//æ›´æ–°åˆ°æ­£ç¡®çš„æ–‡ä»¶é‡Œ
	if (SettingsObject.IsValid())
	{
		if (SettingsObject->GetClass()->HasAnyClassFlags(CLASS_DefaultConfig))
		{
			SettingsObject->TryUpdateDefaultConfigFile();
		}
		else if (SettingsObject->GetClass()->HasAnyClassFlags(CLASS_GlobalUserConfig))
		{
			SettingsObject->UpdateGlobalUserConfigFile();
		}
		else if (SettingsObject->GetClass()->HasAnyClassFlags(CLASS_ProjectUserConfig))
		{
			SettingsObject->UpdateProjectUserConfigFile();
		}
		else
		{
			SettingsObject->SaveConfig();
		}

		return true;
	}

	return false;
}
```

# EditorConfig

- **åŠŸèƒ½æè¿°ï¼š**  ç”¨æ¥åœ¨ç¼–è¾‘å™¨çŠ¶æ€ä¸‹ä¿å­˜ä¿¡æ¯ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config, Editor
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [EditorConfig](../../../../Meta/Config/EditorConfig.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

ç”¨æ¥åœ¨ç¼–è¾‘å™¨çŠ¶æ€ä¸‹ä¿å­˜ä¿¡æ¯ã€‚

ä¸€èˆ¬ç”¨åœ¨EditorTargetçš„Moduleé‡Œï¼Œç”¨äºé…ç½®ç›¸åº”ç¼–è¾‘å™¨çš„ä¿¡æ¯ï¼Œæ¯”å¦‚åˆ—å®½ï¼Œæ”¶è—å¤¹ä¹‹ç±»çš„ï¼Œç”¨jsonä¿å­˜ã€‚

ä¿å­˜åœ¨ï¼šC:\Users\{user name}\AppData\Local\UnrealEngine\Editorã€‚å½“å‰æœ‰ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Config\EditorConfig\Untitled.png)

åœ¨æºç é‡Œæœç´¢åï¼Œä½¿ç”¨çš„æ—¶å€™å¿…é¡»ç»§æ‰¿äºåŸºç±»ï¼š

```cpp
/** Inherit from this class to simplify saving and loading properties from editor configs. */
UCLASS()
class EDITORCONFIG_API UEditorConfigBase : public UObject
{
	GENERATED_BODY()

public:

	/** Load any properties of this class into properties marked with metadata tag "EditorConfig" from the class's EditorConfig */
	bool LoadEditorConfig();

	/** Save any properties of this class in properties marked with metadata tag "EditorConfig" into the class's EditorConfig. */
	bool SaveEditorConfig() const;
};
```

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(EditorConfig = "MyEditorGame")
class INSIDER_API UMyClass_EditorConfig : public UEditorConfigBase
{
public:
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (EditorConfig))
	int32 MyPropertyWithConfig = 123;
};

void UMyClass_EditorConfig_Test::TestConfigSave()
{
	//must run after editor initialization
	auto* testObject = NewObject<UMyClass_EditorConfig>(GetTransientPackage(), TEXT("testObject_EditorConfig"));
	testObject->MyPropertyWithConfig = 777;
	testObject->SaveEditorConfig();

}

void UMyClass_EditorConfig_Test::TestConfigLoad()
{
	auto* testObject = NewObject<UMyClass_EditorConfig>(GetTransientPackage(), TEXT("testObject_EditorConfig"));
	testObject->LoadEditorConfig();
}

//è¿è¡ŒSaveåçš„ä¿å­˜ç»“æœï¼šC:\Users\jack.fu\AppData\Local\UnrealEngine\Editor\MyEditorGame.json

{
	"$type": "MyClass_EditorConfig",
	"MyPropertyWithConfig": 777
}
```

# GlobalUserConfig

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯å…¨å±€ç”¨æˆ·è®¾ç½® Engine/Config/UserXXX.iniã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_GlobalUserConfig](../../../../Flags/EClassFlags/CLASS_GlobalUserConfig.md)
- **å…³è”é¡¹ï¼š** [Config](../Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯å…¨å±€ç”¨æˆ·è®¾ç½® Engine/Config/UserXXX.iniã€‚

## ç¤ºä¾‹ä»£ç ï¼š

å±æ€§ç”¨Configæˆ–è€…GlobalConfigéƒ½æ˜¯å¯ä»¥çš„ã€‚

```cpp
UCLASS(Config = MyGame, GlobalUserConfig)
class INSIDER_API UMyClass_GlobalUserConfig:public UDeveloperSettings
{
	GENERATED_BODY()
public:
	/** Gets the settings container name for the settings, either Project or Editor */
	virtual FName GetContainerName() const override { return TEXT("Project"); }
	/** Gets the category for the settings, some high level grouping like, Editor, Engine, Game...etc. */
	virtual FName GetCategoryName() const override { return TEXT("MyGame"); }
	/** The unique name for your section of settings, uses the class's FName. */
	virtual FName GetSectionName() const override { return TEXT("MyGlobalGame"); }
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, GlobalConfig)
		int32 MyPropertyWithGlobalConfig = 456;
};

ä¿å­˜åˆ°C:\Users\jack.fu\AppData\Local\Unreal Engine\Engine\Config\UserMyGame.ini
[/Script/Insider.UMyClass_GlobalUserConfig]
MyPropertyWithGlobalConfig=999
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Config\GlobalUserConfig\Untitled.png)

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(config=Engine, globaluserconfig)
class ANDROIDPLATFORMEDITOR_API UAndroidSDKSettings : public UObject
{
public:
	GENERATED_UCLASS_BODY()

	// Location on disk of the Android SDK (falls back to ANDROID_HOME environment variable if this is left blank)
	UPROPERTY(GlobalConfig, EditAnywhere, Category = SDKConfig, Meta = (DisplayName = "Location of Android SDK (the directory usually contains 'android-sdk-')"))
	FDirectoryPath SDKPath;

	// Location on disk of the Android NDK (falls back to NDKROOT environment variable if this is left blank)
	UPROPERTY(GlobalConfig, EditAnywhere, Category = SDKConfig, Meta = (DisplayName = "Location of Android NDK (the directory usually contains 'android-ndk-')"))
	FDirectoryPath NDKPath;

	// Location on disk of Java (falls back to JAVA_HOME environment variable if this is left blank)
	UPROPERTY(GlobalConfig, EditAnywhere, Category = SDKConfig, Meta = (DisplayName = "Location of JAVA (the directory usually contains 'jdk')"))
	FDirectoryPath JavaPath;
	
	// Which SDK to package and compile Java with (a specific version or (without quotes) 'latest' for latest version on disk, or 'matchndk' to match the NDK API Level)
	UPROPERTY(GlobalConfig, EditAnywhere, Category = SDKConfig, Meta = (DisplayName = "SDK API Level (specific version, 'latest', or 'matchndk' - see tooltip)"))
	FString SDKAPILevel;

	// Which NDK to compile with (a specific version or (without quotes) 'latest' for latest version on disk). Note that choosing android-21 or later won't run on pre-5.0 devices.
	UPROPERTY(GlobalConfig, EditAnywhere, Category = SDKConfig, Meta = (DisplayName = "NDK API Level (specific version or 'latest' - see tooltip)"))
	FString NDKAPILevel;
};
```

# PerObjectConfig

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨å·²ç»æœ‰configé…ç½®æ–‡ä»¶åå­—çš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šåº”è¯¥æŒ‰æ¯ä¸ªå¯¹è±¡å®ä¾‹æ¥å­˜å‚¨å€¼ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç±»ä¸€ä¸ªå­˜å‚¨å€¼ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_PerObjectConfig](../../../Flags/EClassFlags/CLASS_PerObjectConfig.md)
- **å…³è”é¡¹ï¼š** [Config](Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

åœ¨å·²ç»æœ‰configé…ç½®æ–‡ä»¶åå­—çš„æƒ…å†µä¸‹ï¼ŒæŒ‡å®šåº”è¯¥æŒ‰æ¯ä¸ªå¯¹è±¡å®ä¾‹æ¥å­˜å‚¨å€¼ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç±»ä¸€ä¸ªå­˜å‚¨å€¼ã€‚

- æ­¤ç±»çš„é…ç½®ä¿¡æ¯å°†æŒ‰å¯¹è±¡å­˜å‚¨ï¼Œåœ¨.iniæ–‡ä»¶ä¸­ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªåˆ†æ®µï¼Œæ ¹æ®å¯¹è±¡å‘½åï¼Œæ ¼å¼ä¸º[ObjectName ClassName]ã€‚
- æ­¤è¯´æ˜ç¬¦ä¼šä¼ æ’­åˆ°å­ç±»ã€‚æŒ‡å®šè¯¥é…ç½®æ˜¯å¯¹æ¯ä¸ªå¯¹è±¡éƒ½å•ç‹¬ä¿å­˜ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

æ³¨æ„ObjectNameå¿…é¡»ä¸€è‡´

```cpp
UCLASS(Config = Game,PerObjectConfig)
class INSIDER_API UMyClass_PerObjectConfig :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;
};

void UMyClass_Config_Test::TestPerObjectConfigSave()
{
	UMyClass_PerObjectConfig* testObject1 = NewObject<UMyClass_PerObjectConfig>(GetTransientPackage(), TEXT("testObject1"));
	testObject1->MyPropertyWithConfig = 456;
	testObject1->SaveConfig();

	UMyClass_PerObjectConfig* testObject2 = NewObject<UMyClass_PerObjectConfig>(GetTransientPackage(), TEXT("testObject2"));
	testObject2->MyPropertyWithConfig = 789;
	testObject2->SaveConfig();

}

void UMyClass_Config_Test::TestPerObjectConfigLoad()
{
	UMyClass_PerObjectConfig* testObject1 = NewObject<UMyClass_PerObjectConfig>(GetTransientPackage(), TEXT("testObject1"));
	//testObject1->LoadConfig();	//ä¸éœ€è¦æ˜¾å¼è°ƒç”¨LoadConfig

	UMyClass_PerObjectConfig* testObject2 = NewObject<UMyClass_PerObjectConfig>(GetTransientPackage(), TEXT("testObject2"));
	//testObject2->LoadConfig();
}

//\Saved\Config\WindowsEditor\Game.ini
[testObject1 MyClass_PerObjectConfig]
MyPropertyWithConfig=456

[testObject2 MyClass_PerObjectConfig]
MyPropertyWithConfig=789
```

## åŸç†ï¼š

å¯¹è±¡æ„é€ çš„æœ«æœŸä¼šå°è¯•å»è¯»å–é…ç½®ã€‚

```cpp
void FObjectInitializer::PostConstructInit()
{
	//åœ¨NewObjectæ„é€ ä¸­åé¢ä¼šè°ƒç”¨
	if (bIsCDO || Class->HasAnyClassFlags(CLASS_PerObjectConfig))
	{
		Obj->LoadConfig(NULL, NULL, bIsCDO ? UE::LCPF_ReadParentSections : UE::LCPF_None);
	}
}
```

# ProjectUserConfig

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯é¡¹ç›®ç”¨æˆ·è®¾ç½® Project/Config/UserXXX.iniã€‚
- **å¼•æ“æ¨¡å—ï¼š** Config
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_ProjectUserConfig](../../../../Flags/EClassFlags/CLASS_ProjectUserConfig.md)
- **å…³è”é¡¹ï¼š** [Config](../Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŒ‡å®šä¿å­˜åˆ°çš„é…ç½®æ–‡ä»¶å±‚çº§æ˜¯é¡¹ç›®ç”¨æˆ·è®¾ç½® Project/Config/UserXXX.iniã€‚

## ç¤ºä¾‹ä»£ç ï¼š

ä¿å­˜çš„ç›®å½•æ˜¯\Hello\Config\UserMyGame.ini

```cpp
UCLASS(Config = MyGame, ProjectUserConfig)
class INSIDER_API UMyClass_ProjectUserConfig :public UDeveloperSettings
{
	GENERATED_BODY()
public:
	/** Gets the settings container name for the settings, either Project or Editor */
	virtual FName GetContainerName() const override { return TEXT("Project"); }
	/** Gets the category for the settings, some high level grouping like, Editor, Engine, Game...etc. */
	virtual FName GetCategoryName() const override { return TEXT("MyGame"); }
	/** The unique name for your section of settings, uses the class's FName. */
	virtual FName GetSectionName() const override { return TEXT("MyProjectGame"); }
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
		int32 MyPropertyWithConfig = 123;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, GlobalConfig)
		int32 MyPropertyWithGlobalConfig = 456;
};

//ç»“æœï¼š\Hello\Config\UserMyGame.ini
[/Script/Insider.MyClass_ProjectUserConfig]
MyPropertyWithConfig=777
MyPropertyWithGlobalConfig=888
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Config\ProjectUserConfig\Untitled.png)

## åœ¨æºç ä¸­æœç´¢ï¼š

```cpp
UCLASS(config = Engine, projectuserconfig, meta = (DisplayName = "Rendering Overrides (Local)"))
class ENGINE_API URendererOverrideSettings : public UDeveloperSettings
{
}
```

# Deprecated

- **åŠŸèƒ½æè¿°ï¼š**  æ ‡æ˜è¯¥ç±»å·²ç»å¼ƒç”¨ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsæ·»åŠ [CLASS_Deprecated](../../../../Flags/EClassFlags/CLASS_Deprecated.md)ã€[CLASS_NotPlaceable](../../../../Flags/EClassFlags/CLASS_NotPlaceable.md)ï¼Œåœ¨Metaæ·»åŠ [DeprecationMessage](../../../../Meta/Development/DeprecationMessage.md)ã€[DeprecatedProperty](../../../../Meta/Development/DeprecatedProperty/DeprecatedProperty.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æ ‡æ˜è¯¥ç±»å·²ç»å¼ƒç”¨ã€‚

å¼ƒç”¨ä¼šå¯¼è‡´ï¼šä¸å¯è¢«åˆ›å»ºï¼Œä¸å¯è¢«åºåˆ—åŒ–ä¿å­˜ï¼Œåœ¨ç»§æ‰¿åˆ—è¡¨é‡Œè¢«è¿‡æ»¤æ‰ã€‚æ­¤è¯´æ˜ç¬¦å­ç±»ä¼šç»§æ‰¿ä¸‹æ¥ï¼Œæ ‡æ˜å­ç±»ä¹Ÿæ˜¯åºŸå¼ƒçš„ã€‚æ ‡ä¸ŠDeprecated çš„ç±»éœ€è¦åœ¨ç±»åå‰åŠ ä¸ŠUDEPRECATED_çš„æ˜¾çœ¼å‰ç¼€ï¼Œä½†æ˜¯ç±»åä¸ä¼šå˜ï¼ŒActoråŠ ADEPRECATED_ï¼ŒUObjectåŠ UDEPRECATED_ã€‚ClassFLagsé‡Œä¼šæ ‡ä¸ŠCLASS_Deprecatedå’ŒCLASS_NotPlaceableã€‚æ³¨æ„è¿˜æ˜¯å¯ä»¥æ­£å¸¸NewObjectä½¿ç”¨çš„ã€‚è€ŒSpawnActorä¼šå¤±è´¥ï¼ŒæŠ¥é”™ï¼š failed because class %s is deprecatedã€‚EditInlineä¹Ÿéƒ½ä¼šè¢«ç¦æ­¢ã€‚

## ç¤ºä¾‹ä»£ç 1ï¼š

```cpp
UCLASS(Blueprintable)
class INSIDER_API UMyClass_Deprecated :public UObject
{
	GENERATED_BODY()
};
//æ”¹ä¸ºï¼š
UCLASS(Blueprintable, Deprecated)
class INSIDER_API UDEPRECATED_MyClass_Deprecated :public UObject
{
	GENERATED_BODY()
};
```

## ç¤ºä¾‹æ•ˆæœ1ï¼š

ä¾ç„¶å¯ä»¥NewObjectã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Development\Deprecated\Untitled.png)

## ç¤ºä¾‹ä»£ç 2ï¼š

ä½†è¦æ³¨æ„è¿™ä¸ªæ˜¯UEçš„æ ‡è®°ã€‚æºç é‡Œè¿˜çœ‹è§å¾ˆå¤šUE_DEPRECATEDå®çš„ä½¿ç”¨ï¼Œåˆ™æ˜¯åœ¨VSç¼–è¯‘å™¨çº§åˆ«çš„æ ‡è®°ï¼Œä¼šæ ¹æ®ä½¿ç”¨å¼•ç”¨æƒ…å†µåœ¨ç¼–è¯‘çš„æ­¥éª¤ä¸­ç”Ÿæˆè­¦å‘Šã€‚

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_Deprecated_Test :public UObject
{
	GENERATED_BODY()
public:

		UE_DEPRECATED(5.2, "MyClass_Deprecated has been deprecated, please remove it.")
		UDEPRECATED_MyClass_Deprecated* MyProperty_Deprecated;

		UE_DEPRECATED(5.2, "MyIntProperty has been deprecated, please remove it.")
		UPROPERTY(EditAnywhere, BlueprintReadWrite,meta=(DeprecatedProperty, DeprecationMessage = "MyIntProperty has been deprecated."))
		int MyIntProperty;

		UE_DEPRECATED(5.2, "MyClass_Deprecated has been deprecated, please remove it.")
		void MyFunc(UDEPRECATED_MyClass_Deprecated* obj){}

		UFUNCTION(BlueprintCallable, meta = (DeprecatedProperty, DeprecationMessage="MyVoidFunc has been deprecated."))
		void MyVoidFunc(){}
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_Deprecated_Usage :public UObject
{
	GENERATED_BODY()
public:

	void MyFunc()
	{
		UMyClass_Deprecated_Test* obj=NewObject<UMyClass_Deprecated_Test>();
		UDEPRECATED_MyClass_Deprecated* obj2 = NewObject<UDEPRECATED_MyClass_Deprecated>();
		obj->MyProperty_Deprecated= obj2;
		obj->MyProperty_Deprecated->MyFunc(); 

		obj->MyIntProperty++;
		obj->MyFunc(obj2);
		obj->MyVoidFunc();
	}
};

ç¼–è¯‘è­¦å‘Šï¼š
warning C4996: 'UMyClass_Deprecated_Test::MyProperty_Deprecated': MyClass_Deprecated has been deprecated, please remove it. Please update your code to the new API before upgrading to the next release, otherwise your project will no longer compile.
warning C4996: 'UMyClass_Deprecated_Test::MyProperty_Deprecated': MyClass_Deprecated has been deprecated, please remove it. Please update your code to the new API before upgrading to the next release, otherwise your project will no longer compile.
warning C4996: 'UMyClass_Deprecated_Test::MyIntProperty': MyIntProperty has been deprecated, please remove it. Please update your code to the new API before upgrading to the next release, otherwise your project will no longer compile.
warning C4996: 'UMyClass_Deprecated_Test::MyFunc': MyClass_Deprecated has been deprecated, please remove it. Please update your code to the new API before upgrading to the next release, otherwise your project will no longer compile.
æ³¨æ„å¦‚æœæ²¡æœ‰UE_DEPRECATEDæ ‡è®°ï¼Œåˆ™ä¸ä¼šç”Ÿæˆç¼–è¯‘è­¦å‘Šã€‚

UPROPERTY(EditAnywhere, BlueprintReadWrite)	int MyInt2Property_DEPRECATED;
ä¼šè§¦å‘ï¼š
warning : Member variable declaration: Deprecated property 'MyInt2Property_DEPRECATED' should not be marked as blueprint visible without having a BlueprintGetter
warning : Member variable declaration: Deprecated property 'MyInt2Property_DEPRECATED' should not be marked as blueprint writable without having a BlueprintSetter
warning : Member variable declaration: Deprecated property 'MyInt2Property_DEPRECATED' should not be marked as visible or editable
å› æ­¤åªèƒ½æ”¹æˆï¼š
UPROPERTY()	int MyInt2Property_DEPRECATED;
```

## ç¤ºä¾‹æ•ˆæœ2ï¼š

å±æ€§å’Œå‡½æ•°ä¸ŠåŠ ä¸ŠDeprecatedæ ‡è®°åï¼Œä¼šåœ¨BPç¼–è¯‘çš„æ—¶å€™ç”Ÿæˆè­¦å‘Šã€‚æ³¨æ„å‡½æ•°æ˜¯å…ˆæœ‰ä¸€ä¸ªæ­£å¸¸çš„å‡½æ•°ï¼Œåœ¨BPé‡Œè¿æ¥å®Œæˆä¹‹åå†åœ¨C++é‡Œæ ‡è®°DeprecatedFunctionæ‰ä¼šç”Ÿæˆè­¦å‘Šï¼Œå¦åˆ™å·²ç»Deprecatedçš„å‡½æ•°æ˜¯æ— æ³•å†åœ¨BPé‡Œè°ƒç”¨çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Development\Deprecated\Untitled%201.png)

## åŸç†ï¼š

æºç ä¸­æœ‰ä¼—å¤šCLASS_Deprecatedçš„åˆ¤æ–­ï¼Œæ¯”å¦‚SpawnActorï¼š

```cpp
AActor* UWorld::SpawnActor( UClass* Class, FTransform const* UserTransformPtr, const FActorSpawnParameters& SpawnParameters )
{
	if( Class->HasAnyClassFlags(CLASS_Deprecated) )
	{
		UE_LOG(LogSpawn, Warning, TEXT("SpawnActor failed because class %s is deprecated"), *Class->GetName() );
		return NULL;
	}
}
```

# EarlyAccessPreview

- **åŠŸèƒ½æè¿°ï¼š**  æ ‡æ˜è¯¥ç±»æ˜¯æ—©æœŸé¢„è§ˆç‰ˆï¼Œæ¯”è¯•éªŒç‰ˆè¦æ›´å®Œå–„ä¸€äº›ï¼Œä½†è¿˜æ˜¯æ²¡åˆ°äº§å“çº§ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­æ·»åŠ [DevelopmentStatus](../../../../Meta/Development/DevelopmentStatus.md)ï¼Œå°†ç±»æ ‡è®°ä¸ºEarlyAccess
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æ ‡æ˜è¯¥ç±»æ˜¯æ—©æœŸé¢„è§ˆç‰ˆï¼Œæ¯”è¯•éªŒç‰ˆè¦æ›´å®Œå–„ä¸€äº›ï¼Œä½†è¿˜æ˜¯æ²¡åˆ°äº§å“çº§ã€‚

è¿™ä¸ªæ ‡è®°ä¼šåœ¨ç±»çš„å…ƒæ•°æ®ä¸ŠåŠ ä¸Š{ "DevelopmentStatus", "EarlyAccess" }ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
//(BlueprintType = true, DevelopmentStatus = EarlyAccess, IncludePath = Class/Display/MyClass_Deprecated.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_Deprecated.h)
UCLASS(Blueprintable, EarlyAccessPreview)
class INSIDER_API UMyClass_EarlyAccessPreview :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
	UFUNCTION(BlueprintCallable)
		void MyFunc() {}
};
```

## ç¤ºä¾‹ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Development\EarlyAccessPreview\Untitled.png)

# Experimental

- **åŠŸèƒ½æè¿°ï¼š**  æ ‡æ˜è¯¥ç±»æ˜¯è¯•éªŒæ€§ç‰ˆæœ¬ï¼Œå½“å‰æ²¡æœ‰æ–‡æ¡£æè¿°ï¼Œä¹‹åæœ‰å¯èƒ½åºŸå¼ƒæ‰ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Development
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­æ·»åŠ [DevelopmentStatus](../../../../Meta/Development/DevelopmentStatus.md)ï¼Œå°†ç±»æ ‡è®°ä¸ºExperimental
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æ ‡æ˜è¯¥ç±»æ˜¯è¯•éªŒæ€§ç‰ˆæœ¬ï¼Œå½“å‰æ²¡æœ‰æ–‡æ¡£æè¿°ï¼Œä¹‹åæœ‰å¯èƒ½åºŸå¼ƒæ‰ã€‚

æºç é‡Œçš„ä¾‹å­æ˜¯Paper2Dçš„ç±»ã€‚è¿™ä¸ªæ ‡è®°ä¼šåœ¨ç±»çš„å…ƒæ•°æ®ä¸ŠåŠ ä¸Š{ "DevelopmentStatus", "Experimental" }ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
(BlueprintType = true, DevelopmentStatus = Experimental, IncludePath = Class/Display/MyClass_Deprecated.h, IsBlueprintBase = true, ModuleRelativePath = Class/Display/MyClass_Deprecated.h)
*/
UCLASS(Blueprintable, Experimental)
class INSIDER_API UMyClass_Experimental :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
	UFUNCTION(BlueprintCallable)
		void MyFunc() {}
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Development\Experimental\Untitled.png)

# DefaultToInstanced

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å®ä¾‹å±æ€§éƒ½é»˜è®¤æ˜¯UPROPERTY(instanced)ï¼Œå³éƒ½é»˜è®¤åˆ›å»ºæ–°çš„å®ä¾‹ï¼Œè€Œä¸æ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨ã€‚
- **å¼•æ“æ¨¡å—ï¼š** Instance
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_DefaultToInstanced](../../../../Flags/EClassFlags/CLASS_DefaultToInstanced.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…**

æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å®ä¾‹å±æ€§éƒ½é»˜è®¤æ˜¯UPROPERTY(instanced)ï¼Œå³éƒ½é»˜è®¤åˆ›å»ºæ–°çš„å®ä¾‹ï¼Œè€Œä¸æ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨ã€‚

UPROPERTY(instanced)çš„å«ä¹‰æ˜¯é€ æˆPropertyçš„CPF_InstancedReferenceï¼Œå³ä¸ºè¯¥å±æ€§åˆ›å»ºå¯¹è±¡å®ä¾‹ã€‚

æ‰€è°“å®ä¾‹æŒ‡çš„æ˜¯ä¸ºè¯¥UObjectæŒ‡é’ˆåˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„å»æ‰¾åˆ°å¼•æ“å†…å·²æœ‰çš„å¯¹è±¡çš„æ¥å¼•ç”¨ã€‚

ä¹Ÿå¸¸å¸¸å’ŒEditInlineNewé…åˆä½¿ç”¨ï¼Œä»¥ä¾¿åœ¨ç»†èŠ‚é¢æ¿ä¸­å¯ä»¥åˆ›å»ºå¯¹è±¡å®ä¾‹ã€‚

UActorComponentæœ¬èº«å°±æ˜¯å¸¦æœ‰DefaultToInstancedçš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable)
class INSIDER_API UMyClass_NotDefaultToInstanced :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
};

//	ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_DefaultToInstanced | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
UCLASS(Blueprintable, DefaultToInstanced)
class INSIDER_API UMyClass_DefaultToInstanced :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
};

//	ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_EditInlineNew | CLASS_RequiredAPI | CLASS_DefaultToInstanced | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew)
class INSIDER_API UMyClass_DefaultToInstanced_EditInlineNew :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
};

UCLASS(Blueprintable, EditInlineNew)
class INSIDER_API UMyClass_NotDefaultToInstanced_EditInlineNew :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_DefaultToInstanced_Test :public UObject
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "NormalProperty")
	UMyClass_NotDefaultToInstanced* MyObject_NotDefaultToInstanced;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "NormalProperty")
	UMyClass_DefaultToInstanced* MyObject_DefaultToInstanced;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = "NormalProperty | Instanced")
	UMyClass_NotDefaultToInstanced* MyObject_NotDefaultToInstanced_Instanced;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = "NormalProperty | Instanced")
	UMyClass_DefaultToInstanced* MyObject_DefaultToInstanced_Instanced;

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "EditInlineNew")
	UMyClass_NotDefaultToInstanced_EditInlineNew* MyObject_NotDefaultToInstanced_EditInlineNew;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "EditInlineNew")
	UMyClass_DefaultToInstanced_EditInlineNew* MyObject_DefaultToInstanced_EditInlineNew;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = "EditInlineNew | Instanced")
	UMyClass_NotDefaultToInstanced_EditInlineNew* MyObject_NotDefaultToInstanced_EditInlineNew_Instanced;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = "EditInlineNew | Instanced")
	UMyClass_DefaultToInstanced_EditInlineNew* MyObject_DefaultToInstanced_EditInlineNew_Instanced;
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

- MyObject_NotDefaultToInstancedå’ŒMyObject_NotDefaultToInstanced_EditInlineNewå› ä¸ºå±æ€§æ²¡æœ‰instancedçš„æ ‡è®°ï¼Œå› æ­¤æ‰“å¼€æ˜¯ä¸€ä¸ªé€‰æ‹©å¯¹è±¡å¼•ç”¨çš„åˆ—è¡¨ã€‚
- MyObject_DefaultToInstancedå› ä¸ºç±»ä¸Šæœ‰DefaultToInstancedï¼Œå› æ­¤è¯¥å±æ€§æ˜¯Instancedã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨ç»™å±æ€§åŠ ä¸ŠInstancedæ ‡è®°ï¼Œæ­£å¦‚MyObject_NotDefaultToInstanced_Instancedå’ŒMyObject_DefaultToInstanced_Instancedã€‚å‡ºç°äº†åˆ›å»ºå®ä¾‹çš„çª—å£ï¼Œä½†æ˜¯è¿˜ä¸èƒ½åˆ›å»ºåœ¨ç»†èŠ‚é¢æ¿é‡Œç›´æ¥åˆ›å»ºå¯¹è±¡ã€‚
- MyObject_DefaultToInstanced_EditInlineNewï¼ŒMyObject_NotDefaultToInstanced_EditInlineNew_Instancedï¼ŒMyObject_DefaultToInstanced_EditInlineNew_Instancedè¿™3ä¸ªéƒ½å¯ä»¥ç›´æ¥åœ¨ç»†èŠ‚é¢æ¿åˆ›å»ºå¯¹è±¡å®ä¾‹ã€‚æ˜¯å› ä¸ºè¿™ä¸ªç±»æœ¬èº«è¦æœ‰EditInlineNewï¼Œå¦å¤–è¿™ä¸ªå±æ€§è¦æœ‰Instancedï¼ˆè¦å˜›åœ¨è¯¥ç±»ä¸Šè®¾ç½®DefaultToInstancedä»¥æ­¤è¯¥ç±»çš„æ‰€æœ‰å±æ€§éƒ½è‡ªåŠ¨æ˜¯Instancedï¼Œæˆ–è€…åœ¨å±æ€§ä¸Šå•ä¸ªè®¾ç½®Instancedï¼‰

![D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Instance\DefaultToInstanced\image.png](image.png)

## åŸç†ï¼š

```cpp
UObject* FObjectInstancingGraph::InstancePropertyValue(UObject* SubObjectTemplate, UObject* CurrentValue, UObject* Owner, EInstancePropertyValueFlags Flags)
{
	if (CurrentValue->GetClass()->HasAnyClassFlags(CLASS_DefaultToInstanced))
{
	bCausesInstancing = true; // these are always instanced no matter what
}
}
```

# EditInlineNew

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šè¯¥ç±»çš„å¯¹è±¡å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œç›´æ¥å†…è”åˆ›å»ºï¼Œè¦å’Œå±æ€§çš„Instancedé…åˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** Instance
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_EditInlineNew](../../../../Flags/EClassFlags/CLASS_EditInlineNew.md)
- **å…³è”é¡¹ï¼š** NotEditInlineNew (NotEditInlineNew.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šè¯¥ç±»çš„å¯¹è±¡å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œç›´æ¥å†…è”åˆ›å»ºã€‚

å¦‚æœæƒ³åœ¨ç»†èŠ‚é¢æ¿é‡Œç›´æ¥åˆ›å»ºå¯¹è±¡ï¼Œå±æ€§ä¸Šä¹Ÿå¿…é¡»å…ˆæ ‡è®°Instancedæˆ–ShowInnerPropertiesã€‚

EditInlineNewä¸»è¦æ˜¯ç”¨åœ¨UObjectçš„å­ç±»ä¸Šï¼Œä¸€èˆ¬ä¸æ ‡EditInlineNewçš„æ˜¯ç”¨åœ¨Actoræˆ–èµ„äº§çš„å¼•ç”¨ä¸Šã€‚æ³¨æ„EditInlineNewæ˜¯è¡¨æ˜å¢åŠ ä»å±æ€§ç»†èŠ‚é¢æ¿é‡Œç›´æ¥åˆ›å»ºå¯¹è±¡å®ä¾‹çš„èƒ½åŠ›ï¼Œè€Œéé™åˆ¶åªèƒ½åœ¨å±æ€§ç»†èŠ‚é¢æ¿é‡Œåˆ›å»ºï¼Œå½“ç„¶ä¹Ÿå¯ä»¥è‡ªå·±æ‰‹åŠ¨NewObjectå†èµ‹å€¼ç»™å¯¹è±¡å¼•ç”¨å±æ€§ã€‚

è¿™ä¸ªè·ŸUPROPERTYä¸Šçš„Instancedèƒ½åŠ›æ˜¯ç‹¬ç«‹çš„ã€‚å¦‚æœUCLASSä¸Šä¸åŠ EditInlineNewï¼Œä½†æ˜¯å±æ€§ä¸ŠåŠ ä¸ŠInstancedï¼Œåˆ™åœ¨æ‰‹åŠ¨NewObjectèµ‹å€¼è¯¥å±æ€§åï¼Œè¯¥å±æ€§ä¹Ÿä¼šå±•å¼€å†…éƒ¨å±æ€§æ¥æä¾›ç¼–è¾‘åŠŸèƒ½ã€‚å› ä¸ºInstancedçš„å±æ€§ä¼šè‡ªåŠ¨çš„åœ¨propertyä¸ŠåŠ ä¸ŠEditInlineçš„metaã€‚

æ­¤è¯´æ˜ç¬¦ä¼šä¼ æ’­åˆ°æ‰€æœ‰å­ç±»ï¼›å­ç±»å¯é€šè¿‡ NotEditInlineNew è¯´æ˜ç¬¦è¦†ç›–å®ƒã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, EditInlineNew)
class INSIDER_API UMyClass_EditInlineNew :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
};

UCLASS(Blueprintable, NotEditInlineNew)
class INSIDER_API UMyClass_NotEditInlineNew :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_Edit_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = InstancedProperty)
		UMyClass_EditInlineNew* MyEditInlineNew;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = InstancedProperty)
		UMyClass_NotEditInlineNew* MyNotEditInlineNew;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NormalProperty)
		UMyClass_EditInlineNew* MyEditInlineNew_NotInstanced;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NormalProperty)
		UMyClass_NotEditInlineNew* MyNotEditInlineNew_NotInstanced;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

EditInlineNewæ”¯æŒç›´æ¥C++æˆ–BPå­ç±»åˆ›å»ºå¯¹è±¡å®ä¾‹ï¼Œç„¶ååœ¨ä¸Šé¢ç¼–è¾‘å®ä¾‹ã€‚

è€ŒNotEditInlineNewçš„å±æ€§åˆ™æ— æ³•æ‰¾åˆ°æ”¯æŒçš„ç±»æ¥åˆ›å»ºå¯¹è±¡ã€‚

å¦‚æœå±æ€§ä¸Šæ²¡æœ‰Instancedåˆ™åªèƒ½å°è¯•å»å¼•ç”¨ï¼ˆæ‰¾ä¸åˆ°å¯¹è±¡ï¼‰ã€‚

![D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Instance\EditInlineNew\image.png](image.png)

## åŸç†ï¼š

åˆ¤æ–­è¯¥ç±»æ˜¯å¦æœ‰CLASS_EditInlineNewæ¥å†³å®šæ˜¯å¦å¯å†…è”åˆ›å»ºç¼–è¾‘ã€‚

```cpp
template <typename TClass, typename TIsChildOfFunction>
bool FPropertyEditorInlineClassFilter::IsClassAllowedHelper(TClass InClass, TIsChildOfFunction IsClassChildOf, TSharedRef< FClassViewerFilterFuncs > InFilterFuncs)
{
	const bool bMatchesFlags = InClass->HasAnyClassFlags(CLASS_EditInlineNew) &&
		!InClass->HasAnyClassFlags(CLASS_Hidden | CLASS_HideDropDown | CLASS_Deprecated) &&
		(bAllowAbstract || !InClass->HasAnyClassFlags(CLASS_Abstract));
}
```

# NotEditInlineNew

- **åŠŸèƒ½æè¿°ï¼š**  ä¸èƒ½é€šè¿‡EditInlineæŒ‰é’®åˆ›å»º
- **å¼•æ“æ¨¡å—ï¼š** Instance
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­ç§»é™¤[CLASS_EditInlineNew](../../../Flags/EClassFlags/CLASS_EditInlineNew.md)
- **å…³è”é¡¹ï¼š** EditInlineNew (EditInlineNew.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

# Within

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šå¯¹è±¡åˆ›å»ºçš„æ—¶å€™å¿…é¡»ä¾èµ–äºOuterClassNameçš„å¯¹è±¡ä½œä¸ºOuterã€‚
- **å¼•æ“æ¨¡å—ï¼š** Instance
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **ä½œç”¨æœºåˆ¶ï¼š** ä¿å­˜åœ¨UClass* UClass::ClassWithin=XXXçš„XXXä¸­
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æŒ‡å®šå¯¹è±¡åˆ›å»ºçš„æ—¶å€™å¿…é¡»ä¾èµ–äºOuterClassNameçš„å¯¹è±¡ä½œä¸ºOuterã€‚

æ­¤ç±»çš„å¯¹è±¡æ— æ³•åœ¨OuterClassNameå¯¹è±¡çš„å®ä¾‹ä¹‹å¤–å­˜åœ¨ã€‚è¿™æ„å‘³ç€ï¼Œè¦åˆ›å»ºæ­¤ç±»çš„å¯¹è±¡ï¼Œéœ€è¦æä¾›OuterClassNameçš„ä¸€ä¸ªå®ä¾‹ä½œä¸ºå…¶Outerå¯¹è±¡ã€‚

æœ¬ç±»åœ¨è¿™ç§æƒ…å†µä¸€èˆ¬æ˜¯ç”¨æ¥å½“åšå­å¯¹è±¡æ¥ä½¿ç”¨çš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Within= MyClass_Within_Outer)
class INSIDER_API UMyClass_Within :public UObject
{
	GENERATED_BODY()
};

UCLASS()
class INSIDER_API UMyClass_Within_Outer :public UObject
{
	GENERATED_BODY()
public:
};

	
```

## ç¤ºä¾‹ç»“æœï¼š

```cpp
//é”™è¯¯ï¼Fatal error: Object MyClass_Within None created in Package instead of MyClass_Within_Outer
UMyClass_Within* obj=NewObject<UMyClass_Within>();

//æ­£ç¡®ï¼š
UMyClass_Within_Outer* objOuter = NewObject<UMyClass_Within_Outer>();
UMyClass_Within* obj=NewObject<UMyClass_Within>(objOuter);
```

## åŸç†ï¼š

ç”Ÿæˆçš„UClassçš„å­—æ®µï¼šUClass* ClassWithinä¼šä¿å­˜è¿™ä¸ªä¿¡æ¯ï¼Œç„¶ååœ¨åˆ›å»ºçš„æ—¶å€™StaticAllocateObjectä¼šæµ‹è¯• check(bCreatingCDO || !InOuter || InOuter->IsA(InClass->ClassWithin))ã€‚å› æ­¤éœ€è¦å…ˆåˆ›å»ºWithinçš„å¯¹è±¡ã€‚

```cpp
bool StaticAllocateObjectErrorTests( const UClass* InClass, UObject* InOuter, FName InName, EObjectFlags InFlags)
{
		if ( (InFlags & (RF_ClassDefaultObject|RF_ArchetypeObject)) == 0 )
		{
			if ( InOuter != NULL && !InOuter->IsA(InClass->ClassWithin) )
			{
				UE_LOG(LogUObjectGlobals, Fatal, TEXT("%s"), *FString::Printf( TEXT("Object %s %s created in %s instead of %s"), *InClass->GetName(), *InName.ToString(), *InOuter->GetClass()->GetName(), *InClass->ClassWithin->GetName()) );
				return true;
			}
		}
}
```

åœ¨æºç é‡Œå¯ä»¥æœç´¢åˆ°å¾ˆå¤šWithinçš„ç”¨æ³•

UCLASS(Within=Engine, config=Engine, transient)
class ENGINE_API ULocalPlayer

UCLASS(Abstract, DefaultToInstanced, Within=UserWidget)
class UMG_API UUserWidgetExtension : public UObject
{

# ConversionRoot

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨åœºæ™¯ç¼–è¾‘å™¨é‡Œå…è®¸Actoråœ¨è‡ªèº«ä»¥åŠå­ç±»ä¹‹é—´åšè½¬æ¢
- **å¼•æ“æ¨¡å—ï¼š** Scene
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [IsConversionRoot](../../../../Meta/Blueprint/IsConversionRoot.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

ä¸€èˆ¬æ˜¯ç”¨åœ¨Actorä¸Šï¼Œåœ¨Actorè½¬æ¢çš„æ—¶å€™ç”¨æ¥é™åˆ¶è½¬æ¢çš„çº§åˆ«ã€‚æ¯”å¦‚ASkeletalMeshActorï¼ŒAStaticMeshActorç­‰ã€‚

å¸¸å¸¸ComponentWrapperClassä¸€èµ·å‡ºç°ã€‚

æ ¹æ®ä»£ç æ¥è¯´ï¼Œmetaä¸­çš„IsConversionRootä¼šé™åˆ¶åªä¼ è¾¾åˆ°è¿™ä¸€å±‚ï¼Œä¸ç»§ç»­å¾€æ ¹ä¸ŠæŸ¥æ‰¾ã€‚

åªæœ‰é…æœ‰ConversionRootçš„Actoræ‰ä¼šå…è®¸Convert Actorï¼Œå¦åˆ™æ˜¯ç¦ç”¨çš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
//(BlueprintType = true, IncludePath = Class/Trait/MyClass_ConversionRoot.h, IsBlueprintBase = true, IsConversionRoot = true, ModuleRelativePath = Class/Trait/MyClass_ConversionRoot.h)
UCLASS(Blueprintable,BlueprintType, ConversionRoot)
class INSIDER_API AMyActor_ConversionRoot :public AActor
{
	GENERATED_BODY()
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨è“å›¾ä¸­åˆ›å»ºå…¶å­ç±»BP_ConversionRoot_Child1å’ŒBP_ConversionRoot_Child2ã€‚ç„¶åæŠŠBP_ConversionRoot_Child1æ‹–æ”¾è¿›åœºæ™¯é‡Œåˆ›å»ºä¸ªActorï¼Œä¹Ÿåˆ›å»ºä¸ªæ™®é€šçš„è“å›¾Actorä½œä¸ºå¯¹æ¯”ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Scene\ConversionRoot\Untitled.png)

åœ¨å…³å¡ä¸­é€‰æ‹©Child1ï¼Œä¼šå…è®¸ConvertActorï¼Œåœ¨ConverstionRootçš„è‡ªèº«ä»¥åŠæ‰€æœ‰å­ç±»ä¹‹é—´åšè½¬æ¢ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Scene\ConversionRoot\Untitled%201.png)

å¦‚æœæ˜¯æ™®é€šçš„Actorï¼Œå› ä¸ºæ²¡æœ‰å®šä¹‰ConversionRootï¼Œåˆ™ä¸èƒ½åšè½¬æ¢ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Scene\ConversionRoot\Untitled%202.png)

## åŸç†ï¼š

åœ¨å…³å¡ä¸­çš„Actoré€‰æ‹©ï¼šå…³å¡ä¸­é€‰æ‹©ä¸€ä¸ªActorï¼Œç„¶åDetailsPanelé‡Œä¼šæ˜¾ç¤ºConverActorå±æ€§æ ï¼Œå¯ä»¥é€‰æ‹©å¦å¤–ä¸€ä¸ªActoræ¥è¿›è¡Œæ”¹å˜ã€‚
TSharedRef<SWidget> FActorDetails::MakeConvertMenu( const FSelectedActorInfo& SelectedActorInfo )
è¿™ä¸ªå‡½æ•°å°±æ˜¯ç”¨æ¥åˆ›å»ºSelect Typeçš„Combo Buttonçš„èœå•çš„ã€‚å†…éƒ¨ä¼šè°ƒç”¨CreateClassPickerConvertActorFilterï¼š

```cpp
UClass* FActorDetails::GetConversionRoot( UClass* InCurrentClass ) const
{
	UClass* ParentClass = InCurrentClass;

	while(ParentClass)
	{
		if( ParentClass->GetBoolMetaData(FName(TEXT("IsConversionRoot"))) )
		{
			break;
		}
		ParentClass = ParentClass->GetSuperClass();
	}

	return ParentClass;
}

void FActorDetails::CreateClassPickerConvertActorFilter(const TWeakObjectPtr<AActor> ConvertActor, class FClassViewerInitializationOptions* ClassPickerOptions)
Filter->AllowedChildOfRelationship.Add(RootConversionClass);//é™å®šè¿™ä¸ªåŸºç±»ä»¥ä¸‹çš„å…¶ä»–å­ç±»

```

# NotPlaceable

- **åŠŸèƒ½æè¿°ï¼š** æ ‡æ˜è¯¥Actorä¸å¯è¢«æ”¾ç½®åœ¨å…³å¡é‡Œ
- **å¼•æ“æ¨¡å—ï¼š** Behavior
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_NotPlaceable](../../../../Flags/EClassFlags/CLASS_NotPlaceable.md)
- **å…³è”é¡¹ï¼š** Placeable (Placeable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æ ‡æ˜è¯¥Actorä¸å¯è¢«æ”¾ç½®åœ¨å…³å¡é‡Œï¼Œæ²¡æ³•æ‹–æ”¾åˆ°åœºæ™¯é‡Œã€‚ä½¿ç»§æ‰¿è‡ªåŸºç±»çš„Placeableè¯´æ˜ç¬¦æ— æ•ˆã€‚ä¼šåœ¨ClassFlagssé‡Œæ ‡è®°ä¸ŠCLASS_NotPlaceableï¼Œè¿™ä¸ªæ ‡è®°æ˜¯å¯ä»¥ç»§æ‰¿çš„ï¼Œæ„å‘³ç€å…¶æ‰€æœ‰çš„å­ç±»é»˜è®¤éƒ½ä¸å¯æ”¾ç½®ã€‚ä¾‹å¦‚AWorldSettingså…¶å®å°±æ˜¯ä¸€ä¸ªnotplaceableçš„Actorã€‚

ä½†æ˜¯æ³¨æ„è¯¥ç±»ä¾ç„¶å¯ä»¥é€šè¿‡SpawnActoråŠ¨æ€ç”Ÿæˆåˆ°å…³å¡ä¸­ã€‚

NotPlaceableçš„ç±»æ˜¯ä¸å‡ºç°åœ¨PlaceModeçš„ç±»é€‰æ‹©é‡Œå»çš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable,BlueprintType, NotPlaceable)
class INSIDER_API AMyActor_NotPlaceable :public AActor
{
	GENERATED_BODY()
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

æ‹–åŠ¨åˆ°åœºæ™¯é‡Œä¼šå‘ç°ä¸èƒ½åˆ›å»ºActorã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Scene\NotPlaceable\Untitled.png)

## åŸç†ï¼š

å¦‚æœç›´æ¥æ˜¯C++ç±»AMyActor_NotPlaceable ï¼Œæ˜¯å¯ä»¥ç›´æ¥ä»ContentBrowseræ‹–åˆ°åœºæ™¯é‡Œå»çš„ã€‚çœ‹æºç å¯çŸ¥ï¼Œåªæœ‰BPç»§æ‰¿ä¸‹æ¥çš„å­ç±»æ‰æœ‰å—åˆ°è¿™ä¸ªé™åˆ¶ã€‚

```cpp
TArray<AActor*> FLevelEditorViewportClient::TryPlacingActorFromObject( ULevel* InLevel, UObject* ObjToUse, bool bSelectActors, EObjectFlags ObjectFlags, UActorFactory* FactoryToUse, const FName Name, const FViewportCursorLocation* Cursor )
{

	bool bPlace = true;
	if (ObjectClass->IsChildOf(UBlueprint::StaticClass()))
	{
		UBlueprint* BlueprintObj = StaticCast<UBlueprint*>(ObjToUse);
		bPlace = BlueprintObj->GeneratedClass != NULL;
		if(bPlace)
		{
			check(BlueprintObj->ParentClass == BlueprintObj->GeneratedClass->GetSuperClass());
			if (BlueprintObj->GeneratedClass->HasAnyClassFlags(CLASS_NotPlaceable | CLASS_Abstract))
			{
				bPlace = false;
			}
		}
	}

	if (bPlace)
	{
		PlacedActor = FActorFactoryAssetProxy::AddActorForAsset( ObjToUse, bSelectActors, ObjectFlags, FactoryToUse, Name );
		if ( PlacedActor != NULL )
		{
			PlacedActors.Add(PlacedActor);
			PlacedActor->PostEditMove(true);
		}
	}
}
```

# Placeable

- **åŠŸèƒ½æè¿°ï¼š**  æ ‡æ˜è¯¥Actorå¯ä»¥æ”¾ç½®åœ¨å…³å¡é‡Œã€‚
- **å¼•æ“æ¨¡å—ï¼š** Scene
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­ç§»é™¤[CLASS_NotPlaceable](../../../../Flags/EClassFlags/CLASS_NotPlaceable.md)
- **å…³è”é¡¹ï¼š** [NotPlaceable](../NotPlaceable/NotPlaceable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

æ ‡æ˜è¯¥Actorå¯ä»¥æ”¾ç½®åœ¨å…³å¡é‡Œã€‚

é»˜è®¤æƒ…å†µä¸‹æ˜¯placeableçš„ï¼Œå› æ­¤æºç é‡Œç›®å‰æ²¡æœ‰ç”¨åˆ°Placeableçš„åœ°æ–¹ã€‚

å­ç±»å¯ä½¿ç”¨NotPlaceableè¯´æ˜ç¬¦è¦†ç›–æ­¤æ ‡å¿—ï¼Œæ­£å¦‚AInfoä¹‹ç±»çš„ä¸Šé¢è‡ªå·±è®¾ç½®NotPlaceableã€‚

æŒ‡ç¤ºå¯åœ¨ç¼–è¾‘å™¨ä¸­åˆ›å»ºæ­¤ç±»ï¼Œè€Œä¸”å¯å°†æ­¤ç±»æ”¾ç½®åˆ°å…³å¡ã€UIåœºæ™¯æˆ–è“å›¾ï¼ˆå–å†³äºç±»ç±»å‹ï¼‰ä¸­ã€‚æ­¤æ ‡å¿—ä¼šä¼ æ’­åˆ°æ‰€æœ‰å­ç±»ï¼›

placeableæ²¡æ³•æ¸…é™¤çˆ¶ç±»çš„notplaceableæ ‡è®°ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType,placeable)	
class INSIDER_API AMyActor_Placeable :public AMyActor_NotPlaceable
{
	GENERATED_BODY()
};
error : The 'placeable' specifier cannot override a 'nonplaceable' base class. Classes are assumed to be placeable by default. Consider whether using the 'abstract' specifier on the base class would work.
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Scene\Placeable\Untitled.png)

# MatchedSerializers

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šç±»æ”¯æŒæ–‡æœ¬ç»“æ„åºåˆ—åŒ–
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_MatchedSerializers](../../../../Flags/EClassFlags/CLASS_MatchedSerializers.md)ï¼Œåœ¨Metaä¸­æ·»åŠ [MatchedSerializers](../../../../Meta/Serialization/MatchedSerializers.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

è¯¥æ ‡è¯†ç¬¦åªå…è®¸åœ¨NoExportTypes.hä¸­ä½¿ç”¨ï¼Œå±äºæ˜¯å¼•æ“è‡ªç”¨çš„å†…éƒ¨æ ‡è¯†ç¬¦ã€‚

åŸºæœ¬ä¸Šå¤§éƒ¨åˆ†çš„ç±»éƒ½æ‹¥æœ‰è¯¥æ ‡è®°ï¼Œé™¤äº†è‡ªèº«ä¸å¯¼å‡ºçš„ç±»ï¼Œä¸€èˆ¬åŒ…æ‹¬NoExportTypes.hå®šä¹‰çš„ï¼ˆé™¤éæ‰‹åŠ¨åŠ ä¸ŠMatchedSerializersï¼Œæ¯”å¦‚UObjectï¼‰ï¼Œæˆ–è€…é DECLARE_CLASS_INTRINSICç›´æ¥åœ¨æºç é‡Œå®šä¹‰çš„å…ƒæ•°æ®ã€‚

å› æ­¤å®é™…ä¸Šå¤§éƒ¨åˆ†çš„ç±»éƒ½æ‹¥æœ‰è¯¥æ ‡è®°ã€‚å› ä¸ºåœ¨UHTä¸­åªè¦ä¸æ˜¯NoExportçš„ï¼Œå°±ä¼šè‡ªåŠ¨çš„åŠ ä¸Šè¿™ä¸ªæ ‡è®°ã€‚

```cpp
// Force the MatchedSerializers on for anything being exported
if (!ClassExportFlags.HasAnyFlags(UhtClassExportFlags.NoExport))
{
			ClassFlags |= EClassFlags.MatchedSerializers;
}
```

## ç»“æ„åŒ–åºåˆ—åŒ–å™¨ï¼š

å¦‚æœä¸€ä¸ªç±»æ”¯æŒæ–‡æœ¬æ ¼å¼ï¼Œåˆ™StructuredArchiveçš„ç»“æ„çš„æ„æ€æ˜¯ä¼šæŠŠç±»é‡Œçš„å­—æ®µæ ‘å½¢å±•å¼€æ¥åºåˆ—åŒ–å±•ç¤ºå‡ºæ¥ï¼Œä»è€Œæ–¹ä¾¿äººç±»ç†è§£ã€‚è€Œå¦‚æœä¸æ”¯æŒæ–‡æœ¬æ ¼å¼ï¼Œåˆ™ä¼šæŠŠæ‰€æœ‰çš„å­—æ®µå€¼å‹è¿›ä¸€ä¸ªäºŒè¿›åˆ¶bufferé‡Œï¼ˆDataå­—æ®µï¼‰ï¼Œè¿™ä¹Ÿæ˜¯runtimeæ—¶å€™ç”¨çš„æ–¹å¼ã€‚

æµ‹è¯•ä»£ç ï¼š

```cpp

UCLASS(Blueprintable, BlueprintType,editinlinenew)
class INSIDER_API UMyClass_MatchedSerializersSub :public UObject
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyInt_Default = 123;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_MatchedSerializersTestAsset:public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyInt_Default = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Instanced)
	UMyClass_MatchedSerializersSub* SubObject;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UStruct* MyStructType;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UClass* MyClassType;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	UEnum* MyEnumType;
};

void UMyClass_MatchedSerializers_Test::ApplyClassFlag()
{
	UMyClass_MatchedSerializersTestAsset::StaticClass()->ClassFlags |= CLASS_MatchedSerializers;
	UMyClass_MatchedSerializersSub::StaticClass()->ClassFlags |= CLASS_MatchedSerializers;
}

void UMyClass_MatchedSerializers_Test::RemoveClassFlag()
{
	UMyClass_MatchedSerializersTestAsset::StaticClass()->ClassFlags &= ~CLASS_MatchedSerializers;
	UMyClass_MatchedSerializersSub::StaticClass()->ClassFlags &= ~CLASS_MatchedSerializers;
}
```

åœ¨ç¼–è¾‘å™¨ä¸­åˆ›å»ºæµ‹è¯•æ•°æ®Asset

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\MatchedSerializers\Untitled.png)

ç„¶ååœ¨Editoré€‰é¡¹é‡Œæ‰“å¼€TextAssetFormatSupport(UEditorExperimentalSettings::bTextAssetFormatSupport)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\MatchedSerializers\Untitled%201.png)

ç„¶ååœ¨èµ„äº§ä¸Šå°±å‡ºç°3ä¸ªèœå•æ”¯æŒæŠŠèµ„äº§å¯¼å‡ºä¸ºæ–‡æœ¬ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\MatchedSerializers\Untitled%202.png)

ExportToTextFormatä¼šåœ¨è“å›¾èµ„äº§çš„åŒç›®å½•ç”Ÿæˆä¸€ä¸ª.utxtçš„æ–‡ä»¶ï¼Œæ ¼å¼ä¸ºjsonã€‚é€šè¿‡åŠ¨æ€çš„å¢åˆ CLASS_MatchedSerializersè¿™ä¸ªæ ‡è®°æ¥å¯¹æ¯”è¿™ä¸ªæ ‡è®°äº§ç”Ÿçš„å·®å¼‚ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\MatchedSerializers\Untitled%203.png)

å¯ä»¥å‘ç°ï¼Œåºåˆ—åŒ–å‡ºæ¥çš„å†…å®¹æœ‰æ˜æ˜¾çš„å·®å¼‚ï¼Œä¸å¸¦æœ‰CLASS_MatchedSerializersæ ‡è®°çš„äº§ç”Ÿçš„å³ä¾§ç»“æœï¼ŒæŠŠæ‰€æœ‰çš„å­—æ®µå€¼å‹è¿›ä¸€ä¸ªäºŒè¿›åˆ¶bufferé‡Œï¼ˆDataå­—æ®µï¼‰ã€‚

## å†…éƒ¨æœºåˆ¶åŸç†ï¼š

CLASS_MatchedSerializersè¿™ä¸ªæ ‡è®°åœ¨UClass::IsSafeToSerializeToStructuredArchivesä¸­è¢«ä½¿ç”¨ï¼Œæ ‡æ˜é‡‡ç”¨ç»“æ„åºåˆ—åŒ–å™¨ã€‚æ˜¯å¦æ”¯æŒæ–‡æœ¬å¯¼å…¥å¯¼å‡ºï¼Œåªåœ¨ç¼–è¾‘å™¨æƒ…å†µä¸‹ä½¿ç”¨ã€‚

åœ¨å‘ç”Ÿä½œç”¨çš„åªæœ‰SavePackage2.cppå’ŒLinkerLoad.cppï¼Œå› æ­¤æ˜¯åªå‘ç”Ÿåœ¨ä¿å­˜UPackageçš„æ—¶å€™ï¼Œä½œä¸ºå­ç±»å¯¹è±¡ã€‚æ‰€ä»¥ä¸èƒ½ç”¨ç®€å•çš„å†…å­˜é‡ŒArchiveåºåˆ—åŒ–æ¥è¿›è¡Œæµ‹è¯•ã€‚

```cpp
bool UClass::IsSafeToSerializeToStructuredArchives(UClass* InClass)
{
	while (InClass)
	{
		if (!InClass->HasAnyClassFlags(CLASS_MatchedSerializers))
		{
			return false;
		}
		InClass = InClass->GetSuperClass();
	}
	return true;
}

//LinkerLoad.cpp
bool bClassSupportsTextFormat = UClass::IsSafeToSerializeToStructuredArchives(Object->GetClass());
if (IsTextFormat())//å¦‚æœAråºåˆ—åŒ–æ˜¯æ–‡æœ¬æ ¼å¼
{
			FStructuredArchiveSlot ExportSlot = GetExportSlot(Export.ThisIndex);

			if (bClassSupportsTextFormat) //å¦‚æœç±»æœ¬èº«æ”¯æŒæ–‡æœ¬æ ¼å¼
			{
				Object->GetClass()->SerializeDefaultObject(Object, ExportSlot);
			}
			else
			{
				FStructuredArchiveChildReader ChildReader(ExportSlot);
				FArchiveUObjectFromStructuredArchive Adapter(ChildReader.GetRoot());
				Object->GetClass()->SerializeDefaultObject(Object, Adapter.GetArchive());
			}
}

//SavePackage2.cpp
#if WITH_EDITOR
			bool bSupportsText = UClass::IsSafeToSerializeToStructuredArchives(Export.Object->GetClass());
#else
			bool bSupportsText = false;
#endif

if (bSupportsText)
{
				Export.Object->GetClass()->SerializeDefaultObject(Export.Object, ExportSlot);
}
else
{
				FArchiveUObjectFromStructuredArchive Adapter(ExportSlot);
				Export.Object->GetClass()->SerializeDefaultObject(Export.Object, Adapter.GetArchive());
				Adapter.Close();
}
```

æ–‡æœ¬æ ¼å¼åªåœ¨ç¼–è¾‘å™¨ç¯å¢ƒä¸‹ç”Ÿæ•ˆã€‚

å¯ä»¥ä»æºç çœ‹åˆ°ï¼Œå¦‚æœç±»æœ¬èº«æ”¯æŒæ–‡æœ¬æ ¼å¼åºåˆ—åŒ–ï¼Œåˆ™åœ¨Aræ˜¯æ–‡æœ¬æ ¼å¼çš„æ—¶å€™ï¼Œç›´æ¥å¯ä»¥åºåˆ—åŒ–ï¼Œé‡‡ç”¨é»˜è®¤çš„SerializeTaggedPropertiesã€‚å¦åˆ™å¾—é‡‡ç”¨FArchiveUObjectFromStructuredArchive æ¥é€‚é…ä¸€ä¸‹ï¼ŒæŠŠå¯¹è±¡æŒ‡é’ˆè½¬æ¢ä¸ºobject path+ int32 Indexçš„ç»„åˆã€‚

åœ¨å¼•æ“ä¸­æ‰“å°å‡ºæ‰€æœ‰åŒ…å«æˆ–ä¸åŒ…å«CLASS_MatchedSerializersçš„ç±»ï¼Œå‘ç°UStructç»§æ‰¿é“¾ä¸‹é¢çš„ç±»å¼€å§‹åŒ…å«ï¼ˆä½†æ˜¯UClasså´ä¸åŒ…å«ï¼‰ï¼Œè€Œä¸Šé¢UFieldçš„ç±»åˆ™ä¸åŒ…å«ï¼Œæ¯”å¦‚å„ç§Propertyã€‚ç±»åˆ—è¡¨è§Docä¸‹txtæ–‡ä»¶ã€‚

# NonTransient

- **åŠŸèƒ½æè¿°ï¼š** ä½¿ç»§æ‰¿è‡ªåŸºç±»çš„Transientè¯´æ˜ç¬¦æ— æ•ˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­ç§»é™¤[CLASS_Transient](../../../Flags/EClassFlags/CLASS_Transient.md)
- **å…³è”é¡¹ï¼š** [Transient](Transient/Transient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

# Optional

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°è¯¥ç±»çš„å¯¹è±¡æ˜¯å¯é€‰çš„ï¼Œåœ¨Cookingçš„æ—¶å€™å¯ä»¥é€‰æ‹©æ˜¯å¦è¦å¿½ç•¥ä¿å­˜å®ƒä»¬ã€‚

- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_Optional](../../../../Flags/EClassFlags/CLASS_Optional.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æ ‡è®°è¯¥ç±»çš„å¯¹è±¡æ˜¯å¯é€‰çš„ï¼Œåœ¨Cookingçš„æ—¶å€™å¯ä»¥é€‰æ‹©æ˜¯å¦è¦å¿½ç•¥ä¿å­˜å®ƒä»¬ã€‚

- ä¸€èˆ¬ä¸ºEditorOnlyçš„æ•°æ®ï¼Œå¦‚MetaDataç­‰ï¼Œåœ¨æ¸¸æˆè¿è¡Œæ—¶ä¸å­˜åœ¨ï¼Œä¿å­˜åœ¨å…¶ä»–çš„ç‰¹å®šæ–‡ä»¶ä¸­ã€‚
- Optionalçš„å¯¹è±¡ä¸€èˆ¬ä¹ŸåŒ…åœ¨WITH_EDITORONLY_DATAå®é‡Œï¼Œåªåœ¨ç¼–è¾‘å™¨ä¸‹ä½¿ç”¨ã€‚
- å¼•æ“åœ¨cookçš„æ—¶å€™ï¼Œä¼šæ ¹æ®EDITOROPTIONALçš„é…ç½®æ¥åŠ ä¸ŠSAVE_Optionalï¼Œä»è€Œé€‰æ‹©æ˜¯å¦ä¸€èµ·åºåˆ—åŒ–è¯¥å¯¹è±¡å€¼ï¼Œæ¯”å¦‚metadataã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
//ClassFlags:	CLASS_Optional | CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed 
UCLASS(Optional)
class INSIDER_API UMyClass_Optional :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
};

UCLASS()
class INSIDER_API UMyClass_NotOptional :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
};

UCLASS()
class INSIDER_API UMyClass_Optional_Test :public UObject
{
	GENERATED_BODY()
public:

#if WITH_EDITORONLY_DATA
	UPROPERTY()
		UMyClass_Optional* MyOptionalObject;

#endif // WITH_EDITORONLY_DATA

public:
	UPROPERTY()
		UMyClass_NotOptional* MyNotOptionalObject;
public:
	static void CreatePackageAndSave();
	static void LoadPackageAndTest();
};

void UMyClass_Optional_Test::CreatePackageAndSave()
{
	FString packageName = TEXT("/Game/MyOptionTestPackage");
	FString assetPath = FPackageName::LongPackageNameToFilename(packageName, FPackageName::GetAssetPackageExtension());

	IFileManager::Get().Delete(*assetPath, false, true);

	UPackage* package = CreatePackage(*packageName);
	FSavePackageArgs saveArgs{};
	//saveArgs.TopLevelFlags = EObjectFlags::RF_Public | EObjectFlags::RF_Standalone;
	saveArgs.Error = GError;
	saveArgs.SaveFlags=SAVE_NoError;

	//SAVE_Optional = 0x00008000,	///< Indicate that we to save optional exports. This flag is only valid while cooking. Optional exports are filtered if not specified during cooking. 

	UMyClass_Optional_Test* testObject = NewObject<UMyClass_Optional_Test>(package, TEXT("testObject"));	

#if WITH_EDITORONLY_DATA
	testObject->MyOptionalObject = NewObject<UMyClass_Optional>(testObject, TEXT("MyOptionalObject"));	
	testObject->MyOptionalObject->MyProperty = 456;
#endif

	testObject->MyNotOptionalObject = NewObject<UMyClass_NotOptional>(testObject, TEXT("MyNotOptionalObject"));	

	testObject->MyNotOptionalObject->MyProperty = 456;

	FString str = UInsiderSubsystem::Get().PrintObject(package, EInsiderPrintFlags::All);
	FString str2 = UInsiderSubsystem::Get().PrintObject(testObject, EInsiderPrintFlags::All);
	FString str3 = UInsiderSubsystem::Get().PrintObject(UMyClass_Optional::StaticClass(), EInsiderPrintFlags::All);
	FString str4 = UInsiderSubsystem::Get().PrintObject(UMyClass_NotOptional::StaticClass(), EInsiderPrintFlags::All);

	bool result = UPackage::SavePackage(package, testObject, *assetPath, saveArgs);

}

void UMyClass_Optional_Test::LoadPackageAndTest()
{
	FString packageName = TEXT("/Game/MyOptionTestPackage");
	FString assetPath = FPackageName::LongPackageNameToFilename(packageName, FPackageName::GetAssetPackageExtension());

	UPackage* package = LoadPackage(nullptr, *assetPath, LOAD_None);
	package->FullyLoad();

	UMyClass_Optional_Test* newTestObject = LoadObject<UMyClass_Optional_Test>(package, TEXT("testObject"), *assetPath);
	//UMyClass_Transient_Test* newTestObject = nullptr;

	/*const TArray<FObjectExport>& exportMap = package->GetLinker()->ExportMap;
	for (const auto& objExport : exportMap)
	{
		if (objExport.ObjectName == TEXT("testObject"))
		{
			newTestObject = Cast<UMyClass_Transient_Test>(objExport.Object);
			break;
		}
	}*/
	FString str = UInsiderSubsystem::Get().PrintObject(package, EInsiderPrintFlags::All);

}

```

## ç¤ºä¾‹æ•ˆæœï¼š

æ­£å¸¸çš„SavePackageå‘ç°æ˜¯æ²¡æœ‰ä½œç”¨çš„ï¼Œä¾ç„¶ä¼šåºåˆ—åŒ–ä¿å­˜ã€‚ç‰¹æ®Šçš„ä¿å­˜æ–¹å¼åœ¨Cooké˜¶æ®µï¼Œæœ¬ä¾‹å°±æ²¡æœ‰ä¸“é—¨æµ‹è¯•äº†ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\Optional\Untitled.png)

åœ¨æºç é‡Œæœç´¢Optionalï¼Œå¯ä»¥çœ‹åˆ°ä¸€èˆ¬æ˜¯EditorOnlyDataå’ŒCookedMetaDataç±»åœ¨ä½¿ç”¨ã€‚

```cpp
UCLASS(Optional, Within=Enum)
class ENGINE_API UEnumCookedMetaData : public UObject
UCLASS(Optional, Within=ScriptStruct)
class ENGINE_API UStructCookedMetaData : public UObject
UCLASS(Optional, Within=Class)
class ENGINE_API UClassCookedMetaData : public UObject

UMaterialInterfaceEditorOnlyData* UMaterialInterface::CreateEditorOnlyData()
{
	const UClass* EditorOnlyClass = GetEditorOnlyDataClass();
	check(EditorOnlyClass);
	check(EditorOnlyClass->HasAllClassFlags(CLASS_Optional));

	const FString EditorOnlyName = MaterialInterface::GetEditorOnlyDataName(*GetName());
	const EObjectFlags EditorOnlyFlags = GetMaskedFlags(RF_PropagateToSubObjects);
	return NewObject<UMaterialInterfaceEditorOnlyData>(this, EditorOnlyClass, *EditorOnlyName, EditorOnlyFlags);
}
```

å¼•æ“é‡Œä¹Ÿæœ‰ä¸€äº›éªŒè¯ï¼š

```cpp
UnrealTypeDefinitionInfo.cpp:
// Validate if we are using editor only data in a class or struct definition
if (HasAnyClassFlags(CLASS_Optional))
{
	for (TSharedRef<FUnrealPropertyDefinitionInfo> PropertyDef : GetProperties())
	{
		if (PropertyDef->GetPropertyBase().IsEditorOnlyProperty())
		{
			PropertyDef->LogError(TEXT("Cannot specify editor only property inside an optional class."));
		}
		else if (PropertyDef->GetPropertyBase().ContainsEditorOnlyProperties())
		{
			PropertyDef->LogError(TEXT("Do not specify struct property containing editor only properties inside an optional class."));
		}
	}
}
```

é€šè¿‡æºç å‘ç°ï¼š

//SAVE_Optional = 0x00008000,	///< Indicate that we to save optional exports. This flag is only valid while cooking. Optional exports are filtered if not specified during cooking.

è¿™ä¸ªSAVE_Optional ä½œç”¨äºUUserDefinedEnumï¼ŒUUserDefinedStructï¼ŒUBlueprintGeneratedClassçš„MetaDataå¯¹è±¡ä¸Šã€‚

```cpp
void UUserDefinedStruct::PreSaveRoot(FObjectPreSaveRootContext ObjectSaveContext)
{
	Super::PreSaveRoot(ObjectSaveContext);

	if (ObjectSaveContext.IsCooking() && (ObjectSaveContext.GetSaveFlags() & SAVE_Optional))
	{
	//è¿™ä¸ªå¯¹è±¡æ˜¯ä»¥thisä¸ºOuterçš„ï¼Œæ ‡è®°RF_Standalone | RF_Publicï¼Œä¼šé€ æˆè¯¥å­å¯¹è±¡è¢«åºåˆ—åŒ–ä¸‹æ¥
			UStructCookedMetaData* CookedMetaData = NewCookedMetaData();
			CookedMetaData->CacheMetaData(this);

		if (!CookedMetaData->HasMetaData())
		{
				PurgeCookedMetaData();//æ¸…ç†æ‰è¿™ä¸ªCookedMetaDataå¯¹è±¡
		}
	}
	else
	{
		PurgeCookedMetaData();
	}
}
```

å¦å¤–ï¼Œåœ¨cookçš„æ—¶å€™ï¼Œå¦‚æœæŒ‡å®š

bCookEditorOptional = Switches.Contains(TEXT("EDITOROPTIONAL")); // Produce the optional editor package data alongside the cooked data.

åˆ™ä¼šåŠ ä¸ŠCookEditorOptional çš„æ ‡è¯†

CookFlags |= bCookEditorOptional ? ECookInitializationFlags::CookEditorOptional : ECookInitializationFlags::None;

å†ä¹‹ååˆ™ä¼šä¼ è¾¾SAVE_Optional ç»™Packageçš„SaveFlags

SaveFlags |= COTFS.IsCookFlagSet(ECookInitializationFlags::CookEditorOptional) ? SAVE_Optional : SAVE_None;

ä»è€Œåœ¨åŒ…æ‹¬Packageçš„æ—¶å€™ï¼ŒIsSaveOptional()çš„åˆ¤æ–­ä¼šé€ æˆæ˜¯å¦åˆ›å»ºOptionalçš„Realmï¼Œ

```cpp
TArray<ESaveRealm> FSaveContext::GetHarvestedRealmsToSave()
{
	TArray<ESaveRealm> HarvestedContextsToSave;
	if (IsCooking())
	{
		HarvestedContextsToSave.Add(ESaveRealm::Game);
		if (IsSaveOptional())
		{
			HarvestedContextsToSave.Add(ESaveRealm::Optional);
		}
	}
	else
	{
		HarvestedContextsToSave.Add(ESaveRealm::Editor);
	}
	return HarvestedContextsToSave;
}
```

è¿˜æœ‰å¦‚æœå‘ç°Objectæœ‰CLASS_Optionalï¼Œåˆ™ä¸æŠŠå®ƒå½“åšExport(å­å¯¹è±¡)ï¼Œè€Œæ˜¯å½“åšImport(å¼•ç”¨çš„å¯¹è±¡)ï¼ŒOptionalå¯¹è±¡æœ‰å¯èƒ½æ”¾åœ¨å¤–éƒ¨ç‹¬ç«‹çš„æ–‡ä»¶ä¸­ã€‚

```cpp
ESavePackageResult HarvestPackage(FSaveContext& SaveContext)
{
// If we have a valid optional context and we are saving it,
	// transform any harvested non optional export into imports
	// Mark other optional import package as well
	if (!SaveContext.IsSaveAutoOptional() &&
		SaveContext.IsSaveOptional() &&
		SaveContext.IsCooking() &&
		SaveContext.GetHarvestedRealm(ESaveRealm::Optional).GetExports().Num() &&
		SaveContext.GetHarvestedRealm(ESaveRealm::Game).GetExports().Num())
	{
		bool bHasNonOptionalSelfReference = false;
		FHarvestedRealm& OptionalContext = SaveContext.GetHarvestedRealm(ESaveRealm::Optional);
		for (auto It = OptionalContext.GetExports().CreateIterator(); It; ++It)
		{
			if (!It->Obj->GetClass()->HasAnyClassFlags(CLASS_Optional))
			{
				// Make sure the export is found in the game context as well
				if (FTaggedExport* GameExport = SaveContext.GetHarvestedRealm(ESaveRealm::Game).GetExports().Find(It->Obj))
				{
					// Flag the export in the game context to generate it's public hash
					GameExport->bGeneratePublicHash = true;
					// Transform the export as an import
					OptionalContext.AddImport(It->Obj);
					// Flag the package itself to be an import
					bHasNonOptionalSelfReference = true;
				}
				// if not found in the game context and the reference directly came from an optional object, record an illegal reference
				else if (It->bFromOptionalReference)
				{
					SaveContext.RecordIllegalReference(nullptr, It->Obj, EIllegalRefReason::ReferenceFromOptionalToMissingGameExport);
				}
				It.RemoveCurrent();
			}
		}
		// Also add the current package itself as an import if we are referencing any non optional export
		if (bHasNonOptionalSelfReference)
		{
			OptionalContext.AddImport(SaveContext.GetPackage());
		}
	}
}
```

# Transient

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡éƒ½ç•¥è¿‡åºåˆ—åŒ–ã€‚

- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_Transient](../../../../Flags/EClassFlags/CLASS_Transient.md)
- **å…³è”é¡¹ï¼š** [NonTransient](../NonTransient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡éƒ½ç•¥è¿‡åºåˆ—åŒ–ã€‚

- ä»ä¸å°†å±äºæ­¤ç±»çš„å¯¹è±¡ä¿å­˜åˆ°ç£ç›˜ã€‚æ­¤è¯´æ˜ç¬¦ä¼šä¼ æ’­åˆ°å­ç±»ï¼Œä½†æ˜¯å¯ç”±NonTransientè¯´æ˜ç¬¦è¦†ç›–ã€‚å¯ä»¥åœ¨å­ç±»è¢«æ”¹å†™.
- ä¼šé€ æˆç›¸åº”Objectçš„RF_Transientæ ‡è®°ã€‚
- æ³¨æ„ï¼šUPROPERTY(Transient)åªæ˜¯æŒ‡å®šè¿™ä¸€ä¸ªç‰¹å®šçš„å±æ€§ä¸åºåˆ—åŒ–ã€‚è€ŒUCLASS(Transient)æ˜¯ä½œç”¨äºè¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, Transient)
class INSIDER_API UMyClass_Transient :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
};

UCLASS(Blueprintable, NonTransient)
class INSIDER_API UMyClass_NonTransient :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty = 123;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyClass_Transient_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UMyClass_Transient* MyTransientObject;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UMyClass_NonTransient* MyNonTransientObject;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Normal=123;
		UPROPERTY(EditAnywhere, BlueprintReadWrite,Transient)
		int32 MyInt_Transient =123;
};
```

åºåˆ—åŒ–å¯¹è±¡æŒ‡é’ˆå…³é”®æ˜¯é‡‡ç”¨FObjectPropertyé‡Œçš„SerializeItemæ–¹æ³•Slot << ObjectValue;

ä¸èƒ½é‡‡ç”¨Actorçš„Class Defaultæ¥æµ‹è¯•ï¼Œå› ä¸ºï¼š

Transient properties are serialized for (Blueprint) Class Default Objects but should not be serialized for any 'normal' instances of classes.

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyActor_Transient_Test :public AActor
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UMyClass_Transient* MyTransientObject;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		UMyClass_NonTransient* MyNonTransientObject;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Normal=123;
		UPROPERTY(EditAnywhere, BlueprintReadWrite,Transient)
		int32 MyInt_Transient =123;
};
```

ä¹Ÿä¸èƒ½ç”¨FObjectAndNameAsStringProxyArchiveæµ‹è¯•ï¼Œå› ä¸ºFObjectAndNameAsStringProxyArchiveå†…éƒ¨åœ¨åºåˆ—åŒ–å¯¹è±¡çš„æ—¶å€™ï¼Œä¼šå…ˆæŸ¥æ‰¾åå­—ã€‚

```cpp
FArchive& FObjectAndNameAsStringProxyArchive::operator<<(UObject*& Obj)
{
	if (IsLoading())
	{
		// load the path name to the object
		FString LoadedString;
		InnerArchive << LoadedString;
		// look up the object by fully qualified pathname
		Obj = FindObject<UObject>(nullptr, *LoadedString, false);
		// If we couldn't find it, and we want to load it, do that
		if(!Obj && bLoadIfFindFails)
		{
			Obj = LoadObject<UObject>(nullptr, *LoadedString);
		}
	}
	else
	{
		// save out the fully qualified object name
		FString SavedString(Obj->GetPathName());
		InnerArchive << SavedString;
	}
	return *this;
}
```

å› æ­¤é‡‡ç”¨Packageçš„æµ‹è¯•ï¼š

```cpp

FString packageName = TEXT("/Game/MyTestPackage");
FString assetPath = FPackageName::LongPackageNameToFilename(packageName, FPackageName::GetAssetPackageExtension());
UPackage* package = CreatePackage(*packageName);
FSavePackageArgs saveArgs{};
saveArgs.Error = GError;

//ObjectFlags:	RF_NoFlags
UMyClass_Transient_Test* testObject = NewObject<UMyClass_Transient_Test>(package, TEXT("testObject"));	
//ObjectFlags:	RF_Transient 
testObject->MyTransientObject = NewObject<UMyClass_Transient>(testObject, TEXT("MyTransientObject"));	
//ObjectFlags:	RF_NoFlags
testObject->MyNonTransientObject = NewObject<UMyClass_NonTransient>(testObject, TEXT("MyNonTransientObject"));	

testObject->MyTransientObject->MyProperty = 456;
testObject->MyNonTransientObject->MyProperty = 456;
testObject->MyInt_Normal = 456;
testObject->MyInt_Transient = 456;

bool result = UPackage::SavePackage(package, testObject, *assetPath, saveArgs);
```

åœ¨ä¿å­˜å®Œæˆä¹‹åï¼Œé‡æ–°åŠ è½½Package:

```cpp
FString packageName = TEXT("/Game/MyTestPackage");
FString assetPath = FPackageName::LongPackageNameToFilename(packageName, FPackageName::GetAssetPackageExtension());

UPackage* package = LoadPackage(nullptr, *assetPath, LOAD_None);
package->FullyLoad();

UMyClass_Transient_Test* newTestObject=LoadObject<UMyClass_Transient_Test>(package, TEXT("testObject"),*assetPath);
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯ä»¥çœ‹åˆ°MyTransientObject å¹¶æ²¡æœ‰è¢«åºåˆ—åŒ–åˆ°ç£ç›˜ä¸Šï¼Œå› æ­¤ä¸ä¼šåŠ è½½å‡ºæ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\Serialization\Transient\Untitled.png)

## åŸç†ï¼š

åœ¨SavePackageçš„æ—¶å€™ï¼šRF_Transientä¼šå¯¼è‡´è¿™ä¸ªå¯¹è±¡ä¸ä¼šè¢«HarvestExportï¼Œä¸ä¼šè¢«æ”¾è¿›SaveContexté‡Œ

```cpp
void FPackageHarvester::TryHarvestExport(UObject* InObject)
{
	// Those should have been already validated
	check(InObject && InObject->IsInPackage(SaveContext.GetPackage()));

	// Get the realm in which we should harvest this export
	EIllegalRefReason Reason = EIllegalRefReason::None;
	ESaveRealm HarvestContext = GetObjectHarvestingRealm(InObject, Reason);
	if (!SaveContext.GetHarvestedRealm(HarvestContext).IsExport(InObject))
	{
		SaveContext.MarkUnsaveable(InObject);
		bool bExcluded = false;
		if (!InObject->HasAnyFlags(RF_Transient))
		{
			bExcluded = ConditionallyExcludeObjectForTarget(SaveContext, InObject, HarvestContext);
		}
		if (!InObject->HasAnyFlags(RF_Transient) && !bExcluded)
		{
			// It passed filtering so mark as export
			HarvestExport(InObject, HarvestContext);
		}

		// If we have a illegal ref reason, record it
		if (Reason != EIllegalRefReason::None)
		{
			SaveContext.RecordIllegalReference(CurrentExportDependencies.CurrentExport, InObject, Reason);
		}
	}
}
```

# HideDropDown

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨ç±»é€‰æ‹©å™¨ä¸­éšè—æ­¤ç±»
- **å¼•æ“æ¨¡å—ï¼š** TypePicker
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_HideDropDown](../../../../Flags/EClassFlags/CLASS_HideDropDown.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…**

åœ¨ç±»é€‰æ‹©å™¨ä¸­éšè—æ­¤ç±»ï¼Œé€šå¸¸æ˜¯TSubClassOfè§¦å‘ï¼Œæˆ–è€…Classå˜é‡è§¦å‘çš„ç±»é€‰æ‹©çª—å£ã€‚è¿™ä¸ªæ—¶å€™ï¼Œè¿™ä¸ªæ ‡è¯†ç¬¦å¯ä»¥é˜»æ­¢å…¶å‡ºç°ã€‚åœ¨æºç é‡Œçš„ä½¿ç”¨ï¼Œé€šå¸¸æ˜¯ä¸€äº›æ—§çš„åºŸå¼ƒçš„ç±»æˆ–è€…Testç±»ï¼ŒAbstractç±»å’ŒåŸºç±»ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable)
class INSIDER_API UMyClass_HideDropDownBase :public UObject
{
	GENERATED_BODY()
public:
};

UCLASS(Blueprintable, hidedropdown)
class INSIDER_API UMyClass_HideDropDown :public UMyClass_HideDropDownBase
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
};

UCLASS(Blueprintable, hidedropdown)
class INSIDER_API UMyClass_NoHideDropDown :public UMyClass_HideDropDownBase
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyProperty;
};

UCLASS(Blueprintable)
class INSIDER_API UMyClass_HideDropDown_Test :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TSubclassOf<UMyClass_HideDropDownBase> DropDownClass;
};
```

## ç¤ºä¾‹ç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\TypePicker\HideDropDown\Untitled.png)

## åŸç†ï¼š

HideDropDownä¼šé€ æˆCLASS_HideDropDownæ ‡è®°ï¼Œä»è€Œåœ¨ç±»å‹UIå®šåˆ¶åŒ–çš„åˆ—è¡¨é‡ŒæŠŠè¯¥ç±»å‰”é™¤å‡ºå»ã€‚

```cpp
template <typename TClass>
bool FPropertyEditorClassFilter::IsClassAllowedHelper(TClass InClass)
{
	bool bMatchesFlags = !InClass->HasAnyClassFlags(CLASS_Hidden | CLASS_HideDropDown | CLASS_Deprecated) &&
		(bAllowAbstract || !InClass->HasAnyClassFlags(CLASS_Abstract));

	if (bMatchesFlags && InClass->IsChildOf(ClassPropertyMetaClass)
		&& (!InterfaceThatMustBeImplemented || InClass->ImplementsInterface(InterfaceThatMustBeImplemented)))
	{
		auto PredicateFn = [InClass](const UClass* Class)
		{
			return InClass->IsChildOf(Class);
		};

		if (DisallowedClassFilters.FindByPredicate(PredicateFn) == nullptr &&
			(AllowedClassFilters.Num() == 0 || AllowedClassFilters.FindByPredicate(PredicateFn) != nullptr))
		{
			return true;
		}
	}

	return false;
}
```

# CustomConstructor

- **åŠŸèƒ½æè¿°ï¼š** é˜»æ­¢æ„é€ å‡½æ•°å£°æ˜è‡ªåŠ¨ç”Ÿæˆã€‚
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_CustomConstructor](../../../Flags/EClassFlags/CLASS_CustomConstructor.md)

UHTä¸ä¼šç”Ÿæˆ NO_API UMyClass_ModuleAPI(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());çš„é»˜è®¤æ„é€ å‡½æ•°ã€‚ä½†æ˜¯è¿™ä¸ªä¸€èˆ¬éƒ½æ˜¯é…åˆGENERATED_UCLASS_BODYä½¿ç”¨çš„ï¼Œå› ä¸ºGENERATED_BODYä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°ã€‚ä¸€èˆ¬åœ¨è‡ªå·±éœ€è¦è‡ªå®šä¹‰è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ä½¿ç”¨ã€‚ï¼ˆä½†å…¶å®ç”¨GENERATED_BODYä¹Ÿè¡Œï¼‰

å½“å‰å·²ç»å¼ƒç”¨ï¼š

```cpp
CLASS_CustomConstructor UE_DEPRECATED(5.1, "CLASS_CustomConstructor should no longer be used. It is no longer being set by engine code.") = 0x00008000u,
```

# CustomFieldNotify

- **åŠŸèƒ½æè¿°ï¼š** é˜»æ­¢UHTä¸ºè¯¥ç±»ç”ŸæˆFieldNotifyçš„ç›¸å…³ä»£ç ã€‚

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [HasCustomFieldNotify](../../../Flags/EClassFlags/HasCustomFieldNotify.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

é˜»æ­¢UHTä¸ºè¯¥ç±»ç”ŸæˆFieldNotifyçš„ç›¸å…³ä»£ç ã€‚

åœ¨æºç é‡Œåªåœ¨UWidgetä¸Šä½¿ç”¨ï¼Œä¾‹å¦‚è¯¥ç±»é‡Œé¢çš„bIsEnabledæ˜¯FieldNotifyï¼Œæ­£å¸¸æ¥è¯´UHTè¦ä¸ºå…¶ç”Ÿæˆä»£ç ã€‚ä½†å¦‚æœè¯¥ç±»æƒ³è‡ªå·±æ‰‹åŠ¨ä¹¦å†™è¿™äº›UHTä»£ç ï¼Œåˆ™å¯ä»¥åŠ ä¸ŠCustomFieldNotifyæ¥é˜»æ­¢UHTç”Ÿæˆã€‚UWidgetçš„cppé‡Œå› ä¸ºè¦ç”¨åˆ«çš„æ–¹å¼UE_FIELD_NOTIFICATION_IMPLEMENT_CLASS_DESCRIPTORï¼Œå› æ­¤è¦æ‹’ç»UHTç”Ÿæˆã€‚

å¦‚æœè‡ªå·±çš„ç±»ä¹Ÿè¦è‡ªå·±UE_FIELD_NOTIFICATION_IMPLEMENT_CLASS_DESCRIPTORï¼Œåˆ™å¯ä»¥ç”¨ä¸ŠCustomFieldNotifyã€‚

## æºç ä¾‹å­ï¼š

```cpp
//E:\P4V\Engine\Source\Runtime\UMG\Public\FieldNotification\FieldNotificationDeclaration.h
UCLASS(Abstract, BlueprintType, Blueprintable, CustomFieldNotify)
class UMG_API UWidget : public UVisual, public INotifyFieldValueChanged
{
	GENERATED_UCLASS_BODY()
public:
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_BASE_BEGIN(UMG_API)
		UE_FIELD_NOTIFICATION_DECLARE_FIELD(ToolTipText)
		UE_FIELD_NOTIFICATION_DECLARE_FIELD(Visibility)
		UE_FIELD_NOTIFICATION_DECLARE_FIELD(bIsEnabled)
		UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_BEGIN(ToolTipText)
		UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(Visibility)
		UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(bIsEnabled)
		UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_END()
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_BASE_END();
	
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, FieldNotify, Getter="GetIsEnabled", Setter="SetIsEnabled", BlueprintGetter="GetIsEnabled", BlueprintSetter="SetIsEnabled", Category="Behavior")
	uint8 bIsEnabled:1;
	
	//cpp
UE_FIELD_NOTIFICATION_IMPLEMENT_CLASS_DESCRIPTOR_ThreeFields(UWidget, ToolTipText, Visibility, bIsEnabled);

```

## åŸç†ï¼š

åœ¨åˆ¤æ–­æ¡ä»¶ä¸Šå¯è§HasCustomFieldNotifyçš„åˆ¤æ–­ã€‚

```cpp
		protected static bool NeedFieldNotifyCodeGen(UhtClass classObj)
		{
			return
				!classObj.ClassExportFlags.HasAnyFlags(UhtClassExportFlags.HasCustomFieldNotify) &&
				classObj.ClassExportFlags.HasAnyFlags(UhtClassExportFlags.HasFieldNotify);
		}

```

# CustomThunkTemplates

- **åŠŸèƒ½æè¿°ï¼š** Specifies the struct that contains the CustomThunk implementations

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool

åœ¨æºç é‡Œæ‰¾ä¸åˆ°å¼•ç”¨çš„åœ°æ–¹

# Interface

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†è¿™ä¸ªClassæ˜¯ä¸ªInterfaceã€‚
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­æ·»åŠ [CLASS_Interface](../../../Flags/EClassFlags/CLASS_Interface.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æ ‡è¯†è¿™ä¸ªClassæ˜¯ä¸ªInterfaceã€‚

åªç”¨åœ¨NoExportTypes.hä¸­ï¼Œæˆ‘ä»¬è‡ªå·±çš„UInterfaceä¸éœ€è¦æ‰‹åŠ¨è®¾ç½®ã€‚

æ˜¯UHTåœ¨ä¸ºUInterfaceç”Ÿæˆçš„æ—¶å€™ï¼Œè®¾ç½®åœ¨.generated.hé‡Œçš„ã€‚

## æºç ä¾‹å­ï¼š

```cpp
UCLASS(abstract, noexport, intrinsic, interface, Config = Engine)
class UInterface : public UObject
{}
```

## åŸç†ï¼š

```cpp
bool FKismetEditorUtilities::IsClassABlueprintInterface(const UClass* Class)
{
	if (Class->HasAnyClassFlags(CLASS_Interface) && !Class->HasAnyClassFlags(CLASS_NewerVersionExists))
	{
		return true;
	}
	return false;
}
```

# Intrinsic

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTå®Œå…¨ä¸ä¸ºæ­¤ç±»ç”Ÿæˆä»£ç ï¼Œéœ€è¦è‡ªå·±æ‰‹å†™ã€‚

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_Intrinsic](../../../Flags/EClassFlags/CLASS_Intrinsic.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šUHTå®Œå…¨ä¸ä¸ºæ­¤ç±»ç”Ÿæˆä»£ç ï¼Œéœ€è¦è‡ªå·±æ‰‹å†™ã€‚

åªåœ¨C++ç›´æ¥è®¾å®šï¼Œä¸€èˆ¬æ–°ç±»ä¸è®¾å®šè¿™ä¸ªï¼Œæ ‡è®°è¿™ä¸ªçš„éƒ½æ˜¯UE4å†…éƒ¨åŸç”Ÿçš„é‚£äº›ç±»ï¼Œç›¸å½“äºå·²ç»åœ¨æºç ä¸­æ‰‹å†™äº†å…ƒæ•°æ®ä»£ç ã€‚

noexportè‡³å°‘è¿˜ä¼šè§£æç”Ÿæˆå…ƒæ•°æ®ï¼Œåªæ˜¯ç¼ºå°‘æ³¨å†Œã€‚å› æ­¤instricç±»çš„æ‰€æœ‰å…ƒæ•°æ®flagsè¦è‡ªå·±æ‰‹åŠ¨æ ‡è®°ã€‚ä½†æ˜¯intrinsicå®Œå…¨ä¸ç”Ÿæˆä»£ç ã€‚å…¶generated.hå’Œ.gen.cppé‡Œé¢éƒ½æ˜¯ç©ºçš„ã€‚noexporttyps.hé‡Œçš„ç›®å‰é‡‡ç”¨intrinsicçš„ç±»åªæœ‰UCLASS(noexport, Intrinsic)class UModel{}ï¼Œè¿™è¿˜æ˜¯è¢«cppä¸ç¼–è¯‘çš„ã€‚

```cpp
//UCLASS(Intrinsic)
//class INSIDER_API UMyClass_Intrinsic :public UObject	//syntax error: missing ';' before '<class-head>'
//{
//	GENERATED_BODY()
//
//};

//.h
class INSIDER_API UMyClass_Intrinsic :public UObject
{
	DECLARE_CLASS_INTRINSIC(UMyClass_Intrinsic, UObject, CLASS_MatchedSerializers, TEXT("/Script/Insider"))
};
//.cpp
IMPLEMENT_INTRINSIC_CLASS(UMyClass_Intrinsic, INSIDER_API, UObject, INSIDER_API, "/Script/Insider", {})

class COREUOBJECT_API UInterface : public UObject
{
	DECLARE_CLASS_INTRINSIC(UInterface, UObject, CLASS_Interface | CLASS_Abstract, TEXT("/Script/CoreUObject"))
};
```

# MinimalAPI

- **åŠŸèƒ½æè¿°ï¼š** ä¸dllå¯¼å‡ºè¯¥ç±»çš„å‡½æ•°ï¼Œåªå¯¼å‡ºç±»å‹ä¿¡æ¯å½“ä½œå˜é‡ã€‚

- **å¼•æ“æ¨¡å—ï¼š** DllExport
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagså¢åŠ [CLASS_MinimalAPI](../../../../Flags/EClassFlags/CLASS_MinimalAPI.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸dllå¯¼å‡ºè¯¥ç±»çš„å‡½æ•°ï¼Œåªå¯¼å‡ºç±»å‹ä¿¡æ¯å½“ä½œå˜é‡ã€‚

- å…¶ä»–å¼•ç”¨çš„æ¨¡å—å¯ä»¥åˆ©ç”¨æŒ‡é’ˆæ¥åšè½¬æ¢ï¼Œä½†æ˜¯ä¸èƒ½è°ƒç”¨ä¸Šé¢çš„å‡½æ•°ã€‚ä½†æ˜¯è“å›¾é‡Œä¾ç„¶å¯ä»¥è®¿é—®ã€‚
- å¥½å¤„æ˜¯å¯ä»¥ç¼©çŸ­ç¼–è¯‘ä¿¡æ¯å’ŒåŠ å¿«é“¾æ¥é€Ÿåº¦ï¼Œå› ä¸ºæ²¡æœ‰äº†é‚£ä¹ˆå¤šdllexportå‡½æ•°ã€‚
- æ³¨æ„MinimalAPIä¸èƒ½å’ŒMODULENAME_APIä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºMinimalAPIå°±æ˜¯ç”¨æ¥ä¸å¯¼å‡ºçš„ï¼Œè€ŒMODULENAME_APIå°±æ˜¯ç”¨æ¥å¯¼å‡ºçš„ã€‚ä½†æ˜¯MinimalAPIçš„æ•ˆæœå¹¶ä¸ç­‰ä»·äºä¸å†™MODULENAME_APIçš„æ•ˆæœï¼Œå› ä¸ºMinimalAPIè¿˜ä¼šå¯¼å‡ºGetPrivateStaticClassç”¨æ¥å…è®¸NewObjectã€‚æ‰€ä»¥å¦‚æœä¸€ä¸ªç±»å®Œå…¨ä¸æƒ³è®©å¦ä¸€ä¸ªæ¨¡å—çŸ¥é“ï¼Œåˆ™ä¸éœ€è¦å†™ä»»ä½•å¯¼å‡ºã€‚è€Œå¦‚æœæƒ³è®©å¦ä¸€ä¸ªæ¨¡å—çŸ¥é“ç±»å‹ï¼Œä½†æ˜¯å®Œå…¨ä¸èƒ½è°ƒç”¨å‡½æ•°ï¼Œåˆ™å¯ä»¥ç”¨MinimalAPIæ¥é˜²æ­¢ã€‚
- æ¸¸æˆçš„æ¨¡å—æ¨èä¸å¯¼å‡ºã€‚æ’ä»¶çš„æ¨¡å—å¤–éƒ¨çš„æ¨èå¯¼å‡ºï¼Œå†…éƒ¨çš„åŸºç±»å¯ä»¥è€ƒè™‘MinimalAPIï¼Œç§æœ‰ç±»åˆ™å¯ä»¥å®Œå…¨ä¸å¯¼å‡ºã€‚å¼•æ“é‡Œä½¿ç”¨MinimalAPIè¿˜æ˜¯éå¸¸å¤šçš„ï¼Œç”Ÿæˆçš„æ•ˆæœæ˜¯è¿™äº›ç±»å¯ä»¥ä½œä¸ºå˜é‡ä½¿ç”¨ï¼Œä½†ä¸èƒ½ç»§æ‰¿å’Œè°ƒç”¨æ–¹æ³•ã€‚
- ä¸€èˆ¬æ˜¯é…åˆBlueprintTypeä½¿ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨è“å›¾ä¸­ä½œä¸ºå˜é‡ã€‚
- å¯ä»¥æ­£å¸¸åœ¨è“å›¾ä¸­è°ƒç”¨å‡½æ•°å’Œå±æ€§ã€‚å› ä¸ºè“å›¾è°ƒç”¨æ˜¯åªéœ€è¦åå°„ä¿¡æ¯å°±å¯ä»¥çš„ï¼Œå› ä¸ºæ˜¯è‡ªå·±æ¨¡å—æŠŠå‡½æ•°å’Œå±æ€§çš„æŒ‡é’ˆæ³¨å†Œåˆ°ç³»ç»Ÿé‡Œã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS()
class UMyClass_NotMinimalAPI :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
	UFUNCTION(BlueprintCallable)
	void MyFunc();
};

UCLASS(MinimalAPI)
class UMyClass_MinimalAPI :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
	UFUNCTION(BlueprintCallable)
	void MyFunc();
};

UCLASS(MinimalAPI, BlueprintType)
class UMyClass_MinimalAPI_BlueprintType :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty;
	UFUNCTION(BlueprintCallable)
	void MyFunc() {}
};

UCLASS(MinimalAPI)
class UMyClass_MinimalAPI_BlueprintFunctionLibary :public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:

	UFUNCTION(BlueprintCallable)
	static void MyFuncInMinimalAPI();

	UFUNCTION(BlueprintCallable)
	static INSIDER_API void MyFuncInMinimalAPIWithAPI();
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯ä»¥æ­£å¸¸åœ¨è“å›¾ä¸­è°ƒç”¨å‡½æ•°å’Œå±æ€§ã€‚è“å›¾å‡½æ•°åº“ä¸­çš„æ–¹æ³•ä¹Ÿå¯ä»¥è°ƒç”¨ï¼Œè¯´æ˜UHTå¯¹MinimalAPIè¿˜æ˜¯ä¾ç„¶ç”Ÿæˆåå°„çš„è°ƒç”¨ä¿¡æ¯çš„ï¼Œè“å›¾è°ƒç”¨æ˜¯åªéœ€è¦åå°„ä¿¡æ¯å°±å¯ä»¥çš„ï¼Œå› ä¸ºæ˜¯è‡ªå·±æ¨¡å—æŠŠå‡½æ•°å’Œå±æ€§çš„æŒ‡é’ˆæ³¨å†Œåˆ°ç³»ç»Ÿé‡Œï¼Œå› æ­¤å¹¶ä¸éœ€è¦dllå¯¼å‡ºã€‚åªä¸è¿‡åœ¨dllå¯¼å‡ºå·¥å…·é‡ŒæŸ¥çœ‹dllå¯¼å‡ºçš„å‡½æ•°åˆ—è¡¨å¹¶æ²¡æœ‰è¯¥å‡½æ•°ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\UHT\MinimalAPI\Untitled.png)

æŸ¥çœ‹dllå¯¼å‡ºå‡½æ•°åˆ—è¡¨ï¼š

```cpp
class UClass * __ptr64 __cdecl StaticClass<class UMyClass_MinimalAPI>(void)
class UClass * __ptr64 __cdecl StaticClass<class UMyClass_MinimalAPI_BlueprintFunctionLibary>(void)
class UClass * __ptr64 __cdecl StaticClass<class UMyClass_MinimalAPI_BlueprintType>(void)
class UClass * __ptr64 __cdecl StaticClass<class UMyClass_NotMinimalAPI>(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI_BlueprintFunctionLibary(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI_BlueprintFunctionLibary_NoRegister(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI_BlueprintType(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI_BlueprintType_NoRegister(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_MinimalAPI_NoRegister(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_NotMinimalAPI(void)
class UClass * __ptr64 __cdecl Z_Construct_UClass_UMyClass_NotMinimalAPI_NoRegister(void)
private: static class UClass * __ptr64 __cdecl UMyClass_MinimalAPI::GetPrivateStaticClass(void)
private: static class UClass * __ptr64 __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::GetPrivateStaticClass(void)
private: static class UClass * __ptr64 __cdecl UMyClass_MinimalAPI_BlueprintType::GetPrivateStaticClass(void)
public: __cdecl UMyClass_MinimalAPI::UMyClass_MinimalAPI(class FObjectInitializer const & __ptr64) __ptr64
public: __cdecl UMyClass_MinimalAPI::UMyClass_MinimalAPI(class FVTableHelper & __ptr64) __ptr64
public: __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::UMyClass_MinimalAPI_BlueprintFunctionLibary(class FObjectInitializer const & __ptr64) __ptr64
public: __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::UMyClass_MinimalAPI_BlueprintFunctionLibary(class FVTableHelper & __ptr64) __ptr64
public: __cdecl UMyClass_MinimalAPI_BlueprintType::UMyClass_MinimalAPI_BlueprintType(class FObjectInitializer const & __ptr64) __ptr64
public: __cdecl UMyClass_MinimalAPI_BlueprintType::UMyClass_MinimalAPI_BlueprintType(class FVTableHelper & __ptr64) __ptr64
public: static void __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::MyFuncInMinimalAPIWithAPI(void)
public: virtual __cdecl UMyClass_MinimalAPI::~UMyClass_MinimalAPI(void) __ptr64
public: virtual __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::~UMyClass_MinimalAPI_BlueprintFunctionLibary(void) __ptr64
public: virtual __cdecl UMyClass_MinimalAPI_BlueprintType::~UMyClass_MinimalAPI_BlueprintType(void) __ptr64
public: void __cdecl UMyClass_MinimalAPI::`default constructor closure'(void) __ptr64
public: void __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::`default constructor closure'(void) __ptr64
public: void __cdecl UMyClass_MinimalAPI_BlueprintType::`default constructor closure'(void) __ptr64
```

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UCLASS\UHT\MinimalAPI\Untitled%201.png)

åœ¨è·¨æ¨¡å—è°ƒç”¨çš„æ—¶å€™ï¼Œå› ä¸ºæ²¡æœ‰dllå¯¼å‡ºï¼Œå› æ­¤ä¼šè§¦å‘é“¾æ¥é”™è¯¯ã€‚

```cpp
UMyClass_MinimalAPI* a = NewObject<UMyClass_MinimalAPI>();

//ç¬¬ä¸€ç§é”™è¯¯
//error LNK2019: unresolved external symbol "public: void __cdecl UMyClass_MinimalAPI::MyFunc(void)" (?MyFunc@UMyClass_MinimalAPI@@QEAAXXZ) referenced in function "public: void __cdecl UMyClass_UseMinimalAPI::TestFunc(void)" (?TestFunc@UMyClass_UseMinimalAPI@@QEAAXXZ)
//a->MyFunc();

a->MyProperty++;

//ç¬¬äºŒç§é”™è¯¯
//error LNK2019: unresolved external symbol "private: static class UClass * __cdecl UMyClass_NotMinimalAPI::GetPrivateStaticClass(void)" (?GetPrivateStaticClass@UMyClass_NotMinimalAPI@@CAPEAVUClass@@XZ)
//referenced in function "class UMyClass_NotMinimalAPI * __cdecl NewObject<class UMyClass_NotMinimalAPI>(class UObject *)" (??$NewObject@VUMyClass_NotMinimalAPI@@@@YAPEAVUMyClass_NotMinimalAPI@@PEAVUObject@@@Z)
auto* a = NewObject<UMyClass_NotMinimalAPI>();

//ç¬¬ä¸‰ç§é”™è¯¯
//error LNK2019: unresolved external symbol "public: static void __cdecl UMyClass_MinimalAPI_BlueprintFunctionLibary::MyFuncInMinimalAPI(void)" (?MyFuncInMinimalAPI@UMyClass_MinimalAPI_BlueprintFunctionLibary@@SAXXZ) 
//referenced in function "public: void __cdecl UMyClass_UseMinimalAPI::TestFunc(void)" (?TestFunc@UMyClass_UseMinimalAPI@@QEAAXXZ)
UMyClass_MinimalAPI_BlueprintFunctionLibary::MyFuncInMinimalAPI();

UMyClass_MinimalAPI_BlueprintFunctionLibary::MyFuncInMinimalAPIWithAPI();
```

# NoExport

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ EClassFlags: [CLASS_NoExport](../../../Flags/EClassFlags/CLASS_NoExport.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚

å¼•æ“çš„NoExportTypes.hé‡Œå¤§é‡éƒ½æ˜¯è¿™ç§ç±»å‹ï¼Œä¸“é—¨æä¾›ç»™UHTæ¥æå–ä¿¡æ¯çš„ã€‚ä¸€èˆ¬ä¼šç”¨#if !CPP //noexport classæ¥åŒ…è£¹ï¼Œæ¥é¿å…ç¼–è¯‘ã€‚åŒæ—¶åœ¨å¦ä¸€ä¸ªåœ°æ–¹ä¼šå®šä¹‰è¿™ä¸ªç±»ã€‚å› ä¸ºStaticRegisterNatives##TClassæ²¡æœ‰ç”Ÿæˆï¼Œæ‰€ä»¥GetPrivateStaticClassä¸èƒ½è°ƒç”¨æˆåŠŸï¼Œæ‰€ä»¥ä¸èƒ½NewObjectã€‚ä¸€èˆ¬noexportå’ŒIntrinsicéƒ½æ˜¯é…åˆä½¿ç”¨çš„ã€‚å› ä¸ºDECLARE_CLASS_INTRINSICå†…éƒ¨ä¼šå£°æ˜static void StaticRegisterNatives##TClass() {} æ¥å…è®¸æˆåŠŸè°ƒç”¨ã€‚

å¼•æ“é‡Œçš„ç»“æ„å€’æ˜¯ç»å¸¸ç”¨noexportæ¥é˜»æ­¢ç”ŸæˆUHTæ³¨å†Œã€‚å› ä¸ºç»“æ„å…¶å®ä¸éœ€è¦è°ƒç”¨GetPrivateStaticClassæ¥åˆ›å»ºå…ƒæ•°æ®ã€‚åªè¦æœ‰Z_Construct_UScriptStruct_XXXæ¥ç”Ÿæˆæ„é€ ç›¸åº”çš„UScriptStructå¯¹è±¡å°±è¡Œã€‚

## æµ‹è¯•ä»£ç :

```cpp
UCLASS(noexport)
class INSIDER_API UMyClass_NoExport :public UObject
{
	GENERATED_BODY()
public:
};
```

## æµ‹è¯•ç»“æœï¼š

```cpp
ç¼–è¯‘çš„æ—¶å€™ç”Ÿæˆé”™è¯¯ï¼š
error LNK2019: unresolved external symbol "private: static void __cdecl UMyClass_NoExport::StaticRegisterNativesUMyClass_NoExport(void)" (?StaticRegisterNativesUMyClass_NoExport@UMyClass_NoExport@@CAXXZ) referenced in function "private: static class UClass * __cdecl UMyClass_NoExport::GetPrivateStaticClass(void)" (?GetPrivateStaticClass@UMyClass_NoExport@@CAPEAVUClass@@XZ)
```

# UCLASS()

- **åŠŸèƒ½æè¿°ï¼š** ç•™ç©ºçš„é»˜è®¤è¡Œä¸ºæ˜¯ä¸èƒ½åœ¨è“å›¾ä¸­è¢«ç»§æ‰¿ï¼Œä¸èƒ½åœ¨è“å›¾ä¸­å®šä¹‰å˜é‡ï¼Œä½†æ‹¥æœ‰åå°„çš„åŠŸèƒ½ã€‚

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨ClassFlagsä¸­å¢åŠ [CLASS_MatchedSerializers](../../../Flags/EClassFlags/CLASS_MatchedSerializers.md), [CLASS_Native](../../../Flags/EClassFlags/CLASS_Native.md), [CLASS_RequiredAPI](../../../Flags/EClassFlags/CLASS_RequiredAPI.md), [CLASS_TokenStreamAssembled](../../../Flags/EClassFlags/CLASS_TokenStreamAssembled.md), [CLASS_Intrinsic](../../../Flags/EClassFlags/CLASS_Intrinsic.md), [CLASS_Constructed](../../../Flags/EClassFlags/CLASS_Constructed.md)
- **å…³è”é¡¹ï¼š** [ä¸å†™UCLASS()](ä¸å†™UCLASS().md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

ä¸èƒ½åœ¨è“å›¾ä¸­è¢«ç»§æ‰¿ï¼Œä¸èƒ½åœ¨è“å›¾ä¸­å®šä¹‰å˜é‡ã€‚

ä½†ä¾ç„¶éƒ½å¯ä»¥é€šè¿‡è“å›¾ConstructObjectåˆ›å»ºå‡ºæ¥ã€‚å¯¹äºæƒ³è¦æ‹¥æœ‰åå°„åŠŸèƒ½ï¼Œä½†æ˜¯å¹¶ä¸æƒ³åœ¨è“å›¾ä¸­è¢«ä½¿ç”¨ä¼šæŒºé€‚åˆã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
/*
[MyClass_Default	Class->Struct->Field->Object	/Script/Insider.MyClass_Default] [IncludePath = Class/MyClass_Default.h, ModuleRelativePath = Class/MyClass_Default.h]
ObjectFlags:	RF_Public | RF_Standalone | RF_Transient
Outer:	Package /Script/Insider
ClassFlags:	CLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed
Size:	48
{
public: void ExecuteUbergraph(int32 EntryPoint);
};
*/

UCLASS()
class INSIDER_API UMyClass_Default :public UObject
{
	GENERATED_BODY()
public:
};
```

é»˜è®¤çš„æ‹¥æœ‰è¿™äº›æ ‡å¿—ï¼šCLASS_MatchedSerializers | CLASS_Native | CLASS_RequiredAPI | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructed

# ä¸å†™UCLASS()

- **åŠŸèƒ½æè¿°ï¼š** åªæ˜¯ä½œä¸ºä¸€ä¸ªæ™®é€šçš„C++å¯¹è±¡ï¼Œæ²¡æœ‰åå°„åŠŸèƒ½ã€‚

- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å…³è”é¡¹ï¼š** [UCLASS()](UCLASS().md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åªæ˜¯ä½œä¸ºä¸€ä¸ªæ™®é€šçš„C++å¯¹è±¡ï¼Œæ²¡æœ‰åå°„åŠŸèƒ½ã€‚

ä¸€èˆ¬æƒ…å†µç»§æ‰¿è‡ªUObjectçš„æœ€å°‘ä¹Ÿä¼šæœ‰ä¸€ä¸ªUCLASS()ï¼Œè¿™æ ·æ‰æœ‰åå°„åŠŸèƒ½ã€‚ä½†æ˜¯æ³¨æ„ï¼Œå¦‚æœè°ƒç”¨UMyClass_NoUCLASS::StaticClass()ä¼šè¿”å›åŸºç±»UObjectçš„Classï¼Œå› ä¸ºå­ç±»æ²¡æœ‰è¦†ç›–ã€‚å› æ­¤ä¹Ÿå¯ä»¥è¯´æœ¬ç±»æ˜¯æ²¡æœ‰ç”Ÿæˆè‡ªå·±çš„UClasså…ƒæ•°æ®å¯¹è±¡ã€‚

```cpp
class INSIDER_API UMyClass_NoUCLASS :public UObject
{
	
};
```

UObjectçš„Classé»˜è®¤çš„æ ‡è®°æ˜¯ï¼šCLASS_Abstract | CLASS_MatchedSerializers | CLASS_Native | CLASS_TokenStreamAssembled | CLASS_Intrinsic | CLASS_Constructedã€‚å› æ­¤ä¸èƒ½è¢«NewObjectç”Ÿæˆå¯¹è±¡ã€‚åœ¨æ‰‹åŠ¨å»æ‰CLASS_Abstractåå¯ä»¥æ­£å¸¸newï¼Œä½†æ˜¯å¯¹è±¡çš„åç§°ä¾ç„¶æ˜¯Objectï¼Œæ˜¾ç„¶è¿™æ˜¯å› ä¸ºä½¿ç”¨çš„å°±æ˜¯Objectçš„Classã€‚

# Blueprintable

- **åŠŸèƒ½æè¿°ï¼š**  å¯ä»¥åœ¨è“å›¾ä¸­å®ç°
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[IsBlueprintBase](../../../../Meta/Blueprint/IsBlueprintBase.md), [BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å…³è”é¡¹ï¼š** [NotBlueprintable](../NotBlueprintable/NotBlueprintable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æ˜¯å¦å¯ä»¥åœ¨è“å›¾ä¸­å®ç°ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UINTERFACE(Blueprintable,MinimalAPI)
class UMyInterface_Blueprintable:public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class INSIDER_API IMyInterface_Blueprintable
{
	GENERATED_IINTERFACE_BODY()
public:
	UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	void Func_ImplementableEvent() const;

	UFUNCTION(BlueprintCallable,BlueprintNativeEvent)
	void Func_NativeEvent() const;
};

UINTERFACE(NotBlueprintable,MinimalAPI)
class UMyInterface_NotBlueprintable:public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class INSIDER_API IMyInterface_NotBlueprintable
{
	GENERATED_IINTERFACE_BODY()
public:
//ä¹Ÿä¸å¾—å®šä¹‰è“å›¾å‡½æ•°ï¼Œå› ä¸ºå·²ç»ä¸èƒ½åœ¨è“å›¾ä¸­å®ç°äº†
//UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
	//void Func_ImplementableEvent() const;

//	UFUNCTION(BlueprintCallable,BlueprintNativeEvent)
//	void Func_NativeEvent() const;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨è“å›¾ä¸­æµ‹è¯•ï¼Œå‘ç°UMyInterface_NotBlueprintableå¹¶ä¸èƒ½æ‰¾åˆ°ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UINTERFACE\Blueprint\Blueprintable\Untitled.png)

# NotBlueprintable

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šä¸å¯ä»¥åœ¨è“å›¾ä¸­å®ç°
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å»é™¤[IsBlueprintBase](../../../../Meta/Blueprint/IsBlueprintBase.md)ã€[BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)ï¼Œç­‰ä»·äº[CannotImplementInterfaceInBlueprint](../../../../Meta/Blueprint/CannotImplementInterfaceInBlueprint.md)
- **å…³è”é¡¹ï¼š** [Blueprintable](../Blueprintable/Blueprintable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…**

åœ¨Class Settingsé‡Œçš„Interfaceé‡Œæ‰¾ä¸åˆ°ä¸å…è®¸å®ç°çš„æ¥å£ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UINTERFACE\Blueprint\NotBlueprintable\Untitled.png)

ä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦ç”¨åˆ°è¯¥æ ‡è®°ï¼Ÿè™½ç„¶ä¸èƒ½åœ¨è“å›¾ä¸­å®ç°ï¼Œä½†æ˜¯ä¾ç„¶å¯ä»¥åœ¨C++é‡Œå®ç°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡åå°„åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦å®ç°è¯¥æ¥å£ã€‚

# ConversionRoot

- **åŠŸèƒ½æè¿°ï¼š**  Sets IsConversionRoot metadata flag for this interface.
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[IsConversionRoot](../../../Meta/Blueprint/IsConversionRoot.md)

åœ¨æºç ä¸­å¹¶ä¸èƒ½æ‰¾åˆ°è¯¥ä½¿ç”¨ç¤ºä¾‹

# MinimalAPI

- **åŠŸèƒ½æè¿°ï¼š**  æŒ‡å®šè¯¥UInterfaceå¯¹è±¡ä¸å¯¼å‡ºåˆ°åˆ«çš„æ¨¡å—
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DllExport
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

å¯ä»¥å‚ç…§UCLASSé‡Œçš„MinimalAPIçš„è§£é‡Šã€‚

ç®€å•æ¥è¯´UInterfaceå¯¹è±¡ï¼Œåªæ˜¯ä½œä¸ºæ¥å£çš„è¾…åŠ©å¯¹è±¡ï¼Œå› æ­¤æœ¬èº«å¹¶æ²¡æœ‰ä»€ä¹ˆå¯å€¼å¾—æš´éœ²å‡ºæ¥çš„å‡½æ•°ã€‚å› æ­¤æºç é‡Œçš„å¤§éƒ¨åˆ†UInterfaceå¯¹è±¡éƒ½è¢«æ ‡è®°æˆäº†MinimalAPIï¼Œä»¥åŠ å¿«ç¼–è¯‘åŒæ—¶éš”ç»åˆ«çš„æ¨¡å—ä½¿ç”¨ã€‚

```cpp
UINTERFACE(MinimalAPI, BlueprintType)
class USoundLibraryProviderInterface : public UInterface
{
	GENERATED_BODY()
};
```

# BlueprintInternalUseOnly

- **åŠŸèƒ½æè¿°ï¼š**  ä¸å¯å®šä¹‰æ–°BPå˜é‡ï¼Œä½†å¯ä½œä¸ºåˆ«çš„ç±»çš„æˆå‘˜å˜é‡æš´éœ²å’Œå˜é‡ä¼ é€’
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintInternalUseOnly](../../../../Meta/Blueprint/BlueprintInternalUseOnly.md), [BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡æ˜è¿™ä¸ªSTRUCTä¼šæ˜¯ä¸ªBlueprintTypeï¼Œä½†åœ¨è“å›¾ç¼–è¾‘å™¨ä¸­åˆä¸èƒ½å£°æ˜æ–°å˜é‡ï¼Œä½†æ˜¯å¯ä»¥ä½œä¸ºåˆ«çš„ç±»çš„æˆå‘˜å˜é‡æš´éœ²åˆ°è“å›¾ä¸­ã€‚

å’Œä¸å†™BlueprintTypeçš„å·®åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

ä¸å†™BlueprintTypeåˆ™å®Œå…¨ä¸èƒ½ä½œä¸ºåˆ«çš„ç±»çš„æˆå‘˜å˜é‡ã€‚BlueprintInternalUseOnlyæŠ‘åˆ¶äº†å®šä¹‰æ–°å˜é‡çš„èƒ½åŠ›ï¼Œä½†æ˜¯å¯ä»¥ä½œä¸ºå˜é‡ä¼ é€’ã€‚æ¯”å¦‚åœ¨C++ä¸­å®šä¹‰å˜é‡ï¼Œç„¶ååœ¨è“å›¾ä¸­ä¼ é€’ã€‚

å¦‚FTableRowBaseæœ¬èº«å¹¶ä¸èƒ½å®šä¹‰æ–°å˜é‡ï¼Œä½†æ˜¯å…¶å­ç±»ï¼ˆè¦åŠ ä¸ŠBlueprintTypeï¼‰æ˜¯å¯ä»¥å®šä¹‰æ–°å˜é‡çš„ï¼Œæ­£å¸¸è¢«ä½¿ç”¨ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
//(BlueprintInternalUseOnly = true, BlueprintType = true, ModuleRelativePath = Struct/MyStruct_BlueprintInternalUseOnly.h)
USTRUCT(BlueprintInternalUseOnly)
struct INSIDER_API FMyStruct_BlueprintInternalUseOnly
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite,EditAnywhere)
	float Score=0.f;
};

USTRUCT()
struct INSIDER_API FMyStruct_NoBlueprintInternalUseOnly
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	float Score=0.f;
};

UCLASS(Blueprintable,BlueprintType)
class INSIDER_API UMyClass_BlueprintInternalUseOnlyTest :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintReadWrite,EditAnywhere)
	FMyStruct_BlueprintInternalUseOnly MyInternalStruct;

	/*UPROPERTY(BlueprintReadWrite,EditAnywhere)	//no supported by BP
	FMyStruct_NoBlueprintInternalUseOnly MyStruct;*/
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

NewVaræ˜¯UMyClass_BlueprintInternalUseOnlyTest ç±»å‹çš„ï¼Œä¾ç„¶å¯ä»¥è®¿é—®å†…éƒ¨çš„MyInternalStructå˜é‡ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\USTRUCT\Blueprint\BlueprintInternalUseOnly\Untitled.png)

æºç é‡Œå¯ä»¥æ‰¾åˆ°ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnly)
struct FLatentActionInfo
{}

USTRUCT(BlueprintInternalUseOnly)
struct FTableRowBase
{}
```

## åŸç†ï¼š

```cpp
bool UEdGraphSchema_K2::IsAllowableBlueprintVariableType(const UScriptStruct* InStruct, const bool bForInternalUse)
{
	if (const UUserDefinedStruct* UDStruct = Cast<const UUserDefinedStruct>(InStruct))
	{
		if (EUserDefinedStructureStatus::UDSS_UpToDate != UDStruct->Status.GetValue())
		{
			return false;
		}

		// User-defined structs are always allowed as BP variable types.
		return true;
	}

	// struct needs to be marked as BP type
	if (InStruct && InStruct->GetBoolMetaDataHierarchical(FBlueprintMetadata::MD_AllowableBlueprintVariableType))
	{
		// for internal use, all BP types are allowed
		if (bForInternalUse)
		{
			return true;
		}

		// for user-facing use case, only allow structs that don't have the internal-use-only tag
		// struct itself should not be tagged
		if (!InStruct->GetBoolMetaData(FBlueprintMetadata::MD_BlueprintInternalUseOnly))
		{
			// struct's base structs should not be tagged
			if (!InStruct->GetBoolMetaDataHierarchical(FBlueprintMetadata::MD_BlueprintInternalUseOnlyHierarchical))
			{
				return true;
			}
		}
	}

	return false;
}

//Node->IsIntermediateNode()å¦‚æœä¸ºtrueï¼Œåˆ™æ˜¯ä½œä¸ºä¸­é—´èŠ‚ç‚¹ä½¿ç”¨ï¼Œtrueä¼šå¯¼è‡´bForInternalUseä¸ºtrue
if (!UK2Node_MakeStruct::CanBeMade(Node->StructType, Node->IsIntermediateNode()))
```

# BlueprintInternalUseOnlyHierarchical

- **åŠŸèƒ½æè¿°ï¼š**  åœ¨BlueprintInternalUseOnlyçš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†å­ç±»ä¹Ÿä¸èƒ½å®šä¹‰æ–°BPå˜é‡çš„é™åˆ¶ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintInternalUseOnlyHierarchical](../../../Meta/Blueprint/BlueprintInternalUseOnlyHierarchical.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

åœ¨BlueprintInternalUseOnlyçš„åŸºç¡€ä¸Šï¼Œå¢åŠ äº†å­ç±»ä¹Ÿä¸èƒ½å®šä¹‰æ–°BPå˜é‡çš„é™åˆ¶ã€‚

ç›®å‰åªæ‰¾åˆ°ä¸€ä¸ªç”¨å¤„ï¼Œä½†æ˜¯ä¹Ÿä¾ç„¶æ²¡æœ‰å­ç±»ã€‚å¦‚æœæˆ‘ä»¬åœ¨C++ä¸­å®šä¹‰æ–°çš„å­ç±»ï¼Œåˆ™æ‰€æœ‰çš„å­ç±»éƒ½ä¸èƒ½å®šä¹‰å˜é‡ã€‚æ³¨æ„å’ŒFTableRowBaseçš„åŒºåˆ«æ˜¯ï¼ŒFTableRowBaseçš„å­ç±»ä¾ç„¶å¯ä»¥å®šä¹‰æ–°å˜é‡ï¼Œå› ä¸ºFTableRowBaseçš„BlueprintInternalUseOnlyæ ‡è®°åªä½œç”¨äºè‡ªå·±ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
USTRUCT(BlueprintInternalUseOnlyHierarchical)
struct GAMEPLAYABILITIESEDITOR_API FGameplayAbilityAuditRow : public FTableRowBase
{}

USTRUCT(BlueprintInternalUseOnly)
struct FTableRowBase
{}
```

## åŸç†ï¼š

åªåœ¨è¿™ä¸ªåœ°æ–¹ç”¨åˆ°ï¼ŒGetBoolMetaDataHierarchicalä¼šæ£€æŸ¥ç»“æ„çš„æ‰€æœ‰çˆ¶ç±»æµ‹è¯•æ˜¯å¦å«æœ‰æŸä¸ªæ ‡è®°ã€‚æ‰€ä»¥åªè¦æœ‰ä¸€ä¸ªçˆ¶ç±»æœ‰ä¸€ä¸ªè¿™ä¸ªæ ‡è®°ï¼Œå°±ä¸èƒ½å®šä¹‰æ–°å˜é‡ã€‚

```cpp
bool UEdGraphSchema_K2::IsAllowableBlueprintVariableType(const UScriptStruct* InStruct, const bool bForInternalUse)
{
	if (const UUserDefinedStruct* UDStruct = Cast<const UUserDefinedStruct>(InStruct))
	{
		if (EUserDefinedStructureStatus::UDSS_UpToDate != UDStruct->Status.GetValue())
		{
			return false;
		}

		// User-defined structs are always allowed as BP variable types.
		return true;
	}

	// struct needs to be marked as BP type
	if (InStruct && InStruct->GetBoolMetaDataHierarchical(FBlueprintMetadata::MD_AllowableBlueprintVariableType))
	{
		// for internal use, all BP types are allowed
		if (bForInternalUse)
		{
			return true;
		}

		// for user-facing use case, only allow structs that don't have the internal-use-only tag
		// struct itself should not be tagged
		if (!InStruct->GetBoolMetaData(FBlueprintMetadata::MD_BlueprintInternalUseOnly))
		{
			// struct's base structs should not be tagged
			if (!InStruct->GetBoolMetaDataHierarchical(FBlueprintMetadata::MD_BlueprintInternalUseOnlyHierarchical))
			{
				return true;
			}
		}
	}

	return false;
}

```

# BlueprintType

- **åŠŸèƒ½æè¿°ï¼š**  å…è®¸è¿™ä¸ªç»“æ„åœ¨è“å›¾ä¸­å£°æ˜å˜é‡
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

å’ŒUCLASSé‡Œçš„ä¸€æ ·ï¼Œå¯ä»¥å…è®¸è¿™ä¸ªç»“æ„åœ¨è“å›¾ä¸­å£°æ˜å˜é‡

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_BlueprintType
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite,EditAnywhere)
	float Score;
};

USTRUCT()
struct INSIDER_API FMyStruct_NoBlueprintType
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere)
	float Score;
};
```

## æµ‹è¯•è“å›¾ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\USTRUCT\Blueprint\BlueprintType\Untitled.png)

# immutable

- **åŠŸèƒ½æè¿°ï¼š** Immutable is only legal in Object.h and is being phased out, do not use on new structs!
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨StructFlagsä¸­åŠ å…¥[STRUCT_Immutable](../../../Flags/EStructFlags/STRUCT_Immutable.md)

å½“å‰åªåœ¨noexporttypes.hé‡Œæ‰¾åˆ°ä¸€å †Struct

æŒ‡å®šè¿™ä¸ªç»“æ„çš„å­—æ®µå·²ç»å®šä¹‰å®Œæ¯•ï¼Œä»¥åä¸ä¼šå†ä¿®æ”¹ï¼Œå› æ­¤å¯ä»¥UseBinarySerializationæ¥åºåˆ—åŒ–ï¼Œä¸éœ€è¦æ”¯æŒå­—æ®µçš„å¢åˆ ã€‚

```cpp
//USTRUCT(BlueprintType,Immutable)	//error : Immutable is being phased out in favor of SerializeNative, and is only legal on the mirror structs declared in UObject
//struct INSIDER_API FMyStruct_Immutable
//{
//	GENERATED_BODY()
//
//	UPROPERTY(BlueprintReadWrite,EditAnywhere)
//	float Score;
//
//};

Struct[67] WithFlags:STRUCT_Immutable 
Struct:	ScriptStruct /Script/CoreUObject.Guid
Struct:	ScriptStruct /Script/CoreUObject.DateTime
Struct:	ScriptStruct /Script/CoreUObject.Box
Struct:	ScriptStruct /Script/CoreUObject.Vector
Struct:	ScriptStruct /Script/CoreUObject.Box2D
Struct:	ScriptStruct /Script/CoreUObject.Vector2D
Struct:	ScriptStruct /Script/CoreUObject.Box2f
Struct:	ScriptStruct /Script/CoreUObject.Vector2f
Struct:	ScriptStruct /Script/CoreUObject.Box3d
Struct:	ScriptStruct /Script/CoreUObject.Vector3d
Struct:	ScriptStruct /Script/CoreUObject.Box3f
Struct:	ScriptStruct /Script/CoreUObject.Vector3f
Struct:	ScriptStruct /Script/CoreUObject.Color
Struct:	ScriptStruct /Script/CoreUObject.Int32Point
Struct:	ScriptStruct /Script/CoreUObject.Int32Vector
Struct:	ScriptStruct /Script/CoreUObject.Int32Vector2
Struct:	ScriptStruct /Script/CoreUObject.Int32Vector4
Struct:	ScriptStruct /Script/CoreUObject.Int64Point
Struct:	ScriptStruct /Script/CoreUObject.Int64Vector
Struct:	ScriptStruct /Script/CoreUObject.Int64Vector2
Struct:	ScriptStruct /Script/CoreUObject.Int64Vector4
Struct:	ScriptStruct /Script/CoreUObject.LinearColor
Struct:	ScriptStruct /Script/CoreUObject.Quat
Struct:	ScriptStruct /Script/CoreUObject.TwoVectors
Struct:	ScriptStruct /Script/CoreUObject.IntPoint
Struct:	ScriptStruct /Script/CoreUObject.IntVector
Struct:	ScriptStruct /Script/CoreUObject.IntVector2
Struct:	ScriptStruct /Script/CoreUObject.IntVector4
Struct:	ScriptStruct /Script/CoreUObject.Matrix
Struct:	ScriptStruct /Script/CoreUObject.Plane
Struct:	ScriptStruct /Script/CoreUObject.Matrix44d
Struct:	ScriptStruct /Script/CoreUObject.Plane4d
Struct:	ScriptStruct /Script/CoreUObject.Matrix44f
Struct:	ScriptStruct /Script/CoreUObject.Plane4f
Struct:	ScriptStruct /Script/CoreUObject.OrientedBox
Struct:	ScriptStruct /Script/CoreUObject.PackedNormal
Struct:	ScriptStruct /Script/CoreUObject.PackedRGB10A2N
Struct:	ScriptStruct /Script/CoreUObject.PackedRGBA16N
Struct:	ScriptStruct /Script/CoreUObject.Quat4d
Struct:	ScriptStruct /Script/CoreUObject.Quat4f
Struct:	ScriptStruct /Script/CoreUObject.Ray
Struct:	ScriptStruct /Script/CoreUObject.Ray3d
Struct:	ScriptStruct /Script/CoreUObject.Ray3f
Struct:	ScriptStruct /Script/CoreUObject.Rotator
Struct:	ScriptStruct /Script/CoreUObject.Rotator3d
Struct:	ScriptStruct /Script/CoreUObject.Rotator3f
Struct:	ScriptStruct /Script/CoreUObject.Sphere
Struct:	ScriptStruct /Script/CoreUObject.Sphere3d
Struct:	ScriptStruct /Script/CoreUObject.Sphere3f
Struct:	ScriptStruct /Script/CoreUObject.Timespan
Struct:	ScriptStruct /Script/CoreUObject.Transform3d
Struct:	ScriptStruct /Script/CoreUObject.Transform3f
Struct:	ScriptStruct /Script/CoreUObject.Uint32Point
Struct:	ScriptStruct /Script/CoreUObject.Uint32Vector
Struct:	ScriptStruct /Script/CoreUObject.Uint32Vector2
Struct:	ScriptStruct /Script/CoreUObject.Uint32Vector4
Struct:	ScriptStruct /Script/CoreUObject.Uint64Point
Struct:	ScriptStruct /Script/CoreUObject.Uint64Vector
Struct:	ScriptStruct /Script/CoreUObject.Uint64Vector2
Struct:	ScriptStruct /Script/CoreUObject.Uint64Vector4
Struct:	ScriptStruct /Script/CoreUObject.UintPoint
Struct:	ScriptStruct /Script/CoreUObject.UintVector
Struct:	ScriptStruct /Script/CoreUObject.UintVector2
Struct:	ScriptStruct /Script/CoreUObject.UintVector4
Struct:	ScriptStruct /Script/CoreUObject.Vector4
Struct:	ScriptStruct /Script/CoreUObject.Vector4d
Struct:	ScriptStruct /Script/CoreUObject.Vector4f
```

# Atomic

- **åŠŸèƒ½æè¿°:** æŒ‡å®šè¯¥ç»“æ„åœ¨åºåˆ—åŒ–çš„æ—¶å€™æ€»æ˜¯ä¸€æ•´ä¸ªè¾“å‡ºå…¨éƒ¨å±æ€§ï¼Œè€Œä¸æ˜¯åªè¾“å‡ºæ”¹å˜çš„å±æ€§ã€‚
- **å…ƒæ•°æ®ç±»å‹:** bool
- **å¼•æ“æ¨¡å—:** UHT
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨StructFlagsä¸­åŠ å…¥[STRUCT_Atomic](../../../../Flags/EStructFlags/STRUCT_Atomic.md)
- **å¸¸ç”¨ç¨‹åº¦:** â˜…

æŒ‡å®šè¯¥ç»“æ„åœ¨åºåˆ—åŒ–çš„æ—¶å€™æ€»æ˜¯ä¸€æ•´ä¸ªè¾“å‡ºå…¨éƒ¨å±æ€§ï¼Œè€Œä¸æ˜¯åªè¾“å‡ºæ”¹å˜çš„å±æ€§ã€‚

æ‰€è°“çš„åŸå­åŒ–åºåˆ—åŒ–æŒ‡çš„æ˜¯å¦‚æœè¯¥ç»“æ„çš„æŸä¸ªå­—æ®µå±æ€§åŒé»˜è®¤å€¼ä¸åŒï¼Œä½†æ˜¯å…¶ä»–å­—æ®µç›¸åŒï¼Œä¹Ÿè¦ä¸€æ¬¡æ€§çš„åºåˆ—åŒ–æ•´ä¸ªç»“æ„ï¼Œè€Œä¸æ˜¯æ‹†å¼€ã€‚æ³¨æ„è¿™ä¸ªåªåœ¨æ™®é€šçš„SerializeVersionedTaggedPropertiesä¸‹æœ‰æ•ˆï¼Œå› ä¸ºæ˜¯å¯¹æ¯”é»˜è®¤å€¼ã€‚åœ¨Binä¸‹æ— æ•ˆã€‚å…¶å®ä½œç”¨æœºç†æ˜¯å½“é‡‡ç”¨åŸå­åŒ–åºåˆ—åŒ–çš„æ—¶å€™ï¼Œå°±ä¸æ£€æŸ¥å†…éƒ¨å±æ€§çš„é»˜è®¤å€¼ï¼Œä»è€Œæ— è®ºä»€ä¹ˆæƒ…å†µéƒ½ä¼šåºåˆ—åŒ–è¿›æ•´ä¸ªå±æ€§ã€‚

UEçš„noexporttype.hä¸­æœ‰å¤§é‡çš„atomicçš„åŸºç¡€ç»“æ„ï¼Œå¦‚FVectorï¼Œå› ä¸ºImmutableä¹Ÿä¼šåŒæ—¶è®¾ç½®STRUCT_Atomicï¼Œä½†æ˜¯æ²¡æœ‰å‘ç°å•ç‹¬è®¾ç½®Atomicçš„åœ°æ–¹ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_InnerItem
{
	GENERATED_BODY()

		UPROPERTY(BlueprintReadWrite, EditAnywhere)
		int32 A = 1;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
		int32 B = 2;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
		int32 C = 3;

	bool operator==(const FMyStruct_InnerItem& other)const
	{
		return A == other.A;
	}
};

USTRUCT(BlueprintType)
struct INSIDER_API FMyStruct_NoAtomic
{
	GENERATED_BODY()

		UPROPERTY(BlueprintReadWrite, EditAnywhere)
		FMyStruct_InnerItem Item;
};

USTRUCT(Atomic, BlueprintType)
struct INSIDER_API FMyStruct_Atomic
{
	GENERATED_BODY()

		UPROPERTY(BlueprintReadWrite, EditAnywhere)
		FMyStruct_InnerItem Item;
};

template<>
struct TStructOpsTypeTraits<FMyStruct_InnerItem> : public TStructOpsTypeTraitsBase2<FMyStruct_InnerItem>
{
	enum
	{
		WithIdenticalViaEquality = true,
	};
};

void USerializationLibrary::SaveStructToMemory(UScriptStruct* structClass, void* structObject, const void* structDefaults, TArray<uint8>& outSaveData, EInsiderSerializationFlags flags/*=EInsiderSerializationFlags::None*/)
{
	FMemoryWriter MemoryWriter(outSaveData, false);
	MemoryWriter.SetWantBinaryPropertySerialization(EnumHasAnyFlags(flags, EInsiderSerializationFlags::UseBinary));
	if (!EnumHasAnyFlags(flags, EInsiderSerializationFlags::CheckDefaults))
	{
		structDefaults=nullptr;
	}
	structClass->SerializeItem(MemoryWriter, structObject, structDefaults);
}

æµ‹è¯•ä»£ç ï¼š
FMyStruct_NoAtomic NoAtomicStruct;
NoAtomicStruct.Item.A=3;

FMyStruct_Atomic AtomicStruct;
AtomicStruct.Item.A=3;

TArray<uint8> NoAtomicMemoryChanged;
USerializationLibrary::SaveStructToMemory(NoAtomicStruct,NoAtomicMemoryChanged,EInsiderSerializationFlags::CheckDefaults);

TArray<uint8> AtomicMemoryChanged;
USerializationLibrary::SaveStructToMemory(AtomicStruct,AtomicMemoryChanged,EInsiderSerializationFlags::CheckDefaults);
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯è§AtomicMemoryChangedçš„å ç”¨å†…å­˜å¤§å°æ¯”AtomicMemoryChangedå¤šï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç»“æ„çš„å±æ€§è™½ç„¶éƒ½æ”¹å˜äº†ï¼Œä½†æ˜¯AtomicStructæ€»æ˜¯ä¼šæŠŠæ‰€æœ‰çš„å±æ€§éƒ½åºåˆ—åŒ–å‡ºæ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\USTRUCT\UHT\Atomic\Untitled.png)

## åŸç†ï¼š

ä½œç”¨çš„æœºç†æ˜¯ï¼Œä¸€ä¸ªå¤–éƒ¨ç»“æ„æ˜¯Atomicçš„ï¼Œå…¶å†…éƒ¨çš„å±æ€§å¦‚æœå‘ç°æœ‰æ”¹å˜ï¼Œè¿™ä¸ªæ—¶å€™å†…éƒ¨å±æ€§å¾—æ˜¯å¦ä¸€ä¸ªç»“æ„ï¼Œå› ä¸ºå¦‚æœåªæ˜¯Intå±æ€§ï¼Œåˆ™ä¸ä¼šå¯¹æ¯”å†…éƒ¨å±æ€§é»˜è®¤å€¼ã€‚å¦‚æœæ˜¯å†…éƒ¨ç»“æ„å±æ€§çš„è¯ï¼Œå› ä¸ºå…¶ä¸­ä¸€ä¸ªIDå­—æ®µä¸ä¸€æ ·ï¼Œå°±åœ¨å¯¹æ¯”çš„æ—¶å€™å¯¼è‡´æ•´ä¸ªç»“æ„ä¸ç­‰ï¼ˆä½†åŒæ—¶è¯¥å†…éƒ¨ç»“æ„åˆæœ‰å…¶ä»–å±æ€§æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥ä¸Šé¢ç¤ºä¾‹ä»£ç åªæ”¹äº†Aï¼Œä¸”æä¾›äº†==çš„æ¯”è¾ƒå‡½æ•°ï¼‰ã€‚é»˜è®¤çš„æ–¹å¼æ˜¯ä¾ç„¶ä¼šåœ¨å†…éƒ¨ç»“æ„çš„å†…éƒ¨å±æ€§ä¸Šç»§ç»­å¯¹æ¯”é»˜è®¤å€¼ï¼Œä½†åŸå­åŒ–åå°±æˆªæ–­äº†é»˜è®¤å€¼ä¸ºnullï¼Œä»è€Œå¯¼è‡´å­™å­å±æ€§æ²¡æœ‰é»˜è®¤å€¼å¯å¯¹æ¯”ï¼Œä»è€Œå°±æŠŠæ•´ä¸ªå†…éƒ¨å±æ€§å°±éƒ½è¾“å‡ºå‡ºæ¥ã€‚å› æ­¤Atomicæ˜¯ç”¨åœ¨å¤–éƒ¨ç»“æ„ä¸Šçš„ï¼Œç”¨åœ¨FVectorè¿™ç§ä¸å¤ªä¼šç»§ç»­æ‹†å¼€çš„ç»“æ„å…¶å®æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚

```cpp
void UStruct::SerializeVersionedTaggedProperties(FStructuredArchive::FSlot Slot, uint8* Data, UStruct* DefaultsStruct, uint8* Defaults, const UObject* BreakRecursionIfFullyLoad) const
{
//â€¦â€¦
/** If true, it means that we want to serialize all properties of this struct if any properties differ from defaults */
		bool bUseAtomicSerialization = false;
		if (DefaultsScriptStruct)
		{
			bUseAtomicSerialization = DefaultsScriptStruct->ShouldSerializeAtomically(UnderlyingArchive);
		}

if (bUseAtomicSerialization)
	{
		DefaultValue = NULL;
	}
}
```

# HasDefaults

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç»“æ„çš„å­—æ®µæ‹¥æœ‰é»˜è®¤å€¼ã€‚è¿™æ ·å¦‚æœæœ¬ç»“æ„ä½œä¸ºå‡½æ•°å‚æ•°æˆ–è¿”å›å€¼æ—¶å€™ï¼Œå‡½æ•°åˆ™å¯ä»¥ä¸ºå…¶æä¾›é»˜è®¤å€¼ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **é™åˆ¶ç±»å‹ï¼š** åªåœ¨NoExportTypes.hä¾›UHTä½¿ç”¨
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_HasDefaults](../../../Flags/EFunctionFlags/FUNC_HasDefaults.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥ç»“æ„çš„å­—æ®µæ‹¥æœ‰é»˜è®¤å€¼ã€‚

ä¸æ˜¯æŒ‡çš„æ˜¯NoExportTypes.hçš„å£°æ˜ä¸Šæ˜¯å¦å†™æœ‰é»˜è®¤å€¼ï¼Œè€Œæ˜¯æŒ‡å…¶çœŸæ­£çš„å£°æ˜ä¹‹å¤„ï¼Œå…¶å†…éƒ¨çš„å±æ€§éƒ½æœ‰åˆå§‹å€¼ã€‚è¿™æ ·å¦‚æœæœ¬ç»“æ„ä½œä¸ºå‡½æ•°å‚æ•°æˆ–è¿”å›å€¼æ—¶å€™ï¼Œå‡½æ•°åˆ™å¯ä»¥ä¸ºå…¶æä¾›é»˜è®¤å€¼ã€‚

NoExportTypes.hé‡Œçš„å¤§éƒ¨åˆ†ç»“æ„éƒ½æ‹¥æœ‰è¯¥ç»“æ„ï¼ˆ88/135)ï¼Œæ²¡æœ‰çš„æ˜¯åƒFPackedXXXçš„ã€‚

## åŸç†ï¼š

å¦‚æœæ˜¯ä¸€ä¸ªclassä¸­çš„å‡½æ•°ä¸”å‚æ•°ç”¨åˆ°äº†ç»“æ„ï¼Œå¦‚æœè¯¥ç»“æ„æ‹¥æœ‰HasDefaultsï¼Œåˆ™ä¼šé€ æˆEFunctionFlags.HasDefaults

```cpp
// The following code is only performed on functions in a class.
if (Outer is UhtClass)
{
	foreach (UhtType type in Children)
	{
		if (type is UhtProperty property)
		{
			if (property.PropertyFlags.HasExactFlags(EPropertyFlags.OutParm | EPropertyFlags.ReturnParm, EPropertyFlags.OutParm))
			{
				FunctionFlags |= EFunctionFlags.HasOutParms;
			}
			if (property is UhtStructProperty structProperty)
			{
				if (structProperty.ScriptStruct.HasDefaults)
				{
					FunctionFlags |= EFunctionFlags.HasDefaults;
				}
			}
		}
	}
}
```

# HasNoOpConstructor

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç»“æ„æ‹¥æœ‰ForceInitçš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·åœ¨ä½œä¸ºBP functionè¿”å›å€¼çš„æ—¶å€™ï¼Œå¯ä»¥è°ƒç”¨æ¥åˆå§‹åŒ–
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **é™åˆ¶ç±»å‹ï¼š** åªåœ¨NoExportTypes.hä¾›UHTä½¿ç”¨
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥ç»“æ„æ‹¥æœ‰ForceInitçš„æ„é€ å‡½æ•°ï¼Œè¿™æ ·åœ¨ä½œä¸ºBP Functionè¿”å›å€¼æˆ–å‚æ•°çš„æ—¶å€™ï¼Œå¼•æ“å°±çŸ¥é“è¿™ä¸ªç»“æ„æœ‰è¿™ä¹ˆä¸€ä¸ªæ„é€ å‡½æ•°å¯ä»¥è°ƒç”¨æ¥åˆå§‹åŒ–ã€‚

ä½œç”¨çš„åœ°æ–¹æ˜¯UhtHeaderCodeGeneratorä¸­çš„AppendEventParameterï¼Œä¸ºäº†è¿™æ ·çš„ä»£ç ï¼Œè¿™æ˜¯ä¸€ä¸ªæš´éœ²åˆ°BPä¸­çš„Eventï¼Œè¦ä¸ºå®ƒç”Ÿæˆä¸€äº›èƒ¶æ°´ä»£ç ã€‚è¿™é‡ŒFLinearColor å°±æ˜¯HasNoOpConstructorã€‚ä¾‹å¦‚ä»¥ä¸‹è¿™ä¸ªå‡½æ•°ï¼š

```cpp
UFUNCTION(BlueprintNativeEvent, Category = "Modifier")
FLinearColor GetVisualizationColor(FInputActionValue SampleValue, FInputActionValue FinalValue) const;
```

ç”Ÿæˆçš„ä»£ç ï¼š

```cpp
struct InputModifier_eventGetVisualizationColor_Parms
	{
		FInputActionValue SampleValue;
		FInputActionValue FinalValue;
		FLinearColor ReturnValue;

		/** Constructor, initializes return property only **/
		InputModifier_eventGetVisualizationColor_Parms()
			: ReturnValue(ForceInit)//å¼ºåˆ¶åˆå§‹åŒ–
		{
		}
	};

static FName NAME_UInputModifier_GetVisualizationColor = FName(TEXT("GetVisualizationColor"));
	FLinearColor UInputModifier::GetVisualizationColor(FInputActionValue SampleValue, FInputActionValue FinalValue) const
	{
		InputModifier_eventGetVisualizationColor_Parms Parms;
		Parms.SampleValue=SampleValue;
		Parms.FinalValue=FinalValue;
		const_cast<UInputModifier*>(this)->ProcessEvent(FindFunctionChecked(NAME_UInputModifier_GetVisualizationColor),&Parms);
		return Parms.ReturnValue;
	}
```

å› æ­¤è¦æ±‚è¯¥ç»“æ„æ‹¥æœ‰ForceInitçš„æ„é€ å‡½æ•°

```cpp
FORCEINLINE explicit FLinearColor(EForceInit)
	: R(0), G(0), B(0), A(0)
	{}
```

## åŸç†ï¼š

```cpp
if (ScriptStruct.HasNoOpConstructor)
{
//If true, the an argument will need to be added to the constructor
	PropertyCaps |= UhtPropertyCaps.RequiresNullConstructorArg;
}
```

# IsAlwaysAccessible

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTåœ¨ç”Ÿæˆæ–‡ä»¶çš„æ—¶å€™æ€»æ˜¯å¯ä»¥è®¿é—®åˆ°æ”¹ç»“æ„çš„å£°æ˜ï¼Œå¦åˆ™è¦åœ¨gen.cppé‡Œç”Ÿæˆé•œåƒç»“æ„å®šä¹‰
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **é™åˆ¶ç±»å‹ï¼š** åªåœ¨NoExportTypes.hä¾›UHTä½¿ç”¨
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥ç»“æ„çš„å£°æ˜æ˜¯å¦åœ¨UHTä¸ºNoExportTypes.hç”Ÿæˆçš„gen.cppé‡Œæ€»æ˜¯å¯ä»¥è®¿é—®åˆ°ã€‚

æ¢å¥è¯è¯´å…¶å®å°±æ˜¯æ˜¯å¦è¿™äº›ç»“æ„åœ¨GeneratedCppIncludes.hçš„å£°æ˜é‡Œå¯ä»¥æ‰¾åˆ°ã€‚å¦‚æœä¸å¯ä»¥æ‰¾åˆ°ï¼Œé‚£åœ¨åé¢ç”ŸæˆZ_Construct_UScriptStruct_FMatrix44d_Staticsè¿™ç§ç±»ä¼¼çš„æ—¶å€™å°±å¾—å†è‡ªå·±å®šä¹‰ä¸€ä¸ªé•œåƒç»“æ„å®šä¹‰ã€‚å¦‚æœå¯ä»¥æ‰¾åˆ°ï¼Œæ¯”å¦‚FGuidï¼Œåˆ™å°±ä¸éœ€è¦ã€‚

å› æ­¤è¿™åªæ˜¯ä¸€ä¸ªæ‰‹åŠ¨çš„å†…éƒ¨æ ‡è®°ï¼Œå¸®åŠ©UHTç¨‹åºè¯†åˆ«å“ªäº›ç»“æ„è¦å†åˆ›å»ºé•œåƒç»“æ„å®šä¹‰ã€‚

åœ¨NoExportTypes.hæŸ¥çœ‹å„ä¸ªç»“æ„çš„æ—¶å€™ï¼Œä¼šå‘ç°æœ‰äº›ç»“æ„ï¼ˆ85/135ï¼‰ä¼šæ ‡ä¸ŠIsAlwaysAccessibleï¼Œè€Œæœ‰äº›æ²¡æœ‰ã€‚è¿™æ˜¯å› ä¸ºUHTåœ¨ä¸ºNoExportTypes.hç”Ÿæˆgen.cppçš„æ—¶å€™ï¼Œ

```cpp
\UnrealEngine\Engine\Source\Runtime\CoreUObject\Public\UObject\GeneratedCppIncludes.h
#include "UObject/Object.h"
#include "UObject/UObjectGlobals.h"
#include "UObject/CoreNative.h"
#include "UObject/Class.h"
#include "UObject/MetaData.h"
#include "UObject/UnrealType.h"
#include "UObject/EnumProperty.h"
#include "UObject/TextProperty.h"
#include "UObject/FieldPathProperty.h"

#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2
#include "CoreMinimal.h"
#endif

\Hello\Intermediate\Build\Win64\HelloEditor\Inc\CoreUObject\UHT\NoExportTypes.gen.cppï¼š
// Copyright Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

//ä»¥ä¸‹è¿™ä¸¤è¡Œ
#include "UObject/GeneratedCppIncludes.h"//A
#include "UObject/NoExportTypes.h"//B
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeNoExportTypes() {}
```

åœ¨æœ€å¼€å¤´çš„ä¸¤ä¸ªincludeé‡Œå¦‚æœå¯ä»¥ç›´æ¥æ‰¾åˆ°è¯¥structçš„å®šä¹‰ï¼Œåˆ™åœ¨gen.cppä¸­çš„Aå’ŒBå¤„éœ€è¦ç»“æ„å®šä¹‰çš„æ—¶å€™ï¼Œå°±ä¸éœ€è¦å†é¢å¤–å»æ‰¾å®šä¹‰äº†ã€‚

```cpp
const UECodeGen_Private::FStructParams Z_Construct_UScriptStruct_FMatrix44f_Statics::ReturnStructParams = {
		(UObject* (*)())Z_Construct_UPackage__Script_CoreUObject,
		nullptr,
		nullptr,
		"Matrix44f",
		Z_Construct_UScriptStruct_FMatrix44f_Statics::PropPointers,
		UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FMatrix44f_Statics::PropPointers),
		sizeof(FMatrix44f),//è¿™ä¸ªA
		alignof(FMatrix44f),//è¿™ä¸ªB
		RF_Public|RF_Transient|RF_MarkAsNative,
		EStructFlags(0x00000038),
		METADATA_PARAMS(UE_ARRAY_COUNT(Z_Construct_UScriptStruct_FMatrix44f_Statics::Struct_MetaDataParams), Z_Construct_UScriptStruct_FMatrix44f_Statics::Struct_MetaDataParams)
	};
```

å¦‚æœæ‰¾ä¸åˆ°ï¼Œæ¯”å¦‚FMatrix44fï¼Œæ˜¯å®šä¹‰åœ¨Engine\Source\Runtime\Core\Public\Math\Matrix.hï¼Œåˆ™å¿…é¡»ä¸ºå®ƒç”Ÿæˆä¸€ä¸ªä¸€æ¨¡ä¸€æ ·çš„å®šä¹‰ï¼ˆä¸includeçš„ä½œç”¨æ˜¯åŠ å¿«ç¼–è¯‘)ï¼š

```cpp
struct Z_Construct_UScriptStruct_FMatrix44f_Statics
	{
		struct FMatrix44f //å†…å­˜å¸ƒå±€ä¸€è‡´çš„å®šä¹‰
		{
			FPlane4f XPlane;
			FPlane4f YPlane;
			FPlane4f ZPlane;
			FPlane4f WPlane;
		};

		static_assert(sizeof(FMatrix44f) < MAX_uint16);
		static_assert(alignof(FMatrix44f) < MAX_uint8);
```

å½“ç„¶å¦‚æœå­å­—æ®µæˆ–è€…çˆ¶ç±»ä¹Ÿæ‰¾ä¸åˆ°å®šä¹‰ï¼Œåˆ™åªéœ€è¦æŠŠçˆ¶å®šä¹‰å…ˆå†™åœ¨å‰é¢å°±å¯ä»¥äº†ã€‚å› æ­¤csé‡Œçš„FindNoExportStructsRecursiveå°±æ˜¯ä¸ºäº†æ‰¾åˆ°å…¶ç›¸å…³çš„ç»“æ„ã€‚æ²¡æœ‰æ ‡IsAlwaysAccessibleåˆ™æ„å‘³ç€è¦ç”Ÿæˆå‡çš„ç»“æ„å®šä¹‰

```cpp
private static void FindNoExportStructsRecursive(List<UhtScriptStruct> outScriptStructs, UhtStruct structObj)
		{
			for (UhtStruct? current = structObj; current != null; current = current.SuperStruct)
			{
				// Is isn't true for noexport structs
				if (current is UhtScriptStruct scriptStruct)
				{
					if (scriptStruct.ScriptStructFlags.HasAnyFlags(EStructFlags.Native))
					{
						break;
					}

					// these are a special cases that already exists and if wrong if exported naively
					if (!scriptStruct.IsAlwaysAccessible)
					{
						outScriptStructs.Remove(scriptStruct);
						outScriptStructs.Add(scriptStruct);
					}
				}

				foreach (UhtType type in current.Children)
				{
					if (type is UhtProperty property)
					{
						foreach (UhtType referenceType in property.EnumerateReferencedTypes())
						{
							if (referenceType is UhtScriptStruct propertyScriptStruct)
							{
								FindNoExportStructsRecursive(outScriptStructs, propertyScriptStruct);
							}
						}
					}
				}
			}
		}
```

# IsCoreType

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥ç»“æ„æ˜¯æ ¸å¿ƒç±»ï¼ŒUHTåœ¨ç”¨å®ƒçš„æ—¶å€™ä¸éœ€è¦å‰å‘å£°æ˜ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **é™åˆ¶ç±»å‹ï¼š** åªåœ¨NoExportTypes.hä¾›UHTä½¿ç”¨
- **å¸¸ç”¨ç¨‹åº¦ï¼š** 0

æŒ‡å®šè¯¥ç»“æ„æ˜¯æ ¸å¿ƒç±»ï¼ŒUHTåœ¨ç”¨å®ƒçš„æ—¶å€™ä¸éœ€è¦å‰å‘å£°æ˜ã€‚

## åŸç†ï¼š

çœ‹UHTæºç æ˜¯æŠŠstructç”¨åœ¨å‚æ•°æˆ–å±æ€§ç­‰è¢«å¼•ç”¨çš„æ—¶å€™ã€‚

```cpp
public override string? UhtStructProperty::GetForwardDeclarations()
		{
			if (ScriptStruct.IsCoreType)
			{
				return null;
			}

			if (TemplateWrapper != null)
			{
				StringBuilder builder = new();
				TemplateWrapper.AppendForwardDeclarations(builder);
				return builder.ToString();
			}

			return $"struct {ScriptStruct.SourceName};";
		}
```

# NoExport

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…**

æŒ‡å®šUHTä¸è¦ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆæ³¨å†Œçš„ä»£ç ï¼Œè€Œåªæ˜¯è¿›è¡Œè¯æ³•åˆ†ææå–å…ƒæ•°æ®ã€‚

NoExportTypes.hé‡Œä½¿ç”¨äº†å¾ˆå¤šè¯¥ä¾‹å­ã€‚å®šä¹‰çš„ç»“æ„å¸¸å¸¸ç”¨!CPPå®åŒ…èµ·æ¥ä»¥ä¸åœ¨C++ä¸­å‚ä¸ç¼–è¯‘ã€‚å› æ­¤ä¸€èˆ¬æ˜¯åªç»™å¼•æ“å†…éƒ¨ä½¿ç”¨çš„ã€‚

å®é™…ä¸Šæˆ‘ä»¬æƒ³ä½¿ç”¨ä¹Ÿå¯ä»¥ï¼Œåªè¦ä¿æŒC++ä¸­å†…å­˜å¸ƒå±€ä¸€æ ·ï¼Œå°±å¯ä»¥è‡ªå·±å¤šå®šä¹‰ã€‚ä½¿ç”¨åœºæ™¯ï¼šæƒ³è‡ªå·±å®šä¹‰ä¸€ä¸ªUHTå¤´å–‚ç»™UHTåˆ†æï¼Œç„¶åè‡ªå·±åœ¨åˆ«å¤„å®šä¹‰å®é™…çš„C++ã€‚ä¸€ç§å…¸å‹ç”¨é€”æ˜¯C++é‡Œçš„å®é™…å¤šä¸ªç±»ç»§æ‰¿äºä¸€ä¸ªæ¨¡æ¿åŸºç±»ï¼Œå¦‚FVector2MaterialInputï¼Œè¿™æ ·å¯ä»¥æ¯ä¸ªç‰¹åŒ–å­ç±»å®šä¸€ä¸ªUHTç±»å‹åˆ«åã€‚å¦ä¸€ç§ç›®çš„æ˜¯æŠŠUHTè¦åˆ†æçš„å¤´æ–‡ä»¶éƒ½æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œï¼ŒåŠ é€ŸUHTåˆ†æç”Ÿæˆï¼Œä¸ç”¨åˆ†æå¤šä¸ªæ–‡ä»¶ï¼Œåæ­£åªè¦UHTä¿¡æ¯å’Œå†…å­˜å¸ƒå±€å¯¹å°±è¡Œã€‚

```cpp
#if !CPP	// begin noexport class
USTRUCT(noexport, BlueprintType) //å¦‚æœä¸å†™noexportï¼Œä¼šæŠ¥é”™ï¼šExpected a GENERATED_BODY() at the start of the structã€
struct FFloatRK4SpringInterpolator
{
	
	UPROPERTY(EditAnywhere, Category = "FloatRK4SpringInterpolator")
	float StiffnessConstant;

	/** 0 = Undamped, <1 = Underdamped, 1 = Critically damped, >1 = Over damped */
	UPROPERTY(EditAnywhere, Category = "FloatRK4SpringInterpolator")
	float DampeningRatio;

	bool bIsInitialized;
	bool bIsInMotion;
	float TimeRemaining;
	FRK4SpringConstants SpringConstants;

	float LastPosition;
	RK4Integrator::FRK4State<float> State;
};
#endif	// end noexport class

//å®é™…åº”ç”¨ï¼š
template <typename T>
struct FRK4SpringInterpolator
{
protected:
	float StiffnessConstant;
	float DampeningRatio;

	bool bIsInitialized;
	bool bIsInMotion;
	float TimeRemaining;
	FRK4SpringConstants SpringConstants;

	T LastPosition;
	RK4Integrator::FRK4State<T> State;
}

struct FFloatRK4SpringInterpolator : FRK4SpringInterpolator<float>
struct FVectorRK4SpringInterpolator : FRK4SpringInterpolator<FVector>
```

ä¸ç”Ÿæˆçš„ä»£ç åŒ…æ‹¬ï¼š

```cpp
USTRUCT(BlueprintType,noexport)
struct INSIDER_API FMyStruct_NoExport
{
	//æŠ‘åˆ¶ï¼šGENERATED_BODY()è§£é‡Šç”Ÿæˆçš„ï¼š
	//static class UScriptStruct* StaticStruct();	

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float Score;
};

//æŠ‘åˆ¶ï¼š
//template<> INSIDER_API UScriptStruct* StaticStruct<struct FMyStruct_NoExport>();
```

Â .hé‡Œä¸ä¼šç”Ÿæˆï¼Œå› æ­¤ä¸ä¼šåœ¨åˆ«çš„æ¨¡å—é‡Œä½¿ç”¨

```cpp
template<> INSIDER_API UScriptStruct* StaticStruct<struct FMyStruct_NoExport>();
```

ä½†æ˜¯ä¾ç„¶ä¼šåœ¨Module.init.gen.cppé‡Œç”ŸæˆZ_Construct_UScriptStruct_FMyStruct_NoExportçš„è°ƒç”¨ï¼Œå› æ­¤è¿˜æ˜¯ä¼šåœ¨è“å›¾é‡Œæš´éœ²å‡ºæ¥ã€‚

```cpp
#include "UObject/GeneratedCppIncludes.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeInsider_init() {}
	INSIDER_API UScriptStruct* Z_Construct_UScriptStruct_FMyStruct_NoExport();
	static FPackageRegistrationInfo Z_Registration_Info_UPackage__Script_Insider;
	FORCENOINLINE UPackage* Z_Construct_UPackage__Script_Insider()
	{
		if (!Z_Registration_Info_UPackage__Script_Insider.OuterSingleton)
		{
			static UObject* (*const SingletonFuncArray[])() = {
					(UObject* (*)())Z_Construct_UScriptStruct_FMyStruct_NoExport,//è¿™é‡Œæ³¨å…¥è°ƒç”¨
			};
			static const UECodeGen_Private::FPackageParams PackageParams = {
				"/Script/Insider",
				SingletonFuncArray,
				UE_ARRAY_COUNT(SingletonFuncArray),
				PKG_CompiledIn | 0x00000000,
				0x02A7B98C,
				0xFA17C3C4,
				METADATA_PARAMS(0, nullptr)
			};
			UECodeGen_Private::ConstructUPackage(Z_Registration_Info_UPackage__Script_Insider.OuterSingleton, PackageParams);
		}
		return Z_Registration_Info_UPackage__Script_Insider.OuterSingleton;
	}
	static FRegisterCompiledInInfo Z_CompiledInDeferPackage_UPackage__Script_Insider(Z_Construct_UPackage__Script_Insider, TEXT("/Script/Insider"), Z_Registration_Info_UPackage__Script_Insider, CONSTRUCT_RELOAD_VERSION_INFO(FPackageReloadVersionInfo, 0x02A7B98C, 0xFA17C3C4));
PRAGMA_ENABLE_DEPRECATION_WARNINGS
```

è“å›¾é‡Œçš„æ•ˆæœï¼šä¾ç„¶å¯ä»¥å½“ä½œå˜é‡ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\USTRUCT\UHT\NoExport\Untitled.png)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\USTRUCT\UHT\NoExport\Untitled%201.png)

åŠ ä¸Šnoexportçš„åŒºåˆ«æ˜¯ä¸èƒ½ç”¨StaticStructå’Œæ²¡äº†TCppStructOpsï¼Œä¸èƒ½åšä¸€äº›ä¼˜åŒ–ã€‚å…¶ä»–è¿˜æ˜¯å¯ä»¥æ­£å¸¸ä½¿ç”¨ï¼Œå°±åƒFVectorä¸€æ ·ã€‚

ç¼ºå¤±çš„ä»£ç ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ‰‹åŠ¨æ·»åŠ ä»£ç æ¥è·å¾—ã€‚

```cpp
USTRUCT(BlueprintType,noexport)
struct INSIDER_API FMyStruct_NoExport
{
	//GENERATED_BODY()	//missing type specifier - int assumedï¼Œ..generated.hé‡Œåªæ˜¯å®šä¸€ä¸ªStaticStruct()å‡½æ•°

	static class UScriptStruct* StaticStruct();	//å¯ä»¥è‡ªå·±å®šä¹‰

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	float Score;

};

template<> INSIDER_API UScriptStruct* StaticStruct<struct FMyStruct_NoExport>();//å¯ä»¥è‡ªå·±å®šä¹‰

//.cpp
//é“¾å…¥å‡½æ•°å£°æ˜ï¼Œåœ¨å…¶ä»–çš„cppé‡Œå·²ç»æœ‰å®ç°ï¼Œæ‰€ä»¥å¯ä»¥æ­£å¸¸è°ƒç”¨åˆ°
INSIDER_API UScriptStruct* Z_Construct_UScriptStruct_FMyStruct_NoExport();
UPackage* Z_Construct_UPackage__Script_Insider();

static FStructRegistrationInfo Z_Registration_Info_UScriptStruct_MyStruct_NoExport;

class UScriptStruct* FMyStruct_NoExport::StaticStruct()
{
	if (!Z_Registration_Info_UScriptStruct_MyStruct_NoExport.OuterSingleton)
	{
		Z_Registration_Info_UScriptStruct_MyStruct_NoExport.OuterSingleton = GetStaticStruct(Z_Construct_UScriptStruct_FMyStruct_NoExport, Z_Construct_UPackage__Script_Insider(), TEXT("MyStruct_NoExport"));
	}
	return Z_Registration_Info_UScriptStruct_MyStruct_NoExport.OuterSingleton;
}

template<> INSIDER_API UScriptStruct* StaticStruct<FMyStruct_NoExport>()
{
	return FMyStruct_NoExport::StaticStruct();
}
```

# BlueprintType

- **åŠŸèƒ½æè¿°ï¼š**  å¯ä»¥ä½œä¸ºè“å›¾å˜é‡
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [BlueprintType](../../Meta/Blueprint/BlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

å’Œå…¶ä»–åœ°æ–¹çš„BlueprintTypeç”¨æ³•ä¸€æ ·ã€‚

# Flags

- **åŠŸèƒ½æè¿°ï¼š**  æŠŠè¯¥æšä¸¾çš„å€¼ä½œä¸ºä¸€ä¸ªæ ‡å¿—æ¥æ‹¼æ¥å­—ç¬¦ä¸²è¾“å‡ºã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Trait
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨EnumFlagsä¸­æ·»åŠ [Flags](../../../Flags/EEnumFlags/Flags.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŠŠè¯¥æšä¸¾çš„å€¼ä½œä¸ºä¸€ä¸ªæ ‡å¿—æ¥æ‹¼æ¥å­—ç¬¦ä¸²è¾“å‡ºã€‚

æŒ‡å®šä½œç”¨çš„åœ°æ–¹æ˜¯å½“æŠŠä¸€ä¸ªå€¼è¾“å‡ºä¸ºå­—ç¬¦ä¸²è¾“å‡ºçš„æ—¶å€™ã€‚è½¬æ¢æˆå­—ç¬¦ä¸²çš„æ–¹å¼ï¼šä¸€ç§æ˜¯ç›´æ¥æŸ¥æ‰¾ç²¾ç¡®ç›¸ç­‰çš„å€¼ï¼Œç„¶åæŸ¥æ‰¾ç‰¹å®šçš„æšä¸¾å€¼ã€‚ç¬¬äºŒç§å°±æ˜¯æŠŠå®ƒå½“åšæ ‡å¿—ï¼Œè¾“å‡ºç¬¦åˆç›¸åº”æ ‡è®°çš„â€œA | B | Câ€è¿™ç§æ ¼å¼çš„å€¼ã€‚Flagså°±æ˜¯æŒ‡å®šé‡‡ç”¨ç¬¬äºŒç§æ–¹å¼ã€‚

ä½†æ˜¯è¦æ³¨æ„å…¶æšä¸¾å€¼æ˜¯å®Œå…¨æ²¡æœ‰å½±å“å˜åŒ–çš„ã€‚è·Ÿç›´æ¥æŠŠæšä¸¾å€¼å®šä¹‰ä¸ºæ ‡è®°æ˜¯ä¸åŒçš„ã€‚

æ³¨æ„å’Œmeta(bitflags)çš„åŒºåˆ†ï¼Œåè€…æ˜¯æ ‡è®°è¯¥æšä¸¾å¯ä»¥ä½œä¸ºä¸€ä¸ªæ ‡è®°ï¼Œå¯ä»¥ä½œä¸ºBitmaskè¢«ç­›é€‰ä¸­ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UENUM(BlueprintType)
enum class EMyEnum_Normal:uint8
{
	First,
	Second,
	Third,
};

/*
[EMyEnum_Flags	Enum->Field->Object	/Script/Insider.EMyEnum_Flags]
(BlueprintType = true, First.Name = EMyEnum_Flags::First, ModuleRelativePath = Enum/MyEnum_Flags.h, Second.Name = EMyEnum_Flags::Second, Third.Name = EMyEnum_Flags::Third)
	ObjectFlags:	RF_Public | RF_Transient 
	Outer:	Package /Script/Insider
	EnumFlags:	EEnumFlags::Flags 
	EnumDisplayNameFn:	0
	CppType:	EMyEnum_Flags
	CppForm:	EnumClass
{
	First = 0,
	Second = 1,
	Third = 2,
	EMyEnum_MAX = 3
};
*/
UENUM(BlueprintType,Flags)
enum class EMyEnum_Flags:uint8
{
	First,
	Second,
	Third,
};

void UMyActor_EnumBitFlags_Test::TestFlags()
{
	int value = 3;

	FString outStr_Normal = StaticEnum<EMyEnum_Normal>()->GetValueOrBitfieldAsString(value);
	FString outStr_Flags = StaticEnum<EMyEnum_Flags>()->GetValueOrBitfieldAsString(value);
	FString outStr_BitFlags = StaticEnum<EMyEnum_BitFlags>()->GetValueOrBitfieldAsString(value);

}
```

## ç¤ºä¾‹æ•ˆæœï¼š

è“å›¾ä¸­çš„è¡¨ç¤ºï¼Œä¾ç„¶åªèƒ½é€‰æ‹©å•é¡¹ã€‚

![D:\github\UnrealSpecifiers\Doc\Specifier\UENUM\Flags\Flags.gif](Flags.gif)

è€Œæµ‹è¯•ä»£ç é‡Œæ‰“å°å‡ºæ¥çš„å­—ç¬¦ä¸²ï¼š

å¯è§outStr_Flags çš„æ‰“å°æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥çš„ã€‚

![D:\github\UnrealSpecifiers\Doc\Specifier\UENUM\Flags\image.png](image.png)

## åŸç†ï¼š

åªåœ¨GetValueOrBitfieldAsStringè¿™ä¸ªå‡½æ•°ä¸­ç”Ÿæ•ˆï¼Œæ‰€ä»¥è¦ç”¨è¿™ä¸ªæ–¹æ³•æµ‹è¯•æ‰ç”Ÿæ•ˆã€‚

```cpp
FString UEnum::GetValueOrBitfieldAsString(int64 InValue) const
{
	if (!HasAnyEnumFlags(EEnumFlags::Flags) || InValue == 0)
	{
		return GetNameStringByValue(InValue);
	}
	else
	{
		FString BitfieldString;
		bool WroteFirstFlag = false;
		while (InValue != 0)
		{
			int64 NextValue = 1ll << FMath::CountTrailingZeros64(InValue);
			InValue = InValue & ~NextValue;
			if (WroteFirstFlag)
			{
				// We don't just want to use the NameValuePair.Key because we want to strip enum class prefixes
				BitfieldString.Appendf(TEXT(" | %s"), *GetNameStringByValue(NextValue));
			}
			else
			{
				// We don't just want to use the NameValuePair.Key because we want to strip enum class prefixes
				BitfieldString.Appendf(TEXT("%s"), *GetNameStringByValue(NextValue));
				WroteFirstFlag = true;
			}
		}
		return BitfieldString;
	}
}
```

# BlueprintCallable

- **åŠŸèƒ½æè¿°ï¼š** æš´éœ²åˆ°è“å›¾ä¸­å¯è¢«è°ƒç”¨

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagså¢åŠ [FUNC_BlueprintCallable](../../../../Flags/EFunctionFlags/FUNC_BlueprintCallable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION(BlueprintCallable)
void MyFunc_BlueprintCallable() {}
```

## æ•ˆæœå±•ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\BlueprintCallable\Untitled.png)

# BlueprintGetter

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Getå‡½æ•°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintGetter](../../../Meta/Blueprint/BlueprintGetter.md)ï¼Œåœ¨FunctionFlagsåŠ å…¥[FUNC_BlueprintCallable](../../../Flags/EFunctionFlags/FUNC_BlueprintCallable.md)ã€[FUNC_BlueprintPure](../../../Flags/EFunctionFlags/FUNC_BlueprintPure.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Getå‡½æ•°ã€‚

æ­¤è¯´æ˜ç¬¦éšå«BlueprintPureå’ŒBlueprintCallableã€‚

æ›´å¤šå¯ä»¥å‚è€ƒUPROPERTYçš„BlueprintGetter

# BlueprintImplementableEvent

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªå‡½æ•°è°ƒç”¨ç‚¹ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­é‡è½½å®ç°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­å¢åŠ [FUNC_Event](../../../../Flags/EFunctionFlags/FUNC_Event.md)ã€[FUNC_Native](../../../../Flags/EFunctionFlags/FUNC_Native.md)ã€[FUNC_BlueprintEvent](../../../../Flags/EFunctionFlags/FUNC_BlueprintEvent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šä¸€ä¸ªå‡½æ•°è°ƒç”¨ç‚¹ï¼Œå¯ä»¥åœ¨è“å›¾ä¸­é‡è½½å®ç°ã€‚æ˜¯ä¸€ç§æ–¹ä¾¿çš„ç”¨æ¥å®ç°C++æ¥è°ƒç”¨è“å›¾å‡½æ•°çš„æ–¹å¼ã€‚

è“å›¾ä¸­å¦‚æœæ²¡æä¾›å®ç°ï¼Œè°ƒç”¨çš„è¯ç›¸å½“äºè°ƒç”¨ç©ºå‡½æ•°ã€‚

BlueprintImplementableEventä¹Ÿè¦é…åˆBlueprintCallableä½¿ç”¨ï¼Œå¦‚æœæ²¡åŠ BlueprintCallableçš„è¯å°±åªèƒ½åœ¨CPPé‡Œè°ƒç”¨ï¼Œåœ¨è“å›¾ä¼šå‘ç°æ‰¾ä¸åˆ°Call Functionçš„èŠ‚ç‚¹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//FunctionFlags:	FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
UFUNCTION(BlueprintCallable, BlueprintImplementableEvent)
void MyFunc_ImplementableEvent();
```

## æ•ˆæœå±•ç¤ºï¼š

å³é”®å¯æ·»åŠ è‡ªå®šä¹‰å®ç°

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\BlueprintImplementableEvent\Untitled.png)

## åŸç†ï¼š

åœ¨C++é‡Œè°ƒç”¨çš„æ—¶å€™ï¼Œé‡Œé¢ä¼šFindFunctionCheckedæ ¹æ®åå­—å¯»æ‰¾ã€‚å¦‚æœè“å›¾ä¸­æœ‰æ‰¾åˆ°çš„è¯ï¼Œåˆ™ä¼šè°ƒç”¨ã€‚å¦‚æœåœ¨è“å›¾ä¸­ç›´æ¥è°ƒç”¨ï¼Œåˆ™å…¶å®æ˜¯ä¼šç›´æ¥FindFunctionCheckedæŸ¥æ‰¾ï¼Œè“å›¾ä¸­æœ‰å®šä¹‰çš„è¯åˆ™ä¼šè¢«ç›´æ¥æ‰¾åˆ°ã€‚

```cpp
void AMyFunction_Default::MyFunc_ImplementableEvent()
{
		ProcessEvent(FindFunctionChecked(NAME_AMyFunction_Default_MyFunc_ImplementableEvent),NULL);
}
```

# BlueprintNativeEvent

- **åŠŸèƒ½æè¿°ï¼š** å¯ä»¥åœ¨è“å›¾æ€»è¦†ç›–å®ç°ï¼Œä½†æ˜¯ä¹Ÿåœ¨C++ä¸­æä¾›ä¸€ä¸ªé»˜è®¤å®ç°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­å¢åŠ [FUNC_Event](../../../../Flags/EFunctionFlags/FUNC_Event.md)ã€[FUNC_BlueprintEvent](../../../../Flags/EFunctionFlags/FUNC_BlueprintEvent.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¯ä»¥åœ¨è“å›¾æ€»è¦†ç›–å®ç°ï¼Œä½†æ˜¯ä¹Ÿåœ¨C++ä¸­æä¾›ä¸€ä¸ªé»˜è®¤å®ç°ã€‚

éœ€è¦åœ¨CPPä¸­å£°æ˜åç§°ä¸ä¸»å‡½æ•°ç›¸åŒçš„é™„åŠ å‡½æ•°ï¼Œä½†æ˜¯æœ«å°¾æ·»åŠ äº†_Implementationã€‚å¦‚æœæœªæ‰¾åˆ°ä»»ä½•è“å›¾è¦†ç›–ï¼Œè¯¥è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç å°†è°ƒç”¨â€œ [FunctionName]_Implementationâ€æ–¹æ³•ã€‚ä¸€èˆ¬ç”¨åœ¨OnXXXä¹‹ç±»çš„å‡½æ•°ä¸Šï¼Œåœ¨C++æä¾›å®ç°ï¼Œè¿™æ ·å¦‚æœè“å›¾ä¸­æ²¡æœ‰è¦†ç›–çš„æ—¶å€™ï¼Œå°±å¯ä»¥é»˜è®¤è°ƒç”¨C++ä¸­é»˜è®¤å®ç°ç‰ˆæœ¬ã€‚
BlueprintNativeEventï¼Œæ²¡åŠ BlueprintCallableçš„è¯å°±åªèƒ½åœ¨CPPé‡Œè°ƒç”¨ï¼Œå› æ­¤ä¸€èˆ¬ä¹Ÿè¦é…åˆåŠ ä¸ŠBlueprintCallableã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//FunctionFlags:	FUNC_Native | FUNC_Event | FUNC_Public | FUNC_BlueprintCallable | FUNC_BlueprintEvent 
UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
void MyFunc_NativeEvent();

void AMyFunction_Default::MyFunc_NativeEvent_Implementation()
{
	GEngine->AddOnScreenDebugMessage(-1, 3.f, FColor::Red, "MyFunc_NativeEvent_Implementation");
}
```

## æ•ˆæœå±•ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\BlueprintNativeEvent\Untitled.png)

## åŸç†ï¼š

åœ¨è°ƒç”¨MyFunc_NativeEventçš„æ—¶å€™ï¼Œå†…éƒ¨FindFunctionCheckedä¼šæ ¹æ®åå­—æŸ¥æ‰¾ï¼Œå¦‚æœåœ¨è“å›¾ä¸­æœ‰å®šä¹‰ï¼Œåˆ™ä¼šæ‰¾åˆ°è“å›¾ä¸­çš„å®ç°ç‰ˆæœ¬ã€‚å¦åˆ™çš„è¯ï¼Œåˆ™ä¼šæ‰¾åˆ°execMyFunc_NativeEventè¿™ä¸ªå®ç°ç‰ˆæœ¬ï¼Œä»è€Œè°ƒç”¨MyFunc_NativeEvent_Implementationã€‚

```cpp
DEFINE_FUNCTION(AMyFunction_Default::execMyFunc_NativeEvent)
{
	P_FINISH;
	P_NATIVE_BEGIN;
	P_THIS->MyFunc_NativeEvent_Implementation();
	P_NATIVE_END;
}

void AMyFunction_Default::MyFunc_NativeEvent()
{
	ProcessEvent(FindFunctionChecked(NAME_AMyFunction_Default_MyFunc_NativeEvent),NULL);
}
```

# BlueprintPure

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä½œä¸ºä¸€ä¸ªçº¯å‡½æ•°ï¼Œä¸€èˆ¬ç”¨äºGetå‡½æ•°ç”¨æ¥è¿”å›å€¼ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagså¢åŠ [FUNC_BlueprintCallable](../../../../Flags/EFunctionFlags/FUNC_BlueprintCallable.md)ã€[FUNC_BlueprintPure](../../../../Flags/EFunctionFlags/FUNC_BlueprintPure.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æŒ‡å®šä½œä¸ºä¸€ä¸ªçº¯å‡½æ•°ï¼Œä¸€èˆ¬ç”¨äºGetå‡½æ•°ç”¨æ¥è¿”å›å€¼ã€‚

- çº¯å‡½æ•°æ˜¯æŒ‡æ²¡æœ‰æ‰§è¡Œå¼•è„šçš„å‡½æ•°ï¼Œä¸æ˜¯æŒ‡constå‡½æ•°ã€‚
- çº¯å‡½æ•°å¯ä»¥æœ‰å¤šä¸ªè¿”å›å€¼ï¼Œç”¨å¼•ç”¨å‚æ•°åŠ åˆ°å‡½æ•°é‡Œå°±è¡Œã€‚
- ä¸èƒ½ç”¨äºvoidå‡½æ•°ï¼Œå¦åˆ™ä¼šæŠ¥é”™â€œerror : BlueprintPure specifier is not allowed for functions with no return value and no output parameters.â€

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION(BlueprintPure)
	int32 GetMyInt()const { return MyInt; }
private:
	int32 MyInt;
```

## æ•ˆæœå±•ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\BlueprintPure\Untitled.png)

# BlueprintSetter

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Setå‡½æ•°ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintSetter](../../../Meta/Blueprint/BlueprintSetter.md)ï¼Œåœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_BlueprintCallable ](../../../Flags/EFunctionFlags/FUNC_BlueprintCallable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šè¯¥å‡½æ•°ä½œä¸ºå±æ€§çš„è‡ªå®šä¹‰Setå‡½æ•°ã€‚

æ­¤è¯´æ˜ç¬¦éšå«BlueprintCallableã€‚

æ›´å¤šå¯ä»¥å‚è€ƒUPROPERTYçš„BlueprintSetter

# CallInEditor

- **åŠŸèƒ½æè¿°ï¼š** å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸Šä½œä¸ºä¸€ä¸ªæŒ‰é’®æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­å¢åŠ [CallInEditor](../../../../Meta/Blueprint/CallInEditor.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¯ä»¥åœ¨å±æ€§ç»†èŠ‚é¢æ¿ä¸Šä½œä¸ºä¸€ä¸ªæŒ‰é’®æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚

è¯¥å‡½æ•°å†™åœ¨AActoræˆ–UObjectå­ç±»é‡Œéƒ½æ˜¯å¯ä»¥çš„ï¼Œåªè¦æœ‰å¯¹åº”çš„å±æ€§ç»†èŠ‚é¢æ¿ã€‚

æ³¨æ„è¿™ä¸€èˆ¬æ˜¯å¤„äºEditorè¿è¡Œç¯å¢ƒçš„ã€‚å…¸å‹çš„ä¾‹å­æ˜¯ASkyLightçš„RecaptureæŒ‰é’®ã€‚å› æ­¤å‡½æ•°é‡Œæœ‰æ—¶ä¼šè°ƒç”¨ç¼–è¾‘å™¨ç¯å¢ƒä¸‹å‡½æ•°ã€‚ä½†ä¹Ÿè¦æ³¨æ„ä¸è¦åœ¨runtimeä¸‹æ··ç”¨äº†ï¼Œæ¯”è¾ƒå®¹æ˜“å‡ºé”™ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Default :public AActor
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(CallInEditor)
	void MyFunc_CallInEditor(){}
};
```

## è“å›¾å±•ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\CallInEditor\Untitled.png)

# SealedEvent

- **åŠŸèƒ½æè¿°ï¼š** æ— æ³•åœ¨å­ç±»ä¸­è¦†ç›–æ­¤å‡½æ•°ã€‚SealedEventå…³é”®è¯åªèƒ½ç”¨äºäº‹ä»¶ã€‚å¯¹äºéäº‹ä»¶å‡½æ•°ï¼Œè¯·å°†å®ƒä»¬å£°æ˜ä¸ºstaticæˆ–finalï¼Œä»¥å¯†å°å®ƒä»¬ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Behavior
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­æ·»åŠ [FUNC_Final](../../../../Flags/EFunctionFlags/FUNC_Final.md)

åœ¨æºç é‡Œæœç´¢ï¼šå‘ç°éƒ½æ˜¯ç”¨åœ¨ç½‘ç»œçš„å‡½æ•°ä¸Š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Blueprint\SealedEvent\Untitled.png)

## UHTä¸­çš„å¤„ç†ï¼š

```cpp
//å…ˆè¯†åˆ«ç¬¦å·
[UhtSpecifier(Extends = UhtTableNames.Function, ValueType = UhtSpecifierValueType.Legacy)]
private static void SealedEventSpecifier(UhtSpecifierContext specifierContext)
{
	UhtFunction function = (UhtFunction)specifierContext.Type;
	function.FunctionExportFlags |= UhtFunctionExportFlags.SealedEvent;
}

//å†è®¾ç½®æ ‡è®°
// Handle the initial implicit/explicit final
// A user can still specify an explicit final after the parameter list as well.
if (automaticallyFinal || function.FunctionExportFlags.HasAnyFlags(UhtFunctionExportFlags.SealedEvent))
{
				function.FunctionFlags |= EFunctionFlags.Final;
				function.FunctionExportFlags |= UhtFunctionExportFlags.Final | UhtFunctionExportFlags.AutoFinal;
}

å†éªŒè¯ï¼šé™å®šåªèƒ½ç”¨åœ¨Eventä¸Šã€‚

if (FunctionExportFlags.HasAnyFlags(UhtFunctionExportFlags.SealedEvent) && !FunctionFlags.HasAnyFlags(EFunctionFlags.Event))
{
	this.LogError("SealedEvent may only be used on events");
}

if (FunctionExportFlags.HasAnyFlags(UhtFunctionExportFlags.SealedEvent) && FunctionFlags.HasAnyFlags(EFunctionFlags.BlueprintEvent))
{
	this.LogError("SealedEvent cannot be used on Blueprint events");
}

```

## æµ‹è¯•ä»£ç ï¼š

```cpp
//Error: "SealedEvent may only be used on events"
UFUNCTION(SealedEvent)
void MyFunc_SealedEvent() {} 

//Error: "SealedEvent cannot be used on Blueprint events"
UFUNCTION(BlueprintCallable,BlueprintImplementableEvent,SealedEvent)
void MyFunc_ImplementableEvent();

//Error: "SealedEvent cannot be used on Blueprint events"
UFUNCTION(BlueprintCallable,BlueprintNativeEvent,SealedEvent)
void MyFunc_NativeEvent();
```

å› æ­¤æ— æ³•ç”¨äºæ™®é€šçš„å‡½æ•°ï¼Œåˆæ— æ³•ç”¨äºè“å›¾ä¸­çš„Eventã€‚æ‰€ä»¥æ—¢æ˜¯Eventåˆä¸æ˜¯BlueprintEventçš„æ˜¯ä»€ä¹ˆï¼Ÿçœ‹æºç æ˜¯åªæœ‰ç½‘ç»œçš„ä¸€äº›å‡½æ•°ã€‚

é€šè¿‡å¯¹æ¯”ï¼Œå‘ç°Sealedå‡½æ•°çš„åŒºåˆ«æ˜¯å¤šäº†FUNC_Finalçš„æ ‡è®°ã€‚ä½†FUNC_Finalåˆä¸ä¸€å®šå¿…é¡»è¦ä»¥SealedEventæ‰èƒ½æ·»åŠ ï¼Œexecæˆ–æ™®é€šçš„BlueprintCallableå‡½æ•°éƒ½ä¼šæ·»åŠ ã€‚ä½†æ˜¯å¦‚æœæ˜¯vituralçš„å‡½æ•°å°±ä¸ä¼šæ·»åŠ ã€‚åœ¨UHTä¸­çš„åŸç†æ˜¯ï¼š

```cpp
private static UhtParseResult ParseUFunction(UhtParsingScope parentScope, UhtToken token)
{
		if (function.FunctionFlags.HasAnyFlags(EFunctionFlags.Net))
		{
						// Network replicated functions are always events, and are only final if sealed
						scopeName = "event";
						tokenContext.Reset(scopeName);
						automaticallyFinal = false;
		}

		// If virtual, remove the implicit final, the user can still specifying an explicit final at the end of the declaration
		if (function.FunctionExportFlags.HasAnyFlags(UhtFunctionExportFlags.Virtual))
		{
						automaticallyFinal = false;
		}
		// Handle the initial implicit/explicit final
		// A user can still specify an explicit final after the parameter list as well.
		if (automaticallyFinal || function.FunctionExportFlags.HasAnyFlags(UhtFunctionExportFlags.SealedEvent))
		{
						function.FunctionFlags |= EFunctionFlags.Final;
						function.FunctionExportFlags |= UhtFunctionExportFlags.Final | UhtFunctionExportFlags.AutoFinal;
		}

}
```

åœ¨è‡ªå·±çš„C++ä»£ç ä¸­æµ‹è¯•ï¼Œå‘ç°åœ¨C++ä¸­æ€ä¹ˆç»§æ‰¿éƒ½ä¸ä¼šè§¦å‘ç¼–è¯‘é”™è¯¯ã€‚å› æ­¤å¦‚æœæƒ³æ‹’ç»è¢«ç»§æ‰¿ï¼Œè¿˜æ˜¯ç”¨C++æ ‡å‡†æ˜¯finalå…³é”®å­—ã€‚åœ¨å‡½æ•°æœ«å°¾åŠ finalã€‚

E:\P4V\Engine\Source\Editor\KismetCompiler\Private\KismetCompiler.cpp 

```cpp
const uint32 OverrideFlagsToCheck = (FUNC_FuncOverrideMatch & ~FUNC_AccessSpecifiers);
if ((Context.Function->FunctionFlags & OverrideFlagsToCheck) != (OverridenFunction->FunctionFlags & OverrideFlagsToCheck))
{
	MessageLog.Error(*LOCTEXT("IncompatibleOverrideFlags_Error", "Overriden function is not compatible with the parent function @@. Check flags: Exec, Final, Static.").ToString(), Context.EntryPoint);
}
```

åœ¨ç¼–è¯‘çš„æ—¶å€™æ£€æµ‹çš„æ˜¯å¦æ˜¯é‡è½½çˆ¶ç±»çš„å‡½æ•°ï¼Œä½†å› ä¸ºSealedEventä¸ä½œç”¨äºæ™®é€šå‡½æ•°ï¼Œä¹Ÿä¸ä½œç”¨äºBlueprintEventï¼Œå› æ­¤æ„Ÿè§‰åªèƒ½åœ¨C++ä¸­ç»§æ‰¿ã€‚

# Category

- **åŠŸèƒ½æè¿°ï¼š** åœ¨è“å›¾çš„å³é”®èœå•ä¸­ä¸ºè¯¥å‡½æ•°æŒ‡å®šç±»åˆ«åˆ†ç»„ï¼Œå¯ä»¥åµŒå¥—å¤šçº§

- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=â€œa|b|câ€
- **å¼•æ“æ¨¡å—ï¼š** Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[Category](../../../Meta/DetailsPanel/Category.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨è“å›¾çš„å³é”®èœå•ä¸­ä¸ºè¯¥å‡½æ•°æŒ‡å®šç±»åˆ«åˆ†ç»„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Default :public AActor
{
public:
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Category = MyCategory)
	void MyFunc_WithCategory(){}
	UFUNCTION(BlueprintCallable)
	void MyFunc_Default(){}
};
```

## è“å›¾ä¸­çš„å±•ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Category\Untitled.png)

# Exec

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ç‰¹å®šç±»é‡Œæ³¨å†Œä¸€ä¸ªå‡½æ•°ä¸ºä½œä¸ºæ§åˆ¶å°å‘½ä»¤ï¼Œå…è®¸æ¥å—å‚æ•°ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Behavior
- **é™åˆ¶ç±»å‹ï¼š** ç‰¹å®šçš„å‡ ä¸ªç±»
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_Exec](../../../Flags/EFunctionFlags/FUNC_Exec.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸€èˆ¬ç‰¹å®šçš„å‡ ä¸ªç±»æ˜¯ï¼šUPlayerInputï¼ŒAPlayerControllerï¼ŒAPawnï¼ŒAHUDï¼ŒAGameModeBaseï¼ŒACheatManagerï¼ŒAGameStateBaseï¼ŒAPlayerCameraManagerçš„å­ç±»ã€‚

å½“åœ¨è§†å£ä¸­è¾“å…¥æ§åˆ¶å°å‘½ä»¤åï¼Œé¦–å…ˆæ‰§è¡Œåˆ°çš„æ˜¯UConsole::ConsoleCommandï¼Œç„¶åæ˜¯APlayerController::ConsoleCommandï¼Œç„¶åæ˜¯UPlayer::ConsoleCommandï¼Œä¸­é—´å…ˆå°è¯•ViewportClient->Execï¼ˆå¯èƒ½å¤„ç†ä¸€äº›ç¼–è¾‘å™¨å‘½ä»¤ï¼‰ï¼Œç„¶ååˆ°è¾¾ULocalPlayer::Execï¼ˆå·²ç»å¤„ç†ä¸€äº›è‡ªå®šä¹‰å‘½ä»¤äº†ï¼‰ã€‚

UGameViewportClientï¼ŒUGameInstanceï¼ŒUPlayeræ˜¯ç»§æ‰¿äºFExecçš„ï¼Œå› æ­¤æœ¬èº«å«æœ‰ä¸€äº›Execï¼ŒExec_Runtimeï¼ŒExec_Devï¼ŒExec_Editorçš„4ä¸ªè™šå‡½æ•°é‡è½½ã€‚

å…¶ä¸­UEngine::Execï¼Œå†…éƒ¨ä¼šè½¬å‘ç»™å„ä¸ªæ¨¡å—æ¥å°è¯•ã€‚å…¶ä¸­é‡è¦çš„æ˜¯StaticExecï¼Œæœ€åä¼šFSelfRegisteringExec::StaticExec( InWorld, Cmd,Ar )æ¥è°ƒç”¨è‡ªæ³¨å†Œçš„Execã€‚

å¦‚æœæ˜¯åœ¨ç¼–è¾‘å™¨ä¸­~æ‰§è¡Œå‘½ä»¤ï¼ŒFConsoleCommandExecutor::ExecInternalï¼Œæœ€åä¹Ÿä¼šåˆ°ULocalPlayer::Execã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Exec :public APawn
{
public:
	GENERATED_BODY()
public:
	//FunctionFlags:	FUNC_Final | FUNC_Exec | FUNC_Native | FUNC_Public 
	UFUNCTION(exec)
	void MyExec();
};
void AMyFunction_Exec::MyExec()
{
	GEngine->AddOnScreenDebugMessage(-1, 3.f, FColor::Red, "MyExec");
}
```

åœ¨PIEçš„æ—¶å€™~æ‰“å¼€æ§åˆ¶å°è¿è¡Œç»“æœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Exec\Untitled.png)

## åŸç†ï¼š

æ ¹æ®æºç ä¸­çš„æµç¨‹ï¼š

```cpp
bool UGameViewportClient::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
{
	//æŒ‰é¡ºåºULocalPlayer::Exec_Editor,Exec_Dev,Exec_Runtimeï¼Œå„è‡ªåˆ¤æ–­æ˜¯å¦æ˜¯ä¸€äº›å‘½ä»¤
	if (FExec::Exec(InWorld, Cmd, Ar))
	{
		return true;
	}
	else if (ProcessConsoleExec(Cmd, Ar, NULL))
	{
		return true;
	}
	else if (GameInstance && (GameInstance->Exec(InWorld, Cmd, Ar) || GameInstance->ProcessConsoleExec(Cmd, Ar, nullptr)))
	{
		return true;
	}
	else if (GEngine->Exec(InWorld, Cmd, Ar))
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool UPlayer::Exec( UWorld* InWorld, const TCHAR* Cmd,FOutputDevice& Ar)
{
	// Route through Exec_Dev and Exec_Editor first
	//æŒ‰é¡ºåºULocalPlayer::Exec_Editor,Exec_Dev,Exec_Runtimeï¼Œå„è‡ªåˆ¤æ–­æ˜¯å¦æ˜¯ä¸€äº›å‘½ä»¤
	if (FExec::Exec(InWorld, Cmd, Ar))
	{
		return true;
	}

	AActor* ExecActor = PlayerController;
	if (!ExecActor)
	{
		UNetConnection* NetConn = Cast<UNetConnection>(this);
		ExecActor = (NetConn && NetConn->OwningActor) ? ToRawPtr(NetConn->OwningActor) : nullptr;
	}

	if (ExecActor)
	{
		// Since UGameViewportClient calls Exec on UWorld, we only need to explicitly
		// call UWorld::Exec if we either have a null GEngine or a null ViewportClient
		UWorld* World = ExecActor->GetWorld();
		check(World);
		check(InWorld == nullptr || InWorld == World);
		const bool bWorldNeedsExec = GEngine == nullptr || Cast<ULocalPlayer>(this) == nullptr || static_cast<ULocalPlayer*>(this)->ViewportClient == nullptr;
		APawn* PCPawn = PlayerController ? PlayerController->GetPawnOrSpectator() : nullptr;
		if (bWorldNeedsExec && World->Exec(World, Cmd, Ar))
		{
			return true;
		}
		else if (PlayerController && PlayerController->PlayerInput && PlayerController->PlayerInput->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (ExecActor->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (PCPawn && PCPawn->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (PlayerController && PlayerController->MyHUD && PlayerController->MyHUD->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (World->GetAuthGameMode() && World->GetAuthGameMode()->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (PlayerController && PlayerController->CheatManager && PlayerController->CheatManager->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (World->GetGameState() && World->GetGameState()->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
		else if (PlayerController && PlayerController->PlayerCameraManager && PlayerController->PlayerCameraManager->ProcessConsoleExec(Cmd, Ar, PCPawn))
		{
			return true;
		}
	}
	return false;
}
```

æŸ¥æ‰¾Execçš„é¡ºåºåº”è¯¥æ˜¯ï¼š

- UGameInstance::Execï¼ŒUGameInstance::ProcessConsoleExec
- GEngine->Exec(InWorld, Cmd, Ar)
- `UWorld`::Execï¼Œåœ¨æ²¡æœ‰LocalPlayerå¤„ç†çš„æƒ…å†µä¸‹
- `UPlayerInput::ProcessConsoleExec`
- `APlayerController::ProcessConsoleExec`
- `APawn::ProcessConsoleExec`
- `AHUD::ProcessConsoleExec`
- `AGameModeBase::ProcessConsoleExec`
- `ACheatManager::ProcessConsoleExec`
- `AGameStateBase::ProcessConsoleExec`
- `APlayerCameraManager::ProcessConsoleExec`

ProcessConsoleExecå†…éƒ¨ä¼šè°ƒç”¨CallFunctionByNameWithArgumentsä»£ç ï¼šå› æ­¤ç¡®å®ä¼šé™åˆ¶è¿™ç§æ–¹å¼å£°æ˜çš„Execåªèƒ½åœ¨ä»¥ä¸Šå‡ ä¸ªç±»é‡Œé¢

```cpp
bool UObject::CallFunctionByNameWithArguments(const TCHAR* Str, FOutputDevice& Ar, UObject* Executor, bool bForceCallWithNonExec/*=false*/)
{
	UFunction* Function = FindFunction(Message);//å¯»æ‰¾å‡½æ•°
}
```

# BlueprintAuthorityOnly

- **åŠŸèƒ½æè¿°ï¼š** è¿™ä¸ªå‡½æ•°åªèƒ½åœ¨æ‹¥æœ‰ç½‘ç»œæƒé™çš„ç«¯ä¸Šè¿è¡Œã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­æ·»åŠ [FUNC_BlueprintAuthorityOnly](../../../../Flags/EFunctionFlags/FUNC_BlueprintAuthorityOnly.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¿™ä¸ªå‡½æ•°åªèƒ½åœ¨æ‹¥æœ‰ç½‘ç»œæƒé™çš„ç«¯ä¸Šè¿è¡Œã€‚HasAuthority::ï¼ˆGetLocalRole() == ROLE_Authorityï¼‰ã€‚å…±æœ‰4ç§NetRole: ROLE_Noneï¼ˆä¸å¤åˆ¶ï¼‰ï¼ŒROLE_SimulatedProxyï¼ˆåœ¨å®¢æˆ·ç«¯ä¸Šæ¨¡æ‹Ÿçš„ä»£ç†ï¼‰ï¼ŒROLE_AutonomousProxyï¼ˆåœ¨å®¢æˆ·ç«¯ä¸Šçš„åŒ¿åä»£ç†ï¼Œæ¥æ”¶ç©å®¶è¾“å…¥ï¼‰ï¼ŒROLE_Authorityï¼ˆæœåŠ¡å™¨æ‹¥æœ‰æƒé™çš„ï¼‰ã€‚

å› æ­¤BlueprintAuthorityOnlyé™å®šè¿™ä¸ªå‡½æ•°åªèƒ½åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œï¼Œè¿™ä¸ªâ€œæœåŠ¡å™¨â€å¯ä»¥æ˜¯LSæœåŠ¡å™¨ï¼ŒDSæœåŠ¡å™¨ï¼Œå•æœºï¼ˆå¯ä»¥çœ‹ä½œæ²¡æœ‰å®¢æˆ·ç«¯çš„æœåŠ¡å™¨ï¼‰ã€‚

æ³¨æ„åœ¨æµ‹è¯•çš„æ—¶å€™éœ€è¦æŠŠè¯¥Actorè®¾ç½®ä¸ºReplicatesã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Network :public AActor
{
public:
	GENERATED_BODY()
public:
	//FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable)
	void MyFunc_Default();

	//FunctionFlags:	FUNC_Final | FUNC_BlueprintAuthorityOnly | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable, BlueprintAuthorityOnly)
	void MyFunc_BlueprintAuthorityOnly();

	static void PrintFuncStatus(AActor* actor,FString funcName);
};

void AMyFunction_Network::MyFunc_Default()
{
	PrintFuncStatus(this,TEXT("MyFunc_Default"));
}

void AMyFunction_Network::MyFunc_BlueprintAuthorityOnly()
{
	PrintFuncStatus(this,TEXT("MyFunc_BlueprintAuthorityOnly"));
}

void AMyFunction_Network::PrintFuncStatus(AActor* actor, FString funcName)
{
	FString actorName = actor->GetName();

	FString localRoleStr;
	UEnum::GetValueAsString(actor->GetLocalRole(), localRoleStr);

	FString remoteRoleStr;
	UEnum::GetValueAsString(actor->GetRemoteRole(), remoteRoleStr);

	FString netModeStr = Insider::NetModeToString(actor->GetNetMode());

	FString str = FString::Printf(TEXT("%s\t%s\t%s\tLocal:%s\tRemote:%s"), *funcName,*actorName, *netModeStr, *localRoleStr, *remoteRoleStr);
	GEngine->AddOnScreenDebugMessage(-1, 20.f, FColor::Red, str);

	UE_LOG(LogInsider, Display, TEXT("%s"), *str);
}
```

## è“å›¾ä»£ç ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\BlueprintAuthorityOnly\Untitled.png)

å¯¹äºä¸Replicatedçš„Actorï¼š

```cpp
MyFunc_Default  BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_None
MyFunc_Default  BP_Network_C_1  NM_Client   Local:ROLE_None Remote:ROLE_Authority
MyFunc_Default  BP_Network_C_1  NM_Client   Local:ROLE_None Remote:ROLE_Authority
```

è€Œå¯¹äºReplicatedçš„Actorï¼ŒåŒæ—¶æœ‰1ä¸ªSå’Œä¸¤ä¸ªCï¼Œè¿è¡Œæ™®é€šçš„å‡½æ•°ï¼š

```cpp
MyFunc_Default  BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
MyFunc_Default  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
MyFunc_Default  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
```

å¦‚æœå…è®¸çš„BlueprintAuthorityOnlyå‡½æ•°ï¼š

```cpp
MyFunc_BlueprintAuthorityOnly   BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
```

ç»“æœå¯è§ï¼ŒDefaultçš„å‡½æ•°åœ¨3ä¸ªç«¯ä¸Šéƒ½å¯ä»¥è¿è¡Œï¼Œè€ŒBlueprintAuthorityOnlyåªèƒ½åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œã€‚è€ŒClientä¸Šæ— æ³•è¿è¡Œã€‚

## åŸç†ï¼š

```cpp
int32 AActor::GetFunctionCallspace( UFunction* Function, FFrame* Stack )
{
	FunctionCallspace::Type Callspace = (LocalRole < ROLE_Authority) && Function->HasAllFunctionFlags(FUNC_BlueprintAuthorityOnly) ? FunctionCallspace::Absorbed : FunctionCallspace::Local;
}
```

# BlueprintCosmetic

- **åŠŸèƒ½æè¿°ï¼š** æ­¤å‡½æ•°ä¸ºä¿®é¥°æ€§çš„ï¼Œæ— æ³•åœ¨DSä¸Šè¿è¡Œã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_BlueprintCosmetic](../../../../Flags/EFunctionFlags/FUNC_BlueprintCosmetic.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¿™ä¸ªå‡½æ•°æ˜¯ä¿®é¥°æ€§çš„ï¼Œæ‰€è°“ä¿®é¥°æ€§æ˜¯æŒ‡è¿™ä¸ªå‡½æ•°çš„å†…å®¹æ˜¯ä¸ºäº†å±•ç°ä¸€äº›ä¸é€»è¾‘æ— å…³çš„å†…å®¹ï¼Œæ¯”å¦‚åŠ¨ç”»éŸ³æ•ˆç‰¹æ•ˆç­‰ã€‚å› ä¸ºDSå¹¶æ²¡æœ‰å®é™…çš„ç”»é¢è¾“å‡ºï¼Œå› æ­¤è¿™äº›ä¿®é¥°æ€§çš„å‡½æ•°æ˜¯å¯¹DSæ— æ„ä¹‰çš„ã€‚å› æ­¤è¿™äº›ä¿®é¥°æ€§å‡½æ•°ä¼šè¢«æ— è§†æ‰ã€‚

ä½†æ˜¯ä¹Ÿæ³¨æ„åœ¨ListenServeræˆ–Clientä¸Šï¼Œè¿™äºŒè€…éƒ½ä¼šå…è®¸è¿è¡Œã€‚å› ä¸ºè¿™ä¸¤ä¸ªç«¯éƒ½éœ€è¦ç”»é¢å±•ç¤ºã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UFUNCTION(BlueprintCallable, BlueprintCosmetic)
void MyFunc_BlueprintCosmetic();
```

## æµ‹è¯•è“å›¾ï¼š

èŠ‚ç‚¹ä¸Šçš„ç”µè„‘æ ‡è®°å°±æ˜¯æ„å‘³ç€åªåœ¨å®¢æˆ·ç«¯ä¸Šè¿è¡Œã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\BlueprintCosmetic\Untitled.png)

ç»“æœè¾“å‡º

```cpp
MyFunc_BlueprintCosmetic    BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
MyFunc_BlueprintCosmetic    BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
MyFunc_BlueprintCosmetic    BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
```

## åŸç†ï¼š

```cpp
int32 AActor::GetFunctionCallspace( UFunction* Function, FFrame* Stack )
{
// Dedicated servers don't care about "cosmetic" functions.
if (NetMode == NM_DedicatedServer && Function->HasAllFunctionFlags(FUNC_BlueprintCosmetic))
{
	DEBUG_CALLSPACE(TEXT("GetFunctionCallspace Blueprint Cosmetic Absorbed: %s"), *Function->GetName());
	return FunctionCallspace::Absorbed;
}
}
```

# Client

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨å®¢æˆ·ç«¯ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsåŠ å…¥[FUNC_Net](../../../../Flags/EFunctionFlags/FUNC_Net.md)ã€[FUNC_NetClient](../../../../Flags/EFunctionFlags/FUNC_NetClient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨å®¢æˆ·ç«¯ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚

ä¸€èˆ¬ç”¨äºä»Serverå‘é€ä¸€ä¸ªRPCåˆ°Clientã€‚å’Œè“å›¾é‡ŒRunOnClientçš„æ•ˆæœä¸€æ ·ã€‚

æ‰€è°“Client-ownedï¼Œå‚è€ƒæ–‡æ¡£ï¼š[https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/](https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\Client\Untitled.png)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_PlayerController :public APlayerController
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Client, Reliable)
	void MyFunc_RunOnClient();
};

void AMyFunction_PlayerController::MyFunc_RunOnClient_Implementation()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc_RunOnClient_Implementation"));
}
```

æµ‹è¯•è“å›¾ï¼šPIEæ¨¡å¼ï¼Œä¸€ä¸ªListenServer+2Client

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\Client\Untitled%201.png)

## æµ‹è¯•è¾“å‡ºç»“æœï¼š

```cpp
MyFunc_Client_Implementation    BP_NetworkPC_C_0    NM_Client   Local:ROLE_AutonomousProxy  Remote:ROLE_Authority
OtherClientFunc BP_NetworkPC_C_0    NM_Client   Local:ROLE_AutonomousProxy  Remote:ROLE_Authority
```

å¯è§ï¼Œæµ‹è¯•ä»£ç ä¸­å–ç¬¬2ä¸ªPCï¼Œå‘å‡ºä¸€ä¸ªRun on Clientçš„RPCè°ƒç”¨ï¼Œæœ€ç»ˆåœ¨Clientä¸ŠæˆåŠŸè§¦å‘ã€‚C++å®šä¹‰çš„å‡½æ•°å’Œè“å›¾ä¸­æ·»åŠ çš„è‡ªå®šä¹‰RunOnClientäº‹ä»¶æ•ˆæœæ˜¯ç­‰ä»·çš„ã€‚

è€Œå¦‚æœè¿™ä¸ªå‡½æ•°åœ¨Server owned Actorä¸Šæ‰§è¡Œï¼Œåˆ™åªä¼šåœ¨è¿è¡Œåœ¨æœåŠ¡å™¨ä¸Šï¼Œä¸ä¼šä¼ é€’åˆ°å®¢æˆ·ç«¯ã€‚

# NetMulticast

- **åŠŸèƒ½æè¿°ï¼š** å®šä¹‰ä¸€ä¸ªå¤šæ’­RPCå‡½æ•°åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¸Šéƒ½æ‰§è¡Œã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_Net](../../../../Flags/EFunctionFlags/FUNC_Net.md)ã€[FUNC_NetMulticast](../../../../Flags/EFunctionFlags/FUNC_NetMulticast.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

å®šä¹‰ä¸€ä¸ªå¤šæ’­RPCå‡½æ•°åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¸Šéƒ½æ‰§è¡Œã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚

RPCæ‰§è¡Œçš„è§„åˆ™ï¼Œå‚è€ƒæ–‡æ¡£ï¼š[https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/](https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\NetMulticast\Untitled.png)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Network :public AActor
{
public:
	GENERATED_BODY()

public:
		UFUNCTION(BlueprintCallable, NetMulticast, Reliable)
	void MyFunc_NetMulticast();
};

void AMyFunction_Network::MyFunc_NetMulticast_Implementation()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc_NetMulticast_Implementation"));
}
```

æµ‹è¯•è“å›¾ï¼šPIEæ¨¡å¼ï¼Œä¸€ä¸ªListenServer+2Client

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\NetMulticast\Untitled.png)

## æµ‹è¯•è¾“å‡ºç»“æœï¼š

```cpp
LogInsider: Display: 46715a00    MyFunc_NetMulticast_Implementation  BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
LogInsider: Display: 46e65000    MyFunc_NetMulticast_Implementation  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
LogInsider: Display: 29aaaa00    MyFunc_NetMulticast_Implementation  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority

LogInsider: Display: 4ff44600    OtherMulticastFunc  BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
LogInsider: Display: 3bf89b00    OtherMulticastFunc  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
LogInsider: Display: 29d68700    OtherMulticastFunc  BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
```

åœ¨ä¸€ä¸ªServer Ownedçš„Actorä¸Šï¼Œå‘å‡ºMulticast RPCäº‹ä»¶è°ƒç”¨ï¼Œå¯ä»¥è§åˆ°åœ¨3ä¸ªç«¯éƒ½å¾—åˆ°äº†è°ƒç”¨ã€‚

# Reliable

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œå¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶ä¼šé‡å‘ä»¥ä¿è¯åˆ°è¾¾ã€‚ä¸€èˆ¬ç”¨åœ¨é€»è¾‘å…³é”®çš„å‡½æ•°ä¸Šã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsåŠ å…¥[FUNC_NetReliable](../../../Flags/EFunctionFlags/FUNC_NetReliable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œå¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶ä¼šé‡å‘ä»¥ä¿è¯åˆ°è¾¾ã€‚ä¸€èˆ¬ç”¨åœ¨é€»è¾‘å…³é”®çš„å‡½æ•°ä¸Šã€‚

å…·ä½“çš„åŸç†æ¶‰åŠåˆ°äº†é‡å‘ä¿¡æ¯åŒ…çš„é€»è¾‘ã€‚

# Server

- **åŠŸèƒ½æè¿°ï¼š** åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨æœåŠ¡å™¨ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_Net](../../../../Flags/EFunctionFlags/FUNC_Net.md)ã€[FUNC_NetServer](../../../../Flags/EFunctionFlags/FUNC_NetServer.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

åœ¨Client-ownedçš„Actorä¸Šï¼ˆPlayerControlleræˆ–Pawnï¼‰æ‰§è¡Œä¸€ä¸ªRPCå‡½æ•°ï¼Œåªè¿è¡Œåœ¨æœåŠ¡å™¨ä¸Šã€‚å¯¹åº”çš„å®ç°å‡½æ•°ä¼šæ·»åŠ _Implementationåç¼€ã€‚

å’ŒRunOnServerçš„æ•ˆæœä¸€æ ·ã€‚

æ‰€è°“Client-ownedï¼Œå‚è€ƒæ–‡æ¡£ï¼š[https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/](https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\Server\Untitled.png)

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_PlayerController :public APlayerController
{
	GENERATED_BODY()
public:
UFUNCTION(BlueprintCallable, Server, Reliable)
	void MyFunc_RunOnServer();
};

void AMyFunction_PlayerController::MyFunc_RunOnServer_Implementation()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc_RunOnServer_Implementation"));
}
```

æµ‹è¯•è“å›¾ï¼šPIEæ¨¡å¼ï¼Œä¸€ä¸ªListenServer+2Client

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\Network\Server\Untitled.png)

## æµ‹è¯•è¾“å‡ºç»“æœï¼š

```cpp
LogInsider: Display: 5118b400    MyFunc_RunOnServer_Implementation   BP_NetworkPC_C_1    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy
LogInsider: Display: 44ec3c00    MyFunc_RunOnServer_Implementation   BP_NetworkPC_C_2    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy

LogInsider: Display: 49999000    OtherServerFunc BP_NetworkPC_C_1    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy
LogInsider: Display: 4bcbd800    OtherServerFunc BP_NetworkPC_C_2    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy
```

å¯è§ï¼Œæµ‹è¯•ä»£ç ä¸­å–ç¬¬2ä¸ªPCï¼Œå‘å‡ºä¸€ä¸ªRun on Serverçš„RPCè°ƒç”¨ï¼Œæœ€ç»ˆåœ¨Serverä¸ŠæˆåŠŸè§¦å‘ã€‚C++å®šä¹‰çš„å‡½æ•°å’Œè“å›¾ä¸­æ·»åŠ çš„è‡ªå®šä¹‰RunOnServeräº‹ä»¶æ•ˆæœæ˜¯ç­‰ä»·çš„ã€‚

è€Œå¦‚æœè¿™ä¸ªå‡½æ•°åœ¨Server owned Actorä¸Šæ‰§è¡Œï¼Œåˆ™åªä¼šåœ¨è¿è¡Œåœ¨æœåŠ¡å™¨ä¸Šï¼Œä¸ä¼šä¼ é€’åˆ°å®¢æˆ·ç«¯ã€‚

# ServiceRequest

- **åŠŸèƒ½æè¿°ï¼š** æ­¤å‡½æ•°ä¸ºRPCï¼ˆè¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼‰æœåŠ¡è¯·æ±‚ã€‚rpcæœåŠ¡è¯·æ±‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[CustomThunk](../../../Meta/UHT/CustomThunk.md)ï¼Œåœ¨FunctionFlagsåŠ å…¥[FUNC_Net](../../../Flags/EFunctionFlags/FUNC_Net.md)ã€[FUNC_Event](../../../Flags/EFunctionFlags/FUNC_Event.md)ã€[FUNC_NetReliable](../../../Flags/EFunctionFlags/FUNC_NetReliable.md)ã€[FUNC_NetRequest](../../../Flags/EFunctionFlags/FUNC_NetRequest.md)

åœ¨æºç é‡Œéƒ½æ²¡çœ‹åˆ°ä½¿ç”¨ï¼Œåªæœåˆ°

```cpp
UCLASS()
class UTestReplicationStateDescriptor_TestFunctionWithNotReplicatedNonPODParameters : public UObject
{
	GENERATED_BODY()

protected:
	// Currently some features such as not replicating all parameters isn't allowed on regular RPCs
	UFUNCTION(ServiceRequest(Iris))
	void FunctionWithNotReplicatedNonPODParameters(int Param0, bool Param1, int Param2, UPARAM(NotReplicated) const TArray<FTestReplicationStateDescriptor_TestStructWithRefCArray>& NotReplicatedParam3);
	void FunctionWithNotReplicatedNonPODParameters_Implementation(int Param0, bool Param1, int Param2, UPARAM(NotReplicated) const TArray<FTestReplicationStateDescriptor_TestStructWithRefCArray>& NotReplicatedParam3);
};
```

## UDNå›ç­”ï¼š

Alex: Those specifiers were added quite a while ago as a way to mark functions as RPC requests/responses to and from a backend service, the name of which would be given as part of the specifier: UFUNCTION(ServiceRequest(<Endpoint Name>)). However, the feature was never fully implemented, and since then the specifiers have only been used internally (and even then, I don't believe "ServiceResponse" is used at all anymore). This is why there isn't any public documentation or examples available, as they're not formally supported in the engine. You can check out ServiceRequestSpecifier and ServiceResponseSpecifier in UhtFunctionSpecifiers.cs to see how UHT handles these specifiers.

Mi: è¿™ä¸¤ä¸ªæ ‡è®°æ˜¯æˆ‘ä»¬ç”¨æ¥è‡ªç”±æ‰©å±•å’Œè‡ªå·±çš„æœåŠ¡å™¨é€šä¿¡çš„ï¼ˆä¾‹å¦‚http requestï¼‰ï¼Œè­¬å¦‚å¯ä»¥æä¾›è‡ªå·±çš„NetDriverå¤„ç†ç‰¹å®šæ ‡è®°çš„ServiceRequestçš„RPCï¼Œè‡ªå·±åºåˆ—åŒ–å¯¹åº”å‚æ•°å‘ç»™è‡ªå·±çš„æœåŠ¡ã€‚

â€œæ„æ€æ˜¯å¦‚æœä½¿ç”¨å¼•æ“çš„é»˜è®¤å®ç°çš„è¯ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªæ ‡è®°æ˜¯æ— æ•ˆçš„å—ï¼Ÿæˆ‘å°è¯•åœ¨æœåŠ¡å™¨æˆ–è€…å®¢æˆ·ç«¯å‘èµ·å¯¹ServiceRequestæ ‡è®°çš„ufunctionçš„è°ƒç”¨ï¼Œç»“æœéƒ½æ˜¯ä¼šæ‰“å°é”™è¯¯æ—¥å¿—â€

æ˜¯çš„ï¼Œé»˜è®¤çš„UE clientå’ŒDSé€šä¿¡çš„NetDriverçš„RPCä¸éœ€è¦è¿™ä¸¤ä¸ªå…³é”®å­—ï¼Œç”¨äº†ä¹‹åä¼šæ‰¾ä¸åˆ°ç›¸åº”å¤„ç†çš„NetDriverçš„å®ç°ã€‚

åœ¨Server Owned Actorä¸Šè°ƒç”¨ä¼šå‡ºé”™ï¼šLogNet: Warning: UNetDriver::ProcessRemoteFunction: No owning connection for actor BP_Network_C_1. Function MyFunc_ServiceRequest will not be processed.

åœ¨PCä¸ŠServerè°ƒç”¨ä¹Ÿä¼šï¼š

LogRep: Error: Rejected RPC function due to access rights. Object: BP_NetworkPC_C /Game/UEDPIE_0_StartMap.StartMap:PersistentLevel.BP_NetworkPC_C_1, Function: MyFunc_ServiceRequest
LogNet: Error: UActorChannel::ProcessBunch: Replicator.ReceivedBunch failed.  Closing connection. RepObj: BP_NetworkPC_C /Game/UEDPIE_0_StartMap.StartMap:PersistentLevel.BP_NetworkPC_C_1, Channel: 3

# ServiceResponse

- **åŠŸèƒ½æè¿°ï¼š** æ­¤å‡½æ•°ä¸ºRPCæœåŠ¡å“åº”ã€‚rpcæœåŠ¡å›å¤

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsåŠ å…¥[FUNC_Net](../../../Flags/EFunctionFlags/FUNC_Net.md)ã€[FUNC_Event](../../../Flags/EFunctionFlags/FUNC_Event.md)ã€[FUNC_NetReliable](../../../Flags/EFunctionFlags/FUNC_NetReliable.md)ã€[FUNC_NetResponse](../../../Flags/EFunctionFlags/FUNC_NetResponse.md)

åœ¨æºç é‡Œä¸€ä¸ªä¹Ÿæ²¡çœ‹åˆ°ä½¿ç”¨ã€‚

# Unreliable

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œä¸å¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶å°±ä¼šè¢«ä¸¢å¼ƒã€‚ä¸€èˆ¬ç”¨åœ¨ä¼ æ’­æ•ˆæœè¡¨ç°çš„å‡½æ•°ä¸Šï¼Œå°±ç®—æ¼æ‰ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°ä¸ºâ€œä¸å¯é çš„â€ï¼Œå½“é‡è§ç½‘ç»œé”™è¯¯æ—¶å°±ä¼šè¢«ä¸¢å¼ƒã€‚ä¸€èˆ¬ç”¨åœ¨ä¼ æ’­æ•ˆæœè¡¨ç°çš„å‡½æ•°ä¸Šï¼Œå°±ç®—æ¼æ‰ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚

# WithValidation

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°åœ¨æ‰§è¡Œå‰éœ€è¦éªŒè¯ï¼Œåªæœ‰éªŒè¯é€šè¿‡æ‰å¯ä»¥æ‰§è¡Œã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨FunctionFlagsä¸­åŠ å…¥[FUNC_NetValidate](../../../Flags/EFunctionFlags/FUNC_NetValidate.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šä¸€ä¸ªRPCå‡½æ•°åœ¨æ‰§è¡Œå‰éœ€è¦éªŒè¯ï¼Œåªæœ‰éªŒè¯é€šè¿‡æ‰å¯ä»¥æ‰§è¡Œã€‚

WithValidationå®é™…ä¸Šå¯ä»¥ç”¨äºClientï¼ŒServerï¼ŒNetMulticastçš„RPCå‡½æ•°ï¼Œä½†ä¸€èˆ¬æ¥è¯´è¿˜æ˜¯ç”¨åœ¨Serverçš„æœ€å¤šï¼Œå› ä¸ºä¸€èˆ¬æ˜¯Serverçš„æ•°æ®æœ€æƒå¨å¯ä»¥è¿›è¡Œæ•°æ®åˆæ³•æ€§æ ¡éªŒã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_PlayerController :public APlayerController
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Client, Reliable,WithValidation)
	void MyFunc2_RunOnClient();

		UFUNCTION(BlueprintCallable, Server, Reliable,WithValidation)
	void MyFunc2_RunOnServer();
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Network :public AActor
{
public:
	GENERATED_BODY()
	UFUNCTION(BlueprintCallable, NetMulticast, Reliable,WithValidation)
	void MyFunc2_NetMulticast();
};

void AMyFunction_PlayerController::MyFunc2_RunOnServer_Implementation()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc2_RunOnServer_Implementation"));
}

bool AMyFunction_PlayerController::MyFunc2_RunOnServer_Validate()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc2_RunOnServer_Validate"));
	return true;
}

bool AMyFunction_Network::MyFunc2_NetMulticast_Validate()
{
	UInsiderLibrary::PrintFuncStatus(this, TEXT("MyFunc2_NetMulticast_Validate"));
	return true;
}
```

## æµ‹è¯•ç»“æœï¼š

```cpp
RunOnClient:
LogInsider: Display: 815f7800    MyFunc2_RunOnClient_Validate    BP_NetworkPC_C_0    NM_Client   Local:ROLE_AutonomousProxy  Remote:ROLE_Authority
LogInsider: Display: 815f7800    MyFunc2_RunOnClient_Implementation  BP_NetworkPC_C_0    NM_Client   Local:ROLE_AutonomousProxy  Remote:ROLE_Authority

RunOnServer:
LogInsider: Display: 7fd11800    MyFunc2_RunOnServer_Validate    BP_NetworkPC_C_1    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy
LogInsider: Display: 7fd11800    MyFunc2_RunOnServer_Implementation  BP_NetworkPC_C_1    NM_ListenServer Local:ROLE_Authority    Remote:ROLE_AutonomousProxy

Multicast: ServerOwned
LogInsider: Display: 947e6400    MyFunc2_NetMulticast_Validate   BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
LogInsider: Display: 947e6400    MyFunc2_NetMulticast_Implementation BP_Network_C_1  NM_ListenServer Local:ROLE_Authority    Remote:ROLE_SimulatedProxy
LogInsider: Display: 8795eb00    MyFunc2_NetMulticast_Validate   BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
LogInsider: Display: 8795eb00    MyFunc2_NetMulticast_Implementation BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
LogInsider: Display: 8f6a3700    MyFunc2_NetMulticast_Validate   BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority
LogInsider: Display: 8f6a3700    MyFunc2_NetMulticast_Implementation BP_Network_C_1  NM_Client   Local:ROLE_SimulatedProxy   Remote:ROLE_Authority

```

## åŸç†ï¼š

å¦‚æœåŠ ä¸ŠWithValidationæ ‡è®°ï¼Œåœ¨UHTç”Ÿæˆä»£ç çš„æ—¶å€™å°±ä¼šï¼š

```cpp
DEFINE_FUNCTION(AMyFunction_PlayerController::execMyFunc2_RunOnServer)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		if (!P_THIS->MyFunc2_RunOnServer_Validate())
		{
			RPC_ValidateFailed(TEXT("MyFunc2_RunOnServer_Validate"));
			return;
		}
		P_THIS->MyFunc2_RunOnServer_Implementation();
		P_NATIVE_END;
	}
	DEFINE_FUNCTION(AMyFunction_PlayerController::execMyFunc2_RunOnClient)
	{
		P_FINISH;
		P_NATIVE_BEGIN;
		if (!P_THIS->MyFunc2_RunOnClient_Validate())
		{
			RPC_ValidateFailed(TEXT("MyFunc2_RunOnClient_Validate"));
			return;
		}
		P_THIS->MyFunc2_RunOnClient_Implementation();
		P_NATIVE_END;
	}

DEFINE_FUNCTION(AMyFunction_Network::execMyFunc2_NetMulticast)
{
	P_FINISH;
	P_NATIVE_BEGIN;
	if (!P_THIS->MyFunc2_NetMulticast_Validate())
	{
		RPC_ValidateFailed(TEXT("MyFunc2_NetMulticast_Validate"));
		return;
	}
	P_THIS->MyFunc2_NetMulticast_Implementation();
	P_NATIVE_END;
}
```

# BlueprintInternalUseOnly

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡ç¤ºä¸åº”å‘æœ€ç»ˆç”¨æˆ·å…¬å¼€æ­¤å‡½æ•°ã€‚è“å›¾å†…éƒ¨è°ƒç”¨ï¼Œä¸æš´éœ²ç»™ç”¨æˆ·ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, UHT
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[BlueprintInternalUseOnly](../../../../Meta/Blueprint/BlueprintInternalUseOnly.md)ã€[BlueprintType](../../../../Meta/Blueprint/BlueprintType.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡ç¤ºä¸åº”å‘æœ€ç»ˆç”¨æˆ·å…¬å¼€æ­¤å‡½æ•°ã€‚è“å›¾å†…éƒ¨è°ƒç”¨ï¼Œä¸æš´éœ²ç»™ç”¨æˆ·ã€‚

ç­‰ä»·äºmetaé‡ŒåŠ ä¸ŠBlueprintInternalUseOnly = trueã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒBlueprintCallable/Pureçš„å‡½æ•°ä¼šç”ŸæˆUK2Node_CallFunctionæ¥è°ƒç”¨ã€‚ä½†BlueprintInternalUseOnlyé˜»æ­¢äº†è¿™ä¸€éƒ¨åˆ†ã€‚

å…¸å‹çš„ç”¨å¤„æœ‰äºŒï¼š

ä¸€æ˜¯åœ¨è“å›¾ä¸­éšè—è¯¥å‡½æ•°ï¼Œä½†å› ä¸ºè¯¥å‡½æ•°ä¾ç„¶æœ‰UFUNCTIONï¼Œå› æ­¤å¯ä»¥é€šè¿‡åå­—æ¥åå°„è°ƒç”¨è¯¥å‡½æ•°ã€‚è™½ç„¶è¯¥ç”¨æ³•æ¯”è¾ƒç¨€å°‘ï¼Œä½†ä¹Ÿç®—æ˜¯ä¸€ç§ç”¨å¤„ã€‚

äºŒæ˜¯å¼•æ“åœ¨åˆ«çš„åœ°æ–¹ä¼šä¸ºè¯¥å‡½æ•°å£°æ˜å»æŒ‰ç…§ç‰¹å®šçš„è§„åˆ™åˆ›å»ºå¦ä¸€ä¸ªè“å›¾å‡½æ•°èŠ‚ç‚¹ï¼Œå› æ­¤è¦éšè—æ‰æŒ‰ç…§é»˜è®¤è§„åˆ™åˆ›å»ºçš„è¿™ä¸ªã€‚è¿™ç§ç”¨æ³•å°±æ˜¯å¼•æ“æºç é‡Œå¤§é‡åœ¨ä½¿ç”¨çš„ç”¨æ³•ã€‚

## ç¤ºä¾‹ä»£ç 1ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyFunction_Internal :public AActor
{
public:
	GENERATED_BODY()
public:
	//(BlueprintInternalUseOnly = true, BlueprintType = true, ModuleRelativePath = Function/MyFunction_Internal.h)
	//FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable, BlueprintInternalUseOnly)
	void MyFunc_InternalOnly() {}

	//FunctionFlags:	FUNC_Final | FUNC_Native | FUNC_Public | FUNC_BlueprintCallable 
	UFUNCTION(BlueprintCallable)
	void MyFunc_Default() {}
};
```

åœ¨è“å›¾ä¸­åªæœ‰MyFunc_Defaultæ˜¯å¯ä»¥è°ƒç”¨çš„ã€‚å› æ­¤å¯ä»¥ç†è§£ä¸ºè¿™ä¸ªå‡½æ•°ä¾ç„¶æš´éœ²åˆ°è“å›¾ï¼Œä½†æ˜¯å´åˆè¢«éšè—èµ·æ¥äº†ã€‚ä¸èƒ½è®©ç”¨æˆ·è‡ªå·±ç›´æ¥è°ƒç”¨ï¼Œä½†æ˜¯å¯ä»¥åœ¨ä»£ç é‡Œé€šè¿‡æŸ¥æ‰¾å‡½æ•°åä¹‹ç±»çš„é—´æ¥å¯ä»¥è°ƒç”¨åˆ°ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\BlueprintInternalUseOnly\Untitled.png)

åœ¨æºç é‡Œæ‰¾åˆ°ä¸€ä¸ªç¤ºä¾‹ï¼Œå› æ­¤è¿™ä¸ªGetLevelScriptActorå‡½æ•°ï¼Œå¯ä»¥ä¸åœ¨è“å›¾ä¸­è¢«è°ƒç”¨ï¼Œä½†æ˜¯æœ‰å¯ä»¥é€šè¿‡åå­—æŸ¥æ‰¾åˆ°ã€‚æ–¹ä¾¿ç”Ÿæˆä¸€ä¸ªUFunctionä»¥è¢«æ³¨å…¥åˆ°åˆ«çš„åœ°æ–¹ä½œä¸ºcallback

```cpp
ULevelStreaming:
UFUNCTION(BlueprintPure, meta = (BlueprintInternalUseOnly = "true"))
ENGINE_API ALevelScriptActor* GetLevelScriptActor();

ç„¶åå‘ç°ï¼š
GetLevelScriptActorNode->SetFromFunction(ULevelStreaming::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(ULevelStreaming, GetLevelScriptActor)));
```

## ç¤ºä¾‹ä»£ç 2ï¼š

å®ç°ä»£ç å°±ä¸è´´äº†ï¼Œå¯ä»¥è‡ªå·±å»é¡¹ç›®é‡ŒæŸ¥çœ‹ã€‚

```cpp
UCLASS(Blueprintable, BlueprintType,meta = (ExposedAsyncProxy = MyAsyncObject,HasDedicatedAsyncNode))
class INSIDER_API UMyFunction_Async :public UCancellableAsyncAction
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Loop;

	UPROPERTY(BlueprintAssignable)
	FDelayOutputPin Complete;

	UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = "true", WorldContext = "WorldContextObject"), Category = "Flow Control")
	static UMyFunction_Async* DelayLoop(const UObject* WorldContextObject, const float DelayInSeconds, const int Iterations);

	virtual void Activate() override;

	UFUNCTION()
	static void Test();
private:
	const UObject* WorldContextObject = nullptr;
	float MyDelay = 0.f;
	int MyIterations = 0;
	bool Active = false;

	UFUNCTION()
	void ExecuteLoop();

	UFUNCTION()
	void ExecuteComplete();
};

```

## ç¤ºä¾‹æ•ˆæœï¼š

å‡å¦‚æ³¨é‡Šæ‰ä¸Šè¿°æºç çš„BlueprintInternalUseOnly ï¼Œä¼šå‘ç°åœ¨è“å›¾é‡Œå¯ä»¥æœ‰ä¸¤ä¸ªDelayLoopã€‚ä¸Šé¢çš„ä¸€ä¸ªæ˜¯æŒ‰UBlueprintAsyncActionBaseè§„åˆ™ç”Ÿæˆçš„ï¼Œç¬¬äºŒä¸ªæ˜¯æŒ‰æ™®é€šçš„è“å›¾å‡½æ•°è§„åˆ™ç”Ÿæˆçš„ã€‚æ˜æ˜¾è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¹¶ä¸æƒ³åŒæ—¶å‡ºç°ä¸¤ä¸ªæ¥ç»™ç”¨æˆ·é€ æˆå›°æƒ‘ã€‚å› æ­¤è¦åŠ ä¸ŠBlueprintInternalUseOnly æ¥é˜»æ­¢ç”Ÿæˆé»˜è®¤çš„è“å›¾èŠ‚ç‚¹ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\BlueprintInternalUseOnly\Untitled%201.png)

## åŸç†ï¼š

å…³äºUBlueprintAsyncActionBaseçš„ä½¿ç”¨ï¼ŒUK2Node_BaseAsyncTaskçš„å‡½æ•°å®ç°é‡Œä½“ç°äº†ä¹¦å†™ç»§æ‰¿äºUBlueprintAsyncActionBaseçš„è§„åˆ™ï¼Œç®€å•æ¥è¯´å°±æ˜¯é€šè¿‡static å‡½æ•°æ¥å½“ä½œFactory functionï¼Œç„¶ååˆ†æè¿™ä¸ªProxyç±»çš„Delegate propertyæ¥å½“ä½œPinã€‚

å¦‚æœä¸åŠ BlueprintInternalUseOnly = "trueâ€ï¼Œåˆ™ä¼šç”Ÿæˆä¸¤ä¸ªå‡½æ•°ã€‚ä¸‹é¢é‚£ä¸ªæ˜¯æ™®é€šstaticå‡½æ•°çš„ç”Ÿæˆã€‚ä¸Šé¢é‚£ä¸ªæ˜¯åˆ†æUBlueprintAsyncActionBaseç”Ÿæˆçš„å‡½æ•°ã€‚

å…¶ä¸­è¯†åˆ«UBlueprintAsyncActionBaseé‡Œé¢staticå‡½æ•°ä½œä¸ºFactoryFunctionçš„æµç¨‹æ˜¯ï¼ŒBlueprintActionDatabaseImpl::GetNodeSpecificActionsä¼šè§¦å‘UK2Node_AsyncAction::GetMenuActionsï¼Œä»è€ŒActionRegistrar.RegisterClassFactoryActionsï¼Œå†…éƒ¨å†åˆ¤æ–­RegisterClassFactoryActions_Utils::IsFactoryMethod(Function, UBlueprintAsyncActionBase)ä¼šé€šè¿‡ï¼ˆåˆ¤æ–­æ˜¯staticå‡½æ•°ï¼Œå¹¶ä¸”è¿”å›ç±»å‹æ˜¯UBlueprintAsyncActionBaseçš„å­ç±»å¯¹è±¡ï¼‰ï¼Œç»§è€Œç»§ç»­é€šè¿‡å›è°ƒUBlueprintFunctionNodeSpawner::Create(FactoryFunc);åˆ›å»ºä¸€ä¸ªå·¥å‚æ–¹æ³•çš„nodeSpawnerã€‚

å› æ­¤æ€»ç»“ï¼Œæ­¤æ—¶çš„BlueprintInternalUseOnly å°±æ˜¯éšè—æ‰é»˜è®¤ç”Ÿæˆçš„é‚£ä¸ªã€‚

# CustomThunk

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šUHTä¸ä¸ºè¯¥å‡½æ•°ç”Ÿæˆè“å›¾è°ƒç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œè€Œéœ€è¦ç”¨æˆ·è‡ªå®šä¹‰ç¼–å†™ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[CustomThunk](../../../../Meta/UHT/CustomThunk.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šUHTä¸ä¸ºè¯¥å‡½æ•°ç”Ÿæˆè“å›¾è°ƒç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œè€Œéœ€è¦ç”¨æˆ·è‡ªå®šä¹‰ç¼–å†™ã€‚

è¿™é‡ŒThunkçš„æ„æ€å°±æ˜¯ç±»ä¼¼execFooçš„å‡½æ•°ï¼Œéœ€è¦ç”¨æˆ·è‡ªå·±å®šä¹‰ã€‚

CustomThunkä¸€èˆ¬æ˜¯ç”¨äºé…åˆå‡½æ•°å‚æ•°ä¸å®šçš„æƒ…å†µï¼Œå¦‚å„ç§é€šé…ç¬¦ï¼Œæˆ–è€…éœ€è¦è‡ªå·±æ›´ç»†è‡´çš„è‡ªå®šä¹‰çš„é€»è¾‘å¤„ç†ã€‚

## æµ‹è¯•ä»£ç ï¼›

```cpp
UFUNCTION(BlueprintPure, CustomThunk)
static int32 MyFunc_CustomDivide(int32 A, int32 B = 1);

DECLARE_FUNCTION(execMyFunc_CustomDivide);

int32 UMyFunction_Custom::MyFunc_CustomDivide(int32 A, int32 B /*= 1*/)
{
	return 1;
}

DEFINE_FUNCTION(UMyFunction_Custom::execMyFunc_CustomDivide)
{
	P_GET_PROPERTY(FIntProperty, A);
	P_GET_PROPERTY(FIntProperty, B);

	P_FINISH;

	if (B == 0)
	{
		FFrame::KismetExecutionMessage(*FString::Printf(TEXT("Modulo by zero detected: %d %% 0\n%s"), A, *Stack.GetStackTrace()), ELogVerbosity::Warning);
		*(int32*)RESULT_PARAM = 0;
		return;
	}

	*(int32*)RESULT_PARAM = A/B;
}
```

## è“å›¾æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\CustomThunk\Untitled.png)

å¯ä»¥çœ‹åˆ°ï¼Œå³ä½¿æ˜¯ç”¨é™¤ä»¥0ï¼Œå¯ä»¥è‡ªå®šä¹‰æŠ¥é”™ä¿¡æ¯ã€‚

æœ€é‡è¦çš„æ˜¯å¦‚æœè§‚å¯Ÿ.gen.cppï¼Œå¯ä»¥å¯¹æ¯”å‘ç°å†…éƒ¨ä¸å†ç”ŸæˆexecFooçš„å‡½æ•°ã€‚

# FieldNotify

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºè¯¥å‡½æ•°åˆ›å»ºä¸€ä¸ªFieldNotifyçš„ç»‘å®šç‚¹ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** UHT
- **é™åˆ¶ç±»å‹ï¼š** ViewModelé‡Œçš„å‡½æ•°
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºè¯¥å‡½æ•°åˆ›å»ºä¸€ä¸ªFieldNotifyçš„ç»‘å®šç‚¹ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ˜¯Getå‡½æ•°åˆ™å…¶è¿”å›å€¼æ”¹å˜çš„æ—¶å€™ï¼Œéœ€è¦åœ¨åˆ«çš„è§¦å‘æ”¹å˜çš„åœ°æ–¹æ‰‹åŠ¨å¹¿æ’­äº‹ä»¶ã€‚æ­£å¦‚ä¸‹é¢çš„ä»£ç UE_MVVM_BROADCAST_FIELD_VALUE_CHANGED(GetHPPercent);æ‰€åšçš„ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyViewModel :public UMVVMViewModelBase
{
	GENERATED_BODY()
protected:
	UPROPERTY(BlueprintReadWrite, FieldNotify, Getter, Setter, BlueprintSetter = SetHP)
	float HP = 1.f;

	UPROPERTY(BlueprintReadWrite, FieldNotify, Getter, Setter, BlueprintSetter = SetMaxHP)
	float MaxHP = 100.f;
public:
	float GetHP()const { return HP; }
	UFUNCTION(BlueprintSetter)
	void SetHP(float val)
	{
		if (UE_MVVM_SET_PROPERTY_VALUE(HP, val))
		{
			UE_MVVM_BROADCAST_FIELD_VALUE_CHANGED(GetHPPercent);
		}
	}

	float GetMaxHP()const { return MaxHP; }
	UFUNCTION(BlueprintSetter)
	void SetMaxHP(float val)
	{
		if (UE_MVVM_SET_PROPERTY_VALUE(MaxHP, val))
		{
			UE_MVVM_BROADCAST_FIELD_VALUE_CHANGED(GetHPPercent);
		}
	}

	//You need to manually notify that GetHealthPercent changed when CurrentHealth or MaxHealth changed.
	UFUNCTION(BlueprintPure, FieldNotify)
	float GetHPPercent() const
	{
		return (MaxHP != 0.f) ? HP / MaxHP : 0.f;
	}
};

```

## æµ‹è¯•æ•ˆæœï¼š

å¯è§GetHPPercentæœ‰ç”Ÿæˆä¸€ä¸ªFIELDã€‚

```cpp
//MyViewModel.generated.h
#define FID_GitWorkspace_Hello_Source_Insider_Property_MVVM_MyViewModel_h_12_FIELDNOTIFY \
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_BEGIN(INSIDER_API ) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(HP) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(MaxHP) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(GetHPPercent) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_BEGIN(HP) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(MaxHP) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(GetHPPercent) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_END() \
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_END();
//MyViewModel.gen.cpp
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, HP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, MaxHP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, GetHPPercent)
	UE_FIELD_NOTIFICATION_IMPLEMENTATION_BEGIN(UMyViewModel)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, HP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, MaxHP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, GetHPPercent)
	UE_FIELD_NOTIFICATION_IMPLEMENTATION_END(UMyViewModel);
```

## è“å›¾æ•ˆæœï¼š

è¿›åº¦æ¡å¯ä»¥ç»‘å®šåˆ°GetHPPercentã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\FieldNotify\Untitled.png)

# Variadic

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è¯†ä¸€ä¸ªå‡½æ•°å¯ä»¥æ¥å—ä»»æ„ç±»å‹çš„å¤šä¸ªå‚æ•°ï¼ˆåŒ…æ‹¬input/output)ï¼

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, UHT
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[Variadic](../../../../Meta/Blueprint/Variadic.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æ ‡è¯†ä¸€ä¸ªå‡½æ•°å¯ä»¥æ¥å—ä»»æ„ç±»å‹çš„å¤šä¸ªå‚æ•°ï¼ˆåŒ…æ‹¬input/output)ï¼

åœ¨æºç ä¸­æœç´¢åº”ç”¨ï¼šç„¶åé…åˆUK2Node_ExecutePythonScript

```cpp
UFUNCTION(BlueprintCallable, CustomThunk, Category = "Python|Execution", meta=(Variadic, BlueprintInternalUseOnly="true"))
    static bool ExecutePythonScript(UPARAM(meta=(MultiLine=True)) const FString& PythonScript, const TArray<FString>& PythonInputs, const TArray<FString>& PythonOutputs);
	DECLARE_FUNCTION(execExecutePythonScript);
```

è“å›¾çš„æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\Variadic\Untitled.png)

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyFunction_Variadic : public UBlueprintFunctionLibrary
{
public:
	GENERATED_BODY()
public:
	/*
			[PrintVariadicFields	Function->Struct->Field->Object	/Script/Insider.MyFunction_Variadic:PrintVariadicFields]
			(BlueprintInternalUseOnly = true, BlueprintType = true, CustomThunk = true, ModuleRelativePath = Function/Variadic/MyFunction_Variadic.h, Variadic = )
	*/
	UFUNCTION(BlueprintCallable, CustomThunk, BlueprintInternalUseOnly, meta = (Variadic))
	static FString PrintVariadicFields(const TArray<FString>& Inputs, const TArray<FString>& Outputs);
	DECLARE_FUNCTION(execPrintVariadicFields);
};

FString UMyFunction_Variadic::PrintVariadicFields(const TArray<FString>& Inputs, const TArray<FString>& Outputs)
{
	check(0);
	return TEXT("");
}

DEFINE_FUNCTION(UMyFunction_Variadic::execPrintVariadicFields)
{
	FString str;

	P_GET_TARRAY_REF(FString, Inputs);
	P_GET_TARRAY_REF(FString, Outputs);

	for (const FString& PythonInput : Inputs)
	{
		Stack.MostRecentPropertyAddress = nullptr;
		Stack.MostRecentProperty = nullptr;
		Stack.StepCompiledIn<FProperty>(nullptr);
		check(Stack.MostRecentProperty && Stack.MostRecentPropertyAddress);

		FProperty* p = CastField<FProperty>(Stack.MostRecentProperty);

		FString propertyValueString;
		const void* propertyValuePtr = p->ContainerPtrToValuePtr<const void*>(Stack.MostRecentPropertyContainer);

		p->ExportTextItem_Direct(propertyValueString, propertyValuePtr, nullptr, nullptr, PPF_None);

		str += FString::Printf(TEXT("%s:%s\n"), *p->GetFName().ToString(), *propertyValueString);

	}
	P_FINISH;

	*(FString*)RESULT_PARAM = str;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\Variadic\Untitled%201.png)

æ‰“å°ï¼š

CallFunc_MakeVector_ReturnValue:(X=1.000000,Y=2.000000,Z=3.000000)
CallFunc_MakeLiteralDouble_ReturnValue:456.000000

## åŸç†ï¼š

æ™®é€šçš„CustomThunkå‡½æ•°è¿˜æœ‰ä¸€äº›é™åˆ¶ï¼Œå‚æ•°åå­—å’Œä¸ªæ•°æ˜¯åœ¨UFuntioné‡Œå†™æ­»çš„ï¼Œä¸èƒ½æ”¯æŒåŠ¨æ€çš„ä¸ªæ•°ã€‚

ç›®å‰ï¼Œæƒ³ä½¿ç”¨**Variadic**åŠŸèƒ½ï¼Œéœ€è¦è‡ªå®šä¹‰è“å›¾èŠ‚ç‚¹ç”¨C++æ¥ä¸º**K2Node_CallFunction**æ·»åŠ å¼•è„šã€‚

æƒ³å¿…æ˜¯æƒ³è¦å¼€å‘æ¥åŒæ—¶å®ç°**K2Node**ä»¥åŠå¯¹åº”çš„**CustomThunk**+**Variadic**æ–¹æ³•ï¼Œæ¥ä¿è¯ä½¿ç”¨ä¸Šçš„å®‰å…¨æ€§ã€‚

BlueprintInternalUseOnlyä¹Ÿè¦åŠ ä¸Šï¼Œå¦åˆ™ä¼šè‡ªåŠ¨ç”Ÿæˆæ™®é€šçš„è“å›¾å‡½æ•°ï¼Œè¾¾ä¸åˆ°variadicçš„æ•ˆæœã€‚

ä»¥ä¸‹æ˜¯ä¸åŠ BlueprintInternalUseOnlyè‡ªåŠ¨ç”Ÿæˆçš„ç‰ˆæœ¬:

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\Variadic\Untitled%202.png)

å®é™…åº”è¯¥æ˜¯ï¼šç„¶åå†æ‰‹åŠ¨æ·»åŠ å‚æ•°ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\Variadic\Untitled%203.png)

å’Œï¼·ildcardçš„åŒºåˆ«æ˜¯ï¼Œï¼·ildcardçš„å‚æ•°æ˜¯ä»»æ„ç±»å‹çš„ï¼Œä½†ä¸ªæ•°æ˜¯å›ºå®šå¥½çš„ï¼

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UFUNCTION\UHT\Variadic\Untitled%204.png)

å®˜æ–¹æ·»åŠ çš„å’Œ**Python**äº¤äº’çš„åŠŸèƒ½Â [Added a Blueprint node for calling Python with args](https://link.zhihu.com/?target=https%3A//github.com/EpicGames/UnrealEngine/commit/61d0f65e1cded45ed94f0422eb931f446888e972)

å®˜æ–¹çš„æäº¤ï¼š

[https://github.com/EpicGames/UnrealEngine/commit/61d0f65e1cded45ed94f0422eb931f446888e972](https://github.com/EpicGames/UnrealEngine/commit/61d0f65e1cded45ed94f0422eb931f446888e972)

## æ³¨é‡Šï¼š

Implemented variadic function support for Blueprints

`Variadic functions are required to be a CustomThunk marked with the "Variadic" meta-data. They can then be used from a custom Blueprint node to accept arbitrary arguments at the end of their parameter list (any extra pins added to the node that aren't part of the main function definition will become the variadic payload).

Variadic arguments aren't type checked, so you need other function input to tell you how many to expect, and for a nativizied function, also what type of arguments you're dealing with.

#jira UE-84932
#rb Dan.OConnor

[CL 10421401 by Jamie Dale in Dev-Editor branch]`

# Const

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å‡½æ•°å‚æ•°ä¸å¯æ›´æ”¹
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Parameter
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_ConstParm](../../../../Flags/EPropertyFlags/CPF_ConstParm.md)ï¼Œåœ¨Metaä¸­åŠ å…¥[NativeConst](../../../../Meta/Blueprint/NativeConst.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

æŒ‡å®šè¯¥å‡½æ•°å‚æ•°ä¸å¯æ›´æ”¹ã€‚

å¦‚æœåœ¨C++ä»£ç çš„å‚æ•°ä¸Šç›´æ¥åŠ constï¼Œåˆ™ä¼šè‡ªåŠ¨çš„è¢«UHTè¯†åˆ«å¹¶æ·»åŠ CPF_ConstParm æ ‡å¿—ï¼Œä»¥åŠNativeConstå…ƒæ•°æ®ã€‚ä½†ä¹Ÿå¯ä»¥æ‰‹åŠ¨åŠ ä¸ŠUPARAM(const)æ¥å¼ºåˆ¶UHTæ·»åŠ CPF_ConstParmï¼Œæ•ˆæœè§ä¸‹é¢è“å›¾ä¸­çš„OutèŠ‚ç‚¹ï¼ŒæŠŠè¾“å‡ºå‚æ•°å˜æˆäº†è¾“å…¥å‚æ•°ã€‚

è™½ç„¶ä¸çŸ¥é“ä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼Œå› æ­¤åœ¨æºç ä¸­æ²¡æœ‰æ‰¾åˆ°å®é™…çš„ç”¨ä¾‹ã€‚èƒ½æƒ³åˆ°çš„ç”¨å¤„æ˜¯åœ¨è“å›¾å±‚é¢ä½¿å®ƒå˜æˆconstè¾“å…¥å‚æ•°ï¼Œä½†æ˜¯åœ¨C++å±‚é¢ä¾ç„¶æ˜¯å¯å˜çš„å¼•ç”¨å‚æ•°ï¼Œæ–¹ä¾¿åœ¨C++é‡Œè°ƒç”¨ä¸€äº›éconstçš„æ–¹æ³•ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//PropertyFlags:	CPF_ConstParm | CPF_Parm | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_ConstInt(UPARAM(const) int value);

	//PropertyFlags:	CPF_ConstParm | CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReferenceParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_ConstIntOut(UPARAM(const) int& value);

	//(NativeConst = )
	//PropertyFlags:	CPF_ConstParm | CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReferenceParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_ConstIntRef(UPARAM(const) const int& value);

	//PropertyFlags:	CPF_Parm | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_NoConstInt(int value);

	//PropertyFlags:	CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_NoConstIntOut(int& value);

	//(NativeConst = )
	//PropertyFlags:	CPF_ConstParm | CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReferenceParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_NoConstIntRef(const int& value);
```

## è“å›¾èŠ‚ç‚¹ï¼š

MyFuncTestParam_ConstIntOutçš„è¾“å‡ºValueå˜æˆäº†è¾“å…¥çš„Valueï¼Œå› ä¸ºä¸èƒ½æ”¹å˜ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPARAM\Blueprint\Const\Untitled.png)

## åŸç†ä»£ç ï¼š

åœ¨ä»£ç ä¸­å®é™…å‡ºç°constï¼Œå°±ä¼šå¢åŠ CPF_ConstParam Flagã€‚

```cpp
\Engine\Source\Programs\Shared\EpicGames.UHT\Parsers\UhtPropertyParser.cs 1030

if (propertySettings.PropertyCategory != UhtPropertyCategory.Member && !isTemplateArgument)
{
	// const before the variable type support (only for params)
	if (tokenReader.TryOptional("const"))
	{
		propertySettings.PropertyFlags |= EPropertyFlags.ConstParm;
		propertySettings.MetaData.Add(UhtNames.NativeConst, "");
	}
}
```

# DisplayName

- **åŠŸèƒ½æè¿°ï¼š** æ›´æ”¹å‡½æ•°å‚æ•°åœ¨è“å›¾èŠ‚ç‚¹ä¸Šçš„æ˜¾ç¤ºåå­—

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Parameter
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[DisplayName](../../../../Meta/Blueprint/DisplayName.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æ³¨æ„ï¼šUPARAMä¹Ÿå¯ä»¥ç”¨åœ¨è¿”å›å€¼ä¸Šï¼Œé»˜è®¤å€¼æ˜¯ReturnValueã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//(DisplayName = My Other Name)
	UFUNCTION(BlueprintCallable)
	UPARAM(DisplayName = "My Return String") FString MyFuncTestParam_DisplayName(UPARAM(DisplayName = "My Other Name") int value);
```

## è“å›¾èŠ‚ç‚¹ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPARAM\Blueprint\DisplayName\Untitled.png)

# ref

- **åŠŸèƒ½æè¿°ï¼š** ä½¿å¾—å‡½æ•°çš„å‚æ•°å˜æˆå¼•ç”¨ç±»å‹

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Parameter
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_ReferenceParm](../../../../Flags/EPropertyFlags/CPF_ReferenceParm.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æ™®é€šå‚æ•°å’Œå¼•ç”¨å‚æ•°çš„åŒºåˆ«æ˜¯ï¼Œåœ¨è·å–å‚æ•°çš„æ—¶å€™ï¼ŒRefç±»å‹ä¼šç›´æ¥è·å¾—å®å‚çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯æ‹·è´ã€‚è¿™æ ·å°±å¯ä»¥é¿å…æ‹·è´ï¼Œä¿å­˜ä¿®æ”¹ã€‚

å•çº¯çš„&å‚æ•°æ˜¯ä¼šè¢«è§£ææˆè¾“å‡ºè¿”å›å‚æ•°ï¼Œå› æ­¤è¦ç”¨refå†ç»§ç»­æ ‡æ˜ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//PropertyFlags:	CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_Default(int& refValue);

	//PropertyFlags:	CPF_Parm | CPF_OutParm | CPF_ZeroConstructor | CPF_ReferenceParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_Ref(UPARAM(ref) int& refValue);

	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_Copy(int value);
```

## è“å›¾çš„ä»£ç ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPARAM\Blueprint\ref\Untitled.png)

## åŸç†ï¼š

refå‚æ•°åœ¨UHTç”Ÿæˆæ—¶ä¼šç”¨P_GET_PROPERTY_REFæ¥è·å¾—

```cpp
#define P_GET_PROPERTY(PropertyType, ParamName)													\
	PropertyType::TCppType ParamName = PropertyType::GetDefaultPropertyValue();					\
	Stack.StepCompiledIn<PropertyType>(&ParamName);

#define P_GET_PROPERTY_REF(PropertyType, ParamName)												\
	PropertyType::TCppType ParamName##Temp = PropertyType::GetDefaultPropertyValue();			\
	PropertyType::TCppType& ParamName = Stack.StepCompiledInRef<PropertyType, PropertyType::TCppType>(&ParamName##Temp);
```

# Required

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå‡½æ•°çš„å‚æ•°èŠ‚ç‚¹å¿…é¡»è¿æ¥æä¾›ä¸€ä¸ªå€¼

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Parameter
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_RequiredParm](../../../../Flags/EPropertyFlags/CPF_RequiredParm.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šå‡½æ•°çš„å‚æ•°èŠ‚ç‚¹å¿…é¡»è¿æ¥ä¸ªå˜é‡æ¥æä¾›ä¸€ä¸ªå€¼ã€‚

å¦‚æœå‚æ•°ä¸Šæœ‰æä¾›é»˜è®¤å€¼ï¼Œè¯¥æ ‡å¿—ä¾ç„¶ä¼šå¿½ç•¥é»˜è®¤å€¼ï¼Œè®¤ä¸ºè¿˜æ˜¯æ²¡æä¾›å€¼ã€‚è¿˜æ˜¯å¿…é¡»è¦è¿æ¥å˜é‡ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
//PropertyFlags:	CPF_Parm | CPF_ZeroConstructor | CPF_RequiredParm | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_RequiredObject(UPARAM(Required) UObject* objValue);

	//(CPP_Default_intValue = 123, ModuleRelativePath = Function/Param/MyFunction_TestParam.h)
	//PropertyFlags:	CPF_Parm | CPF_ZeroConstructor | CPF_RequiredParm | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UFUNCTION(BlueprintCallable)
	FString MyFuncTestParam_RequiredInt(UPARAM(Required) int intValue=123);
```

## è“å›¾èŠ‚ç‚¹ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPARAM\Blueprint\Required\Untitled.png)

å¦‚æœä¸è¿ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼š

Pin  Int Value  must be linked to another node (in  My Func Test Param Required Int )
Pin  Obj Value  must be linked to another node (in  My Func Test Param Required Object )

## åŸç†ï¼š

æ ¹æ®è¿™ä¸ªæ ‡è®°æ¥åˆ¤æ–­ã€‚

```cpp
const bool bIsRequiredParam = Param->HasAnyPropertyFlags(CPF_RequiredParm);
	// Don't let the user edit the default value if the parameter is required to be explicit.
	Pin->bDefaultValueIsIgnored |= bIsRequiredParam;
```

# NotReplicated

- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Network, Parameter
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_RepSkip](../../../Flags/EPropertyFlags/CPF_RepSkip.md)

å‚ç…§UFUNCTIONçš„ServiceRequestï¼Œè¯¥æ ‡è¯†ç¬¦å¼ƒç”¨ã€‚

â€œOnly parameters in service request functions can be marked NotReplicatedâ€

```cpp
if (context.PropertySettings.PropertyCategory == UhtPropertyCategory.ReplicatedParameter)
			{
				context.PropertySettings.PropertyCategory = UhtPropertyCategory.RegularParameter;
				context.PropertySettings.PropertyFlags |= EPropertyFlags.RepSkip;
			}
			else
			{
				context.MessageSite.LogError("Only parameters in service request functions can be marked NotReplicated");
			}
```

æºç é‡ŒåªçŸ¥é“

```cpp
// Currently some features such as not replicating all parameters isn't allowed on regular RPCs
UFUNCTION(ServiceRequest(Iris))
void FunctionWithNotReplicatedNonPODParameters(int Param0, bool Param1, int Param2, UPARAM(NotReplicated) const TArray<FTestReplicationStateDescriptor_TestStructWithRefCArray>& NotReplicatedParam3);
void FunctionWithNotReplicatedNonPODParameters_Implementation(int Param0, bool Param1, int Param2, UPARAM(NotReplicated) const TArray<FTestReplicationStateDescriptor_TestStructWithRefCArray>& NotReplicatedParam3);
```

# AssetRegistrySearchable

- **åŠŸèƒ½æè¿°ï¼š** æ ‡è®°è¯¥å±æ€§å¯ä»¥ä½œä¸ºAssetRegistryçš„Tagå’ŒValueå€¼æ¥è¿›è¡Œèµ„äº§çš„è¿‡æ»¤æœç´¢
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Asset
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_AssetRegistrySearchable](../../../../Flags/EPropertyFlags/CPF_AssetRegistrySearchable.md)ï¼Œåœ¨Metaä¸­åŠ å…¥[RequiredAssetDataTags](../../../../Meta/Asset/RequiredAssetDataTags/RequiredAssetDataTags.md)ã€[DisallowedAssetDataTags](../../../../Meta/Asset/DisallowedAssetDataTags.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸èƒ½ç”¨åœ¨ç»“æ„å±æ€§ä¸Šã€‚

å­ç±»ä¹Ÿå¯ä»¥é‡è½½GetAssetRegistryTagsä»¥æä¾›è‡ªå®šä¹‰çš„Tagã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_AssetRegistrySearchable :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, AssetRegistrySearchable, Category = DataRegistry)
		FString MyIdForSearch;
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 OtherValue = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = DataRegistry)
		FString MyOtherIdForSearch;
public:
	virtual void GetAssetRegistryTags(FAssetRegistryTagsContext Context) const override
	{
		//called on CDO and instances
		Super::GetAssetRegistryTags(Context);
		Context.AddTag(FAssetRegistryTag(TEXT("MyOtherId"),MyOtherIdForSearch, UObject::FAssetRegistryTag::TT_Alphabetical));
	}
};

```

## æµ‹è¯•ç»“æœï¼š

åœ¨EditorUtilityWidgetä¸­æµ‹è¯•ï¼Œå¯è§ListAssetByTagValueéƒ½å¯ä»¥æœç´¢æ‰¾åˆ°è¯¥Assetã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Asset\AssetRegistrySearchable\Untitled.png)

æµ‹è¯•çš„è“å›¾ä»£ç ï¼Œä¹Ÿå¯ç”¨IAssetRegistry::Get()->GetAssetsByTagValues(tagValues,outAssets);æ¥è¿›è¡Œæœç´¢ï¼Œä¸è¿‡è¦æ³¨æ„æœç´¢çš„æ—¶æœºè¦åœ¨AssetRegistryåŠ è½½ä¹‹åï¼ŒAssetRegistryå¦‚æœæ˜¯Runtimeè¦è®°å¾—åºåˆ—åŒ–åˆ°ç£ç›˜

```cpp
//DefaultEngine.ini
[AssetRegistry]
bSerializeAssetRegistry=true
```

## åŸç†ï¼š

å¯æŸ¥çœ‹GetAssetRegistryTagsçš„å‡½æ•°çš„å®ç°å’Œè°ƒç”¨ã€‚åœ¨UObject::GetAssetRegistryTagsä¸­è°ƒç”¨ä½¿ç”¨ï¼ŒæŠŠè¯¥å±æ€§çš„å€¼ä½œä¸ºAssetDataçš„Tagä¾›ç»™AssetRegistry

# Localized

- **åŠŸèƒ½æè¿°ï¼š** æ­¤å±æ€§çš„å€¼å°†æ‹¥æœ‰ä¸€ä¸ªå®šä¹‰çš„æœ¬åœ°åŒ–å€¼ã€‚å¤šç”¨äºå­—ç¬¦ä¸²ã€‚æš—ç¤ºä¸º ReadOnlyã€‚è¯¥å€¼æœ‰ä¸€ä¸ªæœ¬åœ°åŒ–å€¼ã€‚æœ€å¸¸æ ‡è®°åœ¨stringä¸Š
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Behavior
- **é™åˆ¶ç±»å‹ï¼š** FString

# BlueprintAssignable

- **åŠŸèƒ½æè¿°ï¼š** åœ¨è“å›¾ä¸­å¯ä»¥ä¸ºè¿™ä¸ªå¤šæ’­å§”æ‰˜ç»‘å®šäº‹ä»¶

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **é™åˆ¶ç±»å‹ï¼š** Multicast Delegates
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintAssignable](../../../../Flags/EPropertyFlags/CPF_BlueprintAssignable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

## C++çš„æµ‹è¯•ä»£ç ï¼š

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMyDynamicMulticastDelegate_One, int32, Value);

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable, BlueprintCallable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateAssignAndCall;

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintCallable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateCall;

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateAssign;

UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FMyDynamicMulticastDelegate_One MyMulticastDelegate;

```

## è“å›¾ä¸­çš„è¡¨ç°ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintAssignable\Untitled.png)

å› æ­¤ä¸€èˆ¬å»ºè®®äºŒè€…æ ‡è®°éƒ½åŠ ä¸Šï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintAssignable\Untitled%201.png)

# BlueprintAuthorityOnly

- **åŠŸèƒ½æè¿°ï¼š** åªèƒ½ç»‘å®šä¸ºBlueprintAuthorityOnlyçš„äº‹ä»¶ï¼Œè®©è¯¥å¤šæ’­å§”æ‰˜åªæ¥å—åœ¨æœåŠ¡ç«¯è¿è¡Œçš„äº‹ä»¶

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint, Network
- **é™åˆ¶ç±»å‹ï¼š** Multicast Delegates
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintAuthorityOnly](../../../../Flags/EPropertyFlags/CPF_BlueprintAuthorityOnly.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

## æµ‹è¯•ä»£ç ï¼š

```cpp
UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable, BlueprintCallable)
		FMyDynamicMulticastDelegate_One MyMulticastDelegateAssignAndCall;

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable, BlueprintCallable, BlueprintAuthorityOnly)
		FMyDynamicMulticastDelegate_One MyMulticastDelegateAuthorityOnly;
```

## è“å›¾ä¸­è¡¨ç°ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintAuthorityOnly\Untitled.png)

# BlueprintCallable

- **åŠŸèƒ½æè¿°ï¼š** åœ¨è“å›¾ä¸­å¯ä»¥è°ƒç”¨è¿™ä¸ªå¤šæ’­å§”æ‰˜

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **é™åˆ¶ç±»å‹ï¼š** Multicast Delegates
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintCallable](../../../../Flags/EPropertyFlags/CPF_BlueprintCallable.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨è“å›¾ä¸­å¯ä»¥è°ƒç”¨è¿™ä¸ªå¤šæ’­å§”æ‰˜ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMyDynamicMulticastDelegate_One, int32, Value);

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable, BlueprintCallable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateAssignAndCall;

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintCallable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateCall;

UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable)
	FMyDynamicMulticastDelegate_One MyMulticastDelegateAssign;

UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FMyDynamicMulticastDelegate_One MyMulticastDelegate;
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintCallable\Untitled.png)

æ³¨æ„BlueprintAssignableå’ŒBlueprintCallableåªèƒ½ç”¨äºå¤šæ’­å§”æ‰˜ï¼š

```cpp
DECLARE_DYNAMIC_DELEGATE_OneParam(FMyDynamicSinglecastDelegate_One, int32, Value);

//ç¼–è¯‘æŠ¥é”™ï¼š'BlueprintCallable' is only allowed on a property when it is a multicast delegate
UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintCallable)
	FMyDynamicSinglecastDelegate_One MyMyDelegate4;

	//ç¼–è¯‘æŠ¥é”™ï¼š'BlueprintAssignable' is only allowed on a property when it is a multicast delegate
UPROPERTY(EditAnywhere, BlueprintReadWrite, BlueprintAssignable)
	FMyDynamicSinglecastDelegate_One MyMyDelegate5;
```

# BlueprintGetter

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºå±æ€§å®šä¹‰ä¸€ä¸ªè‡ªå®šä¹‰çš„Getå‡½æ•°æ¥è¯»å–ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintReadOnly](../../../../Flags/EPropertyFlags/CPF_BlueprintReadOnly.md)ã€[CPF_BlueprintVisible](../../../../Flags/EPropertyFlags/CPF_BlueprintVisible.md)ï¼Œåœ¨Metaä¸­åŠ å…¥[BlueprintGetter](../../../../Meta/Blueprint/BlueprintGetter.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºå±æ€§å®šä¹‰ä¸€ä¸ªè‡ªå®šä¹‰çš„Getå‡½æ•°æ¥è¯»å–ã€‚
å¦‚æœæ²¡æœ‰è®¾ç½®BlueprintSetteræˆ–BlueprintReadWriteï¼Œåˆ™ä¼šé»˜è®¤è®¾ç½®BlueprintReadOnlyï¼Œè¿™ä¸ªå±æ€§å˜æˆåªè¯»çš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
public:
	//(BlueprintGetter = , Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	UFUNCTION(BlueprintGetter, Category = Blueprint)	//or BlueprintPure
		int32 MyInt_Getter()const { return MyInt_WithGetter * 2; }

	//(BlueprintSetter = , Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	UFUNCTION(BlueprintSetter, Category = Blueprint)	//or BlueprintCallable
		void MyInt_Setter(int NewValue) { MyInt_WithSetter = NewValue / 4; }
private:
	//(BlueprintGetter = MyInt_Getter, Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	//PropertyFlags:	CPF_BlueprintVisible | CPF_BlueprintReadOnly | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	UPROPERTY(BlueprintGetter = MyInt_Getter, Category = Blueprint)
		int32 MyInt_WithGetter = 123;

	//(BlueprintSetter = MyInt_Setter, Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	//PropertyFlags:	CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	UPROPERTY(BlueprintSetter = MyInt_Setter, Category = Blueprint)
		int32 MyInt_WithSetter = 123;
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯è§MyInt_WithGetteræ˜¯åªè¯»çš„ã€‚

è€ŒMyInt_WithSetter æ˜¯å¯è¯»å†™çš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintGetter\Untitled.png)

# BlueprintReadOnly

- **åŠŸèƒ½æè¿°ï¼š** æ­¤å±æ€§å¯ç”±è“å›¾è¯»å–ï¼Œä½†ä¸èƒ½è¢«ä¿®æ”¹ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintVisible](../../../../Flags/EPropertyFlags/CPF_BlueprintVisible.md), [CPF_BlueprintReadOnly](../../../../Flags/EPropertyFlags/CPF_BlueprintReadOnly.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

æ­¤å±æ€§å¯ç”±è“å›¾è¯»å–ï¼Œä½†ä¸èƒ½è¢«ä¿®æ”¹ã€‚æ­¤è¯´æ˜ç¬¦ä¸ BlueprintReadWrite è¯´æ˜ç¬¦ä¸å…¼å®¹ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
public:
	//PropertyFlags:	CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite, Category = Blueprint)
		int32 MyInt_ReadWrite = 123;
	//PropertyFlags:	CPF_BlueprintVisible | CPF_BlueprintReadOnly | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadOnly, Category = Blueprint)
		int32 MyInt_ReadOnly = 123;
```

## ç¤ºä¾‹æ•ˆæœï¼š

æŒ‡å®šè“å›¾ä¸­åªè¯»ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintReadOnly\Untitled.png)

## åŸç†ï¼š

æœ‰CPF_BlueprintVisible å°±å¯ä»¥Get

åŠ ä¸ŠCPF_BlueprintReadOnly åå°±ä¸èƒ½ä¿®æ”¹ã€‚

```cpp
EPropertyAccessResultFlags PropertyAccessUtil::CanGetPropertyValue(const FProperty* InProp)
{
	if (!InProp->HasAnyPropertyFlags(CPF_Edit | CPF_BlueprintVisible | CPF_BlueprintAssignable))
	{
		return EPropertyAccessResultFlags::PermissionDenied | EPropertyAccessResultFlags::AccessProtected;
	}

	return EPropertyAccessResultFlags::Success;
}

FBlueprintEditorUtils::EPropertyWritableState FBlueprintEditorUtils::IsPropertyWritableInBlueprint(const UBlueprint* Blueprint, const FProperty* Property)
{
	if (Property)
	{
		if (!Property->HasAnyPropertyFlags(CPF_BlueprintVisible))
		{
			return EPropertyWritableState::NotBlueprintVisible;
		}
		if (Property->HasAnyPropertyFlags(CPF_BlueprintReadOnly))
		{
			return EPropertyWritableState::BlueprintReadOnly;
		}
		if (Property->GetBoolMetaData(FBlueprintMetadata::MD_Private))
		{
			const UClass* OwningClass = Property->GetOwnerChecked<UClass>();
			if (OwningClass->ClassGeneratedBy.Get() != Blueprint)
			{
				return EPropertyWritableState::Private;
			}
		}
	}
	return EPropertyWritableState::Writable;
}
```

# BlueprintReadWrite

- **åŠŸèƒ½æè¿°ï¼š** å¯ä»è“å›¾è¯»å–æˆ–å†™å…¥æ­¤å±æ€§ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintVisible](../../../../Flags/EPropertyFlags/CPF_BlueprintVisible.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

å¯ä»è“å›¾è¯»å–æˆ–å†™å…¥æ­¤å±æ€§ã€‚

æ­¤è¯´æ˜ç¬¦ä¸ BlueprintReadOnly è¯´æ˜ç¬¦ä¸å…¼å®¹ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
public:
	//PropertyFlags:	CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadWrite, Category = Blueprint)
		int32 MyInt_ReadWrite = 123;
	//PropertyFlags:	CPF_BlueprintVisible | CPF_BlueprintReadOnly | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(BlueprintReadOnly, Category = Blueprint)
		int32 MyInt_ReadOnly = 123;
```

## ç¤ºä¾‹æ•ˆæœï¼š

è“å›¾ä¸­å¯è¯»å†™ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintReadWrite\Untitled.png)

## åŸç†ï¼š

å¦‚æœæœ‰CPF_Edit | CPF_BlueprintVisible | CPF_BlueprintAssignableä¹‹ä¸€ï¼Œåˆ™å¯ä»¥Getå±æ€§ã€‚

```cpp
EPropertyAccessResultFlags PropertyAccessUtil::CanGetPropertyValue(const FProperty* InProp)
{
	if (!InProp->HasAnyPropertyFlags(CPF_Edit | CPF_BlueprintVisible | CPF_BlueprintAssignable))
	{
		return EPropertyAccessResultFlags::PermissionDenied | EPropertyAccessResultFlags::AccessProtected;
	}

	return EPropertyAccessResultFlags::Success;
}

```

# BlueprintSetter

- **åŠŸèƒ½æè¿°ï¼š** é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„setå‡½æ•°æ¥è¯»å–ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_BlueprintVisible](../../../Flags/EPropertyFlags/CPF_BlueprintVisible.md)ï¼Œåœ¨Metaä¸­åŠ å…¥[BlueprintSetter](../../../Meta/Blueprint/BlueprintSetter.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

é‡‡ç”¨ä¸€ä¸ªè‡ªå®šä¹‰çš„setå‡½æ•°æ¥è¯»å–ã€‚

ä¼šé»˜è®¤è®¾ç½®BlueprintReadWriteã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	//(BlueprintGetter = , Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	UFUNCTION(BlueprintGetter, Category = Blueprint)	//or BlueprintPure
		int32 MyInt_Getter()const { return MyInt_WithGetter * 2; }

	//(BlueprintSetter = , Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	UFUNCTION(BlueprintSetter, Category = Blueprint)	//or BlueprintCallable
		void MyInt_Setter(int NewValue) { MyInt_WithSetter = NewValue / 4; }
private:
	//(BlueprintGetter = MyInt_Getter, Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	//PropertyFlags:	CPF_BlueprintVisible | CPF_BlueprintReadOnly | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	UPROPERTY(BlueprintGetter = MyInt_Getter, Category = Blueprint)
		int32 MyInt_WithGetter = 123;

	//(BlueprintSetter = MyInt_Setter, Category = Blueprint, ModuleRelativePath = Property/MyProperty_Test.h)
	//PropertyFlags:	CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPrivate 
	UPROPERTY(BlueprintSetter = MyInt_Setter, Category = Blueprint)
		int32 MyInt_WithSetter = 123;
```

## è“å›¾è¡¨ç°ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\BlueprintGetter\Untitled.png)

## åŸç†ï¼š

å¦‚æœæœ‰MD_PropertySetFunctionåˆ™ç”¨å®ƒæ¥ä½œä¸ºSetçš„è°ƒç”¨ã€‚

```cpp
void UK2Node_VariableSet::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
		// If property has a BlueprintSetter accessor, then replace the variable get node with a call function
		if (VariableProperty)
		{
			// todo check with BP team if we need to test if the variable has native Setter
			const FString& SetFunctionName = VariableProperty->GetMetaData(FBlueprintMetadata::MD_PropertySetFunction);
			if (!SetFunctionName.IsEmpty())
			{
			}
		}
}
```

# Getter

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Getå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Getå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚

- Getterä¸Šå¦‚ä¸æä¾›å‡½æ•°åï¼Œé‚£å°±ç”¨é»˜è®¤çš„GetXXXçš„åå­—ã€‚ä¹Ÿå¯ä»¥æä¾›å¦å¤–ä¸€ä¸ªå‡½æ•°åã€‚
- è¿™äº›Getterå‡½æ•°æ˜¯ä¸åŠ UFUNCTIONçš„ï¼Œè¿™ç‚¹è¦å’ŒBlueprintGetteråŒºåˆ†ã€‚
- æ„Ÿè§‰æ›´å¥½çš„åå­—æ˜¯NativeGetterã€‚
- GetXXXçš„å‡½æ•°å¿…é¡»è‡ªå·±æ‰‹å†™ï¼Œå¦åˆ™UHTä¼šæŠ¥é”™ã€‚
- æˆ‘ä»¬å½“ç„¶ä¹Ÿå¯ä»¥è‡ªå·±å†™GetSetå‡½æ•°ï¼Œä¸éœ€è¦å†™Getterå’ŒSetterçš„å…ƒæ•°æ®ã€‚ä½†å†™ä¸ŠGetterå’ŒSettterçš„å¥½å¤„æ˜¯ï¼Œä¸‡ä¸€åœ¨é¡¹ç›®é‡Œåˆ«çš„åœ°æ–¹ï¼Œç”¨åˆ°äº†åå°„æ¥è·å–å’Œè®¾ç½®å€¼ï¼Œè¿™ä¸ªæ—¶å€™å¦‚æœæ²¡æœ‰æ ‡ä¸ŠGetterå’ŒSetterï¼Œå°±ä¼šç›´æ¥ä»å±æ€§ä¸Šè·å–å€¼ï¼Œä»è€Œè·³è¿‡æˆ‘ä»¬æƒ³è¦çš„è‡ªå®šä¹‰Get/Setæµç¨‹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	//GetterFunc:	Has Native Getter
	UPROPERTY(BlueprintReadWrite, Getter)
	float MyFloat = 1.0f;

	//GetterFunc:	Has Native Getter
	UPROPERTY(BlueprintReadWrite, Getter = GetMyCustomFloat)
	float MyFloat2 = 1.0f;
public:
	float GetMyFloat()const { return MyFloat + 100.f; }

	float GetMyCustomFloat()const { return MyFloat2 + 100.f; }
	
void UMyProperty_Get::RunTest()
{
	float Value1=MyFloat;

	FProperty* prop=GetClass()->FindPropertyByName(TEXT("MyFloat"));
	float Value2=0.f;

	prop->GetValue_InContainer(this,&Value2);
}
```

## è“å›¾è¡¨ç°ï¼š

åœ¨æµ‹è¯•çš„æ—¶å€™ï¼Œå¯è§å¦‚æœæ˜¯ç”¨GetValue_InContainerè¿™ç§åå°„çš„æ–¹å¼æ¥è·å–å€¼ï¼Œå°±ä¼šè‡ªåŠ¨çš„è°ƒç”¨åˆ°GetMyFloatï¼Œä»è€Œè¿”å›ä¸åŒçš„å€¼ã€‚

åœ¨è“å›¾é‡Œç›´æ¥Get MyFloat æ˜¯ä¾ç„¶æ˜¯1.

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\Setter\Untitled.png)

## åŸç†ï¼š

UHTåœ¨åˆ†æGetteræ ‡è®°åï¼Œä¼šåœ¨gen.cppé‡Œç”Ÿæˆç›¸åº”çš„å‡½æ•°åŒ…è£…ã€‚åœ¨æ„å»ºFPropertyçš„æ—¶å€™ï¼Œå°±ä¼šåˆ›å»ºTPropertyWithSetterAndGetterï¼Œä¹‹ååœ¨GetSingleValue_InContainerçš„æ—¶å€™å°±ä¼šè°ƒç”¨åˆ°CallGetterã€‚

```cpp
void UMyProperty_Get::GetMyFloat_WrapperImpl(const void* Object, void* OutValue)
{
	const UMyProperty_Get* Obj = (const UMyProperty_Get*)Object;
	float& Result = *(float*)OutValue;
	Result = (float)Obj->GetMyFloat();
}

const UECodeGen_Private::FFloatPropertyParams Z_Construct_UClass_UMyProperty_Get_Statics::NewProp_MyFloat = { "MyFloat", nullptr, (EPropertyFlags)0x0010000000000004, UECodeGen_Private::EPropertyGenFlags::Float, RF_Public|RF_Transient|RF_MarkAsNative, nullptr, &UMyProperty_Get::GetMyFloat_WrapperImpl, 1, STRUCT_OFFSET(UMyProperty_Get, MyFloat), METADATA_PARAMS(UE_ARRAY_COUNT(NewProp_MyFloat_MetaData), NewProp_MyFloat_MetaData) };

template <typename PropertyType, typename PropertyParamsType>
PropertyType* NewFProperty(FFieldVariant Outer, const FPropertyParamsBase& PropBase)
{
	const PropertyParamsType& Prop = (const PropertyParamsType&)PropBase;
	PropertyType* NewProp = nullptr;

	if (Prop.SetterFunc || Prop.GetterFunc)
	{
		NewProp = new TPropertyWithSetterAndGetter<PropertyType>(Outer, Prop);
	}
	else
	{
		NewProp = new PropertyType(Outer, Prop);
	}
}

void FProperty::GetSingleValue_InContainer(const void* InContainer, void* OutValue, int32 ArrayIndex) const
{
	checkf(ArrayIndex <= ArrayDim, TEXT("ArrayIndex (%d) must be less than the property %s array size (%d)"), ArrayIndex, *GetFullName(), ArrayDim);
	if (!HasGetter())
	{
		// Fast path - direct memory access
		CopySingleValue(OutValue, ContainerVoidPtrToValuePtrInternal((void*)InContainer, ArrayIndex));
	}
	else
	{
		if (ArrayDim == 1)
		{
			// Slower but no mallocs. We can copy the value directly to the resulting param
			CallGetter(InContainer, OutValue);
		}
		else
		{
			// Malloc a temp value that is the size of the array. Getter will then copy the entire array to the temp value
			uint8* ValueArray = (uint8*)AllocateAndInitializeValue();
			GetValue_InContainer(InContainer, ValueArray);
			// Copy the item we care about and free the temp array
			CopySingleValue(OutValue, ValueArray + ArrayIndex * ElementSize);
			DestroyAndFreeValue(ValueArray);
		}
	}
}

```

# Setter

- **åŠŸèƒ½æè¿°ï¼š** ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Setå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Blueprint
- **å…³è”é¡¹ï¼š** [Getter](../Getter.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

ä¸ºå±æ€§å¢åŠ ä¸€ä¸ªC++çš„Setå‡½æ•°ï¼Œåªåœ¨C++å±‚é¢åº”ç”¨ã€‚

- Getterä¸Šå¦‚ä¸æä¾›å‡½æ•°åï¼Œé‚£å°±ç”¨é»˜è®¤çš„SetXXXçš„åå­—ã€‚ä¹Ÿå¯ä»¥æä¾›å¦å¤–ä¸€ä¸ªå‡½æ•°åã€‚
- è¿™äº›Getterå‡½æ•°æ˜¯ä¸åŠ UFUNCTIONçš„ï¼Œè¿™ç‚¹è¦å’ŒBlueprintGetteråŒºåˆ†ã€‚
- æ„Ÿè§‰æ›´å¥½çš„åå­—æ˜¯NativeSetterã€‚
- SetXXXçš„å‡½æ•°å¿…é¡»è‡ªå·±æ‰‹å†™ï¼Œå¦åˆ™UHTä¼šæŠ¥é”™ã€‚
- æˆ‘ä»¬å½“ç„¶ä¹Ÿå¯ä»¥è‡ªå·±å†™GetSetå‡½æ•°ï¼Œä¸éœ€è¦å†™Getterå’ŒSetterçš„å…ƒæ•°æ®ã€‚ä½†å†™ä¸ŠGetterå’ŒSettterçš„å¥½å¤„æ˜¯ï¼Œä¸‡ä¸€åœ¨é¡¹ç›®é‡Œåˆ«çš„åœ°æ–¹ï¼Œç”¨åˆ°äº†åå°„æ¥è·å–å’Œè®¾ç½®å€¼ï¼Œè¿™ä¸ªæ—¶å€™å¦‚æœæ²¡æœ‰æ ‡ä¸ŠGetterå’ŒSetterï¼Œå°±ä¼šç›´æ¥ä»å±æ€§ä¸Šè·å–å€¼ï¼Œä»è€Œè·³è¿‡æˆ‘ä»¬æƒ³è¦çš„è‡ªå®šä¹‰Get/Setæµç¨‹ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
public:
	UPROPERTY(BlueprintReadWrite, Setter)
	float MyFloat = 1.0f;

	UPROPERTY(BlueprintReadWrite, Setter = SetMyCustomFloat)
	float MyFloat2 = 1.0f;
public:
	void SetMyFloat(float val) { MyFloat = val + 100.f; }
	void SetMyCustomFloat(float val) { MyFloat2 = val + 100.f; }

public:
	UFUNCTION(BlueprintCallable)
	void RunTest();
};

void UMyProperty_Set::RunTest()
{
	float OldValue=MyFloat;

	FProperty* prop=GetClass()->FindPropertyByName(TEXT("MyFloat"));
	const float Value2=20.f;

	prop->SetValue_InContainer(this,&Value2);

	float NewValue=MyFloat;
}
```

## è“å›¾è¡¨ç°ï¼š

åœ¨æµ‹è¯•çš„æ—¶å€™ï¼Œå¯è§å¦‚æœæ˜¯ç”¨SetValue_InContainerè¿™ç§åå°„çš„æ–¹å¼æ¥è·å–å€¼ï¼Œå°±ä¼šè‡ªåŠ¨çš„è°ƒç”¨åˆ°SetMyFloatï¼Œä»è€Œå®é™…ä¸Šè®¾ç½®åˆ°ä¸åŒçš„å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\Setter\Untitled.png)

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Blueprint\Setter\Untitled%201.png)

## åŸç†ï¼š

UHTåœ¨åˆ†æSetteræ ‡è®°åï¼Œä¼šåœ¨gen.cppé‡Œç”Ÿæˆç›¸åº”çš„å‡½æ•°åŒ…è£…ã€‚åœ¨æ„å»ºFPropertyçš„æ—¶å€™ï¼Œå°±ä¼šåˆ›å»ºTPropertyWithSetterAndGetterï¼Œä¹‹ååœ¨GetSingleValue_InContainerçš„æ—¶å€™å°±ä¼šè°ƒç”¨åˆ°CallGetterã€‚

```cpp
void UMyProperty_Set::SetMyFloat_WrapperImpl(void* Object, const void* InValue)
{
	UMyProperty_Set* Obj = (UMyProperty_Set*)Object;
	float& Value = *(float*)InValue;
	Obj->SetMyFloat(Value);
}

const UECodeGen_Private::FFloatPropertyParams Z_Construct_UClass_UMyProperty_Set_Statics::NewProp_MyFloat = { "MyFloat", nullptr, (EPropertyFlags)0x0010000000000004, UECodeGen_Private::EPropertyGenFlags::Float, RF_Public|RF_Transient|RF_MarkAsNative, &UMyProperty_Set::SetMyFloat_WrapperImpl, nullptr, 1, STRUCT_OFFSET(UMyProperty_Set, MyFloat), METADATA_PARAMS(UE_ARRAY_COUNT(NewProp_MyFloat_MetaData), NewProp_MyFloat_MetaData) };

template <typename PropertyType, typename PropertyParamsType>
PropertyType* NewFProperty(FFieldVariant Outer, const FPropertyParamsBase& PropBase)
{
	const PropertyParamsType& Prop = (const PropertyParamsType&)PropBase;
	PropertyType* NewProp = nullptr;

	if (Prop.SetterFunc || Prop.GetterFunc)
	{
		NewProp = new TPropertyWithSetterAndGetter<PropertyType>(Outer, Prop);
	}
	else
	{
		NewProp = new PropertyType(Outer, Prop);
	}
}

void FProperty::SetSingleValue_InContainer(void* OutContainer, const void* InValue, int32 ArrayIndex) const
{
	checkf(ArrayIndex <= ArrayDim, TEXT("ArrayIndex (%d) must be less than the property %s array size (%d)"), ArrayIndex, *GetFullName(), ArrayDim);
	if (!HasSetter())
	{
		// Fast path - direct memory access
		CopySingleValue(ContainerVoidPtrToValuePtrInternal((void*)OutContainer, ArrayIndex), InValue);
	}
	else
	{
		if (ArrayDim == 1)
		{
			// Slower but no mallocs. We can copy the value directly to the resulting param
			CallSetter(OutContainer, InValue);
		}
		else
		{
			// Malloc a temp value that is the size of the array. We will then copy the entire array to the temp value
			uint8* ValueArray = (uint8*)AllocateAndInitializeValue();
			GetValue_InContainer(OutContainer, ValueArray);
			// Replace the value at the specified index in the temp array with the InValue
			CopySingleValue(ValueArray + ArrayIndex * ElementSize, InValue);
			// Now call a setter to replace the entire array and then destroy the temp value
			CallSetter(OutContainer, ValueArray);
			DestroyAndFreeValue(ValueArray);
		}
	}
}
```

# Config

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªé…ç½®å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥è¢«åºåˆ—åŒ–è¯»å†™åˆ°iniæ–‡ä»¶ï¼ˆè·¯å¾„ç”±uclassçš„configæ ‡ç­¾æŒ‡å®šï¼‰ä¸­ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Config
- **ä½œç”¨æœºåˆ¶ï¼š** [CPF_Config](../../../Flags/EPropertyFlags/CPF_Config.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥å±æ€§æ˜¯ä¸€ä¸ªé…ç½®å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥è¢«åºåˆ—åŒ–è¯»å†™åˆ°iniæ–‡ä»¶ï¼ˆè·¯å¾„ç”±uclassçš„configæ ‡ç­¾æŒ‡å®šï¼‰ä¸­ã€‚

åœ¨è½½å…¥çš„æ—¶å€™ä¼šè‡ªåŠ¨ä»iniä¸­åŠ è½½ã€‚å¦‚æœæ²¡å†åŠ å†™æ ‡è®°ï¼Œåˆ™ä¼šéšå«è¯¥å±æ€§ä¸ºReadOnlyã€‚

å‚è§UCLASSä¸­çš„configæ ‡è®°çš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# GlobalConfig

- **åŠŸèƒ½æè¿°ï¼š** å’ŒConfigä¸€æ ·æŒ‡å®šè¯¥å±æ€§å¯ä½œä¸ºé…ç½®è¯»å–å’Œå†™å…¥iniä¸­ï¼Œä½†åªä¼šè¯»å–å†™å…¥åˆ°é…ç½®æ–‡ä»¶é‡ŒåŸºç±»çš„å€¼ï¼Œè€Œä¸ä¼šä½¿ç”¨é…ç½®æ–‡ä»¶é‡Œå­ç±»é‡Œçš„å€¼ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Config
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_GlobalConfig](../../../../Flags/EPropertyFlags/CPF_GlobalConfig.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

å’ŒConfigä¸€æ ·æŒ‡å®šè¯¥å±æ€§å¯ä½œä¸ºé…ç½®è¯»å–å’Œå†™å…¥iniä¸­ï¼Œä½†åªä¼šè¯»å–å†™å…¥åˆ°é…ç½®æ–‡ä»¶é‡ŒåŸºç±»çš„å€¼ï¼Œè€Œä¸ä¼šä½¿ç”¨é…ç½®æ–‡ä»¶é‡Œå­ç±»é‡Œçš„å€¼ã€‚

ä½†æ˜¯ä¸åŒç‚¹åœ¨äºï¼Œè¯¥å±æ€§åœ¨LoadConfigçš„æ—¶å€™ï¼Œåªä¼šè¯»å–åŸºç±»çš„iniï¼Œè€Œä¸ä¼šå»è¯»å–å­ç±»çš„iniã€‚å› ä¸ºåªæœ‰åŸºç±»é‡Œçš„Iniè®¾ç½®åœ¨ç”Ÿæ•ˆï¼Œç›¸å½“äºå…¨å±€åªæœ‰ä¸€ä¸ªé…ç½®åœ¨ç”Ÿæ•ˆï¼Œå› æ­¤åå­—å«åšGlobalConfigã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Config = MyOtherGame)
class INSIDER_API UMyProperty_Config :public UObject
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	int32 MyProperty = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Config)
	int32 MyPropertyWithConfig = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, GlobalConfig)
	int32 MyPropertyWithGlobalConfig = 123;
};

UCLASS(Config = MyOtherGame)
class INSIDER_API UMyProperty_Config_Child :public UMyProperty_Config
{
	GENERATED_BODY()
public:
};

void UMyProperty_Config_Test::TestConfigSave()
{
	FString fileName = FPaths::ProjectConfigDir() / TEXT("MyOtherGame.ini");
	fileName = FConfigCacheIni::NormalizeConfigIniPath(fileName);

	{
		UMyProperty_Config* testObject = NewObject<UMyProperty_Config>(GetTransientPackage(), TEXT("testObject"));

		testObject->MyProperty = 777;
		testObject->MyPropertyWithConfig = 777;
		testObject->MyPropertyWithGlobalConfig = 777;

		testObject->SaveConfig(CPF_Config, *fileName);
	}

	{
		UMyProperty_Config_Child* testObject = NewObject<UMyProperty_Config_Child>(GetTransientPackage(), TEXT("testObjectChild"));

		testObject->MyProperty = 888;
		testObject->MyPropertyWithConfig = 888;
		testObject->MyPropertyWithGlobalConfig = 888;

		testObject->SaveConfig(CPF_Config, *fileName);
	}
}

void UMyProperty_Config_Test::TestConfigLoad()
{
	FString fileName = FPaths::ProjectConfigDir() / TEXT("MyOtherGame.ini");
	fileName = FConfigCacheIni::NormalizeConfigIniPath(fileName);

	UMyProperty_Config* testObject = NewObject<UMyProperty_Config>(GetTransientPackage(), TEXT("testObject"));
	testObject->LoadConfig(nullptr, *fileName);

	UMyProperty_Config_Child* testObjectChild = NewObject<UMyProperty_Config_Child>(GetTransientPackage(), TEXT("testObjectChild"));
	testObjectChild->LoadConfig(nullptr, *fileName);
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

TestConfigSaveä¹‹åï¼ŒMyPropertyWithGlobalConfig=888ï¼Œå¯è§ä¿å­˜çš„æ—¶å€™ä¹Ÿåªä¼šä¿å­˜åœ¨åŸºç±»ä¸Šã€‚

```cpp
[/Script/Insider.MyProperty_Config]
MyPropertyWithConfig=777
MyPropertyWithGlobalConfig=888

[/Script/Insider.MyProperty_Config_Child]
MyPropertyWithConfig=888
```

ä¸ºäº†æµ‹è¯•ï¼Œå‡å¦‚æ‰‹åŠ¨æŠŠé…ç½®é‡Œçš„å€¼æ”¹ä¸ºï¼šç„¶åå†è¿›è¡ŒTestConfigLoadæµ‹è¯•

```cpp
[/Script/Insider.MyProperty_Config]
MyPropertyWithConfig=777
MyPropertyWithGlobalConfig=888

[/Script/Insider.MyProperty_Config_Child]
MyPropertyWithConfig=888
MyPropertyWithGlobalConfig=999
```

æ˜¾ç¤ºæ•ˆæœï¼š

å¯è§testObjectChild çš„å€¼å¹¶æ²¡æœ‰ä½¿ç”¨inié‡ŒMyProperty_Config_Childä¸‹çš„999çš„å€¼ï¼Œè€Œæ˜¯åŒæ ·çš„888.

![D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Config\GlobalConfig\image.png](image.png)

## åŸç†ï¼š

å¦‚æœæ˜¯bGlobalConfig ï¼Œä¼šé‡‡ç”¨åŸºç±»ã€‚

```cpp
void UObject::LoadConfig( UClass* ConfigClass/*=NULL*/, const TCHAR* InFilename/*=NULL*/, uint32 PropagationFlags/*=LCPF_None*/, FProperty* PropertyToLoad/*=NULL*/ )
{
		const bool bGlobalConfig = (Property->PropertyFlags&CPF_GlobalConfig) != 0;
		UClass* OwnerClass = Property->GetOwnerClass();
		
		UClass* BaseClass = bGlobalConfig ? OwnerClass : ConfigClass;
		if ( !bPerObject )
		{
			ClassSection = BaseClass->GetPathName();
			LongCommitName = BaseClass->GetOutermost()->GetFName();
		
			// allow the class to override the expected section name
			OverrideConfigSection(ClassSection);
		}
		
		// globalconfig properties should always use the owning class's config file
		// specifying a value for InFilename will override this behavior (as it does with normal properties)
		const FString& PropFileName = (bGlobalConfig && InFilename == NULL) ? OwnerClass->GetConfigName() : Filename;
}
```

# AdvancedDisplay

- **åŠŸèƒ½æè¿°ï¼š** è¢«æŠ˜å åˆ°é«˜çº§æ ä¸‹ï¼Œè¦æ‰‹åŠ¨æ‰“å¼€ã€‚ä¸€èˆ¬ç”¨åœ¨ä¸å¤ªå¸¸ç”¨çš„å±æ€§ä¸Šé¢ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_AdvancedDisplay](../../../../Flags/EPropertyFlags/CPF_AdvancedDisplay.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

è¢«æŠ˜å åˆ°é«˜çº§æ ä¸‹ï¼Œè¦æ‰‹åŠ¨æ‰“å¼€ã€‚ä¸€èˆ¬ç”¨åœ¨ä¸å¤ªå¸¸ç”¨çš„å±æ€§ä¸Šé¢ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Test :public UObject
{
	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_SimpleDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, SimpleDisplay, Category = Display)
		int32 MyInt_SimpleDisplay = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_AdvancedDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = Display)
		int32 MyInt_AdvancedDisplay = 123;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\AdvancedDisplay\Untitled.png)

## åŸç†ï¼š

å¦‚æœCPF_AdvancedDisplayï¼ŒbAdvanced =true

```cpp
void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
	// Property is advanced if it is marked advanced or the entire class is advanced and the property not marked as simple
	static const FName Name_AdvancedClassDisplay("AdvancedClassDisplay");
	bool bAdvanced = Property.IsValid() ? ( Property->HasAnyPropertyFlags(CPF_AdvancedDisplay) || ( !Property->HasAnyPropertyFlags( CPF_SimpleDisplay ) && Property->GetOwnerClass() && Property->GetOwnerClass()->GetBoolMetaData(Name_AdvancedClassDisplay) ) ) : false;

}
```

# Category

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå±æ€§çš„ç±»åˆ«ï¼Œä½¿ç”¨ | è¿ç®—ç¬¦å®šä¹‰åµŒå¥—ç±»ç›®ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** strings=â€œa|b|câ€
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨Metaä¸­åŠ å…¥[Category](../../../../Meta/DetailsPanel/Category.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

æŒ‡å®šå±æ€§çš„ç±»åˆ«ï¼Œä½¿ç”¨ | è¿ç®—ç¬¦å®šä¹‰åµŒå¥—ç±»ç›®ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Test :public UObject
{
	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_SimpleDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, SimpleDisplay, Category = Display)
		int32 MyInt_SimpleDisplay = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_AdvancedDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = Display)
		int32 MyInt_AdvancedDisplay = 123;
public:
	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, Category = Edit)
		int32 MyInt_EditAnywhere = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnInstance | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditDefaultsOnly, Category = Edit)
		int32 MyInt_EditDefaultsOnly = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnTemplate | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditInstanceOnly, Category = Edit)
		int32 MyInt_EditInstanceOnly = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_EditConst | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(VisibleAnywhere, Category = Edit)
		int32 MyInt_VisibleAnywhere = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnInstance | CPF_EditConst | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(VisibleDefaultsOnly, Category = Edit)
		int32 MyInt_VisibleDefaultsOnly = 123;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\Category\Untitled.png)

## åŸç†ï¼š

æ¯”è¾ƒç®€å•ï¼ŒæŠŠå€¼è®¾ç½®åˆ°metaé‡Œçš„Categoryï¼Œä¹‹åè¯»å–å‡ºæ¥ä½¿ç”¨ã€‚

# EditAnywhere

- **åŠŸèƒ½æè¿°ï¼š** åœ¨é»˜è®¤å€¼å’Œå®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šå‡å¯ç¼–è¾‘
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../../Flags/EPropertyFlags/CPF_Edit.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

åœ¨é»˜è®¤å€¼å’Œå®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šå‡å¯ç¼–è¾‘ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Test :public UObject
{
	public:
	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, Category = Edit)
		int32 MyInt_EditAnywhere = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnInstance | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditDefaultsOnly, Category = Edit)
		int32 MyInt_EditDefaultsOnly = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnTemplate | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditInstanceOnly, Category = Edit)
		int32 MyInt_EditInstanceOnly = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_EditConst | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(VisibleAnywhere, Category = Edit)
		int32 MyInt_VisibleAnywhere = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnInstance | CPF_EditConst | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(VisibleDefaultsOnly, Category = Edit)
		int32 MyInt_VisibleDefaultsOnly = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_DisableEditOnTemplate | CPF_EditConst | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(VisibleInstanceOnly, Category = Edit)
		int32 MyInt_VisibleInstanceOnly = 123;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\EditAnywhere\Untitled.png)

## åŸç†ï¼š

CPF_Editåœ¨æºç é‡Œæœ‰éå¸¸å¤šçš„ä½¿ç”¨ï¼Œå†³å®šäº†å¾ˆå¤šåœ°æ–¹å±æ€§æ˜¯å¦å¯ä»¥æ˜¾ç¤ºå’Œç¼–è¾‘ã€‚æœ‰å…´è¶£å¯ä»¥è‡ªå·±å»æœæœCPF_Editçš„ä½¿ç”¨ã€‚

# EditDefaultsOnly

- **åŠŸèƒ½æè¿°ï¼š** åªèƒ½åœ¨é»˜è®¤å€¼é¢æ¿é‡Œç¼–è¾‘
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_DisableEditOnInstance](../../../Flags/EPropertyFlags/CPF_DisableEditOnInstance.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸€å¹¶å‚è§EditAnywhereé‡Œçš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# EditFixedSize

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸å…è®¸æ”¹å˜è¯¥å®¹å™¨çš„å…ƒç´ ä¸ªæ•°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **é™åˆ¶ç±»å‹ï¼š** TArray<T>ï¼ŒTSet<T>ï¼ŒTMap<T>
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_EditFixedSize](../../../../Flags/EPropertyFlags/CPF_EditFixedSize.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨ç»†èŠ‚é¢æ¿ä¸Šä¸å…è®¸æ”¹å˜è¯¥å®¹å™¨çš„å…ƒç´ ä¸ªæ•°ã€‚

åªé€‚ç”¨äºå®¹å™¨ã€‚è¿™èƒ½é˜²æ­¢ç”¨æˆ·é€šè¿‡è™šå¹»ç¼–è¾‘å™¨å±æ€§çª—å£ä¿®æ”¹å®¹å™¨çš„å…ƒç´ ä¸ªæ•°ã€‚

ä½†åœ¨C++ä»£ç å’Œè“å›¾ä¸­ä¾ç„¶æ˜¯å¯ä»¥ä¿®æ”¹çš„ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

ä»¥TArrayä¸ºä¾‹ï¼Œå…¶ä»–åŒç†ã€‚

```cpp
UPROPERTY(EditAnywhere, Category = Array)
		TArray<int32> MyIntArray_Normal{1,2,3};

	UPROPERTY(EditAnywhere, EditFixedSize,Category = Array)
		TArray<int32> MyIntArray_FixedSize{1,2,3};
```

## ç¤ºä¾‹æ•ˆæœï¼š

è“å›¾ä¸­çš„è¡¨ç°ï¼Œå‰è€…å¯ä»¥åŠ¨æ€å†æ·»åŠ å…ƒç´ ã€‚åè€…ä¸å¯ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\EditFixedSize\Untitled.png)

## åŸç†ï¼š

å¦‚æœæœ‰CPF_EditFixedSizeï¼Œåˆ™ä¸ä¼šæ·»åŠ +å’Œæ¸…ç©ºçš„æŒ‰é’®ã€‚

```cpp
void PropertyEditorHelpers::GetRequiredPropertyButtons( TSharedRef<FPropertyNode> PropertyNode, TArray<EPropertyButton::Type>& OutRequiredButtons, bool bUsingAssetPicker )
{
	// Handle a container property.
	if( NodeProperty->IsA(FArrayProperty::StaticClass()) || NodeProperty->IsA(FSetProperty::StaticClass()) || NodeProperty->IsA(FMapProperty::StaticClass()) )
	{
		if( !(NodeProperty->PropertyFlags & CPF_EditFixedSize) )
		{
			OutRequiredButtons.Add( EPropertyButton::Add );
			OutRequiredButtons.Add( EPropertyButton::Empty );
		}
	}
}
```

# EditInstanceOnly

- **åŠŸèƒ½æè¿°ï¼š** åªèƒ½åœ¨å®ä¾‹çš„ç»†èŠ‚é¢æ¿ä¸Šç¼–è¾‘è¯¥å±æ€§

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_DisableEditOnTemplate](../../../Flags/EPropertyFlags/CPF_DisableEditOnTemplate.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸€å¹¶å‚è§EditAnywhereé‡Œçš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# Interp

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§å€¼å¯æš´éœ²åˆ°æ—¶é—´è½´é‡Œç¼–è¾‘ï¼Œåœ¨å¹³å¸¸çš„Timelineæˆ–UMGçš„åŠ¨ç”»é‡Œä½¿ç”¨ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Sequencer
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_BlueprintVisible](../../../../Flags/EPropertyFlags/CPF_BlueprintVisible.md), [CPF_Interp](../../../../Flags/EPropertyFlags/CPF_Interp.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

è¯¥å±æ€§å¯ä»¥æš´éœ²åˆ°æ—¶é—´è½´é‡Œï¼Œä¸€èˆ¬ç”¨æ¥ç¼–è¾‘åŠ¨ç”»ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Interp :public AActor
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Interp, Category = Animation)
		FVector MyInterpVector;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

å½±å“çš„æ˜¯å±æ€§ä¸Šçš„è¯¥æ ‡å¿—

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\Interp\Untitled.png)

ä»è€Œå¯ä»¥åœ¨Sequenceré‡Œå¯¹è¯¥å±æ€§æ·»åŠ Track

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\Interp\Untitled%201.png)

# NoClear

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§çš„ç¼–è¾‘é€‰é¡¹ä¸­ä¸å‡ºç°ClearæŒ‰é’®ï¼Œä¸å…è®¸ç½®nullã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **é™åˆ¶ç±»å‹ï¼š** å¼•ç”¨ç±»å‹
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_NoClear](../../../../Flags/EPropertyFlags/CPF_NoClear.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šè¯¥å±æ€§çš„ç¼–è¾‘é€‰é¡¹ä¸­ä¸å‡ºç°ClearæŒ‰é’®ã€‚

ä½œç”¨æ˜¯é˜»æ­¢ç”¨æˆ·åœ¨ç¼–è¾‘å™¨é¢æ¿ä¸Šå°†æ­¤Objectå¼•ç”¨è®¾ä¸ºnullã€‚ä½†å…¶å®ä¹Ÿå¯ç”¨åœ¨å…¶ä»–è¡¨ç¤ºä¸€ä¸ªå¼•ç”¨ç±»å‹çš„ç»“æ„ä¸Šï¼Œæ¯”å¦‚FPrimaryAssetIdï¼ŒFInstancedStructï¼ŒFDataRegistryTypeç­‰ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UPROPERTY(EditAnywhere, Category = Object)
class UMyClass_Default* MyObject_Normal;
//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_NoClear | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
UPROPERTY(EditAnywhere, NoClear, Category = Object)
class UMyClass_Default* MyObject_NoClear;

//æ„é€ å‡½æ•°èµ‹å€¼ï¼š
MyObject_Normal = CreateDefaultSubobject<UMyClass_Default>("MyObject_Normal");
MyObject_NoClear = CreateDefaultSubobject<UMyClass_Default>("MyObject_NoClear");
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\NoClear\Untitled.png)

## åŸç†ï¼š

CPF_NoClearåœ¨å¼•æ“é‡Œæœ‰æŒºå¤šä½¿ç”¨ã€‚

```cpp
	const bool bAllowClear = !StructPropertyHandle->GetMetaDataProperty()->HasAnyPropertyFlags(CPF_NoClear);

```

# NonTransactional

- **åŠŸèƒ½æè¿°ï¼š** å¯¹è¯¥å±æ€§çš„æ”¹å˜æ“ä½œï¼Œä¸ä¼šè¢«åŒ…å«è¿›ç¼–è¾‘å™¨çš„Undo/Redoå‘½ä»¤ä¸­ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_NonTransactional](../../../../Flags/EPropertyFlags/CPF_NonTransactional.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

æŒ‡å®šè¯¥å±æ€§çš„æ”¹å˜ï¼Œä¸èƒ½åœ¨ç¼–è¾‘å™¨ä¸­é€šè¿‡Ctrl+Zæ¥æ’¤é”€æˆ–Ctrl+Yæ¥é‡åšã€‚åœ¨Actoræˆ–åœ¨BPçš„Class Defautlséƒ½å¯ä»¥ç”Ÿæ•ˆã€‚

## æµ‹è¯•ä»£ç ï¼š

```jsx
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Transaction :public AActor
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite,NonTransactional,Category = Transaction)
		int32 MyInt_NonTransactional= 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category = Transaction)
		int32 MyInt_Transactional = 123;
};
```

## è“å›¾è¡¨ç°ï¼š

åœ¨MyInt_Transactional ä¸Šå¯ä»¥æ’¤é”€ä¹‹å‰çš„è¾“å…¥ï¼Œè€ŒMyInt_NonTransactionalä¸Šçš„è¾“å…¥æ— æ³•ç”¨Ctrl+Zæ’¤é”€ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\NonTransactional\Untitled.png)

# SimpleDisplay

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ç»†èŠ‚é¢æ¿ä¸­ç›´æ¥å¯è§ï¼Œä¸æŠ˜å åˆ°é«˜çº§ä¸­ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_SimpleDisplay](../../../../Flags/EPropertyFlags/CPF_SimpleDisplay.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨ç»†èŠ‚é¢æ¿ä¸­ç›´æ¥å¯è§ï¼Œä¸æŠ˜å åˆ°é«˜çº§ä¸­ã€‚

é»˜è®¤æƒ…å†µä¸‹æœ¬èº«å°±æ˜¯ä¸æŠ˜å ï¼Œä½†å¯ä»¥ç”¨æ¥è¦†ç›–æ‰ç±»ä¸Šçš„AdvancedClassDisplayçš„è®¾ç½®ã€‚å…·ä½“å¯å‚è§AdvancedClassDisplayçš„ä»£ç å’Œæ•ˆæœã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Test :public UObject
{
	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_SimpleDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, SimpleDisplay, Category = Display)
		int32 MyInt_SimpleDisplay = 123;

	//PropertyFlags:	CPF_Edit | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_AdvancedDisplay | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, AdvancedDisplay, Category = Display)
		int32 MyInt_AdvancedDisplay = 123;
}
```

## ç¤ºä¾‹æ•ˆæœï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\DetaisPanel\SimpleDisplay\Untitled.png)

## åŸç†ï¼š

å¦‚æœæœ‰CPF_SimpleDisplayï¼Œåˆ™bAdvanced =false

```cpp
void FPropertyNode::InitNode(const FPropertyNodeInitParams& InitParams)
{
	// Property is advanced if it is marked advanced or the entire class is advanced and the property not marked as simple
	static const FName Name_AdvancedClassDisplay("AdvancedClassDisplay");
	bool bAdvanced = Property.IsValid() ? ( Property->HasAnyPropertyFlags(CPF_AdvancedDisplay) || ( !Property->HasAnyPropertyFlags( CPF_SimpleDisplay ) && Property->GetOwnerClass() && Property->GetOwnerClass()->GetBoolMetaData(Name_AdvancedClassDisplay) ) ) : false;

}
```

# VisibleAnywhere

- **åŠŸèƒ½æè¿°ï¼š** åœ¨é»˜è®¤å€¼å’Œå®ä¾‹ç»†èŠ‚é¢æ¿å‡å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_EditConst](../../../Flags/EPropertyFlags/CPF_EditConst.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸€å¹¶å‚è§EditAnywhereé‡Œçš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# VisibleDefaultsOnly

- **åŠŸèƒ½æè¿°ï¼š** åœ¨é»˜è®¤å€¼ç»†èŠ‚é¢æ¿å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_DisableEditOnInstance](../../../Flags/EPropertyFlags/CPF_DisableEditOnInstance.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸€å¹¶å‚è§EditAnywhereé‡Œçš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# VisibleInstanceOnly

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å®ä¾‹ç»†èŠ‚é¢æ¿å¯è§ï¼Œä½†ä¸å¯ç¼–è¾‘
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** DetailsPanel, Editor
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Edit](../../../Flags/EPropertyFlags/CPF_Edit.md), [CPF_DisableEditOnTemplate](../../../Flags/EPropertyFlags/CPF_DisableEditOnTemplate.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ä¸€å¹¶å‚è§EditAnywhereé‡Œçš„ç¤ºä¾‹ä»£ç å’Œæ•ˆæœã€‚

# Instanced

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šå¯¹è¯¥å¯¹è±¡å±æ€§çš„ç¼–è¾‘èµ‹å€¼åº”è¯¥æ–°åˆ›å»ºä¸€ä¸ªå®ä¾‹å¹¶ä½œä¸ºå­å¯¹è±¡ï¼Œè€Œä¸æ˜¯å¯»æ‰¾ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Instance
- **é™åˆ¶ç±»å‹ï¼š** UObject*
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_PersistentInstance](../../../../Flags/EPropertyFlags/CPF_PersistentInstance.md), [CPF_ExportObject](../../../../Flags/EPropertyFlags/CPF_ExportObject.md), [CPF_InstancedReference](../../../../Flags/EPropertyFlags/CPF_InstancedReference.md)ï¼Œåœ¨Metaä¸­åŠ å…¥[EditInline](../../../../Meta/DetailsPanel/EditInline/EditInline.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

æŒ‡å®šå¯¹è¯¥å¯¹è±¡å±æ€§çš„ç¼–è¾‘èµ‹å€¼åº”è¯¥æ–°åˆ›å»ºä¸€ä¸ªå®ä¾‹å¹¶ä½œä¸ºå­å¯¹è±¡ï¼Œè€Œä¸æ˜¯å¯»æ‰¾ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ã€‚

- å•ä¸ªå±æ€§ä¸Šçš„Instancedå’ŒUCLASSä¸Šçš„DefaultToInstancedä½œç”¨æœ‰ç‚¹ç±»ä¼¼ï¼ŒåŒºåˆ«æ˜¯å‰è€…åªä½œç”¨äºå•ä¸ªå±æ€§ï¼Œåè€…ä½œç”¨äºè¯¥ç±»ç±»å‹çš„æ‰€æœ‰å±æ€§ã€‚
- å¸¸å¸¸å’ŒEditInlineNewä¸€èµ·ä½¿ç”¨ï¼Œåœ¨ç»†èŠ‚é¢æ¿ä¸Šå¯ä»¥ä¸ºå¯¹è±¡å±æ€§æ–°åˆ›å»ºå®ä¾‹å¹¶ç¼–è¾‘ã€‚
- Instancedéšå«äº†EditInline and Export.

åœ¨Object*å±æ€§ä¸Šè®¾ç½®å€¼çš„æ—¶å€™ï¼Œå¦‚æœä¸æ ‡Instancedï¼Œåˆ™åªèƒ½ä¸ºå…¶è®¾ç½®ä¸€ä¸ªå¯¹è±¡å¼•ç”¨ã€‚è€Œå¦‚æœæƒ³åœ¨ç¼–è¾‘å™¨é‡Œä¸ºå…¶çœŸæ­£çš„åˆ›å»ºä¸€ä¸ªå¯¹è±¡å®ä¾‹å¹¶èµ‹äºˆç»™è¿™ä¸ªå±æ€§ï¼Œåˆ™éœ€è¦åŠ ä¸ŠInstancedæ ‡è®°ã€‚ä½†å…‰æœ‰Instancedè¿˜ä¸å¤Ÿï¼Œè¿™ä¸ªClassè¿˜éœ€è¦åŠ ä¸ŠEditInlineNewï¼Œæ‰èƒ½è®©è¯¥ç±»å‡ºç°åœ¨å¯æ–°åˆ›å»ºç±»å®ä¾‹çš„åˆ—è¡¨é‡Œã€‚

å½“ç„¶ï¼Œåœ¨C++é‡Œæ‰‹åŠ¨è®¾ç½®å¯¹è±¡ç»™è¿™ä¸ªå±æ€§çš„è¯è¿˜æ˜¯éƒ½å¯ä»¥çš„ã€‚ä¹Ÿè¦æ³¨æ„å’ŒUCLASS(DefaultToInstanced)åŒºåˆ†ï¼ŒDefaultToInstancedæ˜¯è¡¨æ˜è¿™ä¸ªç±»çš„æ‰€æœ‰å±æ€§éƒ½é»˜è®¤çš„åŠ ä¸ŠInstancedçš„æ„æ€ï¼Œé¿å…äº†å¯¹è¯¥ç±»çš„æ‰€æœ‰å±æ€§æ¯æ¬¡éƒ½è¦æ‰‹åŠ¨è®¾ç½®ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType,editinlinenew)
class INSIDER_API UMyProperty_InstancedObject :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyValue = 123;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Instanced :public UObject
{
public:
	GENERATED_BODY()
		UMyProperty_Instanced(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
public:
	//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ExportObject | CPF_ZeroConstructor | CPF_InstancedReference | CPF_NoDestructor | CPF_PersistentInstance | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Instanced, Category = Behavior)
		UMyProperty_InstancedObject* ObjectInstanced;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Behavior)
		UMyProperty_InstancedObject* Object;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

å¯è§ObjectInstancedå’ŒObjectå¼¹å‡ºçš„ç¼–è¾‘æ¡†æ˜¯ä¸åŒçš„ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Instance\Instanced\Untitled.png)

# NotReplicated

- **åŠŸèƒ½æè¿°ï¼š** è·³è¿‡å¤åˆ¶ã€‚è¿™åªä¼šåº”ç”¨åˆ°æœåŠ¡è¯·æ±‚å‡½æ•°ä¸­çš„ç»“æ„ä½“æˆå‘˜å’Œå‚æ•°ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **é™åˆ¶ç±»å‹ï¼š** Struct members
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_RepSkip](../../../Flags/EPropertyFlags/CPF_RepSkip.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åªç”¨åœ¨ç»“æ„æˆå‘˜ä¸­ï¼ŒæŒ‡å®šstructä¸­çš„æŸä¸ªå±æ€§ä¸å¤åˆ¶ï¼Œå¦åˆ™é»˜è®¤å°±éƒ½ä¼šå¤åˆ¶ã€‚è¿™ä¸ªç”¨äºæ’é™¤æ‰ç»“æ„ä¸­çš„æŸå±æ€§ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
USTRUCT(BlueprintType)
struct FMyReplicatedStruct
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		FString MyString_Default;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,NotReplicated)
		FString MyString_NotReplicated;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Network :public AActor
{
public:
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Replicated)
		FMyReplicatedStruct MyStruct_Replicated;
};
```

å…¶ä¸­MyStruct_Replicatedä¼šå¤åˆ¶ï¼Œä½†æ˜¯å…¶ä¸­çš„MyString_NotReplicatedä¸ä¼šå¤åˆ¶ã€‚

# Replicated

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šè¯¥å±æ€§åº”éšç½‘ç»œè¿›è¡Œå¤åˆ¶ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Net](../../../Flags/EPropertyFlags/CPF_Net.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

## ç¤ºä¾‹ä»£ç ï¼š

è®°å¾—è¦åœ¨cppä»£ç ä¸­ç›¸åº”æ·»åŠ GetLifetimeReplicatedPropså‡½æ•°

```jsx
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Network :public AActor
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;

		UPROPERTY(EditAnywhere, BlueprintReadWrite, Replicated)
		int32 MyInt_Replicated = 123;
		
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Replicated)
		FMyReplicatedStruct MyStruct_Replicated;
};

void AMyProperty_Network::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AMyProperty_Network, MyInt_Replicated);
	DOREPLIFETIME(AMyProperty_Network, MyStruct_Replicated);
}
```

ç¤ºä¾‹æ•ˆæœå°±ä¸å‘äº†ï¼Œè¿™ä¸ªæ˜¯åŸºæœ¬çš„ç½‘ç»œæ ‡è®°ã€‚

# ReplicatedUsing

- **åŠŸèƒ½æè¿°ï¼š** æŒ‡å®šä¸€ä¸ªé€šçŸ¥å›è°ƒå‡½æ•°ï¼Œåœ¨å±æ€§é€šè¿‡ç½‘ç»œæ›´æ–°åæ‰§è¡Œã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** string="abc"
- **å¼•æ“æ¨¡å—ï¼š** Network
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Net](../../../../Flags/EPropertyFlags/CPF_Net.md), [CPF_RepNotify](../../../../Flags/EPropertyFlags/CPF_RepNotify.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

ReplicatedUsing å¯ä»¥æ¥å—æ— å‚æ•°çš„å‡½æ•°ï¼Œæˆ–æ˜¯å¸¦ä¸€ä¸ªå‚æ•°çš„å‡½æ•°æºå¸¦æ—§å€¼ã€‚ä¸€èˆ¬åœ¨OnRepå‡½æ•°é‡Œï¼Œåšä¸€äº›å¼€å¯å…³é—­çš„ç›¸åº”æ“ä½œï¼Œæ¯”å¦‚enabledçš„å¤åˆ¶å°±ä¼šè§¦å‘ç›¸åº”çš„åç»­é€»è¾‘ã€‚

## æµ‹è¯•ä»£ç ï¼š

```jsx
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Network :public AActor
{
public:
	GENERATED_BODY()
protected:
	UFUNCTION()
		void OnRep_MyInt(int32 oldValue);
UPROPERTY(EditAnywhere, BlueprintReadWrite, ReplicatedUsing = OnRep_MyInt)
		int32 MyInt_ReplicatedUsing = 123;
};

void AMyProperty_Network::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AMyProperty_Network, MyInt_ReplicatedUsing);
}
```

åœ¨è“å›¾ä¸­ç­‰ä»·äºRepNotifyçš„ä½œç”¨ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Network\ReplicatedUsing\Untitled.png)

# RepRetry

- **åŠŸèƒ½æè¿°ï¼š** åªé€‚ç”¨äºç»“æ„ä½“å±æ€§ã€‚å¦‚æœæ­¤å±æ€§æœªèƒ½å®Œå…¨å‘é€ï¼ˆä¸¾ä¾‹è€Œè¨€ï¼šObjectå¼•ç”¨å°šæ— æ³•é€šè¿‡ç½‘ç»œè¿›è¡Œåºåˆ—åŒ–ï¼‰ï¼Œåˆ™é‡æ–°å°è¯•å¯¹å…¶çš„å¤åˆ¶ã€‚å¯¹ç®€å•å¼•ç”¨è€Œè¨€ï¼Œè¿™æ˜¯é»˜è®¤é€‰æ‹©ï¼›ä½†å¯¹ç»“æ„ä½“è€Œè¨€ï¼Œè¿™ä¼šäº§ç”Ÿå¸¦å®½å¼€é”€ï¼Œå¹¶éä¼˜é€‰é¡¹ã€‚å› æ­¤åœ¨æŒ‡å®šæ­¤æ ‡ç­¾ä¹‹å‰å…¶å‡ä¸ºç¦ç”¨çŠ¶æ€ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Network

# DuplicateTransient

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å¯¹è±¡å¤åˆ¶æˆ–COPYæ ¼å¼å¯¼å‡ºçš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_DuplicateTransient](../../../../Flags/EPropertyFlags/CPF_DuplicateTransient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…

åœ¨å¯¹è±¡å¤åˆ¶æˆ–COPYæ ¼å¼å¯¼å‡ºçš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Serialization :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_Transient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient)
		int32 MyInt_Transient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_DuplicateTransient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DuplicateTransient)
		int32 MyInt_DuplicateTransient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_NonPIEDuplicateTransient | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, NonPIEDuplicateTransient)
		int32 MyInt_NonPIEDuplicateTransient = 123;
};

void UMyProperty_Serialization_Test::RunTest()
{

	UMyProperty_Serialization* obj = NewObject<UMyProperty_Serialization>(GetTransientPackage());

	obj->MyInt_Default = 456;
	obj->MyInt_Transient = 456;
	obj->MyInt_DuplicateTransient = 456;
	obj->MyInt_NonPIEDuplicateTransient = 456;

	UMyProperty_Serialization* obj3= DuplicateObject<UMyProperty_Serialization>(obj,GetTransientPackage());
}

```

## ç¤ºä¾‹æ•ˆæœï¼š

å¤åˆ¶è“å›¾ï¼Œå¯ä»¥çœ‹åˆ°DuplicateTransientå¹¶ä¸ä¼šè¢«å¤åˆ¶

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\DuplicateTransient\Untitled.png)

åœ¨é‡‡ç”¨C++å¤åˆ¶çš„æ—¶å€™ï¼šä¹Ÿçœ‹åˆ°MyInt_DuplicateTransient å¹¶ä¸ä¼šäº§ç”Ÿå¤åˆ¶ï¼Œè¿˜æ˜¯123è€Œä¸æ˜¯456ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\DuplicateTransient\Untitled.png)

## åŸç†ï¼š

åœ¨æ–‡æœ¬å¯¼å‡ºçš„æ—¶å€™ï¼Œå¦‚æœæ˜¯T3Dæ ¼å¼ï¼Œåˆ™ä¾ç„¶ä¼šå¯¼å‡ºã€‚å¦‚æœæ˜¯COPYæ ¼å¼ï¼Œåˆ™ä¸å¯¼å‡ºã€‚

```cpp
bool FProperty::ShouldPort( uint32 PortFlags/*=0*/ ) const
{
// if we're copying, treat DuplicateTransient as transient
	if ((PortFlags & PPF_Copy) && HasAnyPropertyFlags(CPF_DuplicateTransient | CPF_TextExportTransient) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_IncludeTransient)))
	{
		return false;
	}
}
```

åœ¨äºŒè¿›åˆ¶åºåˆ—åŒ–çš„æ—¶å€™ï¼š

åªæœ‰åœ¨PPF_Duplicateç”Ÿæ•ˆçš„æ—¶å€™ï¼Œï¼ˆDuplicateObjectæˆ–è€…èµ„äº§å¤åˆ¶ï¼‰ï¼Œæ‰ä¼šè·³è¿‡è¯¥å±æ€§

```cpp
bool FProperty::ShouldSerializeValue(FArchive& Ar) const
{
// Skip properties marked DuplicateTransient when duplicating
	if ((PropertyFlags & CPF_DuplicateTransient) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}
}
```

åœ¨å¯¹èµ„äº§è¿›è¡ŒDuplidateçš„æ—¶å€™ï¼Œå‘ç”ŸDuplicateAssetç„¶åDuplicateObjectï¼Œè¿™ä¸ªæ—¶å€™PortFlags=PPF_Duplicateï¼Œç„¶åä¼šè§¦å‘ShouldSerializeValueè¿›è¡Œåˆ¤æ–­ã€‚è¿™ä¸ªæ—¶å€™ä¼šè·³è¿‡è¯¥å±æ€§

# Export

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å¯¹Assetå¯¼å‡ºçš„æ—¶å€™ï¼Œå†³å®šè¯¥ç±»çš„å¯¹è±¡åº”è¯¥å¯¼å‡ºå†…éƒ¨çš„å±æ€§å€¼ï¼Œè€Œæ˜¯å¯¹è±¡çš„è·¯å¾„ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **é™åˆ¶ç±»å‹ï¼š** Objectå±æ€§ï¼Œæˆ–Objectæ•°ç»„
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_ExportObject](../../../../Flags/EPropertyFlags/CPF_ExportObject.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨å¯¹Assetå¯¼å‡ºçš„æ—¶å€™ï¼Œå†³å®šè¯¥ç±»çš„å¯¹è±¡åº”è¯¥å¯¼å‡ºå†…éƒ¨çš„å±æ€§å€¼ï¼Œè€Œæ˜¯å¯¹è±¡çš„è·¯å¾„ã€‚

- è¯´æ˜Objectè¢«å¤åˆ¶æ—¶ï¼ˆä¾‹å¦‚å¤åˆ¶/ç²˜è´´æ“ä½œï¼‰æŒ‡å®šåˆ°æ­¤å±æ€§çš„Objectåº”æ•´ä½“å¯¼å‡ºä¸ºä¸€ä¸ªå­Objectå—ï¼ˆåæ–‡çš„ä¾‹å­é‡Œä¼šçœ‹åˆ°ï¼Œå…¶å®å°±æ˜¯ä¹Ÿè¾“å‡ºå†…éƒ¨å±æ€§çš„å€¼ï¼‰ï¼Œè€Œéåªæ˜¯è¾“å‡ºObjectå¼•ç”¨æœ¬èº«ã€‚
- åªé€‚ç”¨äºObjectå±æ€§ï¼ˆæˆ–Objectæ•°ç»„ï¼‰ï¼Œå› ä¸ºæ˜¯ç”¨åœ¨å¯¹è±¡çš„å¯¼å‡ºçš„ä¸Šçš„ã€‚
- å…¶å®å°±æ˜¯æµ…å¤åˆ¶å’Œæ·±å¤åˆ¶çš„åŒºåˆ«ã€‚ä¸æ ‡Exportå°±æ˜¯æµ…å¤åˆ¶ï¼Œåªè¾“å‡ºå¯¹è±¡è·¯å¾„ã€‚æ ‡ä¸ŠExportåæ˜¯æ·±å¤åˆ¶ï¼Œä¹Ÿè¾“å‡ºå¯¹è±¡çš„å†…éƒ¨å±æ€§ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```jsx
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_ExportObject :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyValue = 123;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Export :public UDataAsset
{
public:
public:
	GENERATED_BODY()
		UMyProperty_Export(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());
public:
	//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ExportObject | CPF_ZeroConstructor | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Export, Category = Behavior)
		UMyProperty_ExportObject* ObjectExport;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Behavior)
		UMyProperty_ExportObject* ObjectWithoutExport;
};
```

é…ç½®çš„å¯¹è±¡å€¼ï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\Export\Untitled.png)

ä¸»è¦æ˜¯ç”¨åœ¨Export æ“ä½œçš„æ—¶å€™ï¼Œç”¨æ¥å†³å®šå¦‚ä½•å¯¼å‡ºObject*å±æ€§çš„å†…å®¹ã€‚NoExportçš„è¯æ˜¯åªè¾“å‡ºå¯¹è±¡å¼•ç”¨çš„è·¯å¾„ï¼Œè€ŒExportçš„è¯ä¼šè¾“å‡ºè¿™ä¸ªå¯¹è±¡å…¶å†å†…éƒ¨çš„çš„å±æ€§å€¼ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\Export\Untitled%201.png)

å¯¼å‡ºçš„æ–‡æœ¬ï¼š

```jsx
Begin Object Class=/Script/Insider.MyProperty_Export Name="MyPropertyExportAsset" ExportPath=/Script/Insider.MyProperty_Export'"/Game/Property/MyPropertyExportAsset.MyPropertyExportAsset"'
   Begin Object Class=/Script/Insider.MyProperty_ExportObject Name="EO1" ExportPath=/Script/Insider.MyProperty_ExportObject'"/Game/Property/EO1.EO1"'
      "MyValue"=456
   End Object
   "ObjectExport"=/Script/Insider.MyProperty_ExportObject'"/Game/Property/EO1.EO1"'
   "ObjectWithoutExport"=/Script/Insider.MyProperty_ExportObject'"/Game/Property/EO2.EO2"'
End Object
```

å¯ä»¥çœ‹åˆ°ObjectExportçš„å¯¹è±¡ä¹Ÿå¯¼å‡ºçš„å­—æ®µå€¼ï¼Œä½†æ˜¯ObjectWithoutExportåªæœ‰è·¯å¾„ã€‚

## åŸç†ï¼š

æºç å†…ä½œç”¨çš„å‡½æ•°ï¼Œè¦æ³¨æ„ä¸€ç‚¹çš„æ˜¯ï¼Œè¦è®©Exportæ ‡è®°åœ¨ExportPropertiesèµ·ä½œç”¨ï¼Œexportæ ‡è®°ä¸èƒ½ç”¨åœ¨å¯¹è±¡çš„sub objectä¸Šï¼Œå¦åˆ™ä¼šèµ°ExportInnerObjectsçš„è°ƒç”¨è·¯çº¿ã€‚ä¸Šé¢ä¾‹å­ä¸­ObjectExportå’ŒObjectWithoutExportéƒ½æ˜¯æŒ‡å‘äº†å¤–éƒ¨çš„å¦å¤–ä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥ç”¨DataAssetæ¥äº§ç”Ÿèµ„äº§ã€‚

```cpp
void ExportProperties()
{
	FObjectPropertyBase* ExportObjectProp = (Property->PropertyFlags & CPF_ExportObject) != 0 ? CastField<FObjectPropertyBase>(Property) : NULL;
}
```

# NonPIEDuplicateTransient

- **åŠŸèƒ½æè¿°ï¼š** åœ¨å¯¹è±¡å¤åˆ¶çš„æ—¶å€™ï¼Œä¸”åœ¨ä¸æ˜¯PIEçš„åœºåˆï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_NonPIEDuplicateTransient](../../../../Flags/EPropertyFlags/CPF_NonPIEDuplicateTransient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨å¯¹è±¡å¤åˆ¶çš„æ—¶å€™ï¼Œä¸”åœ¨ä¸æ˜¯PIEçš„åœºåˆï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

- DuplicateTransientå’ŒNonPIEDuplicateTransientçš„åŒºåˆ«æ˜¯ï¼Œå‰è€…åœ¨ä»»ä½•æƒ…å†µçš„å¯¹è±¡å¤åˆ¶æ—¶éƒ½å¿½ç•¥è¯¥å±æ€§ï¼Œè€Œåè€…åœ¨PIEçš„æ—¶å€™ï¼ˆä¹Ÿæ˜¯åœ¨å‘ç”Ÿå¯¹è±¡å¤åˆ¶è¿‡ç¨‹ï¼‰ä¾ç„¶ä¼šå¤åˆ¶è¯¥å±æ€§ï¼Œå…¶ä»–æƒ…å†µä¸‹çš„å¤åˆ¶å’Œå‰è€…è¡Œä¸ºä¸€è‡´ã€‚
- PIEçš„æ—¶å€™æœ¬è´¨å°±æ˜¯æŠŠå½“å‰çš„ç¼–è¾‘Worldé‡ŒActorå¤åˆ¶ä¸€ä»½åˆ°PIEçš„ä¸–ç•Œé‡Œï¼Œä¼šè§¦å‘Actorçš„å¤åˆ¶ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

å‡†å¤‡äº†ä¸€ä»½DataAssetå’ŒActoræ¥åˆ†åˆ«éªŒè¯å¤åˆ¶è¡Œä¸ºçš„ä¸åŒã€‚

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Serialization :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_Transient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient)
		int32 MyInt_Transient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_DuplicateTransient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DuplicateTransient)
		int32 MyInt_DuplicateTransient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_NonPIEDuplicateTransient | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, NonPIEDuplicateTransient)
		int32 MyInt_NonPIEDuplicateTransient = 123;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API AMyProperty_Serialization_TestActor :public AActor
{
public:
	GENERATED_BODY()
protected:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_Transient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient)
		int32 MyInt_Transient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_DuplicateTransient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DuplicateTransient)
		int32 MyInt_DuplicateTransient = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, NonPIEDuplicateTransient)
		int32 MyInt_NonPIEDuplicateTransient = 123;
};
```

## ç¤ºä¾‹æ•ˆæœï¼š

åœ¨å¯¹èµ„äº§è¿›è¡ŒDuplidateçš„æ—¶å€™ï¼Œå‘ç”ŸDuplicateAssetç„¶åDuplicateObjectï¼Œè¿™ä¸ªæ—¶å€™PortFlags=PPF_Duplicateï¼Œç„¶åä¼šè§¦å‘ShouldSerializeValueè¿›è¡Œåˆ¤æ–­ã€‚è¿™ä¸ªæ—¶å€™ä¼šè·³è¿‡è¯¥å±æ€§ã€‚

å¯ä»¥çœ‹åˆ°NonPIEDuplicateTransientå¹¶ä¸ä¼šè¢«å¤åˆ¶ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\NonPIEDuplicateTransient\Untitled.png)

åœ¨ç‚¹å‡»PIEçš„æ—¶å€™ï¼Œå¯ä»¥çœ‹åˆ°NonPIEDuplicateTransientè¿™ä¸ªæ—¶å€™å´æ˜¯ä¼šå¤åˆ¶å€¼è¿‡å»äº†ã€‚è¿™æ˜¯å› ä¸ºè¿™ä¸ªæ—¶å€™PortFlags=PPF_DuplicateForPIE&PPF_Duplicate

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\NonPIEDuplicateTransient\Untitled%201.png)

ç»“è®ºæ˜¯ç”¨äºä¸€äº›Cacheæ•°æ®ï¼Œåœ¨å¤åˆ¶çš„æ—¶å€™å¹¶ä¸éœ€è¦åºåˆ—åŒ–å¤åˆ¶ï¼Œè¿™æ ·å¯ä»¥é˜»æ­¢ä¸¤ä¸ªä¸åŒçš„Actoré‡‡ç”¨åŒä¸€ä»½è®¡ç®—åçš„ä¸´æ—¶æ•°æ®ã€‚ä½†æ˜¯åˆå¯ä»¥åœ¨PIEçš„æ—¶å€™ï¼Œè®©Actorå„è‡ªé‡‡ç”¨è‡ªå·±çš„ä¸€ä»½æ•°æ®ï¼Œå› ä¸ºPIEçš„æ—¶å€™ï¼Œæœ¬è´¨å°±æ˜¯æŠŠå½“å‰çš„ç¼–è¾‘Worldé‡ŒActorå¤åˆ¶ä¸€ä»½åˆ°PIEçš„ä¸–ç•Œé‡Œï¼Œä¼šè§¦å‘Actorçš„å¤åˆ¶ã€‚

## åŸç†ï¼š

åœ¨æ–‡æœ¬å¯¼å‡ºçš„çš„æ—¶å€™ï¼Œåœ¨ä¸æ˜¯PIEé‡Œçš„å¤åˆ¶çš„æ—¶å€™ï¼Œä¸åºåˆ—åŒ–è¯¥å±æ€§ã€‚

```cpp
bool FProperty::ShouldPort( uint32 PortFlags/*=0*/ ) const
{
// if we're not copying for PIE and NonPIETransient is set, don't export
	if (!(PortFlags & PPF_DuplicateForPIE) && HasAnyPropertyFlags(CPF_NonPIEDuplicateTransient))
	{
		return false;
	}
}
```

åœ¨äºŒè¿›åˆ¶åºåˆ—åŒ–çš„æ—¶å€™ï¼š

åªæœ‰åœ¨PPF_Duplicateç”Ÿæ•ˆçš„æ—¶å€™ï¼Œï¼ˆDuplicateObject?æˆ–è€…èµ„äº§å¤åˆ¶ï¼‰ï¼Œæ‰ä¼šè·³è¿‡è¯¥å±æ€§ã€‚ä½†æ˜¯åœ¨PIEçš„æ—¶å€™ï¼Œåˆè¦ç»§ç»­åºåˆ—åŒ–ã€‚

```cpp
bool FProperty::ShouldSerializeValue(FArchive& Ar) const
{
// Skip properties marked NonPIEDuplicateTransient when duplicating, but not when we're duplicating for PIE
	if ((PropertyFlags & CPF_NonPIEDuplicateTransient) && !(Ar.GetPortFlags() & PPF_DuplicateForPIE) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}
}
```

# SaveGame

- **åŠŸèƒ½æè¿°ï¼š** åœ¨SaveGameå­˜æ¡£çš„æ—¶å€™ï¼Œåªåºåˆ—åŒ–æœ‰SaveGameæ ‡è®°çš„å±æ€§ï¼Œè€Œä¸åºåˆ—åŒ–åˆ«çš„å±æ€§ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…â˜…

åœ¨SaveGameå­˜æ¡£çš„æ—¶å€™ï¼Œåªåºåˆ—åŒ–æœ‰SaveGameæ ‡è®°çš„å±æ€§ï¼Œè€Œä¸åºåˆ—åŒ–åˆ«çš„å±æ€§ã€‚

ç‰¹åˆ«çš„æ ‡è¯†å“ªäº›å±æ€§æ˜¯ç”¨äºå­˜æ¡£ä¿å­˜çš„ã€‚

å¯¹äºå­ç»“æ„æˆ–å­å¯¹è±¡å±æ€§ï¼Œä¹Ÿå¿…é¡»è¦åŠ ä¸ŠSaveGameæ ‡è®°ã€‚

NoExportTypes.hé‡Œçš„å¾ˆå¤šåŸºç¡€ç»“æ„å†…éƒ¨å±æ€§éƒ½è¢«æ ‡ä¸Šäº†SaveGameã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
struct FMySaveGameArchive : public FObjectAndNameAsStringProxyArchive
{
    FMySaveGameArchive (FArchive& InInnerArchive)
        :   FObjectAndNameAsStringProxyArchive(InInnerArchive)
    { 
        ArIsSaveGame = true;
    }
};

USTRUCT(BlueprintType)
struct FMySaveGameStruct
{
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		FString MyString_Default;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,SaveGame)
		FString MyString_SaveGame;
};

UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_SaveGame :public USaveGame
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;
	//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_SaveGame | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)
		int32 MyInt_SaveGame = 123;
	UPROPERTY(EditAnywhere, BlueprintReadWrite,SaveGame)
		FMySaveGameStruct MyStruct;
};

UMyProperty_SaveGame* UMyProperty_SaveGame_Test::LoadGameFromMemory(const TArray<uint8>& InSaveData)
{
	FMemoryReader MemoryReader(InSaveData, true);

	FObjectAndNameAsStringProxyArchive Ar(MemoryReader, true);
		Ar.ArIsSaveGame = true;//å¿…é¡»æ‰‹åŠ¨åŠ ä¸Šè¿™ä¸ªæ ‡è®°

	UMyProperty_SaveGame* OutSaveGameObject = NewObject<UMyProperty_SaveGame>(GetTransientPackage(), UMyProperty_SaveGame::StaticClass());
	OutSaveGameObject->Serialize(Ar);

	return OutSaveGameObject;
}

bool UMyProperty_SaveGame_Test::SaveGameToMemory(UMyProperty_SaveGame* SaveGameObject, TArray<uint8>& OutSaveData)
{
	FMemoryWriter MemoryWriter(OutSaveData, true);

	// Then save the object state, replacing object refs and names with strings
	FObjectAndNameAsStringProxyArchive Ar(MemoryWriter, false);
	Ar.ArIsSaveGame = true;//å¿…é¡»æ‰‹åŠ¨åŠ ä¸Šè¿™ä¸ªæ ‡è®°
	SaveGameObject->Serialize(Ar);

	return true; // Not sure if there's a failure case here.
}

void UMyProperty_SaveGame_Test::RunTest()
{
	UMyProperty_SaveGame* saveGame = Cast<UMyProperty_SaveGame>(UGameplayStatics::CreateSaveGameObject(UMyProperty_SaveGame::StaticClass()));
	saveGame->MyInt_Default = 456;
	saveGame->MyInt_SaveGame = 456;
	saveGame->MyStruct.MyString_Default = TEXT("Hello");
	saveGame->MyStruct.MyString_SaveGame = TEXT("Hello");

	TArray<uint8> outBytes;
	UMyProperty_SaveGame_Test::SaveGameToMemory(saveGame, outBytes);

	UMyProperty_SaveGame* saveGame2 = UMyProperty_SaveGame_Test::LoadGameFromMemory(outBytes);
}
```

æµ‹è¯•ç»“æœï¼Œåªæœ‰SaveGameæ ‡è®°çš„å±æ€§è¿™ä¸ªå€¼æ‰åºåˆ—åŒ–è¿›å»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\SaveGame\Untitled.png)

ç­‰ä»·äºåœ¨è“å›¾çš„ç»†èŠ‚é¢æ¿é‡Œè¡¨ç¤ºï¼š

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\SaveGame\Untitled%201.png)

## åŸç†ï¼š

åªåœ¨ArIsSaveGameçš„æ—¶å€™æ£€æµ‹è¿™ä¸ªæ ‡è®°ï¼Œæ„å‘³ç€è¿™ä¸ªæ ‡è®°åªåœ¨æ£€æµ‹USaveGameçš„å¯¹è±¡çš„å­å¯¹è±¡ç»“æ„å±æ€§çš„æ—¶å€™æ‰ç”¨ã€‚ä½†æ˜¯ArIsSaveGameéœ€è¦è‡ªå·±æ‰‹åŠ¨è®¾ç½®ä¸ºtrueï¼Œå¦åˆ™é»˜è®¤è¿™ä¸ªæœºåˆ¶æ˜¯ä¸å·¥ä½œçš„ã€‚å®ç°çš„ä¸€ç§æ–¹å¼æ˜¯è‡ªå·±æ‰‹åŠ¨åŠ ä¸Šä¸€å¥Ar.ArIsSaveGame = true;ï¼Œæˆ–è€…è‡ªå·±è‡ªå®šä¹‰ä¸€ä¸ªFMySaveGameArchiveæ¥è¿›è¡Œåºåˆ—åŒ–ã€‚

åœ¨æºç é‡Œå‘ç°UEnhancedInputUserSettingsä¹Ÿæ˜¯ç»§æ‰¿äºUSaveGameï¼Œé‡‡ç”¨å­˜æ¡£çš„æ–¹å¼ä¿å­˜çš„ã€‚

```cpp
bool FProperty::ShouldSerializeValue(FArchive& Ar) const
{
	// Skip the property if the archive says we should
	if (Ar.ShouldSkipProperty(this))
	{
		return false;
	}

	// Skip non-SaveGame properties if we're saving game state
	if (!(PropertyFlags & CPF_SaveGame) && Ar.IsSaveGame())
	{
		return false;
	}

	const uint64 SkipFlags = CPF_Transient | CPF_DuplicateTransient | CPF_NonPIEDuplicateTransient | CPF_NonTransactional | CPF_Deprecated | CPF_DevelopmentAssets | CPF_SkipSerialization;
	if (!(PropertyFlags & SkipFlags))
	{
		return true;
	}

	// Skip properties marked Transient when persisting an object, unless we're saving an archetype
	if ((PropertyFlags & CPF_Transient) && Ar.IsPersistent() && !Ar.IsSerializingDefaults())
	{
		return false;
	}

	// Skip properties marked DuplicateTransient when duplicating
	if ((PropertyFlags & CPF_DuplicateTransient) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}

	// Skip properties marked NonPIEDuplicateTransient when duplicating, but not when we're duplicating for PIE
	if ((PropertyFlags & CPF_NonPIEDuplicateTransient) && !(Ar.GetPortFlags() & PPF_DuplicateForPIE) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}

	// Skip properties marked NonTransactional when transacting
	if ((PropertyFlags & CPF_NonTransactional) && Ar.IsTransacting())
	{
		return false;
	}

	// Skip deprecated properties when saving or transacting, unless the archive has explicitly requested them
	if ((PropertyFlags & CPF_Deprecated) && !Ar.HasAllPortFlags(PPF_UseDeprecatedProperties) && (Ar.IsSaving() || Ar.IsTransacting() || Ar.WantBinaryPropertySerialization()))
	{
		return false;
	}

	// Skip properties marked SkipSerialization, unless the archive is forcing them
	if ((PropertyFlags & CPF_SkipSerialization) && (Ar.WantBinaryPropertySerialization() || !Ar.HasAllPortFlags(PPF_ForceTaggedSerialization)))
	{
		return false;
	}

	// Skip editor-only properties when the archive is rejecting them
	if (IsEditorOnlyProperty() && Ar.IsFilterEditorOnly())
	{
		return false;
	}

	// Otherwise serialize!
	return true;
}
```

# SkipSerialization

- **åŠŸèƒ½æè¿°ï¼š** äºŒè¿›åˆ¶åºåˆ—åŒ–æ—¶è·³è¿‡è¯¥å±æ€§ï¼Œä½†åœ¨ExportTextçš„æ—¶å€™ä¾ç„¶å¯ä»¥å¯¼å‡ºã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_SkipSerialization](../../../../Flags/EPropertyFlags/CPF_SkipSerialization.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…

åœ¨è¿›è¡Œæ™®é€šçš„äºŒè¿›åˆ¶åºåˆ—åŒ–çš„æ—¶å€™ï¼Œè¿™ä¸ªæ ‡è®°ä¼šé˜»æ­¢åºåˆ—åŒ–ã€‚ä½œç”¨å’ŒTransientä¸€æ ·ã€‚ä½†å¦‚æœæ˜¯ExportTextï¼Œåˆ™ä¾ç„¶å¯ä»¥æŠŠè¯¥å±æ€§å¯¼å‡ºã€‚å…¶å†…éƒ¨ç”¨çš„ExportPropertiesã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_SerializationText :public UObject
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default= 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic | CPF_SkipSerialization 
	UPROPERTY(EditAnywhere, BlueprintReadWrite,SkipSerialization)
		int32 MyInt_SkipSerialization = 123;
};

void UMyProperty_SerializationText_Test::RunTest()
{
	UMyProperty_SerializationText* obj = NewObject<UMyProperty_SerializationText>(GetTransientPackage());

	obj->MyInt_Default = 456;
	obj->MyInt_SkipSerialization = 456;

	//save obj
	TArray<uint8> outBytes;
	FMemoryWriter MemoryWriter(outBytes, true);
	FObjectAndNameAsStringProxyArchive Ar(MemoryWriter, false);
	obj->Serialize(Ar);

	//load
	FMemoryReader MemoryReader(outBytes, true);

	FObjectAndNameAsStringProxyArchive Ar2(MemoryReader, true);

	UMyProperty_SerializationText* obj2 = NewObject<UMyProperty_SerializationText>(GetTransientPackage());
	obj2->Serialize(Ar2);
}
```

æ­¤æ—¶å¯è§æµ‹è¯•ç»“æœï¼Œè¯¥å±æ€§å¹¶æ²¡æœ‰è¢«åºåˆ—åŒ–è¿›å»ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\SkipSerialization\Untitled.png)

å¦‚æœé‡‡ç”¨ExportTextå¯¼å‡ºï¼šT3Dæˆ–COPYæ ¼å¼éƒ½è¡Œ

```cpp
UMyProperty_SerializationText* obj = NewObject<UMyProperty_SerializationText>(GetTransientPackage());

obj->MyInt_Default = 456;
obj->MyInt_SkipSerialization = 456;

FStringOutputDevice Ar;
UExporter::ExportToOutputDevice(nullptr, obj, nullptr,Ar,TEXT("T3D"), 3);
```

åˆ™è¾“å‡ºç»“æœä¸ºï¼š

```cpp
Begin Object Class=/Script/Insider.MyProperty_SerializationText Name="MyProperty_SerializationText_0" ExportPath=/Script/Insider.MyProperty_SerializationText'"/Engine/Transient.MyProperty_SerializationText_0"'
    MyInt_Default=456
    MyInt_SkipSerialization=456
 End Object
```

å¦å¤–å¦‚æœåœ¨ç¼–è¾‘å™¨é‡Œå³å‡»å¤åˆ¶

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\SkipSerialization\Untitled%201.png)

ä¹Ÿå¯ä»¥äº§ç”Ÿæ–‡æœ¬çš„å¯¼å‡ºï¼š

```cpp
{
	"Tagged": [
		[
			"MyInt_Default",
			"456"
		],
		[
			"MyInt_SkipSerialization",
			"456"
		]
	]
}
```

## åŸç†ï¼š

æ³¨æ„åœ¨åˆ¤æ–­ä¸€ä¸ªPropertyæ˜¯å¦åº”è¯¥åºåˆ—åŒ–çš„æ—¶å€™ï¼ŒShouldSerializeValueå‡½æ•°æ˜¯ç”¨åœ¨æ™®é€šçš„åºåˆ—åŒ–çš„æ—¶å€™ç”¨æ¥åˆ¤æ–­çš„ã€‚è€Œåœ¨ExportTextçš„æ—¶å€™ï¼Œæ˜¯ç”¨ShouldPortåˆ¤æ–­çš„ã€‚

# TextExportTransient

- **åŠŸèƒ½æè¿°ï¼š** åœ¨ExportTextå¯¼å‡ºä¸º.COPYæ ¼å¼çš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_TextExportTransient](../../../Flags/EPropertyFlags/CPF_TextExportTransient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…

åœ¨ExportTextå¯¼å‡ºä¸º.COPYæ ¼å¼çš„æ—¶å€™ï¼Œå¿½ç•¥è¯¥å±æ€§ã€‚

ä½†é¼ æ ‡å¤åˆ¶æ‹·è´å±æ€§ä¾ç„¶ä¼šæœ‰æ–‡æœ¬å¯¼å‡ºç”Ÿæ•ˆã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_SerializationText :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default= 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic | CPF_SkipSerialization 
	UPROPERTY(EditAnywhere, BlueprintReadWrite,SkipSerialization)
		int32 MyInt_SkipSerialization = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_TextExportTransient | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite,TextExportTransient)
		int32 MyInt_TextExportTransient= 123;

};

void UMyProperty_SerializationText_Test::RunExportTest()
{
	UMyProperty_SerializationText* obj = NewObject<UMyProperty_SerializationText>(GetTransientPackage());

	obj->MyInt_Default = 456;
	obj->MyInt_SkipSerialization = 456;
	obj->MyInt_TextExportTransient = 456;

	FStringOutputDevice Ar;
	UExporter::ExportToOutputDevice(nullptr, obj, nullptr,Ar,TEXT("T3D"), 3);

	FStringOutputDevice Ar2;
	UExporter::ExportToOutputDevice(nullptr, obj, nullptr,Ar,TEXT("COPY"), 3);

	FString str=Ar;
}
```

å¯¼å‡ºçš„ç»“æœï¼š

```cpp
T3Dæ ¼å¼ï¼š
Begin Object Class=/Script/Insider.MyProperty_SerializationText Name="BP_SerializationText" ExportPath="/Script/Insider.MyProperty_SerializationText'/Game/Property/BP_SerializationText.BP_SerializationText'"
   MyInt_Default=456
   MyInt_SkipSerialization=456
   MyInt_TextExportTransient=456
End Object

COPYæ ¼å¼ï¼š
Begin Object Class=/Script/Insider.MyProperty_SerializationText Name="BP_SerializationText" ExportPath="/Script/Insider.MyProperty_SerializationText'/Game/Property/BP_SerializationText.BP_SerializationText'"
   MyInt_Default=456
   MyInt_SkipSerialization=456
End Object
```

å¤åˆ¶æ‹·è´ä¾ç„¶ä¼šæœ‰æ–‡æœ¬ç”Ÿæ•ˆï¼š

```cpp
{
	"Tagged": [
		[
			"MyInt_Default",
			"456"
		],
		[
			"MyInt_SkipSerialization",
			"456"
		],
		[
			"MyInt_TextExportTransient",
			"456"
		]
	]
}
```

å› æ­¤å¯ä»¥å‘ç°åœ¨COPYæ ¼å¼çš„æ—¶å€™ï¼ŒMyInt_TextExportTransientå¹¶æ²¡æœ‰è¢«å¯¼å‡ºã€‚

## åŸç†ï¼š

æ³¨æ„åœ¨åˆ¤æ–­ä¸€ä¸ªPropertyæ˜¯å¦åº”è¯¥åºåˆ—åŒ–çš„æ—¶å€™ï¼ŒShouldSerializeValueå‡½æ•°æ˜¯ç”¨åœ¨æ™®é€šçš„åºåˆ—åŒ–çš„æ—¶å€™ç”¨æ¥åˆ¤æ–­çš„ã€‚è€Œåœ¨ExportTextçš„æ—¶å€™ï¼Œæ˜¯ç”¨ShouldPortåˆ¤æ–­çš„ã€‚

ä½†æ˜¯å¦‚æœåºåˆ—åŒ–å‡ºçš„æ ¼å¼æ˜¯COPYï¼Œåœ¨è®¾ç½®PortFlagsçš„æ—¶å€™ï¼Œä¼šé¢å¤–çš„åŠ ä¸ŠPPF_Copyã€‚å› æ­¤åœ¨åç»­çš„åˆ¤æ–­é‡Œæ‰ä¼šç”Ÿæ•ˆå¯¹CPF_TextExportTransientçš„åˆ¤æ–­ã€‚

```cpp
if ( FCString::Stricmp(FileType, TEXT("COPY")) == 0 )
	{
		// some code which doesn't have access to the exporter's file type needs to handle copy/paste differently than exporting to file,
		// so set the export flag accordingly
		PortFlags |= PPF_Copy;
	}

//
// Return whether the property should be exported.
//
bool FProperty::ShouldPort( uint32 PortFlags/*=0*/ ) const
{
	// if no size, don't export
	if (GetSize() <= 0)
	{
		return false;
	}

	if (HasAnyPropertyFlags(CPF_Deprecated) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_UseDeprecatedProperties)))
	{
		return false;
	}

	// if we're parsing default properties or the user indicated that transient properties should be included
	if (HasAnyPropertyFlags(CPF_Transient) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_IncludeTransient)))
	{
		return false;
	}

	// if we're copying, treat DuplicateTransient as transient
	if ((PortFlags & PPF_Copy) && HasAnyPropertyFlags(CPF_DuplicateTransient | CPF_TextExportTransient) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_IncludeTransient)))
	{
		return false;
	}

	// if we're not copying for PIE and NonPIETransient is set, don't export
	if (!(PortFlags & PPF_DuplicateForPIE) && HasAnyPropertyFlags(CPF_NonPIEDuplicateTransient))
	{
		return false;
	}

	// if we're only supposed to export components and this isn't a component property, don't export
	if ((PortFlags & PPF_SubobjectsOnly) && !ContainsInstancedObjectProperty())
	{
		return false;
	}

	// hide non-Edit properties when we're exporting for the property window
	if ((PortFlags & PPF_PropertyWindow) && !(PropertyFlags & CPF_Edit))
	{
		return false;
	}

	return true;
}
```

# Transient

- **åŠŸèƒ½æè¿°ï¼š** ä¸åºåˆ—åŒ–è¯¥å±æ€§ï¼Œè¯¥å±æ€§åˆå§‹åŒ–æ—¶å€™ä¼šè¢«0å¡«å……ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Serialization
- **ä½œç”¨æœºåˆ¶ï¼š** åœ¨PropertyFlagsä¸­åŠ å…¥[CPF_Transient](../../../../Flags/EPropertyFlags/CPF_Transient.md)
- **å¸¸ç”¨ç¨‹åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…**

åºåˆ—åŒ–çš„æ—¶å€™ç•¥è¿‡è¯¥å±æ€§ï¼Œç”¨0æ¥å¡«å……é»˜è®¤å€¼ã€‚

äºŒè¿›åˆ¶å’Œæ–‡æœ¬éƒ½ä¸åºåˆ—åŒ–è¯¥å±æ€§ã€‚

ä¸€èˆ¬ç”¨äºä¸€äº›ä¸´æ—¶ä¸­é—´å˜é‡æˆ–è®¡ç®—åçš„ç»“æœå˜é‡ã€‚

## ç¤ºä¾‹ä»£ç ï¼š

```cpp
UCLASS(Blueprintable, BlueprintType)
class INSIDER_API UMyProperty_Serialization :public UDataAsset
{
public:
	GENERATED_BODY()
public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
		int32 MyInt_Default = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_Transient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Transient)
		int32 MyInt_Transient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_DuplicateTransient | CPF_IsPlainOldData | CPF_NoDestructor | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DuplicateTransient)
		int32 MyInt_DuplicateTransient = 123;
		//PropertyFlags:	CPF_Edit | CPF_BlueprintVisible | CPF_ZeroConstructor | CPF_IsPlainOldData | CPF_NoDestructor | CPF_NonPIEDuplicateTransient | CPF_HasGetValueTypeHash | CPF_NativeAccessSpecifierPublic 
	UPROPERTY(EditAnywhere, BlueprintReadWrite, NonPIEDuplicateTransient)
		int32 MyInt_NonPIEDuplicateTransient = 123;
};
void UMyProperty_Serialization_Test::RunTest()
{
	UMyProperty_Serialization* obj = NewObject<UMyProperty_Serialization>(GetTransientPackage());

	obj->MyInt_Default = 456;
	obj->MyInt_Transient = 456;
	obj->MyInt_DuplicateTransient = 456;
	obj->MyInt_NonPIEDuplicateTransient = 456;

	//save obj
	TArray<uint8> outBytes;
	FMemoryWriter MemoryWriter(outBytes, true);
	FObjectAndNameAsStringProxyArchive Ar(MemoryWriter, false);
	obj->Serialize(Ar);

	//load
	FMemoryReader MemoryReader(outBytes, true);

	FObjectAndNameAsStringProxyArchive Ar2(MemoryReader, true);

	UMyProperty_Serialization* obj2 = NewObject<UMyProperty_Serialization>(GetTransientPackage());
	obj2->Serialize(Ar2);
}
```

å¯¹è¿™ä¹ˆä¸€ä¸ªBP DataAssetè¿›è¡ŒAssetActionsâ†’Exportï¼Œ

T3Dæ ¼å¼ï¼š

```cpp
Begin Object Class=/Script/Insider.MyProperty_Serialization Name="BP_Serialization" ExportPath="/Script/Insider.MyProperty_Serialization'/Game/Property/BP_Serialization.BP_Serialization'"
   MyInt_Default=456
   MyInt_DuplicateTransient=456
End Object
```

COPYæ ¼å¼ï¼š

```cpp
Begin Object Class=/Script/Insider.MyProperty_Serialization Name="BP_Serialization" ExportPath="/Script/Insider.MyProperty_Serialization'/Game/Property/BP_Serialization.BP_Serialization'"
   MyInt_Default=456
End Object
```

å¦‚æœæ˜¯æ™®é€šçš„åºåˆ—åŒ–ï¼š

å¯è§obj2çš„MyInt_Transient å±æ€§å¹¶æ²¡æœ‰ä»åºåˆ—åŒ–ä¸­è·å¾—æ–°å€¼456.

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\Transient\Untitled.png)

## åŸç†ä»£ç ï¼š

åˆ¤æ–­CPF_Transientçš„ç”Ÿæ•ˆï¼Œåªæœ‰åœ¨IsPersistent()çš„æ—¶å€™ï¼Œå¹¶ä¸”ä¸æ˜¯åœ¨ä¿å­˜CDOã€‚SetIsPersistent()çš„è°ƒç”¨åœ¨å¾ˆå¤šåœ°æ–¹éƒ½å‡ºç°ï¼Œæ¯”å¦‚åœ¨MemoryReader/MemoryWriteréƒ½æ˜¯IsPersistentã€‚

å› æ­¤Transientæ˜¯åœ¨åºåˆ—åŒ–çš„æ—¶å€™ä¼šè¢«å¿½ç•¥ã€‚

åœ¨ExportTextçš„æ—¶å€™å‘ç°ä¼šè¿›è¡ŒCPF_Transientçš„åˆ¤æ–­ï¼Œé™¤éå¼ºåˆ¶è¿›è¡ŒåŒ…æ‹¬PPF_IncludeTransient

```cpp
bool FProperty::ShouldSerializeValue(FArchive& Ar) const
{
	// Skip the property if the archive says we should
	if (Ar.ShouldSkipProperty(this))
	{
		return false;
	}

	// Skip non-SaveGame properties if we're saving game state
	if (!(PropertyFlags & CPF_SaveGame) && Ar.IsSaveGame())
	{
		return false;
	}

	const uint64 SkipFlags = CPF_Transient | CPF_DuplicateTransient | CPF_NonPIEDuplicateTransient | CPF_NonTransactional | CPF_Deprecated | CPF_DevelopmentAssets | CPF_SkipSerialization;
	if (!(PropertyFlags & SkipFlags))
	{
		return true;
	}

	// Skip properties marked Transient when persisting an object, unless we're saving an archetype
	if ((PropertyFlags & CPF_Transient) && Ar.IsPersistent() && !Ar.IsSerializingDefaults())
	{

		return false;
	}

	// Skip properties marked DuplicateTransient when duplicating
	if ((PropertyFlags & CPF_DuplicateTransient) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}

	// Skip properties marked NonPIEDuplicateTransient when duplicating, but not when we're duplicating for PIE
	if ((PropertyFlags & CPF_NonPIEDuplicateTransient) && !(Ar.GetPortFlags() & PPF_DuplicateForPIE) && (Ar.GetPortFlags() & PPF_Duplicate))
	{
		return false;
	}

	// Skip properties marked NonTransactional when transacting
	if ((PropertyFlags & CPF_NonTransactional) && Ar.IsTransacting())
	{
		return false;
	}

	// Skip deprecated properties when saving or transacting, unless the archive has explicitly requested them
	if ((PropertyFlags & CPF_Deprecated) && !Ar.HasAllPortFlags(PPF_UseDeprecatedProperties) && (Ar.IsSaving() || Ar.IsTransacting() || Ar.WantBinaryPropertySerialization()))
	{
		return false;
	}

	// Skip properties marked SkipSerialization, unless the archive is forcing them
	if ((PropertyFlags & CPF_SkipSerialization) && (Ar.WantBinaryPropertySerialization() || !Ar.HasAllPortFlags(PPF_ForceTaggedSerialization)))
	{
		return false;
	}

	// Skip editor-only properties when the archive is rejecting them
	if (IsEditorOnlyProperty() && Ar.IsFilterEditorOnly())
	{
		return false;
	}

	// Otherwise serialize!
	return true;
}

///////////////////////////////////////////
bool FProperty::ShouldPort( uint32 PortFlags/*=0*/ ) const
{
	// if no size, don't export
	if (GetSize() <= 0)
	{
		return false;
	}

	if (HasAnyPropertyFlags(CPF_Deprecated) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_UseDeprecatedProperties)))
	{
		return false;
	}

	// if we're parsing default properties or the user indicated that transient properties should be included
	if (HasAnyPropertyFlags(CPF_Transient) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_IncludeTransient)))
	{
		return false;
	}

	// if we're copying, treat DuplicateTransient as transient
	if ((PortFlags & PPF_Copy) && HasAnyPropertyFlags(CPF_DuplicateTransient | CPF_TextExportTransient) && !(PortFlags & (PPF_ParsingDefaultProperties | PPF_IncludeTransient)))
	{
		return false;
	}

	// if we're not copying for PIE and NonPIETransient is set, don't export
	if (!(PortFlags & PPF_DuplicateForPIE) && HasAnyPropertyFlags(CPF_NonPIEDuplicateTransient))
	{
		return false;
	}

	// if we're only supposed to export components and this isn't a component property, don't export
	if ((PortFlags & PPF_SubobjectsOnly) && !ContainsInstancedObjectProperty())
	{
		return false;
	}

	// hide non-Edit properties when we're exporting for the property window
	if ((PortFlags & PPF_PropertyWindow) && !(PropertyFlags & CPF_Edit))
	{
		return false;
	}

	return true;
}
```

å› ä¸ºä¸åºåˆ—Transientå±æ€§ï¼Œå› æ­¤è¯¥å±æ€§ä¿®æ”¹å€¼ä¹Ÿå¹¶ä¸ä¼šè¢«ä¿å­˜èµ·æ¥ã€‚æ‰“å¼€Assetçš„æ—¶å€™ä¾ç„¶ä¼šæ˜¯é»˜è®¤å€¼ï¼Œä¹Ÿå¹¶ä¸ä¼šè¢«å¤åˆ¶ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\Serialization\Transient\Untitled%201.png)

# FieldNotify

- **åŠŸèƒ½æè¿°ï¼š** åœ¨æ‰“å¼€MVVMæ’ä»¶åï¼Œä½¿å¾—è¯¥å±æ€§å˜æˆæ”¯æŒFieldNotifyçš„å±æ€§ã€‚

- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** MVVM, UHT
- **é™åˆ¶ç±»å‹ï¼š** ViewModelé‡Œçš„å±æ€§
- **å¸¸ç”¨ç¨‹åº¦ï¼š** â˜…â˜…â˜…â˜…

åœ¨æ‰“å¼€MVVMæ’ä»¶åï¼Œä½¿å¾—è¯¥å±æ€§å˜æˆæ”¯æŒFieldNotifyçš„å±æ€§ã€‚

## æµ‹è¯•ä»£ç ï¼š

```cpp
UCLASS(BlueprintType)
class INSIDER_API UMyViewModel :public UMVVMViewModelBase
{
	GENERATED_BODY()
protected:
	UPROPERTY(BlueprintReadWrite, FieldNotify, Getter, Setter, BlueprintSetter = SetHP)
	float HP = 1.f;

	UPROPERTY(BlueprintReadWrite, FieldNotify, Getter, Setter, BlueprintSetter = SetMaxHP)
	float MaxHP = 100.f;
public:
	float GetHP()const { return HP; }
	UFUNCTION(BlueprintSetter)
	void SetHP(float val)
	{
		if (UE_MVVM_SET_PROPERTY_VALUE(HP, val))
		{
			UE_MVVM_BROADCAST_FIELD_VALUE_CHANGED(GetHPPercent);
		}
	}

	float GetMaxHP()const { return MaxHP; }
	UFUNCTION(BlueprintSetter)
	void SetMaxHP(float val)
	{
		if (UE_MVVM_SET_PROPERTY_VALUE(MaxHP, val))
		{
			UE_MVVM_BROADCAST_FIELD_VALUE_CHANGED(GetHPPercent);
		}
	}

	//You need to manually notify that GetHealthPercent changed when CurrentHealth or MaxHealth changed.
	UFUNCTION(BlueprintPure, FieldNotify)
	float GetHPPercent() const
	{
		return (MaxHP != 0.f) ? HP / MaxHP : 0.f;
	}
};

```

## æµ‹è¯•æ•ˆæœï¼š

æ•ˆæœä¸€æ–¹é¢æ˜¯UHTç”Ÿæˆçš„.generated.hé‡Œå’Œ.gen.cppé‡Œçš„ä»£ç ï¼Œå…·ä½“çš„å®ä½œç”¨å°±ä¸å±•å¼€äº†ï¼Œå¤§å®¶å¯æŸ¥çœ‹å…¶ä»–æ›´ç»†è‡´çš„MVVMç›¸å…³æ–‡ç« ã€‚è¿™é‡Œåªè¦çŸ¥é“UHTä¼šä¸ºæ ‡äº†FieldNotifyçš„å±æ€§å®šä¹‰FFieldIdä»¥åŠFFieldNotificationClassDescriptoræ¥æ ‡è¯†ä¸€ä¸ªæ¥å—å¯é€šçŸ¥çš„å±æ€§ã€‚

```cpp
//MyViewModel.generated.h
#define FID_GitWorkspace_Hello_Source_Insider_Property_MVVM_MyViewModel_h_12_FIELDNOTIFY \
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_BEGIN(INSIDER_API ) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(HP) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(MaxHP) \
	UE_FIELD_NOTIFICATION_DECLARE_FIELD(GetHPPercent) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_BEGIN(HP) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(MaxHP) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD(GetHPPercent) \
	UE_FIELD_NOTIFICATION_DECLARE_ENUM_FIELD_END() \
	UE_FIELD_NOTIFICATION_DECLARE_CLASS_DESCRIPTOR_END();
//MyViewModel.gen.cpp
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, HP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, MaxHP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_FIELD(UMyViewModel, GetHPPercent)
	UE_FIELD_NOTIFICATION_IMPLEMENTATION_BEGIN(UMyViewModel)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, HP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, MaxHP)
	UE_FIELD_NOTIFICATION_IMPLEMENT_ENUM_FIELD(UMyViewModel, GetHPPercent)
	UE_FIELD_NOTIFICATION_IMPLEMENTATION_END(UMyViewModel);
```

è“å›¾æ•ˆæœï¼š

è¿™äº›æ§ä»¶çš„å±æ€§å°±å¯ä»¥å’ŒViewModelé‡Œçš„å±æ€§ç»‘å®šèµ·æ¥ã€‚

![Untitled](D:\github\UnrealSpecifiers\Doc\Specifier\UPROPERTY\UHT\FieldNotify\Untitled.png)

# Native

- **åŠŸèƒ½æè¿°ï¼š** å±æ€§ä¸ºæœ¬åœ°ï¼šC++ä»£ç è´Ÿè´£å¯¹å…¶è¿›è¡Œåºåˆ—åŒ–å¹¶å…¬å¼€åˆ°åƒåœ¾å›æ”¶ ã€‚
- **å…ƒæ•°æ®ç±»å‹ï¼š** bool
- **å¼•æ“æ¨¡å—ï¼š** Behavior

å·²è¢«åˆ é™¤
